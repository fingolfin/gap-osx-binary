% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}






%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{GAP --- A Tutorial\mbox{}}}\\
\vfill

\hypersetup{pdftitle=GAP --- A Tutorial}
\markright{\scriptsize \mbox{}\hfill GAP --- A Tutorial \hfill\mbox{}}
{\Huge Release 4.7.8, 09-Jun-2015\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{The GAP Group   \mbox{}}}\\
\hypersetup{pdfauthor=The GAP Group   }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{The GAP Group   }  Email: \href{mailto://support@gap-system.org} {\texttt{support@gap-system.org}}\\
  Homepage: \href{http://www.gap-system.org} {\texttt{http://www.gap-system.org}}}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 1 ]}
 Copyright {\copyright} (1987-2015) for the core part of the \textsf{GAP} system by the \textsf{GAP} Group. 

 Most parts of this distribution, including the core part of the \textsf{GAP} system are distributed under the terms of the GNU General Public License, see \href{http://www.gnu.org/licenses/gpl.html} {\texttt{http://www.gnu.org/licenses/gpl.html}} or the file \texttt{GPL} in the \texttt{etc} directory of the \textsf{GAP} installation. 

 More detailed information about copyright and licenses of parts of this
distribution can be found in  (\textbf{Reference: Copyright and License}). 

 \textsf{GAP} is developed over a long time and has many authors and contributors. More
detailed information can be found in  (\textbf{Reference: Authors and Maintainers}). \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 2 ]}}

\tableofcontents
\newpage

            
\chapter{\textcolor{Chapter }{Preface}}\label{Preface}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X874E1D45845007FE}{}
{
  Welcome to \textsf{GAP}. This preface serves not only to introduce this manual, ``the \textsf{GAP} Tutorial'', but also as an introduction to the system as a whole. 

 \textsf{GAP} stands for \emph{Groups, Algorithms and Programming}. The name was chosen to reflect the aim of the system, which is introduced in
this tutorial manual. Since that choice, the system has become somewhat
broader, and you will also find information about algorithms and programming
for other algebraic structures, such as semigroups and algebras. 

 In addition to this manual, there is the \emph{\textsf{GAP} Reference Manual}  containing detailed documentation of the mathematical functionality of \textsf{GAP}, and the manual called \emph{``\textsf{GAP} - Changes from Earlier Versions''}  which describes most essential changes from previous \textsf{GAP} releases. 

 A lot of the functionality of the system and a number of contributed
extensions are provided as ``\textsf{GAP} packages'' and each of these has its own manual. 

 Subsequent sections of this preface explain the structure of the system and
list sources of further information about \textsf{GAP}. 

  
\section{\textcolor{Chapter }{The \textsf{GAP} System}}\label{The GAP System}
\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X869E3CF37EC69123}{}
{
             \textsf{GAP} is a \emph{free}, \emph{open} and \emph{extensible} software package for computation in discrete abstract algebra. The terms ``free'' and ``open'' describe the conditions under which the system is distributed -- in brief, it
is \emph{free of charge} (except possibly for the immediate costs of delivering it to you), you are \emph{free to pass it on} within certain limits, and all of the workings of the system are \emph{open for you to examine and change}. Details of these conditions can be found in Section  (\textbf{Reference: Copyright and License}). 

 The system is ``extensible'' in that you can write your own programs in the \textsf{GAP} language, and use them in just the same way as the programs which form part of
the system (the ``library''). Indeed, we actively support the contribution, refereeing and distribution
of extensions to the system, in the form of ``\textsf{GAP} packages''. Further details of this can be found in chapter  (\textbf{Reference: Using GAP Packages}), and on our website. 

 Development of \textsf{GAP} began at Lehrstuhl D f{\"u}r Mathematik, RWTH-Aachen, under the leadership of
Joachim Neub{\"u}ser in 1985. Version 2.4 was released in 1988 and version 3.1
in 1992. In 1997 coordination of \textsf{GAP} development, now very much an international effort, was transferred to St
Andrews. A complete internal redesign and almost complete rewrite of the
system was completed over the following years and version 4.1 was released in
July 1999. A sign of the further internationalization of the project was the \textsf{GAP}{\nobreakspace}4.4 release in 2004, which has been coordinated from Colorado
State University, Fort Collins. 

 More information on the motivation and development of \textsf{GAP} to date, can be found on our Web pages in a section entitled ``Release history and Prefaces''. 

 For those readers who have used an earlier version of \textsf{GAP}, an overview of the changes from \textsf{GAP}{\nobreakspace}4.4 and a brief summary of changes from earlier versions is
given in a separate manual  (\textbf{Changes: Changes between GAP 4.4 and GAP 4.5}). 

 The system that you are getting now consists of a ``core system'' and a number of packages. The core system consists of four main parts. 
\begin{enumerate}
\item  A \emph{kernel}, written in C, which provides the user with 
\begin{itemize}
\item  automatic dynamic storage management, which the user needn't bother about in
his programming; 
\item  a set of time-critical basic functions, e.g. ``arithmetic'', operations for integers, finite fields, permutations and words, as well as
natural operations for lists and records; 
\item  an interpreter for the \textsf{GAP} language, an untyped imperative programming language with functions as first
class objects and some extra built-in data types such as permutations and
finite field elements. The language supports a form of object-oriented
programming, similar to that supported by languages like C++ and Java but with
some important differences. 
\item  a small set of system functions allowing the \textsf{GAP} programmer to handle files and execute external programs in a uniform way,
regardless of the particular operating system in use. 
\item  a set of programming tools for testing, debugging, and timing algorithms. 
\item  a ``read-eval-view'' style user interface. 
\end{itemize}
 
\item  A much larger \emph{library of \textsf{GAP} functions} that implement algebraic and other algorithms. Since this is written entirely
in the \textsf{GAP} language, the \textsf{GAP} language is both the main implementation language and the user language of the
system. Therefore the user can as easily as the original programmers
investigate and vary algorithms of the library and add new ones to it, first
for own use and eventually for the benefit of all \textsf{GAP} users. 
\item  A \emph{library of group theoretical data} which contains various libraries of groups, including the library of small
groups (containing all groups of order at most 2000, except those of order
1024) and others. Large libraries of ordinary and Brauer character tables and
Tables of Marks are included as packages. 
\item  The \emph{documentation}. This is available as on-line help, as printable files in PDF format and as
HTML for viewing with a Web browser. 
\end{enumerate}
 

 Also included with the core system are some test files and a few small
utilities which we hope you will find useful. 

 \textsf{GAP} \emph{packages} are self-contained extensions to the core system. A package contains \textsf{GAP} code and its own documentation and may also contain data files or external
programs to which the \textsf{GAP} code provides an interface. These packages may be loaded into \textsf{GAP} using the \texttt{LoadPackage} (\textbf{Reference: LoadPackage}) command, and both the package and its documentation are then available just as
if they were parts of the core system. Some packages may be loaded
automatically, when \textsf{GAP} is started, if they are present. Some packages, because they depend on
external programs, may only be available on the operating systems where those
programs are available (usually UNIX). You should note that, while the
packages included with this release are the most recent versions ready for
release at this time, new packages and new versions may be released at any
time and can be easily installed in your copy of \textsf{GAP}. 

 With \textsf{GAP} there are two packages (the library of ordinary and Brauer character tables,
and the library of tables of marks) which contain functionality developed from
parts of the \textsf{GAP} core system. These have been moved into packages for ease of maintenance and
to allow new versions to be released independently of new releases of the core
system. The library of small groups should also be regarded as a package,
although it does not currently use the standard package mechanism. Other
packages contain functionality which has never been part of the core system,
and may extend it substantially, implementing specific algorithms to enhance
its capabilities, providing data libraries, interfaces to other computer
algebra systems and data sources such as the electronic version of the Atlas
of Finite Group Representations; therefore, installation and usage of packages
is recommended. 

 Further details about \textsf{GAP} packages can be found in chapter  (\textbf{Reference: Using GAP Packages}), and on the \textsf{GAP} website here: \href{http://www.gap-system.org/Packages/packages.html} {\texttt{http://www.gap-system.org/Packages/packages.html}}.    }

  
\section{\textcolor{Chapter }{Further Information about \textsf{GAP}}}\label{Further Information about GAP}
\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X7B488D2E8492AB6A}{}
{
             Information about \textsf{GAP} is best obtained from the \textsf{GAP} website 

 \href{http://www.gap-system.org} {\texttt{http://www.gap-system.org}} 

 There you will find, amongst other things 
\begin{itemize}
\item  directions to the sites from which you can download the current \textsf{GAP} distribution, all accepted and deposited \textsf{GAP} packages, and a selection of other contributions. 
\item  the \textsf{GAP} manual and an archive of the \texttt{gap-forum} mailing list, formatted for reading with a Web browser, and indexed for
searching. 
\item  information about \textsf{GAP} developers, and about the email addresses available for comment, discussion
and support. 
\end{itemize}
 

 

 We would particularly ask you to note the following things: 
\begin{itemize}
\item  The \textsf{GAP} Forum {\textendash} an email discussion forum for comments, discussions or
questions about \textsf{GAP}. You must subscribe to the list before you can post to it, see the website
for details. In particular we will announce new releases in this mailing list. 
\item  The email address \href{mailto://support@gap-system.org} {\texttt{support@gap-system.org}} to which you are asked to send any questions or bug reports which do not seem
likely to be of interest to the whole \textsf{GAP} Forum. Please give a (short, if possible) self-contained excerpt of a \textsf{GAP} session containing both input and output that illustrates your problem
(including comments of why you think it is a bug) and state the type of the
machine, operating system, (compiler used, if UNIX/Linux) and the version of \textsf{GAP} you are using (the first line after the \textsf{GAP}{\nobreakspace}4 banner starting \texttt{GAP, Version 4...}). 
\item  We also ask you to send a brief message to \href{mailto://support@gap-system.org} {\texttt{support@gap-system.org}} when you install \textsf{GAP}. 
\item  The correct form of citation of \textsf{GAP}, which we ask you use whenever you publish scientific results obtained using \textsf{GAP}. 
\end{itemize}
 

 It finally remains for us to wish you all pleasure and success in using \textsf{GAP}, and to invite your constructive comment and criticism. 

 

 

 The GAP Group, 

 09-Jun-2015    }

 }

                 

  
\chapter{\textcolor{Chapter }{A First Session with \textsf{GAP}}}\label{A First Session with GAP}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7E1648BF8446FBC2}{}
{
  

 This tutorial introduces you to the \textsf{GAP} system. It is written with users in mind who have just managed to start \textsf{GAP} for the first time on their computer and want to learn the basic facts about \textsf{GAP} by playing around with some instructive examples. Therefore, this tutorial
contains at many places examples consisting of several lines of input (which
you should type on your terminal) followed by the corresponding output ( which \textsf{GAP} produces as an answer to your input). 

 We encourage you to actually run through these examples on your computer. This
will support your feeling for \textsf{GAP} as a tool, which is the leading aim of this tutorial. Do not believe any
statement in it as long as you cannot verify it for your own version of \textsf{GAP}. You will learn to distinguish between small deviations of the behavior of
your personal \textsf{GAP} from the printed examples and serious nonsense. 

 Since the printing routines of \textsf{GAP} are in some sense machine dependent you will for instance encounter a
different layout of the printed objects in different environments. But the
contents should always be the same. In case you encounter serious nonsense it
is highly recommended that you send a bug report to \href{mailto://support@gap-system.org} {\texttt{support@gap-system.org}}. 

 The examples in this tutorial should explain everything you have to know in
order to be able to use \textsf{GAP}. The reference manual then gives a more systematic treatment of the various
types of objects that \textsf{GAP} can manipulate. It seems desirable neither to start this systematic course
with the most elementary (and most boring) structures, nor to confront you
with all the complex data types before you know how they are composed from
elementary structures. For this reason this tutorial wants to provide you with
a basic understanding of \textsf{GAP} objects, on which the reference manual will then build when it explains
everything in detail. So after having mastered this tutorial, you can
immediately plunge into the exciting parts of \textsf{GAP} and only read detailed information about elementary things (in the reference
manual) when you really need them. 

 Each chapter of this tutorial contains a section with references to the
reference manual at the end. 

  
\section{\textcolor{Chapter }{Starting and Leaving \textsf{GAP}}}\label{Starting and Leaving GAP}
\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7B5258097F48EFB6}{}
{
  

 \index{starting GAP@starting \textsf{GAP}} \index{leaving GAP@leaving \textsf{GAP}} \index{quit@\texttt{quit}} If the program is correctly installed then you usually start \textsf{GAP} by simply typing \texttt{gap} at the prompt of your operating system followed by the \textsc{Return} key, sometimes this is also called the \textsc{Newline} key. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  $ gap
\end{Verbatim}
 

 \textsf{GAP} answers your request with its beautiful banner and then it shows its own
prompt \texttt{gap{\textgreater}} asking you for further input. (You can avoid the banner with the command line
option \texttt{-b}; more command line options are described in Section{\nobreakspace} (\textbf{Reference: Command Line Options}).) 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@|
\end{Verbatim}
 

 The usual way to end a \textsf{GAP} session is to type \texttt{quit;} at the \texttt{gap{\textgreater}} prompt. Do not omit the semicolon! 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@quit;|
  $ 
\end{Verbatim}
 

 On some systems you could type \textsc{Ctrl-D} to yield the same effect. In any situation \textsf{GAP} is ended by typing \textsc{Ctrl-C} twice within a second. Here as always, a combination like \textsc{Ctrl-D} means that you have to press the \textsc{D} key while you hold down the \textsc{Ctrl} key. 

 On some systems (for example the Apple Macintosh) minor changes might be
necessary. This is explained in \textsf{GAP} installation instructions (see the \texttt{INSTALL} file in the \textsf{GAP} root directory, or the \textsf{GAP} website).  

 \index{whitespace} In most places \emph{whitespace} characters (i.e. \textsc{Space}s, \textsc{Tab}s and \textsc{Return}s) are insignificant for the meaning of \textsf{GAP} input. Identifiers and keywords must however not contain any whitespace. On
the other hand, sometimes there must be whitespace around identifiers and
keywords to separate them from each other and from numbers. We will use
whitespace to format more complicated commands for better readability. 

 \index{comments} A \emph{comment} in \textsf{GAP} starts with the symbol \texttt{\#} and continues to the end of the line. Comments are treated like whitespace by \textsf{GAP}. We use comments in the printed examples in this tutorial to explain certain
lines of input or output.   }

  
\section{\textcolor{Chapter }{Loading Source Code from a File}}\label{Loading Source Code from a File}
\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X7B8D5EC27E33AF6D}{}
{
  \index{loading source code from a file} \index{reading source code from a file} \index{Read@\texttt{Read}} The most convenient way of creating larger pieces of \textsf{GAP} code is to write them to some text file. For this purpose you can simply use
your favorite text editor. You can load such a file into \textsf{GAP} using the \texttt{Read} (\textbf{Reference: Read}) function: 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Read("../../GAPProgs/Example.g");|
\end{Verbatim}
 

 You can either give the full absolute path name of the source file or its
relative path name from the \textsf{GAP} root directory (the directory containing \texttt{bin/}, \texttt{doc/}, \texttt{lib/}, etc.). }

  
\section{\textcolor{Chapter }{The Read Evaluate Print Loop}}\label{The Read Evaluate Print Loop}
\logpage{[ 2, 3, 0 ]}
\hyperdef{L}{X7C7388A683D15599}{}
{
  \index{read evaluate print loop} \textsf{GAP} is an interactive system. It continuously executes a read evaluate print loop.
Each expression you type at the keyboard is read by \textsf{GAP}, evaluated, and then the result is shown. 

 The interactive nature of \textsf{GAP} allows you to type an expression at the keyboard and see its value
immediately. You can define a function and apply it to arguments to see how it
works. You may even write whole programs containing lots of functions and test
them without leaving the program. 

 When your program is large it will be more convenient to write it on a file
and then read that file into \textsf{GAP}. Preparing your functions in a file has several advantages. You can compose
your functions more carefully in a file (with your favorite text editor), you
can correct errors without retyping the whole function and you can keep a copy
for later use. Moreover you can write lots of comments into the program text,
which are ignored by \textsf{GAP}, but are very useful for human readers of your program text. \textsf{GAP} treats input from a file in the same way that it treats input from the
keyboard. Further details can be found in section \texttt{Read} (\textbf{Reference: Read}). 

 A simple calculation with \textsf{GAP} is as easy as one can imagine. You type the problem just after the prompt,
terminate it with a semicolon and then pass the problem to the program with
the \textsc{Return} key. For example, to multiply the difference between 9 and 7 by the sum of 5
and 6, that is to calculate $(9 - 7) * (5 + 6)$, you type exactly this last sequence of symbols followed by \texttt{;} and \textsc{Return}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@(9 - 7) * (5 + 6);|
  22
  !gapprompt@gap>| !gapinput@|
\end{Verbatim}
 

 Then \textsf{GAP} echoes the result 22 on the next line and shows with the prompt that it is
ready for the next problem. Henceforth, we will no longer print this
additional prompt. 

 \index{line editing} If you make a mistake while typing the line, but \emph{before} typing the final \textsc{Return}, you can use the \textsc{Delete} key (or sometimes \textsc{Backspace} key) to delete the last typed character. You can also move the cursor back and
forward in the line with \textsc{Ctrl-B} and \textsc{Ctrl-F} and insert or delete characters anywhere in the line. The line editing
commands are fully described in section{\nobreakspace} (\textbf{Reference: Line Editing}). 

 If you did omit the semicolon at the end of the line but have already typed \textsc{Return}, then \textsf{GAP} has read everything you typed, but does not know that the command is complete.
The program is waiting for further input and indicates this with a partial
prompt \texttt{{\textgreater}}. This problem is solved by simply typing the missing semicolon on the next
line of input. Then the result is printed and the normal prompt returns. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@(9 - 7) * (5 + 6)|
  !gapprompt@>| !gapinput@;|
  22
\end{Verbatim}
 

 So the input can consist of several lines, and \textsf{GAP} prints a partial prompt \texttt{{\textgreater}} in each input line except the first, until the command is completed with a
semicolon. (\textsf{GAP} may already evaluate part of the input when \textsc{Return} is typed, so for long calculations it might take some time until the partial
prompt appears.) Whenever you see the partial prompt and you cannot decide
what \textsf{GAP} is still waiting for, then you have to type semicolons until the normal prompt
returns. In every situation the exact meaning of the prompt \texttt{gap{\textgreater}} is that the program is waiting for a new problem. 

 But even if you mistyped the command more seriously, you do not have to type
it all again. Suppose you mistyped or forgot the last closing parenthesis.
Then your command is syntactically incorrect and \textsf{GAP} will notice it, incapable of computing the desired result. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@(9 - 7) * (5 + 6;|
  Syntax error: ) expected
  (9 - 7) * (5 + 6;
                  ^
\end{Verbatim}
 

 \index{line editing} Instead of the result an error message occurs indicating the place where an
unexpected symbol occurred with an arrow sign \texttt{\texttt{\symbol{94}}} under it. As a computer program cannot know what your intentions really were,
this is only a hint. But in this case \textsf{GAP} is right by claiming that there should be a closing parenthesis before the
semicolon. Now you can type \textsc{Ctrl-P} to recover the last line of input. It will be written after the prompt with
the cursor in the first position. Type \textsc{Ctrl-E} to take the cursor to the end of the line, then \textsc{Ctrl-B} to move the cursor one character back. The cursor is now on the position of
the semicolon. Enter the missing parenthesis by simply typing \texttt{)}. Now the line is correct and may be passed to \textsf{GAP} by hitting the \textsc{Return} key. Note that for this action it is not necessary to move the cursor past the
last character of the input line. 

 Each line of commands you type is sent to \textsf{GAP} for evaluation by pressing \textsc{Return} regardless of the position of the cursor in that line. We will no longer
mention the \textsc{Return} key from now on. 

 \index{break loops} Sometimes a syntax error will cause \textsf{GAP} to enter a \emph{break loop}. This is indicated by the special prompt \texttt{brk{\textgreater}}. If another syntax error occurs while \textsf{GAP} is in a break loop, the prompt will change to \texttt{brk{\textunderscore}02{\textgreater}}, \texttt{brk{\textunderscore}03{\textgreater}} and so on. You can leave the current break loop and exit to the next outer one
by either typing \texttt{quit;} or by hitting \textsc{Ctrl-D}. Eventually \textsf{GAP} will return to its normal state and show its normal prompt \texttt{gap{\textgreater}} again. }

  
\section{\textcolor{Chapter }{Constants and Operators}}\label{Constants and Operators}
\logpage{[ 2, 4, 0 ]}
\hyperdef{L}{X86CA8242832F5F71}{}
{
  \index{constants}\index{operators} In an expression like \texttt{(9 - 7) * (5 + 6)} the constants \texttt{5}, \texttt{6}, \texttt{7}, and \texttt{9} are being composed by the operators \texttt{+}, \texttt{*} and \texttt{-} to result in a new value. 

 There are three kinds of operators in \textsf{GAP}, arithmetical operators, comparison operators, and logical operators. You
have already seen that it is possible to form the sum, the difference, and the
product of two integer values. There are some more operators applicable to
integers in \textsf{GAP}. Of course integers may be divided by each other, possibly resulting in
noninteger rational values. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@12345/25;|
  2469/5
\end{Verbatim}
 

 Note that the numerator and denominator are divided by their greatest common
divisor and that the result is uniquely represented as a division instruction. 

 The next self-explanatory example demonstrates negative numbers. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@-3; 17 - 23;|
  -3
  -6
\end{Verbatim}
 

 The exponentiation operator is written as \texttt{\texttt{\symbol{94}}}. This operation in particular might lead to very large numbers. This is no
problem for \textsf{GAP} as it can handle numbers of (almost) any size. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@3^132;|
  955004950796825236893190701774414011919935138974343129836853841
\end{Verbatim}
 

 The \texttt{mod} operator allows you to compute one value modulo another. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@17 mod 3;|
  2
\end{Verbatim}
 

 Note that there must be whitespace around the keyword \texttt{mod} in this example since \texttt{17mod3} or \texttt{17mod} would be interpreted as identifiers. The whitespace around operators that do
not consist of letters, e.g., the operators \texttt{*} and \texttt{-}, is not necessary. 

 \textsf{GAP} knows a precedence between operators that may be overridden by parentheses. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@(9 - 7) * 5 = 9 - 7  * 5;|
  false
\end{Verbatim}
 

 Besides these arithmetical operators there are comparison operators in \textsf{GAP}. A comparison results in a \emph{boolean value} which is another kind of constant. The comparison operators \texttt{=}, \texttt{{\textless}{\textgreater}}, \texttt{{\textless}}, \texttt{{\textless}=}, \texttt{{\textgreater}} and \texttt{{\textgreater}=}, test for equality, inequality, less than, less than or equal, greater than
and greater than or equal, respectively. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@10^5 < 10^4;|
  false
\end{Verbatim}
 

 The boolean values \texttt{true} and \texttt{false} can be manipulated via logical operators, i.{\nobreakspace}e., the unary
operator \texttt{not} and the binary operators \texttt{and} and \texttt{or}. Of course boolean values can be compared, too. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@not true; true and false; true or false;|
  false
  false
  true
  !gapprompt@gap>| !gapinput@10 > 0 and 10 < 100;|
  true
\end{Verbatim}
 

 Another important type of constants in \textsf{GAP} are \emph{permutations}. They are written in cycle notation and they can be multiplied. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@(1,2,3);|
  (1,2,3)
  !gapprompt@gap>| !gapinput@(1,2,3) * (1,2);|
  (2,3)
\end{Verbatim}
 

 The inverse of the permutation \texttt{(1,2,3)} is denoted by \texttt{(1,2,3)\texttt{\symbol{94}}-1}. Moreover the caret operator \texttt{\texttt{\symbol{94}}} is used to determine the image of a point under a permutation and to conjugate
one permutation by another. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@(1,2,3)^-1;|
  (1,3,2)
  !gapprompt@gap>| !gapinput@2^(1,2,3);|
  3
  !gapprompt@gap>| !gapinput@(1,2,3)^(1,2);|
  (1,3,2)
\end{Verbatim}
 

 The various other constants that \textsf{GAP} can deal with will be introduced when they are used, for example there are
elements of finite fields such as \texttt{Z(8)}, and complex roots of unity such as \texttt{E(4)}. 

 The last type of constants we want to mention here are the \emph{characters}, which are simply objects in \textsf{GAP} that represent arbitrary characters from the character set of the operating
system. Character literals can be entered in \textsf{GAP} by enclosing the character in \emph{singlequotes} \texttt{'}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@'a';|
  'a'
  !gapprompt@gap>| !gapinput@'*';|
  '*'
\end{Verbatim}
 

 There are no operators defined for characters except that characters can be
compared. 

  In this section you have seen that values may be preceded by unary operators
and combined by binary operators placed between the operands. There are rules
for precedence which may be overridden by parentheses. A comparison results in
a boolean value. Boolean values are combined via logical operators. Moreover
you have seen that \textsf{GAP} handles numbers of arbitrary size. Numbers and boolean values are constants.
There are other types of constants in \textsf{GAP} like permutations. You are now in a position to use \textsf{GAP} as a simple desktop calculator. }

  
\section{\textcolor{Chapter }{Variables versus Objects}}\label{Variables versus Objects}
\logpage{[ 2, 5, 0 ]}
\hyperdef{L}{X82F47EA88347AC2D}{}
{
  \index{variables}\index{assignment}\index{identifier}\index{objects} \index{objects!vs. variables} The constants described in the last section are specified by certain
combinations of digits and minus signs (in the case of integers) or digits,
commas and parentheses (in the case of permutations). These sequences of
characters always have the same meaning to \textsf{GAP}. On the other hand, there are \emph{variables}, specified by a sequence of letters and digits (including at least one
letter), and their meaning depends on what has been assigned to them. An \emph{assignment} is done by a \textsf{GAP} command \texttt{\mbox{\texttt{\mdseries\slshape sequence{\textunderscore}of{\textunderscore}letters{\textunderscore}and{\textunderscore}digits}} := \mbox{\texttt{\mdseries\slshape meaning}}}, where the sequence on the left hand side is called the \emph{identifier} of the variable and it serves as its name. The meaning on the right hand side
can be a constant like an integer or a permutation, but it can also be almost
any other \textsf{GAP} object. From now on, we will use the term \emph{object} to denote something that can be assigned to a variable. 

 There must be no whitespace between the \texttt{:} and the \texttt{=} in the assignment operator. Also do not confuse the assignment operator with
the single equality sign \texttt{=} which in \textsf{GAP} is only used for the test of equality. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@a:= (9 - 7) * (5 + 6);|
  22
  !gapprompt@gap>| !gapinput@a;|
  22
  !gapprompt@gap>| !gapinput@a * (a + 1);|
  506
  !gapprompt@gap>| !gapinput@a = 10;|
  false
  !gapprompt@gap>| !gapinput@a:= 10;|
  10
  !gapprompt@gap>| !gapinput@a * (a + 1);|
  110
\end{Verbatim}
 

 After an assignment the assigned object is echoed on the next line. The
printing of the object of a statement may be in every case prevented by typing
a double semicolon. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@w:= 2;; |
\end{Verbatim}
 

 After the assignment the variable evaluates to that object if evaluated. Thus
it is possible to refer to that object by the name of the variable in any
situation. 

 This is in fact the whole secret of an assignment. An identifier is bound to
an object and from this moment points to that object. Nothing more. This
binding is changed by the next assignment to that identifier. An identifier
does not denote a block of memory as in some other programming languages. It
simply points to an object, which has been given its place in memory by the \textsf{GAP} storage manager. This place may change during a \textsf{GAP} session, but that doesn't bother the identifier. \emph{The identifier points to the object, not to a place in the memory.} 

 For the same reason it is not the identifier that has a type but the object.
This means on the other hand that the identifier \texttt{a} which now is bound to an integer object may in the same session point to any
other object regardless of its type. 

 Identifiers may be sequences of letters and digits containing at least one
letter. For example \texttt{abc} and \texttt{a0bc1} are valid identifiers. But also \texttt{123a} is a valid identifier as it cannot be confused with any number. Just \texttt{1234} indicates the number 1234 and cannot be at the same time the name of a
variable. 

 Since \textsf{GAP} distinguishes upper and lower case, \texttt{a1} and \texttt{A1} are different identifiers. Keywords such as \texttt{quit} must not be used as identifiers. You will see more keywords in the following
sections. 

 In the remaining part of this manual we will ignore the difference between
variables, their names (identifiers), and the objects they point to. It may be
useful to think from time to time about what is really meant by terms such as ``the integer \texttt{w}''. 

 There are some predefined variables coming with \textsf{GAP}. Many of them you will find in the remaining chapters of this manual, since
functions are also referred to via identifiers. 

 You can get an overview of \emph{all} \textsf{GAP} variables by entering \texttt{NamesGVars()}. Many of these are predefined. If you are interested in the variables you
have defined yourself in the current \textsf{GAP} session, you can enter \texttt{NamesUserGVars()}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@NamesUserGVars();|
  [ "a", "w" ]
\end{Verbatim}
 

 This seems to be the right place to state the following rule: The name of
every global variable in the \textsf{GAP} library starts with a \emph{capital letter}. Thus if you choose only names starting with a small letter for your own
variables you will not attempt to overwrite any predefined variable. (Note
that most of the predefined variables are read-only, and trying to change
their values will result in an error message.) 

 There are some further interesting variables one of which will be introduced
now. 

 \index{last@\texttt{last}} \index{last2@\texttt{last2}} \index{last3@\texttt{last3}} Whenever \textsf{GAP} returns an object by printing it on the next line this object is assigned to
the variable \texttt{last}. So if you computed 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@(9 - 7) * (5 + 6);|
  22
\end{Verbatim}
 

 and forgot to assign the object to the variable \texttt{a} for further use, you can still do it by the following assignment. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@a:= last;|
  22
\end{Verbatim}
 

 Moreover there are variables \texttt{last2} and \texttt{last3}, you can guess their values. 

  In this section you have seen how to assign objects to variables. These
objects can later be accessed through the name of the variable, its
identifier. You have also encountered the useful concept of the \texttt{last} variables storing the latest returned objects. And you have learned that a
double semicolon prevents the result of a statement from being printed. }

  
\section{\textcolor{Chapter }{Objects vs. Elements}}\label{Objects vs. Elements}
\logpage{[ 2, 6, 0 ]}
\hyperdef{L}{X7F36AE347AD3CDEC}{}
{
  \index{objects!vs. elements} \index{elements} In the last section we mentioned that every object is given a certain place in
memory by the \textsf{GAP} storage manager (although that place may change in the course of a \textsf{GAP} session). In this sense, objects at different places in memory are never
equal, and if the object pointed to by the variable \texttt{a} (to be more precise, the variable with identifier \texttt{a}) is equal to the object pointed to by the variable \texttt{b}, then we should better say that they are not only equal but \emph{identical}. \textsf{GAP} provides the function \texttt{IsIdenticalObj} (\textbf{Reference: IsIdenticalObj}) to test whether this is the case. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@a:= (1,2);; IsIdenticalObj( a, a );|
  true
  !gapprompt@gap>| !gapinput@b:= (1,2);; IsIdenticalObj( a, b );|
  false
  !gapprompt@gap>| !gapinput@b:= a;; IsIdenticalObj( a, b );|
  true
\end{Verbatim}
 

 \index{IsIdenticalObj@\texttt{IsIdenticalObj}} 

 As the above example indicates, \textsf{GAP} objects \mbox{\texttt{\mdseries\slshape a}} and \mbox{\texttt{\mdseries\slshape b}} can be unequal although they are equal from a mathematical point of view,
i.e., although we should have \mbox{\texttt{\mdseries\slshape a}} = \mbox{\texttt{\mdseries\slshape b}}. It may be that the objects \mbox{\texttt{\mdseries\slshape a}} and \mbox{\texttt{\mdseries\slshape b}} are stored in different places in memory, or it may be that we have an
equivalence relation defined on the set of objects under which \mbox{\texttt{\mdseries\slshape a}} and \mbox{\texttt{\mdseries\slshape b}} belong to the same equivalence class. For example, if $\mbox{\texttt{\mdseries\slshape a}} = x^3$ and $\mbox{\texttt{\mdseries\slshape b}} = x^{{-5}}$ are words in the finitely presented group $\langle x \mid x^2 = 1 \rangle$, we would have \mbox{\texttt{\mdseries\slshape a}} = \mbox{\texttt{\mdseries\slshape b}} in that group. 

 \textsf{GAP} uses the equality operator \texttt{=} to denote such a mathematical equality, \emph{not} the identity of objects. Hence we often have \texttt{\mbox{\texttt{\mdseries\slshape a}} = \mbox{\texttt{\mdseries\slshape b}}} although \texttt{IsIdenticalObj( \mbox{\texttt{\mdseries\slshape a}}, \mbox{\texttt{\mdseries\slshape b}} ) = false}. The operator \texttt{=} defines an equivalence relation on the set of all \textsf{GAP} objects, and we call the corresponding equivalence classes \emph{elements}. Phrasing it differently, the same element may be represented by various \textsf{GAP} objects. 

 Non-trivial examples of elements that are represented by different objects
(objects that really look different, not ones that are merely stored in
different memory places) will occur only when we will be considering composite
objects such as lists or domains. }

  
\section{\textcolor{Chapter }{About Functions}}\label{About Functions}
\logpage{[ 2, 7, 0 ]}
\hyperdef{L}{X796E055D86856B42}{}
{
  A program written in the \textsf{GAP} language is called a \emph{function}. Functions are special \textsf{GAP} objects. Most of them behave like mathematical functions. They are applied to
objects and will return a new object depending on the input. The function \texttt{Factorial} (\textbf{Reference: Factorial}), for example, can be applied to an integer and will return the factorial of
this integer. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Factorial(17);|
  355687428096000
\end{Verbatim}
 

 Applying a function to arguments means to write the arguments in parentheses
following the function. Several arguments are separated by commas, as for the
function \texttt{Gcd} (\textbf{Reference: Gcd}) which computes the greatest common divisor of two integers. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Gcd(1234, 5678);|
  2
\end{Verbatim}
 

 There are other functions that do not return an object but only produce a side
effect, for example changing one of their arguments. These functions are
sometimes called procedures. The function \texttt{Print} (\textbf{Reference: Print}) is only called for the side effect of printing something on the screen. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Print(1234, "\n");|
  1234
\end{Verbatim}
 

 In order to be able to compose arbitrary text with \texttt{Print} (\textbf{Reference: Print}), this function itself will not produce a line break after printing. Thus we
had another newline character \texttt{"\texttt{\symbol{92}}n"} printed to start a new line. 

 Some functions will both change an argument and return an object such as the
function \texttt{Sortex} (\textbf{Reference: Sortex}) that sorts a list and returns the permutation of the list elements that it has
performed. You will not understand right now what it means to change an
object. We will return to this subject several times in the next sections. 

 \index{maps-to operator} A comfortable way to define a function yourself is the \emph{maps-to} operator \texttt{-{\textgreater}} consisting of a minus sign and a greater sign with no whitespace between them.
The function \texttt{cubed} which maps a number to its cube is defined on the following line. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@cubed:= x -> x^3;|
  function( x ) ... end
\end{Verbatim}
 

 After the function has been defined, it can now be applied. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@cubed(5);|
  125
\end{Verbatim}
 

 More complicated functions, especially functions with more than one argument
cannot be defined in this way. You will see how to write your own \textsf{GAP} functions in Section{\nobreakspace}\ref{Writing Functions}. 

  In this section you have seen \textsf{GAP} objects of type function. You have learned how to apply a function to
arguments. This yields as result a new object or a side effect. A side effect
may change an argument of the function. Moreover you have seen an easy way to
define a function in \textsf{GAP} with the maps-to operator. }

  
\section{\textcolor{Chapter }{Help}}\label{Help}
\logpage{[ 2, 8, 0 ]}
\hyperdef{L}{X7A7EADB77FF38BC9}{}
{
  The content of the \textsf{GAP} manuals is also available as on-line help. A \textsf{GAP} session loads a long list of index entries. This typically contains all
chapter and section headers, all names of documented functions, operations and
so on, as well as some explicit index entries defined in the manuals. 

 The format of a query is as follows. 

 \texttt{?[\mbox{\texttt{\mdseries\slshape book}}:][?]\mbox{\texttt{\mdseries\slshape topic}}} 

 A simple example would be to type \texttt{?help} at the \textsf{GAP} prompt. If there is a single section with index entry \mbox{\texttt{\mdseries\slshape topic}} then this is displayed directly. 

 If there are several matches you get an overview like in the example below. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@?sets|
  Help: several entries match this topic - type ?2 to get match [2]
  
  [1] Tutorial: Sets
  [2] Reference: Sets
  [3] Reference: sets
  [4] Reference: Sets of Subgroups
  [5] Reference: setstabilizer
\end{Verbatim}
 

 \textsf{GAP}'s manuals consist of several \emph{books}, which are indicated before the colon in the list above. A help query can be
restricted to one book by using the optional \mbox{\texttt{\mdseries\slshape book}}: part. For example \texttt{?tut : sets} will display the first of these help sections. More precisely, the parts of
the string \mbox{\texttt{\mdseries\slshape book}} which are separated by white space are interpreted as beginnings of the first
words in the name of the book. Try \texttt{?books} to see the list of available books and their names. 

 The search for a matching \mbox{\texttt{\mdseries\slshape topic}} (and optional \mbox{\texttt{\mdseries\slshape book}}) is done \emph{case insensitively}. If there is another \texttt{?} before the \mbox{\texttt{\mdseries\slshape topic}}, then a \emph{substring search} for \mbox{\texttt{\mdseries\slshape topic}} is performed on all index entries. Otherwise the parts of \mbox{\texttt{\mdseries\slshape topic}} which are separated by white space are considered as \emph{beginnings of the first words} in an index entry. 

 White space is normalized in the search string (and the index entries). 

 \emph{Examples.} All the following queries lead to the chapter of the reference manual which
explains the use of \textsf{GAP}'s help system in more detail. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@?Reference: The Help System|
  !gapprompt@gap>| !gapinput@?  REF : t h s|
  !gapprompt@gap>| !gapinput@?ref:?  help   system |
\end{Verbatim}
 

 The query \texttt{??sets} shows all help sections in all books whose index entries contain the substring \texttt{sets}. 

 As mentioned in the example above a complete list of commands for the help
system is available in Section{\nobreakspace}\texttt{?Ref: The Help System} of the reference manual. In particular there are commands to browse through
the help sections, see{\nobreakspace}\texttt{?Ref: Browsing through the Sections} and there is a way to influence the way \emph{how} the help sections are displayed, see{\nobreakspace}\texttt{?Ref: SetHelpViewer}. For example you can use an external pager program, a Web browser, \texttt{dvi}-previewer and/or \texttt{pdf}-viewer for reading \textsf{GAP}'s online help. }

  
\section{\textcolor{Chapter }{Further Information introducing the System}}\label{Further Information introducing the System}
\logpage{[ 2, 9, 0 ]}
\hyperdef{L}{X798515EF7D762548}{}
{
  For large amounts of input data, it might be advisable to write your input
first into a file, and then read this into \textsf{GAP}; see{\nobreakspace}\texttt{Read} (\textbf{Reference: Read}), \texttt{Edit} (\textbf{Reference: Edit}) for this. 

 The definition of the \textsf{GAP} syntax can be looked up in Chapter{\nobreakspace} (\textbf{Reference: The Programming Language}). A complete list of command line editing facilities is found in
Section{\nobreakspace} (\textbf{Reference: Line Editing}). The break loop is described in Section{\nobreakspace} (\textbf{Reference: Break Loops}). 

 Operators are explained in more detail in Sections{\nobreakspace} (\textbf{Reference: Expressions}) and  (\textbf{Reference: Comparisons}). You will find more information about boolean values in
Chapters{\nobreakspace} (\textbf{Reference: Booleans}) and  (\textbf{Reference: Boolean Lists}). Permutations are described in Chapter{\nobreakspace} (\textbf{Reference: Permutations}) and characters in Chapter{\nobreakspace} (\textbf{Reference: Strings and Characters}). 

 Variables and assignments are described in more detail in{\nobreakspace} (\textbf{Reference: Variables}) and  (\textbf{Reference: Assignments}). A complete list of keywords is contained in{\nobreakspace} (\textbf{Reference: Keywords}). 

 More about functions can be found in{\nobreakspace} (\textbf{Reference: Function Calls}) and{\nobreakspace} (\textbf{Reference: Procedure Calls}). }

 }

                 

  
\chapter{\textcolor{Chapter }{Lists and Records}}\label{Lists and Records}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X7863DAFD78E5DFB6}{}
{
  \index{arrays, see lists} Modern mathematics, especially algebra, is based on set theory. When sets are
represented in a computer, they inadvertently turn into lists. That's why we
start our survey of the various objects \textsf{GAP} can handle with a description of lists and their manipulation. \textsf{GAP} regards sets as a special kind of lists, namely as lists without holes or
duplicates whose entries are ordered with respect to the precedence
relation{\nobreakspace}\texttt{{\textless}}. 

 After the introduction of the basic manipulations with lists in{\nobreakspace}\ref{Plain Lists}, some difficulties concerning identity and mutability of lists are discussed
in{\nobreakspace}\ref{Identical Lists} and{\nobreakspace}\ref{Immutability}. Sets, ranges, row vectors, and matrices are introduced as special kinds of
lists in{\nobreakspace}\ref{Sets}, \ref{Ranges}, \ref{Vectors and Matrices}. Handy list operations are shown in{\nobreakspace}\ref{List Operations}. Finally we explain how to use records in{\nobreakspace}\ref{Plain Records}.  
\section{\textcolor{Chapter }{Plain Lists}}\label{Plain Lists}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X81ECC2077D88E112}{}
{
  \index{lists!plain} A \emph{list} is a collection of objects separated by commas and enclosed in brackets. Let
us for example construct the list \texttt{primes} of the first ten prime numbers. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@primes:= [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];|
  [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ]
\end{Verbatim}
 

 The next two primes are 31 and 37. They may be appended to the existing list
by the function \texttt{Append} which takes the existing list as its first and another list as a second
argument. The second argument is appended to the list \texttt{primes} and no value is returned. Note that by appending another list the object \texttt{primes} is changed. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Append(primes, [31, 37]);|
  !gapprompt@gap>| !gapinput@primes;|
  [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37 ]
\end{Verbatim}
 

 You can as well add single new elements to existing lists by the function \texttt{Add} which takes the existing list as its first argument and a new element as its
second argument. The new element is added to the list \texttt{primes} and again no value is returned but the list \texttt{primes} is changed. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Add(primes, 41);|
  !gapprompt@gap>| !gapinput@primes;|
  [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41 ]
\end{Verbatim}
 

 Single elements of a list are referred to by their position in the list. To
get the value of the seventh prime, that is the seventh entry in our list \texttt{primes}, you simply type 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@primes[7];|
  17
\end{Verbatim}
 

 This value can be handled like any other value, for example multiplied by 2 or
assigned to a variable. On the other hand this mechanism allows one to assign
a value to a position in a list. So the next prime 43 may be inserted in the
list directly after the last occupied position of \texttt{primes}. This last occupied position is returned by the function \texttt{Length}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Length(primes);|
  13
  !gapprompt@gap>| !gapinput@primes[14]:= 43;|
  43
  !gapprompt@gap>| !gapinput@primes;|
  [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43 ]
\end{Verbatim}
 

 Note that this operation again has changed the object \texttt{primes}. The next position after the end of a list is not the only position capable
of taking a new value. If you know that 71 is the 20th prime, you can enter it
right now in the 20th position of \texttt{primes}. This will result in a list with holes which is however still a list and now
has length 20. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@primes[20]:= 71;|
  71
  !gapprompt@gap>| !gapinput@primes;|
  [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,,,,,, 71 ]
  !gapprompt@gap>| !gapinput@Length(primes);|
  20
\end{Verbatim}
 

 The list itself however must exist before a value can be assigned to a
position of the list. This list may be the empty list \texttt{[ ]}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@lll[1]:= 2;|
  Error, Variable: 'lll' must have a value
  
  
  !gapprompt@gap>| !gapinput@lll:= []; lll[1]:= 2;|
  [  ]
  2
\end{Verbatim}
 

 Of course existing entries of a list can be changed by this mechanism, too. We
will not do it here because \texttt{primes} then may no longer be a list of primes. Try for yourself to change the 17 in
the list into a 9. 

 To get the position of 17 in the list \texttt{primes} use the function \texttt{Position} (\textbf{Reference: Position}) which takes the list as its first argument and the element as its second
argument and returns the position of the first occurrence of the element 17 in
the list \texttt{primes}. If the element is not contained in the list then \texttt{Position} (\textbf{Reference: Position}) will return the special object \texttt{fail}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Position(primes, 17);|
  7
  !gapprompt@gap>| !gapinput@Position(primes, 20);|
  fail
\end{Verbatim}
 

 In all of the above changes to the list \texttt{primes}, the list has been automatically resized. There is no need for you to tell \textsf{GAP} how big you want a list to be. This is all done dynamically. 

 It is not necessary for the objects collected in a list to be of the same
type. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@lll:= [true, "This is a String",,, 3];|
  [ true, "This is a String",,, 3 ]
\end{Verbatim}
 

 In the same way a list may be part of another list. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@lll[3]:= [4,5,6];; lll;|
  [ true, "This is a String", [ 4, 5, 6 ],, 3 ]
\end{Verbatim}
 

 A list may even be part of itself. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@lll[4]:= lll;|
  [ true, "This is a String", [ 4, 5, 6 ], ~, 3 ]
\end{Verbatim}
 

 Now the tilde in the fourth position of \texttt{lll} denotes the object that is currently printed. Note that the result of the last
operation is the actual value of the object \texttt{lll} on the right hand side of the assignment. In fact it is identical to the value
of the whole list \texttt{lll} on the left hand side of the assignment. 

 \index{strings} \index{lists!dense} A \emph{string} is a special type of list, namely a dense list of \emph{characters}, where \emph{dense} means that the list has no holes. Here, \emph{characters} are special \textsf{GAP} objects representing an element of the character set of the operating system.
The input of printable characters is by enclosing them in single
quotes{\nobreakspace}\texttt{'}. A string literal can either be entered as the list of characters or by
writing the characters between doublequotes \texttt{"}. Strings are handled specially by \texttt{Print} (\textbf{Reference: Print}). You can learn much more about strings in the reference manual. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@s1 := ['H','a','l','l','o',' ','w','o','r','l','d','.'];|
  "Hallo world."
  !gapprompt@gap>| !gapinput@s1 = "Hallo world.";|
  true
  !gapprompt@gap>| !gapinput@s1[7];|
  'w'
\end{Verbatim}
 

 Sublists of lists can easily be extracted and assigned using the operator \texttt{\mbox{\texttt{\mdseries\slshape list}}\texttt{\symbol{123}} \mbox{\texttt{\mdseries\slshape positions}} \texttt{\symbol{125}}}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@sl := lll{ [ 1, 2, 3 ] };|
  [ true, "This is a String", [ 4, 5, 6 ] ]
  !gapprompt@gap>| !gapinput@sl{ [ 2, 3 ] } := [ "New String", false ];|
  [ "New String", false ]
  !gapprompt@gap>| !gapinput@sl;|
  [ true, "New String", false ]
\end{Verbatim}
 

 This way you get a new list whose $i$-th entry is that element of the original list whose position is the $i$-th entry of the argument in the curly braces. }

  
\section{\textcolor{Chapter }{Identical Lists}}\label{Identical Lists}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X7DD65BEA7EDB0CD7}{}
{
  \index{lists!identical} This second section about lists is dedicated to the subtle difference between \emph{equality} and \emph{identity} of lists. It is really important to understand this difference in order to
understand how complex data structures are realized in \textsf{GAP}. This section applies to all \textsf{GAP} objects that have subobjects, e.g., to lists and to records. After reading the
section{\nobreakspace}\ref{Plain Records} about records you should return to this section and translate it into the
record context. 

 Two lists are \emph{equal} if all their entries are equal. This means that the equality operator \texttt{=} returns \texttt{true} for the comparison of two lists if and only if these two lists are of the same
length and for each position the values in the respective lists are equal. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@numbers := primes;; numbers = primes;|
  true
\end{Verbatim}
 

 We assigned the list \texttt{primes} to the variable \texttt{numbers} and, of course they are equal as they have both the same length and the same
entries. Now we will change the third number to 4 and compare the result again
with \texttt{primes}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@numbers[3]:= 4;; numbers = primes;|
  true
\end{Verbatim}
 

 You see that \texttt{numbers} and \texttt{primes} are still equal, check this by printing the value of \texttt{primes}. The list \texttt{primes} is no longer a list of primes! What has happened? The truth is that the lists \texttt{primes} and \texttt{numbers} are not only equal but they are also \emph{identical}. \texttt{primes} and \texttt{numbers} are two variables pointing to the same list. If you change the value of the
subobject \texttt{numbers[3]} of \texttt{numbers} this will also change \texttt{primes}. Variables do \emph{not} point to a certain block of storage memory but they do point to an object that
occupies storage memory. So the assignment \texttt{numbers := primes} did \emph{not} create a new list in a different place of memory but only created the new name \texttt{numbers} for the same old list of primes. 

 From this we see that \emph{the same object can have several names.} 

 If you want to change a list with the contents of \texttt{primes} independently from \texttt{primes} you will have to make a copy of \texttt{primes} by the function \texttt{ShallowCopy} which takes an object as its argument and returns a copy of the argument. (We
will first restore the old value of \texttt{primes}.) 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@primes[3]:= 5;; primes;|
  [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,,,,,, 71 ]
  !gapprompt@gap>| !gapinput@numbers:= ShallowCopy(primes);; numbers = primes;|
  true
  !gapprompt@gap>| !gapinput@numbers[3]:= 4;; numbers = primes;|
  false
\end{Verbatim}
 

 Now \texttt{numbers} is no longer equal to \texttt{primes} and \texttt{primes} still is a list of primes. Check this by printing the values of \texttt{numbers} and \texttt{primes}. 

 Lists and records can be changed this way because \textsf{GAP} objects of these types have subobjects. To clarify this statement consider the
following assignments. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@i:= 1;; j:= i;; i:= i+1;; |
\end{Verbatim}
 

 By adding 1 to \texttt{i} the value of \texttt{i} has changed. What happens to \texttt{j}? After the second statement \texttt{j} points to the same object as \texttt{i}, namely to the integer 1. The addition does \emph{not} change the object \texttt{1} but creates a new object according to the instruction \texttt{i+1}. It is actually the assignment that changes the value of \texttt{i}. Therefore \texttt{j} still points to the object \texttt{1}. Integers (like permutations and booleans) have no subobjects. Objects of
these types cannot be changed but can only be replaced by other objects. And a
replacement does not change the values of other variables. In the above
example an assignment of a new value to the variable \texttt{numbers} would also not change the value of \texttt{primes}. 

 Finally try the following examples and explain the results. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@l:= [];; l:= [l];|
  [ [  ] ]
  !gapprompt@gap>| !gapinput@l[1]:= l;|
  [ ~ ]
\end{Verbatim}
 

 Now return to Section{\nobreakspace}\ref{Plain Lists} and find out whether the functions \texttt{Add} (\textbf{Reference: Add}) and \texttt{Append} (\textbf{Reference: Append}) change their arguments. }

  
\section{\textcolor{Chapter }{Immutability}}\label{Immutability}
\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X8614C8207D57AD7A}{}
{
  \textsf{GAP} has a mechanism that protects lists against changes like the ones that have
bothered us in Section{\nobreakspace}\ref{Identical Lists}. The function \texttt{Immutable} (\textbf{Reference: Immutable}) takes as argument a list and returns an immutable copy of it, i.e., a list
which looks exactly like the old one, but has two extra properties:
(1){\nobreakspace}The new list is immutable, i.e., the list itself and its
subobjects cannot be changed. (2){\nobreakspace}In constructing the copy,
every part of the list that can be changed has been copied, so that changes to
the old list will not affect the new one. In other words, the new list has no
mutable subobjects in common with the old list. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@list := [ 1, 2, "three", [ 4 ] ];; copy := Immutable( list );;|
  !gapprompt@gap>| !gapinput@list[3][5] := 'w';; list; copy;|
  [ 1, 2, "threw", [ 4 ] ]
  [ 1, 2, "three", [ 4 ] ]
  !gapprompt@gap>| !gapinput@copy[3][5] := 'w';|
  Lists Assignment: <list> must be a mutable list
  not in any function
  Entering break read-eval-print loop ...
  you can 'quit;' to quit to outer loop, or
  you can 'return;' and ignore the assignment to continue
  !gapbrkprompt@brk>| !gapinput@quit;|
\end{Verbatim}
 

 As a consequence of these rules, in the immutable copy of a list which
contains an already immutable list as subobject, this immutable subobject need
not be copied, because it is unchangeable. Immutable lists are useful in many
complex \textsf{GAP} objects, for example as generator lists of groups. By making them immutable, \textsf{GAP} ensures that no generators can be added to the list, removed or exchanged.
Such changes would of course lead to serious inconsistencies with other
knowledge that may already have been calculated for the group. 

 A converse function to \texttt{Immutable} (\textbf{Reference: Immutable}) is \texttt{ShallowCopy} (\textbf{Reference: ShallowCopy}), which produces a new mutable list whose $i$-th entry is the $i$-th entry of the old list. The single entries are not copied, they are just
placed in the new list. If the old list is immutable, and hence the list
entries are immutable themselves, the result of \texttt{ShallowCopy} (\textbf{Reference: ShallowCopy}) is mutable only on the top level. 

 It should be noted that also other objects than lists can appear in mutable or
immutable form. Records (see Section{\nobreakspace}\ref{Plain Records}) provide another example. }

  
\section{\textcolor{Chapter }{Sets}}\label{Sets}
\logpage{[ 3, 4, 0 ]}
\hyperdef{L}{X83BE0C20875DD285}{}
{
  \index{lists!strictly sorted} \index{family} \textsf{GAP} knows several special kinds of lists. A \emph{set} in \textsf{GAP} is a list that contains no holes (such a list is called \emph{dense}) and whose elements are strictly sorted w.r.t.{\nobreakspace}\texttt{{\textless}}; in particular, a set cannot contain duplicates. (More precisely, the
elements of a set in \textsf{GAP} are required to lie in the same \emph{family}, but roughly this means that they can be compared using the \texttt{{\textless}} operator.) 

 This provides a natural model for mathematical sets whose elements are given
by an explicit enumeration. 

 \textsf{GAP} also calls a set a \emph{strictly sorted list}, and the function \texttt{IsSSortedList} (\textbf{Reference: IsSSortedList}) tests whether a given list is a set. It returns a boolean value. For almost
any list whose elements are contained in the same family, there exists a
corresponding set. This set is constructed by the function \texttt{Set} (\textbf{Reference: Set}) which takes the list as its argument and returns a set obtained from this list
by ignoring holes and duplicates and by sorting the elements. 

 The elements of the sets used in the examples of this section are strings. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@fruits:= ["apple", "strawberry", "cherry", "plum"];|
  [ "apple", "strawberry", "cherry", "plum" ]
  !gapprompt@gap>| !gapinput@IsSSortedList(fruits);|
  false
  !gapprompt@gap>| !gapinput@fruits:= Set(fruits);|
  [ "apple", "cherry", "plum", "strawberry" ]
\end{Verbatim}
 

 Note that the original list \texttt{fruits} is not changed by the function \texttt{Set} (\textbf{Reference: Set}). We have to make a new assignment to the variable \texttt{fruits} in order to make it a set. 

 The operator \texttt{in} is used to test whether an object is an element of a set. It returns a boolean
value \texttt{true} or \texttt{false}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@"apple" in fruits;|
  true
  !gapprompt@gap>| !gapinput@"banana" in fruits;|
  false
\end{Verbatim}
 

 The operator \texttt{in} can also be applied to ordinary lists. It is however much faster to perform a
membership test for sets since sets are always sorted and a binary search can
be used instead of a linear search. New elements may be added to a set by the
function \texttt{AddSet} (\textbf{Reference: AddSet}) which takes the set \texttt{fruits} as its first argument and an element as its second argument and adds the
element to the set if it wasn't already there. Note that the object \texttt{fruits} is changed. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@AddSet(fruits, "banana");|
  !gapprompt@gap>| !gapinput@fruits;  #  The banana is inserted in the right place.|
  [ "apple", "banana", "cherry", "plum", "strawberry" ]
  !gapprompt@gap>| !gapinput@AddSet(fruits, "apple");|
  !gapprompt@gap>| !gapinput@fruits;  #  fruits has not changed.|
  [ "apple", "banana", "cherry", "plum", "strawberry" ]
\end{Verbatim}
 

 Note that inserting new elements into a set with \texttt{AddSet} (\textbf{Reference: AddSet}) is usually more expensive than simply adding new elements at the end of a
list. 

 Sets can be intersected by the function \texttt{Intersection} (\textbf{Reference: Intersection}) and united by the function \texttt{Union} (\textbf{Reference: Union}) which both take two sets as their arguments and return the intersection resp.
union of the two sets as a new object. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@breakfast:= ["tea", "apple", "egg"];|
  [ "tea", "apple", "egg" ]
  !gapprompt@gap>| !gapinput@Intersection(breakfast, fruits);|
  [ "apple" ]
\end{Verbatim}
 

 The arguments of the functions \texttt{Intersection} (\textbf{Reference: Intersection}) and \texttt{Union} (\textbf{Reference: Union}) could be ordinary lists, while their result is always a set. Note that in the
preceding example at least one argument of \texttt{Intersection} (\textbf{Reference: Intersection}) was not a set. The functions \texttt{IntersectSet} (\textbf{Reference: IntersectSet}) and \texttt{UniteSet} (\textbf{Reference: UniteSet}) also form the intersection resp.{\nobreakspace}union of two sets. They will
however not return the result but change their first argument to be the
result. Try them carefully. }

  
\section{\textcolor{Chapter }{Ranges}}\label{Ranges}
\logpage{[ 3, 5, 0 ]}
\hyperdef{L}{X79596BDE7CAF8491}{}
{
  A \emph{range} is a finite arithmetic progression of integers. This is another special kind
of list. A range is described by the first two values and the last value of
the arithmetic progression which are given in the form \texttt{[\mbox{\texttt{\mdseries\slshape first}},\mbox{\texttt{\mdseries\slshape second}}..\mbox{\texttt{\mdseries\slshape last}}]}. In the usual case of an ascending list of consecutive integers the second
entry may be omitted. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@[1..999999];     #  a range of almost a million numbers|
  [ 1 .. 999999 ]
  !gapprompt@gap>| !gapinput@[1, 2..999999];  #  this is equivalent|
  [ 1 .. 999999 ]
  !gapprompt@gap>| !gapinput@[1, 3..999999];  #  here the step is 2|
  [ 1, 3 .. 999999 ]
  !gapprompt@gap>| !gapinput@Length( last );|
  500000
  !gapprompt@gap>| !gapinput@[ 999999, 999997 .. 1 ];|
  [ 999999, 999997 .. 1 ]
\end{Verbatim}
 

 This compact printed representation of a fairly long list corresponds to a
compact internal representation. The function \texttt{IsRange} (\textbf{Reference: IsRange}) tests whether an object is a range, the function \texttt{ConvertToRangeRep} (\textbf{Reference: ConvertToRangeRep}) changes the representation of a list that is in fact a range to this compact
internal representation. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@a:= [-2,-1,0,1,2,3,4,5];|
  [ -2, -1, 0, 1, 2, 3, 4, 5 ]
  !gapprompt@gap>| !gapinput@IsRange( a );|
  true
  !gapprompt@gap>| !gapinput@ConvertToRangeRep( a );;  a;|
  [ -2 .. 5 ]
  !gapprompt@gap>| !gapinput@a[1]:= 0;; IsRange( a );|
  false
\end{Verbatim}
 

 Note that this change of representation does \emph{not} change the value of the list \texttt{a}. The list \texttt{a} still behaves in any context in the same way as it would have in the long
representation. }

  
\section{\textcolor{Chapter }{For and While Loops}}\label{For and While Loops}
\logpage{[ 3, 6, 0 ]}
\hyperdef{L}{X7CC5B0347F8EC820}{}
{
  \index{loops@loop!for} \index{loops@loop!while} 

 Given a list \texttt{pp} of permutations we can form their product by means of a \texttt{for} loop instead of writing down the product explicitly. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@pp:= [ (1,3,2,6,8)(4,5,9), (1,6)(2,7,8), (1,5,7)(2,3,8,6),|
  !gapprompt@>| !gapinput@          (1,8,9)(2,3,5,6,4), (1,9,8,6,3,4,7,2)];;|
  !gapprompt@gap>| !gapinput@prod:= ();        |
  ()
  !gapprompt@gap>| !gapinput@for p in pp do|
  !gapprompt@>| !gapinput@      prod:= prod*p;    |
  !gapprompt@>| !gapinput@   od;|
  !gapprompt@gap>| !gapinput@prod;        |
  (1,8,4,2,3,6,5,9)
\end{Verbatim}
 

 First a new variable \texttt{prod} is initialized to the identity permutation \texttt{()}. Then the loop variable \texttt{p} takes as its value one permutation after the other from the list \texttt{pp} and is multiplied with the present value of \texttt{prod} resulting in a new value which is then assigned to \texttt{prod}. 

 The \texttt{for} loop has the following syntax 

 \texttt{for} \mbox{\texttt{\mdseries\slshape var}} \texttt{in} \mbox{\texttt{\mdseries\slshape list}} \texttt{do} \mbox{\texttt{\mdseries\slshape statements}} \texttt{od}\texttt{;} 

 The effect of the \texttt{for} loop is to execute the \mbox{\texttt{\mdseries\slshape statements}} for every element of the \mbox{\texttt{\mdseries\slshape list}}. A \texttt{for} loop is a statement and therefore terminated by a semicolon. The list of \mbox{\texttt{\mdseries\slshape statements}} is enclosed by the keywords \texttt{do} and \texttt{od} (reverse \texttt{do}). A \texttt{for} loop returns no value. Therefore we had to ask explicitly for the value of \texttt{prod} in the preceding example. 

 The \texttt{for} loop can loop over any kind of list, even a list with holes. In many
programming languages the \texttt{for} loop has the form 

 \texttt{for \mbox{\texttt{\mdseries\slshape var}} from \mbox{\texttt{\mdseries\slshape first}} to \mbox{\texttt{\mdseries\slshape last}} do \mbox{\texttt{\mdseries\slshape statements}} od;} 

 In \textsf{GAP} this is merely a special case of the general \texttt{for} loop as defined above where the \mbox{\texttt{\mdseries\slshape list}} in the loop body is a range (see{\nobreakspace}\ref{Ranges}): 

 \texttt{for} \mbox{\texttt{\mdseries\slshape var}} \texttt{in} \texttt{[\mbox{\texttt{\mdseries\slshape first}}..\mbox{\texttt{\mdseries\slshape last}}]} \texttt{do} \mbox{\texttt{\mdseries\slshape statements}} \texttt{od}\texttt{;} 

 You can for instance loop over a range to compute the factorial $15!$ of the number $15$ in the following way. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ff:= 1;|
  1
  !gapprompt@gap>| !gapinput@for i in [1..15] do|
  !gapprompt@>| !gapinput@      ff:= ff * i;|
  !gapprompt@>| !gapinput@   od;|
  !gapprompt@gap>| !gapinput@ff;|
  1307674368000
\end{Verbatim}
 

 The \texttt{while} loop has the following syntax 

 \texttt{while} \mbox{\texttt{\mdseries\slshape condition}} \texttt{do} \mbox{\texttt{\mdseries\slshape statements}} \texttt{od}\texttt{;} 

 The \texttt{while} loop loops over the \mbox{\texttt{\mdseries\slshape statements}} as long as the \mbox{\texttt{\mdseries\slshape condition}} evaluates to \texttt{true}. Like the \texttt{for} loop the \texttt{while} loop is terminated by the keyword \texttt{od} followed by a semicolon. 

 We can use our list \texttt{primes} to perform a very simple factorization. We begin by initializing a list \texttt{factors} to the empty list. In this list we want to collect the prime factors of the
number 1333. Remember that a list has to exist before any values can be
assigned to positions of the list. Then we will loop over the list \texttt{primes} and test for each prime whether it divides the number. If it does we will
divide the number by that prime, add it to the list \texttt{factors} and continue. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@n:= 1333;;|
  !gapprompt@gap>| !gapinput@factors:= [];;|
  !gapprompt@gap>| !gapinput@for p in primes do|
  !gapprompt@>| !gapinput@      while n mod p = 0 do|
  !gapprompt@>| !gapinput@         n:= n/p;|
  !gapprompt@>| !gapinput@         Add(factors, p);|
  !gapprompt@>| !gapinput@      od;|
  !gapprompt@>| !gapinput@   od;|
  !gapprompt@gap>| !gapinput@factors;|
  [ 31, 43 ]
  !gapprompt@gap>| !gapinput@n;|
  1
\end{Verbatim}
 

 As \texttt{n} now has the value 1 all prime factors of 1333 have been found and \texttt{factors} contains a complete factorization of 1333. This can of course be verified by
multiplying 31 and 43. 

 This loop may be applied to arbitrary numbers in order to find prime factors.
But as \texttt{primes} is not a complete list of all primes this loop may fail to find all prime
factors of a number greater than 2000, say. You can try to improve it in such
a way that new primes are added to the list \texttt{primes} if needed. 

 You have already seen that list objects may be changed. This of course also
holds for the list in a loop body. In most cases you have to be careful not to
change this list, but there are situations where this is quite useful. The
following example shows a quick way to determine the primes smaller than 1000
by a sieve method. Here we will make use of the function \texttt{Unbind} to delete entries from a list, and the \texttt{if} statement covered in \ref{If Statements}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@primes:= [];;|
  !gapprompt@gap>| !gapinput@numbers:= [2..1000];;|
  !gapprompt@gap>| !gapinput@for p in numbers do|
  !gapprompt@>| !gapinput@      Add(primes, p);|
  !gapprompt@>| !gapinput@      for n in numbers do|
  !gapprompt@>| !gapinput@         if n mod p = 0 then|
  !gapprompt@>| !gapinput@            Unbind(numbers[n-1]);|
  !gapprompt@>| !gapinput@         fi;|
  !gapprompt@>| !gapinput@      od;|
  !gapprompt@>| !gapinput@   od;|
\end{Verbatim}
 

 The inner loop removes all entries from \texttt{numbers} that are divisible by the last detected prime \texttt{p}. This is done by the function \texttt{Unbind} which deletes the binding of the list position \texttt{numbers[n-1]} to the value \texttt{n} so that afterwards \texttt{numbers[n-1]} no longer has an assigned value. The next element encountered in \texttt{numbers} by the outer loop necessarily is the next prime. 

 In a similar way it is possible to enlarge the list which is looped over. This
yields a nice and short orbit algorithm for the action of a group, for
example. 

 More about \texttt{for} and \texttt{while} loops can be found in the sections{\nobreakspace} (\textbf{Reference: While}) and{\nobreakspace} (\textbf{Reference: For}). }

  
\section{\textcolor{Chapter }{List Operations}}\label{List Operations}
\logpage{[ 3, 7, 0 ]}
\hyperdef{L}{X879CFE0985DBA041}{}
{
  There is a more comfortable way than that given in the previous section to
compute the product of a list of numbers or permutations. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Product([1..15]);|
  1307674368000
  !gapprompt@gap>| !gapinput@Product(pp);|
  (1,8,4,2,3,6,5,9)
\end{Verbatim}
 

 The function \texttt{Product} (\textbf{Reference: Product}) takes a list as its argument and computes the product of the elements of the
list. This is possible whenever a multiplication of the elements of the list
is defined. So \texttt{Product} (\textbf{Reference: Product}) executes a loop over all elements of the list. 

 There are other often used loops available as functions. Guess what the
function \texttt{Sum} (\textbf{Reference: Sum}) does. The function \texttt{List} (\textbf{Reference: Lists}) may take a list and a function as its arguments. It will then apply the
function to each element of the list and return the corresponding list of
results. A list of cubes is produced as follows with the function \texttt{cubed} from Section{\nobreakspace}\ref{Functions}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@cubed:= x -> x^3;;|
  !gapprompt@gap>| !gapinput@List([2..10], cubed);|
  [ 8, 27, 64, 125, 216, 343, 512, 729, 1000 ]
\end{Verbatim}
 

 To add all these cubes we might apply the function \texttt{Sum} (\textbf{Reference: Sum}) to the last list. But we may as well give the function \texttt{cubed} to \texttt{Sum} (\textbf{Reference: Sum}) as an additional argument. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Sum(last) = Sum([2..10], cubed);|
  true
\end{Verbatim}
 

 The primes less than 30 can be retrieved out of the list \texttt{primes} from Section{\nobreakspace}\ref{Plain Lists} by the function \texttt{Filtered} (\textbf{Reference: Filtered}). This function takes the list \texttt{primes} and a property as its arguments and will return the list of those elements of \texttt{primes} which have this property. Such a property will be represented by a function
that returns a boolean value. In this example the property of being less than
30 can be represented by the function \texttt{x -{\textgreater} x {\textless} 30} since \texttt{x {\textless} 30} will evaluate to \texttt{true} for values \texttt{x} less than 30 and to \texttt{false} otherwise. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Filtered(primes, x -> x < 30);|
  [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ]
\end{Verbatim}
 

 We have already mentioned the operator \texttt{\texttt{\symbol{123}} \texttt{\symbol{125}}} that forms sublists. It takes a list of positions as its argument and will
return the list of elements from the original list corresponding to these
positions. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@primes{ [1 .. 10] };|
  [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ]
\end{Verbatim}
 

 Finally we mention the function \texttt{ForAll} (\textbf{Reference: ForAll}) that checks whether a property holds for all elements of a list. It takes as
its arguments a list and a function that returns a boolean value. \texttt{ForAll} (\textbf{Reference: ForAll}) checks whether the function returns \texttt{true} for all elements of the list. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@list:= [ 1, 2, 3, 4 ];;|
  !gapprompt@gap>| !gapinput@ForAll( list, x -> x > 0 );|
  true
  !gapprompt@gap>| !gapinput@ForAll( list, x -> x in primes );|
  false
\end{Verbatim}
 

 You will find more predefined \texttt{for} loops in chapter{\nobreakspace} (\textbf{Reference: Lists}). }

  
\section{\textcolor{Chapter }{Vectors and Matrices}}\label{Vectors and Matrices}
\logpage{[ 3, 8, 0 ]}
\hyperdef{L}{X851A7DD07866323F}{}
{
  \index{vectors!row} \index{matrices} This section describes how \textsf{GAP} uses lists to represent row vectors and matrices. A \emph{row vector} is a dense list of elements from a common field. A \emph{matrix} is a dense list of row vectors over a common field and of equal length. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@v:= [3, 6, 2, 5/2];;  IsRowVector(v);|
  true
\end{Verbatim}
 

 Row vectors may be added and multiplied by scalars from their field.
Multiplication of row vectors of equal length results in their scalar product. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@2 * v;  v * 1/3;|
  [ 6, 12, 4, 5 ]
  [ 1, 2, 2/3, 5/6 ]
  !gapprompt@gap>| !gapinput@v * v;   # the scalar product of `v' with itself|
  221/4
\end{Verbatim}
 

 Note that the expression \texttt{v * 1/3} is actually evaluated by first multiplying \texttt{v} by 1 (which yields again \texttt{v}) and by then dividing by 3. This is also an allowed scalar operation. The
expression \texttt{v/3} would result in the same value. 

 Such arithmetical operations (if the results are again vectors) result in \emph{mutable} vectors except if the operation is binary and both operands are immutable;
thus the vectors shown in the examples above are all mutable. 

 So if you want to produce a mutable list with 100{\nobreakspace}entries equal
to{\nobreakspace}25, you can simply say \texttt{25 + 0 * [ 1 .. 100 ]}. Note that ranges are also vectors (over the rationals), and that \texttt{[ 1 .. 100 ]} is mutable. 

 A matrix is a dense list of row vectors of equal length. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@m:= [[1,-1, 1],|
  !gapprompt@>| !gapinput@        [2, 0,-1],|
  !gapprompt@>| !gapinput@        [1, 1, 1]];|
  [ [ 1, -1, 1 ], [ 2, 0, -1 ], [ 1, 1, 1 ] ]
  !gapprompt@gap>| !gapinput@m[2][1];|
  2
\end{Verbatim}
 

 Syntactically a matrix is a list of lists. So the number 2 in the second row
and the first column of the matrix \texttt{m} is referred to as the first element of the second element of the list \texttt{m} via \texttt{m[2][1]}. 

 A matrix may be multiplied by scalars, row vectors and other matrices. (If the
row vectors and matrices involved in such a multiplication do not have
suitable dimensions then the ``missing'' entries are treated as zeros, so the results may look unexpectedly in such
cases.) 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@[1, 0, 0] * m;|
  [ 1, -1, 1 ]
  !gapprompt@gap>| !gapinput@[1, 0, 0, 2] * m;|
  [ 1, -1, 1 ]
  !gapprompt@gap>| !gapinput@m * [1, 0, 0];|
  [ 1, 2, 1 ]
  !gapprompt@gap>| !gapinput@m * [1, 0, 0, 2];|
  [ 1, 2, 1 ]
\end{Verbatim}
 

 Note that multiplication of a row vector with a matrix will result in a linear
combination of the rows of the matrix, while multiplication of a matrix with a
row vector results in a linear combination of the columns of the matrix. In
the latter case the row vector is considered as a column vector. 

 A vector or matrix of integers can also be multiplied with a finite field
scalar and vice versa. Such products result in a matrix over the finite field
with the integers mapped into the finite field in the obvious way. Finite
field matrices are nicer to read when they are \texttt{Display}ed rather than \texttt{Print}ed. (Here we write \texttt{Z(q)} to denote a primitive root of the finite field with \texttt{q} elements.) 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Display( m * One( GF(5) ) );|
   1 4 1
   2 . 4
   1 1 1
  !gapprompt@gap>| !gapinput@Display( m^2 * Z(2) + m * Z(4) );|
  z = Z(4)
   z^1 z^1 z^2
     1   1 z^2
   z^1 z^1 z^2
\end{Verbatim}
 

 Submatrices can easily be extracted using the expression \texttt{\mbox{\texttt{\mdseries\slshape mat}}\texttt{\symbol{123}}\mbox{\texttt{\mdseries\slshape rows}}\texttt{\symbol{125}}\texttt{\symbol{123}}\mbox{\texttt{\mdseries\slshape columns}}\texttt{\symbol{125}}}. They can also be assigned to, provided the big matrix is mutable (which it
is not if it is the result of an arithmetical operation, see above). 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@sm := m{ [ 1, 2 ] }{ [ 2, 3 ] };|
  [ [ -1, 1 ], [ 0, -1 ] ]
  !gapprompt@gap>| !gapinput@sm{ [ 1, 2 ] }{ [2] } := [[-2],[0]];;  sm;|
  [ [ -1, -2 ], [ 0, 0 ] ]
\end{Verbatim}
 

 The first curly brackets contain the selection of rows, the second that of
columns. 

 Matrices appear not only in linear algebra, but also as group elements,
provided they are invertible. Here we have the opportunity to meet a
group-theoretical function, namely \texttt{Order} (\textbf{Reference: Order}), which computes the order of a group element. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Order( m * One( GF(5) ) );|
  8
  !gapprompt@gap>| !gapinput@Order( m );|
  infinity
\end{Verbatim}
 

 For matrices whose entries are more complex objects, for example rational
functions, \textsf{GAP}'s \texttt{Order} (\textbf{Reference: Order}) methods might not be able to prove that the matrix has infinite order, and one
gets the following warning. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  #I  Order: warning, order of <mat> might be infinite
\end{Verbatim}
 In such a case, if the order of the matrix really is infinite, you will have
to interrupt \textsf{GAP} by pressing \texttt{\mbox{\texttt{\mdseries\slshape ctl}}-C} (followed by \texttt{\mbox{\texttt{\mdseries\slshape ctl}}-D} or \texttt{quit;} to leave the break loop). 

 To prove that the order of \texttt{m} is infinite, we also could look at the minimal polynomial of \texttt{m} over the rationals. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@f:= MinimalPolynomial( Rationals, m );;  Factors( f );|
  [ x_1-2, x_1^2+3 ]
\end{Verbatim}
 

 \texttt{Factors} (\textbf{Reference: Factors}) returns a list of irreducible factors of the polynomial \texttt{f}. The first irreducible factor $X-2$ reveals that 2 is an eigenvalue of \texttt{m}, hence its order cannot be finite. }

  
\section{\textcolor{Chapter }{Plain Records}}\label{Plain Records}
\logpage{[ 3, 9, 0 ]}
\hyperdef{L}{X7CF7BBD58135B981}{}
{
  A record provides another way to build new data structures. Like a list a
record contains subobjects. In a record the elements, the so-called \emph{record components}, are not indexed by numbers but by names. 

 In this section you will see how to define and how to use records. Records are
changed by assignments to record components or by unbinding record components. 

 Initially a record is defined as a comma separated list of assignments to its
record components. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@date:= rec(year:= 1997,|
  !gapprompt@>| !gapinput@              month:= "Jul",|
  !gapprompt@>| !gapinput@              day:= 14);|
  rec( day := 14, month := "Jul", year := 1997 )
\end{Verbatim}
 

 The value of a record component is accessible by the record name and the
record component name separated by one dot as the record component selector. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@date.year;|
  1997
\end{Verbatim}
 

 Assignments to new record components are possible in the same way. The record
is automatically resized to hold the new component. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@date.time:= rec(hour:= 19, minute:= 23, second:= 12);|
  rec( hour := 19, minute := 23, second := 12 )
  !gapprompt@gap>| !gapinput@date;|
  rec( day := 14, month := "Jul", 
    time := rec( hour := 19, minute := 23, second := 12 ), year := 1997 )
\end{Verbatim}
 

 Records are objects that may be changed. An assignment to a record component
changes the original object. The remarks made in Sections{\nobreakspace}\ref{Identical Lists} and \ref{Immutability} about identity and mutability of lists are also true for records. 

 Sometimes it is interesting to know which components of a certain record are
bound. This information is available from the function \texttt{RecNames} (\textbf{Reference: RecNames}), which takes a record as its argument and returns a list of names of all
bound components of this record as a list of strings. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@RecNames(date);|
  [ "time", "year", "month", "day" ]
\end{Verbatim}
 

 Now return to Sections \ref{Identical Lists} and \ref{Immutability} and find out what these sections mean for records. }

  
\section{\textcolor{Chapter }{Further Information about Lists}}\label{Further Information about Lists}
\logpage{[ 3, 10, 0 ]}
\hyperdef{L}{X800A5E8681E28E2D}{}
{
  (The following cross-references point to the \textsf{GAP} Reference Manual.) 

                 You will find more about lists, sets, and ranges in Chapter{\nobreakspace} (\textbf{Reference: Lists}), in particular more about identical lists in Section{\nobreakspace} (\textbf{Reference: Identical Lists}).           A more detailed description of strings is contained in Chapter{\nobreakspace} (\textbf{Reference: Strings and Characters}).      Fields are described in Chapter{\nobreakspace} (\textbf{Reference: Fields and Division Rings}), some known fields in \textsf{GAP} are described in Chapters{\nobreakspace} (\textbf{Reference: Rational Numbers}),  (\textbf{Reference: Abelian Number Fields}), and{\nobreakspace} (\textbf{Reference: Finite Fields}). Row vectors and matrices are described in more detail in
Chapters{\nobreakspace} (\textbf{Reference: Row Vectors}) and{\nobreakspace} (\textbf{Reference: Matrices}). Vector spaces are described in Chapter{\nobreakspace} (\textbf{Reference: Vector Spaces}), further matrix related structures are described in Chapters{\nobreakspace} (\textbf{Reference: Matrix Groups}),  (\textbf{Reference: Algebras}), and{\nobreakspace} (\textbf{Reference: Lie Algebras}).     

       You will find more list operations in Chapter{\nobreakspace} (\textbf{Reference: Lists}). 

 Records and functions for records are described in detail in
Chapter{\nobreakspace} (\textbf{Reference: Records}). }

 }

                 

  
\chapter{\textcolor{Chapter }{Functions}}\label{Functions}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X86FA580F8055B274}{}
{
  You have already seen how to use functions in the \textsf{GAP} library, i.e., how to apply them to arguments. 

 In this section you will see how to write functions in the \textsf{GAP} language. You will also see how to use the \texttt{if} statement and declare local variables with the \texttt{local} statement in the function definition. Loop constructions via \texttt{while} and \texttt{for} are discussed further, as are recursive functions.  
\section{\textcolor{Chapter }{Writing Functions}}\label{Writing Functions}
\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X7D81680E7BB09F45}{}
{
  

 Writing a function that prints \texttt{hello, world.} on the screen is a simple exercise in \textsf{GAP}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@sayhello:= function()|
  !gapprompt@>| !gapinput@Print("hello, world.\n");|
  !gapprompt@>| !gapinput@end;|
  function(  ) ... end
\end{Verbatim}
 

 This function when called will only execute the \texttt{Print} statement in the second line. This will print the string \texttt{hello, world.} on the screen followed by a newline character \texttt{\texttt{\symbol{92}}n} that causes the \textsf{GAP} prompt to appear on the next line rather than immediately following the
printed characters. 

 The function definition has the following syntax. 

 \texttt{function}\texttt{( \mbox{\texttt{\mdseries\slshape arguments}} ) \mbox{\texttt{\mdseries\slshape statements}}} \texttt{end} 

 A function definition starts with the keyword \texttt{function} followed by the formal parameter list \mbox{\texttt{\mdseries\slshape arguments}} enclosed in parenthesis \texttt{( )}. The formal parameter list may be empty as in the example. Several parameters
are separated by commas. Note that there must be \emph{no} semicolon behind the closing parenthesis. The function definition is
terminated by the keyword \texttt{end}. 

 A \textsf{GAP} function is an expression like an integer, a sum or a list. Therefore it may
be assigned to a variable. The terminating semicolon in the example does not
belong to the function definition but terminates the assignment of the
function to the name \texttt{sayhello}. Unlike in the case of integers, sums, and lists the value of the function \texttt{sayhello} is echoed in the abbreviated fashion \texttt{function( ) ... end}. This shows the most interesting part of a function: its formal parameter
list (which is empty in this example). The complete value of \texttt{sayhello} is returned if you use the function \texttt{Print} (\textbf{Reference: Print}). 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Print(sayhello, "\n");|
  function (  )
      Print( "hello, world.\n" );
      return;
  end
\end{Verbatim}
 

 Note the additional newline character \texttt{"\texttt{\symbol{92}}n"} in the \texttt{Print} (\textbf{Reference: Print}) statement. It is printed after the object \texttt{sayhello} to start a new line. The extra \texttt{return} statement is inserted by \textsf{GAP} to simplify the process of executing the function. 

 The newly defined function \texttt{sayhello} is executed by calling \texttt{sayhello()} with an empty argument list. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@sayhello();|
  hello, world.
\end{Verbatim}
 

 However, this is not a typical example as no value is returned but only a
string is printed. }

  
\section{\textcolor{Chapter }{If Statements}}\label{If Statements}
\logpage{[ 4, 2, 0 ]}
\hyperdef{L}{X801EE07E839B31B2}{}
{
  In the following example we define a function \texttt{sign} which determines the sign of an integer. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@sign:= function(n)|
  !gapprompt@>| !gapinput@       if n < 0 then|
  !gapprompt@>| !gapinput@          return -1;|
  !gapprompt@>| !gapinput@       elif n = 0 then|
  !gapprompt@>| !gapinput@          return 0;|
  !gapprompt@>| !gapinput@       else|
  !gapprompt@>| !gapinput@          return 1;|
  !gapprompt@>| !gapinput@       fi;|
  !gapprompt@>| !gapinput@   end;|
  function( n ) ... end
  !gapprompt@gap>| !gapinput@sign(0); sign(-99); sign(11);|
  0
  -1
  1
\end{Verbatim}
 

 This example also introduces the \texttt{if} statement which is used to execute statements depending on a condition. The \texttt{if} statement has the following syntax. 

 \texttt{if} \mbox{\texttt{\mdseries\slshape condition}} \texttt{then} \mbox{\texttt{\mdseries\slshape statements}} \texttt{elif} \mbox{\texttt{\mdseries\slshape condition}} \texttt{then} \mbox{\texttt{\mdseries\slshape statements}} \texttt{else} \mbox{\texttt{\mdseries\slshape statements}} \texttt{fi} 

 There may be several \texttt{elif} parts. The \texttt{elif} part as well as the \texttt{else} part of the \texttt{if} statement may be omitted. An \texttt{if} statement is no expression and can therefore not be assigned to a variable.
Furthermore an \texttt{if} statement does not return a value. 

 Fibonacci numbers are defined recursively by $f(1) = f(2) = 1$ and $f(n) = f(n-1) + f(n-2)$ for $n \geq 3$. Since functions in \textsf{GAP} may call themselves, a function \texttt{fib} that computes Fibonacci numbers can be implemented basically by typing the
above equations. (Note however that this is a very inefficient way to compute $f(n)$.) 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@fib:= function(n)|
  !gapprompt@>| !gapinput@      if n in [1, 2] then|
  !gapprompt@>| !gapinput@         return 1;|
  !gapprompt@>| !gapinput@      else|
  !gapprompt@>| !gapinput@         return fib(n-1) + fib(n-2);|
  !gapprompt@>| !gapinput@      fi;|
  !gapprompt@>| !gapinput@   end;|
  function( n ) ... end
  !gapprompt@gap>| !gapinput@fib(15);|
  610
\end{Verbatim}
 

 There should be additional tests for the argument \texttt{n} being a positive integer. This function \texttt{fib} might lead to strange results if called with other arguments. Try inserting
the necessary tests into this example. }

  
\section{\textcolor{Chapter }{Local Variables}}\label{Local Variables}
\logpage{[ 4, 3, 0 ]}
\hyperdef{L}{X797E24D67BB804A2}{}
{
  A function \texttt{gcd} that computes the greatest common divisor of two integers by Euclid's
algorithm will need a variable in addition to the formal arguments. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@gcd:= function(a, b)|
  !gapprompt@>| !gapinput@      local c;|
  !gapprompt@>| !gapinput@      while b <> 0 do|
  !gapprompt@>| !gapinput@         c:= b;|
  !gapprompt@>| !gapinput@         b:= a mod b;|
  !gapprompt@>| !gapinput@         a:= c;|
  !gapprompt@>| !gapinput@      od;|
  !gapprompt@>| !gapinput@      return c;|
  !gapprompt@>| !gapinput@   end;|
  function( a, b ) ... end
  !gapprompt@gap>| !gapinput@gcd(30, 63);|
  3
\end{Verbatim}
 

 The additional variable \texttt{c} is declared as a \emph{local} variable in the \texttt{local} statement of the function definition. The \texttt{local} statement, if present, must be the first statement of a function definition.
When several local variables are declared in only one \texttt{local} statement they are separated by commas. 

 The variable \texttt{c} is indeed a local variable, that is local to the function \texttt{gcd}. If you try to use the value of \texttt{c} in the main loop you will see that \texttt{c} has no assigned value unless you have already assigned a value to the variable \texttt{c} in the main loop. In this case the local nature of \texttt{c} in the function \texttt{gcd} prevents the value of the \texttt{c} in the main loop from being overwritten. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@c:= 7;;|
  !gapprompt@gap>| !gapinput@gcd(30, 63);|
  3
  !gapprompt@gap>| !gapinput@c;|
  7
\end{Verbatim}
 

 We say that in a given scope an identifier identifies a unique variable. A \emph{scope} is a lexical part of a program text. There is the global scope that encloses
the entire program text, and there are local scopes that range from the \texttt{function} keyword, denoting the beginning of a function definition, to the corresponding \texttt{end} keyword. A local scope introduces new variables, whose identifiers are given
in the formal argument list and the local declaration of the function. The
usage of an identifier in a program text refers to the variable in the
innermost scope that has this identifier as its name. }

  
\section{\textcolor{Chapter }{Recursion}}\label{Recursion}
\logpage{[ 4, 4, 0 ]}
\hyperdef{L}{X7981E4197F7113EA}{}
{
  We have already seen recursion in the function \texttt{fib} in Section{\nobreakspace}\ref{If Statements}. Here is another, slightly more complicated example. 

 We will now write a function to determine the number of partitions of a
positive integer. A partition of a positive integer is a descending list of
numbers whose sum is the given integer. For example $[4,2,1,1]$ is a partition of 8. Note that there is just one partition of 0, namely $[ ]$. The complete set of all partitions of an integer $n$ may be divided into subsets with respect to the largest element. The number of
partitions of $n$ therefore equals the sum of the numbers of partitions of $n-i$ with elements less than or equal to $i$ for all possible $i$. More generally the number of partitions of $n$ with elements less than $m$ is the sum of the numbers of partitions of $n-i$ with elements less than $i$ for $i$ less than $m$ and $n$. This description yields the following function. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@nrparts:= function(n)|
  !gapprompt@>| !gapinput@   local np;|
  !gapprompt@>| !gapinput@   np:= function(n, m)|
  !gapprompt@>| !gapinput@      local i, res;|
  !gapprompt@>| !gapinput@      if n = 0 then|
  !gapprompt@>| !gapinput@         return 1;|
  !gapprompt@>| !gapinput@      fi;|
  !gapprompt@>| !gapinput@      res:= 0;|
  !gapprompt@>| !gapinput@      for i in [1..Minimum(n,m)] do|
  !gapprompt@>| !gapinput@         res:= res + np(n-i, i);|
  !gapprompt@>| !gapinput@      od;|
  !gapprompt@>| !gapinput@      return res;|
  !gapprompt@>| !gapinput@   end;|
  !gapprompt@>| !gapinput@   return np(n,n);|
  !gapprompt@>| !gapinput@end;|
  function( n ) ... end
\end{Verbatim}
 

 We wanted to write a function that takes one argument. We solved the problem
of determining the number of partitions in terms of a recursive procedure with
two arguments. So we had to write in fact two functions. The function \texttt{nrparts} that can be used to compute the number of partitions indeed takes only one
argument. The function \texttt{np} takes two arguments and solves the problem in the indicated way. The only task
of the function \texttt{nrparts} is to call \texttt{np} with two equal arguments. 

 We made \texttt{np} local to \texttt{nrparts}. This illustrates the possibility of having local functions in \textsf{GAP}. It is however not necessary to put it there. \texttt{np} could as well be defined on the main level, but then the identifier \texttt{np} would be bound and could not be used for other purposes, and if it were used
the essential function \texttt{np} would no longer be available for \texttt{nrparts}. 

 Now have a look at the function \texttt{np}. It has two local variables \texttt{res} and \texttt{i}. The variable \texttt{res} is used to collect the sum and \texttt{i} is a loop variable. In the loop the function \texttt{np} calls itself again with other arguments. It would be very disturbing if this
call of \texttt{np} was to use the same \texttt{i} and \texttt{res} as the calling \texttt{np}. Since the new call of \texttt{np} creates a new scope with new variables this is fortunately not the case. 

 Note that the formal parameters \mbox{\texttt{\mdseries\slshape n}} and \mbox{\texttt{\mdseries\slshape m}} of \texttt{np} are treated like local variables. 

 (Regardless of the recursive structure of an algorithm it is often cheaper (in
terms of computing time) to avoid a recursive implementation if possible (and
it is possible in this case), because a function call is not very cheap.) }

  
\section{\textcolor{Chapter }{Further Information about Functions}}\label{Further Information about Functions}
\logpage{[ 4, 5, 0 ]}
\hyperdef{L}{X85B6E21781804BBB}{}
{
  The function syntax is described in Section  (\textbf{Reference: Functions}). The \texttt{if} statement is described in more detail in Section  (\textbf{Reference: If}). More about Fibonacci numbers is found in Section \texttt{Fibonacci} (\textbf{Reference: Fibonacci}) and more about partitions in Section \texttt{Partitions} (\textbf{Reference: Partitions}). }

 }

                 

  
\chapter{\textcolor{Chapter }{Groups and Homomorphisms}}\label{Groups and Homomorphisms}
\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X8171DAF2833FF728}{}
{
  In this chapter we will show some computations with groups. The examples deal
mostly with permutation groups, because they are the easiest to input. The
functions mentioned here, like \texttt{Group} (\textbf{Reference: Groups}), \texttt{Size} (\textbf{Reference: Size}) or \texttt{SylowSubgroup} (\textbf{Reference: SylowSubgroup}), however, are the same for all kinds of groups, although the algorithms which
compute the information of course will be different in most cases.  
\section{\textcolor{Chapter }{Permutation groups}}\label{Permutation groups}
\logpage{[ 5, 1, 0 ]}
\hyperdef{L}{X85ED46007CED6191}{}
{
  Permutation groups are so easy to input because their elements, i.e.,
permutations, are so easy to type: they are entered and displayed in disjoint
cycle notation. So let's construct a permutation group: 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@s8 := Group( (1,2), (1,2,3,4,5,6,7,8) );|
  Group([ (1,2), (1,2,3,4,5,6,7,8) ])
\end{Verbatim}
 

 We formed the group generated by the permutations \texttt{(1,2)} and \texttt{(1,2,3,4,5,6,7,8)}, which is well known to be the symmetric group $S_8$ on eight points, and assigned it to the identifier \texttt{s8}. Now $S_8$ contains the alternating group on eight points which can be described in
several ways, e.g., as the group of all even permutations in \texttt{s8}, or as its derived subgroup. Once we ask \textsf{GAP} to verify that the group is an alternating group acting in its natural
permutation representation, the system will display the group accordingly. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@a8 := DerivedSubgroup( s8 );|
  Group([ (1,2,3), (2,3,4), (2,4)(3,5), (2,6,4), (2,4)(5,7), 
    (2,8,6,4)(3,5) ])
  !gapprompt@gap>| !gapinput@Size( a8 ); IsAbelian( a8 ); IsPerfect( a8 );|
  20160
  false
  true
  !gapprompt@gap>| !gapinput@IsNaturalAlternatingGroup(a8);|
  true
  !gapprompt@gap>| !gapinput@a8;|
  Alt( [ 1 .. 8 ] )
\end{Verbatim}
 

 Once information about a group like \texttt{s8} or \texttt{a8} has been computed, it is stored in the group so that it can simply be looked
up when it is required again. This holds for all pieces of information in the
previous example. Namely, \texttt{a8} stores its order and that it is nonabelian and perfect, and \texttt{s8} stores its derived subgroup \texttt{a8}. Had we computed \texttt{a8} as \texttt{CommutatorSubgroup( s8, s8 )}, however, it would not have been stored, because it would then have been
computed as a function of \emph{two} arguments, and hence one could not attribute it to just one of them. (Of
course the function \texttt{CommutatorSubgroup} (\textbf{Reference: CommutatorSubgroup}) can compute the commutator subgroup of \emph{two} arbitrary subgroups.) The situation is a bit different for Sylow $p$-subgroups: The function \texttt{SylowSubgroup} (\textbf{Reference: SylowSubgroup}) also requires two arguments, namely a group and a prime $p$, but the result is stored in the group {\textendash}namely together with the
prime $p$ in a list that can be accessed with \texttt{ComputedSylowSubgroups}, but we won't dwell on the details here. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@syl2 := SylowSubgroup( a8, 2 );; Size( syl2 );|
  64
  !gapprompt@gap>| !gapinput@Normalizer( a8, syl2 ) = syl2;|
  true
  !gapprompt@gap>| !gapinput@cent := Centralizer( a8, Centre( syl2 ) );; Size( cent );|
  192
  !gapprompt@gap>| !gapinput@DerivedSeries( cent );; List( last, Size );|
  [ 192, 96, 32, 2, 1 ]
\end{Verbatim}
 

 We have typed double semicolons after some commands to avoid the output of the
groups (which would be printed by their generator lists). Nevertheless, the
beginner is encouraged to type a single semicolon instead and study the full
output. This remark also applies for the rest of this tutorial. 

 With the next examples, we want to calculate a subgroup of \texttt{a8}, then its normalizer and finally determine the structure of the extension. We
begin by forming a subgroup generated by three commuting involutions, i.e., a
subgroup isomorphic to the additive group of the vector space $2^3$. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@elab := Group( (1,2)(3,4)(5,6)(7,8), (1,3)(2,4)(5,7)(6,8),|
  !gapprompt@>| !gapinput@                  (1,5)(2,6)(3,7)(4,8) );;|
  !gapprompt@gap>| !gapinput@Size( elab );|
  8
  !gapprompt@gap>| !gapinput@IsElementaryAbelian( elab );|
  true
\end{Verbatim}
 

 As usual, \textsf{GAP} prints the group by giving all its generators. This can be annoying,
especially if there are many of them or if they are of huge degree. It also
makes it difficult to recognize a particular group when there are already
several around. Note that although it is no problem for \emph{us} to specify a particular group to \textsf{GAP}, by using well-chosen identifiers such as \texttt{a8} and \texttt{elab}, it is impossible for \textsf{GAP} to use these identifiers when printing a group for us, because the group does
not know which identifier(s) point to it, in fact there can be several. In
order to give a name to the group itself (rather than to the identifier), you
can use the function \texttt{SetName} (\textbf{Reference: SetName}). We do this with the name \texttt{2\texttt{\symbol{94}}3} here which reflects the mathematical properties of the group. From now on, \textsf{GAP} will use this name when printing the group for us, but we still cannot use
this name to specify the group to \textsf{GAP}, because the name does not know to which group it was assigned (after all,
you could assign the same name to several groups). When talking to the
computer, you must always use identifiers. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SetName( elab, "<group of type 2^3>" ); elab;|
  <group of type 2^3>
  !gapprompt@gap>| !gapinput@norm := Normalizer( a8, elab );; Size( norm );|
  1344
\end{Verbatim}
 

 \index{homomorphism!natural} Now that we have the subgroup \texttt{norm} of order 1344 and its subgroup \texttt{elab}, we want to look at its factor group. But since we also want to find
preimages of factor group elements in \texttt{norm}, we really want to look at the \emph{natural homomorphism} defined on \texttt{norm} with kernel \texttt{elab} and whose image is the factor group. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@hom := NaturalHomomorphismByNormalSubgroup( norm, elab );|
  <action epimorphism>
  !gapprompt@gap>| !gapinput@f := Image( hom );|
  Group([ (), (), (), (4,5)(6,7), (4,6)(5,7), (2,3)(6,7), (2,4)(3,5), 
   (1,2)(5,6) ])
  !gapprompt@gap>| !gapinput@Size( f );|
  168
\end{Verbatim}
 

 The factor group is again represented as a permutation group (its first three
generators are trivial, meaning that the first three generators of the
preimage are in the kernel of \texttt{hom}). However, the action domain of this factor group has nothing to do with the
action domain of \texttt{norm}. (It only happens that both are subsets of the natural numbers.) We can now
form images and preimages under the natural homomorphism. The set of preimages
of an element under \texttt{hom} is a coset modulo \texttt{elab}. We use the function \texttt{PreImages} (\textbf{Reference: PreImages}) here because \texttt{hom} is not a bijection, so an element of the range can have several preimages or
none at all. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ker:= Kernel( hom );|
  <group of type 2^3>
  !gapprompt@gap>| !gapinput@x := (1,8,3,5,7,6,2);; Image( hom, x );|
  (1,7,5,6,2,3,4)
  !gapprompt@gap>| !gapinput@coset := PreImages( hom, last );|
  RightCoset(<group of type 2^3>,(2,8,6,7,3,4,5))
\end{Verbatim}
 

 Note that \textsf{GAP} is free to choose any representative for the coset of preimages. Of course the
quotient of two representatives lies in the kernel of the homomorphism. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@rep:= Representative( coset );|
  (2,8,6,7,3,4,5)
  !gapprompt@gap>| !gapinput@x * rep^-1 in ker;|
  true
\end{Verbatim}
 

 The factor group \texttt{f} is a simple group, i.e., it has no non-trivial normal subgroups. \textsf{GAP} can detect this fact, and it can then also find the name by which this simple
group is known among group theorists. (Such names are of course not available
for non-simple groups.) 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsSimple( f ); IsomorphismTypeInfoFiniteSimpleGroup( f );|
  true
  rec( 
    name := "A(1,7) = L(2,7) ~ B(1,7) = O(3,7) ~ C(1,7) = S(2,7) ~ 2A(1,\
  7) = U(2,7) ~ A(2,2) = L(3,2)", parameter := [ 2, 7 ], series := "L" )
  !gapprompt@gap>| !gapinput@SetName( f, "L_3(2)" );|
\end{Verbatim}
 

 We give \texttt{f} the name \texttt{L{\textunderscore}3(2)} because the last part of the name string reveals that it is isomorphic to the
simple linear group $L_3(2)$. This group, however, also has a lot of other names. Names that are connected
with a \texttt{=} sign are different names for the same matrix group, e.g., \texttt{A(2,2)} is the Lie type notation for the classical notation \texttt{L(3,2)}. Other pairs of names are connected via \texttt{\texttt{\symbol{126}}}, these then specify other classical groups that are isomorphic to that linear
group (e.g., the symplectic group \texttt{S(2,7)}, whose Lie type notation would be \texttt{C(1,7)}). 

 The group \texttt{norm} acts on the eight elements of its normal subgroup \texttt{elab} by conjugation, yielding a representation of $L_3(2)$ in \texttt{s8} which leaves one point fixed (namely point{\nobreakspace}\texttt{1}). The image of this representation can be computed with the function \texttt{Action} (\textbf{Reference: Action homomorphisms}); it is even contained in the group \texttt{norm} and we can show that \texttt{norm} is indeed a split extension of the elementary abelian group $2^3$ with this image of $L_3(2)$. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@op := Action( norm, elab );|
  Group([ (), (), (), (5,6)(7,8), (5,7)(6,8), (3,4)(7,8), (3,5)(4,6), 
    (2,3)(6,7) ])
  !gapprompt@gap>| !gapinput@IsSubgroup( a8, op ); IsSubgroup( norm, op );|
  true
  true
  !gapprompt@gap>| !gapinput@IsTrivial( Intersection( elab, op ) );|
  true
  !gapprompt@gap>| !gapinput@SetName( norm, "2^3:L_3(2)" );|
\end{Verbatim}
 

 By the way, you should not try the operator \texttt{{\textless}} instead of the function \texttt{IsSubgroup} (\textbf{Reference: IsSubgroup}). Something like 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@elab < a8;|
  false
\end{Verbatim}
 

 will not cause an error, but the result does not signify anything about the
inclusion of one group in another; \texttt{{\textless}} tests which of the two groups is less in some total order. On the other hand,
the equality operator \texttt{=} in fact does test the equality of its arguments. 

 \emph{Summary.} In this section we have used the elementary group functions to determine the
structure of a normalizer. We have assigned names to the involved groups which
reflect their mathematical structure and \textsf{GAP} uses these names when printing the groups. }

  
\section{\textcolor{Chapter }{Actions of Groups}}\label{Actions of Groups}
\logpage{[ 5, 2, 0 ]}
\hyperdef{L}{X8493BB7D7ECB5AB2}{}
{
  In order to get another representation of \texttt{a8}, we consider another action, namely that on the elements of a certain
conjugacy class by conjugation. 

 In the following example we temporarily increase the line length limit from
its default value 80 to 82 in order to make the long expression fit into one
line. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ccl := ConjugacyClasses( a8 );; Length( ccl );|
  14
  !gapprompt@gap>| !gapinput@List( ccl, c -> Order( Representative( c ) ) );|
  [ 1, 2, 2, 3, 6, 3, 4, 4, 5, 15, 15, 6, 7, 7 ]
  !gapprompt@gap>| !gapinput@List( ccl, Size );|
  [ 1, 210, 105, 112, 1680, 1120, 2520, 1260, 1344, 1344, 1344, 3360, 
    2880, 2880 ]
\end{Verbatim}
 

 Note the difference between \texttt{Order} (\textbf{Reference: Order}) (which means the element order), \texttt{Size} (\textbf{Reference: Size}) (which means the size of the conjugacy class) and \texttt{Length} (\textbf{Reference: Length}) (which means the length of a list). We choose to let \texttt{a8} operate on the class of length{\nobreakspace}112. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@class := First( ccl, c -> Size(c) = 112 );;|
  !gapprompt@gap>| !gapinput@op := Action( a8, AsList( class ),OnPoints );;|
\end{Verbatim}
 

 We use \texttt{AsList} (\textbf{Reference: AsList}) here to convert the conjugacy class into a list of its elements whereas we
wrote \texttt{Action( norm, elab )} directly in the previous section. The reason is that the elementary abelian
group \texttt{elab} can be quickly enumerated by \textsf{GAP} whereas the standard enumeration method for conjugacy classes is slower than
just explicit calculation of the elements. However, \textsf{GAP} is reluctant to construct explicit element lists, because for really large
groups this direct method is infeasible. 

 Note also the function \texttt{First} (\textbf{Reference: First}), used to find the first element in a list which passes some test. 

 In this example, we have specified the action function \texttt{OnPoints} (\textbf{Reference: OnPoints}) in this example, which is defined as \texttt{OnPoints( }$d$\texttt{, }$g$\texttt{ ) = }$d$\texttt{ \texttt{\symbol{94}} }$g$. This ``caret'' operator denotes conjugation in a group if both arguments $d$ and $g$ are group elements (contained in a common group), but it also denotes the
natural action of permutations on positive integers (and exponentiation of
integers as well, of course). It is in fact the default action and will be
supplied by the system if not given. Another common action is for example
always assumes \texttt{OnRight} (\textbf{Reference: OnRight}), which means right multiplication, defined as $d$\texttt{ * }$g$. (Group actions in \textsf{GAP} are always from the right.) 

 We now have a permutation representation \texttt{op} on 112 points, which we test for primitivity. If it is not primitive, we can
obtain a minimal block system (i.e., one where the blocks have minimal length)
by the function \texttt{Blocks} (\textbf{Reference: Blocks}). 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsPrimitive( op, [ 1 .. 112 ] );|
  false
  !gapprompt@gap>| !gapinput@blocks := Blocks( op, [ 1 .. 112 ] );;|
\end{Verbatim}
 

 Note that we must specify the domain of the action. You might think that the
functions \texttt{IsPrimitive} (\textbf{Reference: IsPrimitive}) and \texttt{Blocks} (\textbf{Reference: Blocks}) could use \texttt{[ 1 .. 112 ]} as default domain if no domain was given. But this is not so easy, for example
would the default domain of \texttt{Group( (2,3,4) )} be \texttt{[ 1 .. 4 ]} or \texttt{[ 2 .. 4 ]}? To avoid confusion, all action functions require that you specify the domain
of action. If we had specified \texttt{[ 1 .. 113 ]} in the primitivity test above, point{\nobreakspace}113 would have been a
fixpoint (and the action would not even have been transitive). 

 Now \texttt{blocks} is a list of blocks (i.e., a list of lists), which we do not print here for
the sake of saving paper (try it for yourself). In fact all we want to know is
the size of the blocks, or rather how many there are (the product of these two
numbers must of course be{\nobreakspace}112). Then we can obtain a new
permutation group of the corresponding degree by letting \texttt{op} act on these blocks setwise. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Length( blocks[1] );  Length( blocks );|
  2
  56
  !gapprompt@gap>| !gapinput@op2 := Action( op, blocks, OnSets );;|
  !gapprompt@gap>| !gapinput@IsPrimitive( op2, [ 1 .. 56 ] );|
  true
\end{Verbatim}
 

 Note that we give a third argument (the action function \texttt{OnSets} (\textbf{Reference: OnSets})) to indicate that the action is not the default action on points but an
action on sets of elements given as sorted lists. (Section{\nobreakspace} (\textbf{Reference: Basic Actions}) lists all actions that are pre-defined by \textsf{GAP}.) 

 The action of \texttt{op} on the given block system gave us a new representation on 56 points which is
primitive, i.e., the point stabilizer is a maximal subgroup. We compute its
preimage in the representation on eight points using the associated action
homomorphisms (which of course in this case are monomorphisms). We construct
the composition of two homomorphisms with the \texttt{*} operator, reading left-to-right. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ophom := ActionHomomorphism( a8, op );;|
  !gapprompt@gap>| !gapinput@ophom2 := ActionHomomorphism( op, op2 );;|
  !gapprompt@gap>| !gapinput@composition := ophom * ophom2;;|
  !gapprompt@gap>| !gapinput@stab := Stabilizer( op2, 2 );;|
  !gapprompt@gap>| !gapinput@preim := PreImages( composition, stab );|
  Group([ (1,4,2), (3,6,7), (3,8,5,7,6), (1,4)(7,8) ])
\end{Verbatim}
 

 Alternatively, it is possible to create action homomorphisms immediately
(without creating the action first) by giving the same set of arguments to \texttt{ActionHomomorphism} (\textbf{Reference: ActionHomomorphism}). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@nophom := ActionHomomorphism( a8, AsList(class) );|
  <action homomorphism>
  !gapprompt@gap>| !gapinput@IsSurjective(nophom);|
  false
  !gapprompt@gap>| !gapinput@Image(nophom,(1,2,3));|
  (2,43,14)(3,44,20)(4,45,26)(5,46,32)(6,47,38)(8,13,48)(9,19,53)(10,25,
  58)(11,31,63)(12,37,68)(15,49,73)(16,50,74)(17,51,75)(18,52,76)(21,54,
  77)(22,55,78)(23,56,79)(24,57,80)(27,59,81)(28,60,82)(29,61,83)(30,62,
  84)(33,64,85)(34,65,86)(35,66,87)(36,67,88)(39,69,89)(40,70,90)(41,71,
  91)(42,72,92)
\end{Verbatim}
 

 In this situation, however (for performance reasons, avoiding computation an
image that might never be needed) the homomorphism is defined to be not into
the \emph{Image} of the action, but into the \emph{full symmetric group}, i.e. it is not automatically surjective. Surjectivity can be enforced by
giving the string \texttt{"surjective"} as an extra last argument. The \texttt{Image} of the action homomorphism of course is the same group in either case. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Size(Range(nophom));|
  1974506857221074023536820372759924883412778680349753377966562950949028\
  5896977181144089422435502777936659795733823785363827233491968638562181\
  1850780464277094400000000000000000000000000
  !gapprompt@gap>| !gapinput@Size(Range(ophom));|
  20160
  !gapprompt@gap>| !gapinput@nophom := ActionHomomorphism( a8, AsList(class),"surjective" );|
  <action epimorphism>
  !gapprompt@gap>| !gapinput@Size(Range(nophom));|
  20160
\end{Verbatim}
 

 Continuing the example, the normalizer of an element in the conjugacy class \texttt{class} is a group of order 360, too. In fact, it is a conjugate of the maximal
subgroup we had found before, and a conjugating element in \texttt{a8} is found by the function \texttt{RepresentativeAction} (\textbf{Reference: RepresentativeAction}). 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@sgp := Normalizer( a8, Subgroup(a8,[Representative(class)]) );;|
  !gapprompt@gap>| !gapinput@Size( sgp );|
  360
  !gapprompt@gap>| !gapinput@RepresentativeAction( a8, sgp, preim );|
  (2,4,3)
\end{Verbatim}
                

 \index{homomorphism!operation} \index{homomorphism!action} \index{enumerator} \index{transversal} \index{canonical position} One of the most prominent actions of a group is on the cosets of a subgroup.
Na{\"\i}vely this can be done by constructing the cosets and acting on them by
right multiplication. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@cosets:=RightCosets(a8,norm);;|
  !gapprompt@gap>| !gapinput@op:=Action(a8,cosets,OnRight);|
  Group([ (1,2,3)(4,6,5)(7,8,9)(10,12,11)(13,14,15), 
    (1,3,2)(4,9,13)(5,11,7)(6,15,10)(8,12,14), 
    (1,13)(2,7)(3,10)(4,11)(5,15)(6,9), 
    (1,8,13)(2,7,12)(3,9,5)(4,14,11)(6,10,15), 
    (2,3)(4,14)(5,7)(8,13)(9,12)(10,15), 
    (1,8)(2,3,11,6)(4,12,10,15)(5,7,14,9) ])
  !gapprompt@gap>| !gapinput@NrMovedPoints(op);|
  15
\end{Verbatim}
 

 A problem with this approach is that creating (and storing) all cosets can be
very memory intensive if the subgroup index gets large. Because of this, \textsf{GAP} provides special objects which act like a list of elements, but do not
actually store elements but compute them on the go. Such a simulated list is
called an \emph{enumerator}. The easiest example of this concept is the \texttt{Enumerator} (\textbf{Reference: Enumerator}) of a group. While it behaves like a list of elements, it requires far less
storage, and is applicable to potentially huge groups for which it would be
completely infeasible to write down all elements: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@enum:=Enumerator(SymmetricGroup(20));|
  <enumerator of perm group>
  !gapprompt@gap>| !gapinput@Length(enum);|
  2432902008176640000
  !gapprompt@gap>| !gapinput@enum[123456789012345];|
  (1,4,15,3,14,11,8,17,6,18,5,7,20,13,10,9,2,12)
  !gapprompt@gap>| !gapinput@Position(enum,(1,2,3,4,5,6,7,8,9,10));|
  71948729603
\end{Verbatim}
 

 For the action on cosets the object of interest is the \texttt{RightTransversal} (\textbf{Reference: RightTransversal}) of a subgroup. Again, it does not write out actual elements and thus can be
created even for subgroups of large index. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@t:=RightTransversal(a8,norm);|
  RightTransversal(Alt( [ 1 .. 8 ] ),2^3:L_3(2))
  !gapprompt@gap>| !gapinput@t[7];|
  (4,6,5)
  !gapprompt@gap>| !gapinput@Position(t,(4,6,7,8,5));|
  8
  !gapprompt@gap>| !gapinput@Position(t,(1,2,3));|
  fail
\end{Verbatim}
 

 For the action on cosets there is the added complication that not every group
element is in the transversal (as the last example shows) but the action on
cosets of a subgroup usually will not preserve a chosen set of coset
representatives. Because of this issue, all action functionality actually uses \texttt{PositionCanonical} (\textbf{Reference: PositionCanonical}) instead of \texttt{Position} (\textbf{Reference: Position}). In general, for elements contained in a list, \texttt{PositionCanonical} (\textbf{Reference: PositionCanonical}) returns the same as \texttt{Position}. If the element is not contained in the list (and for special lists, such as
transversals), \texttt{PositionCanonical} returns the list element representing the same objects, e.g. the transversal
element representing the same coset. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PositionCanonical(t,(1,2,3));|
  2
  !gapprompt@gap>| !gapinput@t[2];|
  (6,7,8)
  !gapprompt@gap>| !gapinput@t[2]/(1,2,3);|
  (1,3,2)(6,7,8)
  !gapprompt@gap>| !gapinput@last in norm;|
  true
\end{Verbatim}
 Thus, acting on a \texttt{RightTransversal} with the \texttt{OnRight} action will in fact (in a slight abuse of definitions) produce the action of a
group on cosets of a subgroup and is in general the most efficient way of
creating this action. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Action(a8,RightTransversal(a8,norm),OnRight);|
  Group([ (1,2,3)(4,6,5)(7,8,9)(10,12,11)(13,14,15), 
    (1,3,2)(4,9,13)(5,11,7)(6,15,10)(8,12,14), 
    (1,13)(2,7)(3,10)(4,11)(5,15)(6,9), 
    (1,8,13)(2,7,12)(3,9,5)(4,14,11)(6,10,15), 
    (2,3)(4,14)(5,7)(8,13)(9,12)(10,15), 
    (1,8)(2,3,11,6)(4,12,10,15)(5,7,14,9) ])
\end{Verbatim}
 

 \emph{Summary.} In this section we have learned how groups can operate on \textsf{GAP} objects such as integers and group elements. We have used \texttt{ActionHomomorphism} (\textbf{Reference: ActionHomomorphism}), among others, to construct the corresponding actions and homomorphisms and
have seen how transversals can be used to create the action on cosets of a
subgroup. }

  
\section{\textcolor{Chapter }{Subgroups as Stabilizers}}\label{Subgroups!as Stabilizers}
\logpage{[ 5, 3, 0 ]}
\hyperdef{L}{X8742F6A083ADE513}{}
{
  Action functions can also be used without constructing external sets. We will
try to find several subgroups in \texttt{a8} as stabilizers of such actions. One subgroup is immediately available, namely
the stabilizer of one point. The index of the stabilizer must of course be
equal to the length of the orbit, i.e.,{\nobreakspace}8. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@u8 := Stabilizer( a8, 1 );|
  Group([ (2,3,4), (2,4)(3,5), (2,6,4), (2,4)(5,7), (2,8,6,4)(3,5) ])
  !gapprompt@gap>| !gapinput@Index( a8, u8 );|
  8
  !gapprompt@gap>| !gapinput@Orbit( a8, 1 ); Length( last );|
  [ 1, 3, 2, 4, 5, 6, 7, 8 ]
  8
\end{Verbatim}
 

 This gives us a hint how to find further subgroups. Each subgroup is the
stabilizer of a point of an appropriate transitive action (namely the action
on the cosets of that subgroup or another action that is equivalent to this
action). So the question is how to find other actions. The obvious thing is to
operate on pairs of points. So using the function \texttt{Tuples} (\textbf{Reference: Tuples}) we first generate a list of all pairs. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@pairs := Tuples( [1..8], 2 );;|
\end{Verbatim}
 

 Now we would like to have \texttt{a8} operate on this domain. But we cannot use the default action \texttt{OnPoints} (\textbf{Reference: OnPoints}) because powering a list by a permutation via the caret operator \texttt{\texttt{\symbol{94}}} is not defined. So we must tell the functions from the actions package how the
group elements operate on the elements of the domain (here and below, the word ``package'' refers to the \textsf{GAP} functionality for group actions, not to a \textsf{GAP} package). In our example we can do this by simply passing \texttt{OnPairs} (\textbf{Reference: OnPairs}) as an optional last argument. All functions from the actions package accept
such an optional argument that describes the action. One example is \texttt{IsTransitive} (\textbf{Reference: IsTransitive}). 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsTransitive( a8, pairs, OnPairs );|
  false
\end{Verbatim}
 

 The action is of course not transitive, since the pairs \texttt{[ 1, 1 ]} and \texttt{[ 1, 2 ]} cannot lie in the same orbit. So we want to find out what the orbits are. The
function \texttt{Orbits} (\textbf{Reference: Orbits}) does that for us. It returns a list of all the orbits. We look at the orbit
lengths and representatives for the orbits. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@orbs := Orbits( a8, pairs, OnPairs );; Length( orbs );|
  2
  !gapprompt@gap>| !gapinput@List( orbs, Length );|
  [ 8, 56 ]
  !gapprompt@gap>| !gapinput@List( orbs, o -> o[1] );|
  [ [ 1, 1 ], [ 1, 2 ] ]
\end{Verbatim}
 

 The action of \texttt{a8} on the first orbit (this is the one containing \texttt{[1,1]}, try \texttt{[1,1] in orbs[1]}) is of course equivalent to the original action, so we ignore it and work
with the second orbit. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@u56 := Stabilizer( a8, orbs[2][1], OnPairs );; Index( a8, u56 );|
  56
\end{Verbatim}
 

 So now we have found a second subgroup. To make the following computations a
little bit easier and more efficient we would now like to work on the points \texttt{[ 1 .. 56 ]} instead of the list of pairs. The function \texttt{ActionHomomorphism} (\textbf{Reference: ActionHomomorphism}) does what we need. It creates a homomorphism defined on \texttt{a8} whose image is a new group that acts on \texttt{[ 1 .. 56 ]} in the same way that \texttt{a8} acts on the second orbit. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@h56 := ActionHomomorphism( a8, orbs[2], OnPairs );;|
  !gapprompt@gap>| !gapinput@a8_56 := Image( h56 );;|
\end{Verbatim}
 

 We would now like to know if the subgroup \texttt{u56} of index 56 that we found is maximal or not. As we have used already in
Section{\nobreakspace}\ref{Actions of Groups}, a subgroup is maximal if and only if the action on the cosets of this
subgroup is primitive. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsPrimitive( a8_56, [1..56] );|
  false
\end{Verbatim}
 

 Remember that we can leave out the function if we mean \texttt{OnPoints} (\textbf{Reference: OnPoints}) but that we have to specify the action domain for all action functions. 

 We see that \texttt{a8{\textunderscore}56} is not primitive. This means of course that the action of \texttt{a8} on \texttt{orb[2]} is not primitive, because those two actions are equivalent. So the stabilizer \texttt{u56} is not maximal. Let us try to find its supergroups. We use the function \texttt{Blocks} (\textbf{Reference: Blocks}) to find a block system. The (optional) third argument in the following example
tells \texttt{Blocks} (\textbf{Reference: Blocks}) that we want a block system where 1 and 3 lie in one block. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@blocks := Blocks( a8_56, [1..56], [1,3] );;|
\end{Verbatim}
 

 The result is a list of sets, such that \texttt{a8{\textunderscore}56} acts on those sets. Now we would like the stabilizer of this action on the
sets. Because we want to operate on the sets we have to pass \texttt{OnSets} (\textbf{Reference: OnSets}) as third argument. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@u8_56 := Stabilizer( a8_56, blocks[1], OnSets );;|
  !gapprompt@gap>| !gapinput@Index( a8_56, u8_56 );|
  8
  !gapprompt@gap>| !gapinput@u8b := PreImages( h56, u8_56 );; Index( a8, u8b );|
  8
  !gapprompt@gap>| !gapinput@IsConjugate( a8, u8, u8b );|
  true
\end{Verbatim}
 

 So we have found a supergroup of \texttt{u56} that is conjugate in \texttt{a8} to \texttt{u8}. This is not surprising, since \texttt{u8} is a point stabilizer, and \texttt{u56} is a two point stabilizer in the natural action of \texttt{a8} on eight points. 

 Here is a \emph{warning}: If you specify \texttt{OnSets} (\textbf{Reference: OnSets}) as third argument to a function like \texttt{Stabilizer} (\textbf{Reference: Stabilizers}), you have to make sure that the point (i.e. the second argument) is indeed a
set. Otherwise you will get a puzzling error message or even wrong results! In
the above example, the second argument \texttt{blocks[1]} came from the function \texttt{Blocks} (\textbf{Reference: Blocks}), which returns a list of sets, so everything was OK. 

 Actually there is a third block system of \texttt{a8{\textunderscore}56} that gives rise to a third subgroup. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@blocks := Blocks( a8_56, [1..56], [1,13] );;|
  !gapprompt@gap>| !gapinput@u28_56 := Stabilizer( a8_56, [1,13], OnSets );;|
  !gapprompt@gap>| !gapinput@u28 := PreImages( h56, u28_56 );;|
  !gapprompt@gap>| !gapinput@Index( a8, u28 );|
  28
\end{Verbatim}
 

 We know that the subgroup \texttt{u28} of index 28 is maximal, because we know that \texttt{a8} has no subgroups of index 2, 4, or 7. However we can also quickly verify this
by checking that \texttt{a8{\textunderscore}56} acts primitively on the 28 blocks. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsPrimitive( a8_56, blocks, OnSets );|
  true
\end{Verbatim}
 

 \texttt{Stabilizer} (\textbf{Reference: Stabilizers}) is not only applicable to groups like \texttt{a8} but also to their subgroups like \texttt{u56}. So another method to find a new subgroup is to compute the stabilizer of
another point in \texttt{u56}. Note that \texttt{u56} already leaves 1 and 2 fixed. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@u336 := Stabilizer( u56, 3 );;|
  !gapprompt@gap>| !gapinput@Index( a8, u336 );|
  336
\end{Verbatim}
 

 Other functions are also applicable to subgroups. In the following we show
that \texttt{u336} acts regularly on the 60{\nobreakspace}triples of \texttt{[ 4 .. 8 ]} which contain no element twice. We construct the list of these
60{\nobreakspace}triples with the function \texttt{Orbit} (\textbf{Reference: Orbit}) (using \texttt{OnTuples} (\textbf{Reference: OnTuples}) as the natural generalization of \texttt{OnPairs} (\textbf{Reference: OnPairs})) and then pass it as action domain to the function \texttt{IsRegular} (\textbf{Reference: IsRegular}). The positive result of the regularity test means that this action is
equivalent to the actions of \texttt{u336} on its 60 elements from the right. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsRegular( u336, Orbit( u336, [4,5,6], OnTuples ), OnTuples );|
  true
\end{Verbatim}
 

 Just as we did in the case of the action on the pairs above, we now construct
a new permutation group that acts on \texttt{[ 1 .. 336 ]} in the same way that \texttt{a8} acts on the cosets of \texttt{u336}. But this time we let \texttt{a8} operate on a right transversal, just like \texttt{norm} did in the natural homomorphism above. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@t := RightTransversal( a8, u336 );;|
  !gapprompt@gap>| !gapinput@a8_336 := Action( a8, t, OnRight );;|
\end{Verbatim}
 

 To find subgroups above \texttt{u336} we again look for nontrivial block systems. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@blocks := Blocks( a8_336, [1..336] );; blocks[1];|
  [ 1, 43, 85 ]
\end{Verbatim}
 

 We see that the union of \texttt{u336} with its 43rd and its 85th coset is a subgroup in \texttt{a8{\textunderscore}336}, its index is 112. We can obtain it as the closure of \texttt{u336} with a representative of the 43rd coset, which can be found as the 43rd
element of the transversal{\nobreakspace}\texttt{t}. Note that in the representation \texttt{a8{\textunderscore}336} on 336 points, this subgroup corresponds to the stabilizer of the block \texttt{[ 1, 43, 85 ]}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@u112 := ClosureGroup( u336, t[43] );;|
  !gapprompt@gap>| !gapinput@Index( a8, u112 );|
  112
\end{Verbatim}
 

 Above this subgroup of index 112 lies a subgroup of index 56, which is not
conjugate to \texttt{u56}. In fact, unlike \texttt{u56} it is maximal. We obtain this subgroup in the same way that we obtained \texttt{u112}, this time forcing two points, namely 7 and 43 into the first block. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@blocks := Blocks( a8_336, [1..336], [1,7,43] );;|
  !gapprompt@gap>| !gapinput@Length( blocks );|
  56
  !gapprompt@gap>| !gapinput@u56b := ClosureGroup( u112, t[7] );; Index( a8, u56b );|
  56
  !gapprompt@gap>| !gapinput@IsPrimitive( a8_336, blocks, OnSets );|
  true
\end{Verbatim}
 

 We already mentioned in Section{\nobreakspace}\ref{Actions of Groups} that there is another standard action of permutations, namely the conjugation.
E.g., since no other action is specified in the following example, \texttt{OrbitLength} (\textbf{Reference: OrbitLength}) simply acts via \texttt{OnPoints} (\textbf{Reference: OnPoints}), and because \mbox{\texttt{\mdseries\slshape perm{\textunderscore}1}}\texttt{ \texttt{\symbol{94}} }\mbox{\texttt{\mdseries\slshape perm{\textunderscore}2}} is defined as the conjugation of \mbox{\texttt{\mdseries\slshape perm{\textunderscore}2}} on \mbox{\texttt{\mdseries\slshape perm{\textunderscore}1}}, in fact we compute the length of the conjugacy class of \texttt{(1,2)(3,4)(5,6)(7,8)}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@OrbitLength( a8, (1,2)(3,4)(5,6)(7,8) );|
  105
  !gapprompt@gap>| !gapinput@orb := Orbit( a8, (1,2)(3,4)(5,6)(7,8) );;|
  !gapprompt@gap>| !gapinput@u105 := Stabilizer( a8, (1,2)(3,4)(5,6)(7,8) );; Index( a8, u105 );|
  105
\end{Verbatim}
 

 Note that although the length of a conjugacy class of any element $g$ in any finite group $G$ can be computed as \texttt{OrbitLength( }$G$\texttt{, }$g$\texttt{ )}, the command \texttt{Size( ConjugacyClass( }$G$\texttt{, }$g$\texttt{ ) )} is probably more efficient. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Size( ConjugacyClass( a8, (1,2)(3,4)(5,6)(7,8) ) );|
  105
\end{Verbatim}
 

 Of course the stabilizer \texttt{u105} is in fact the centralizer of the element \texttt{(1,2)(3,4)(5,6)(7,8)}. \texttt{Stabilizer} (\textbf{Reference: Stabilizers}) notices that and computes the stabilizer using the centralizer algorithm for
permutation groups. In the usual way we now look for the subgroups above \texttt{u105}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@blocks := Blocks( a8, orb );; Length( blocks );|
  15
  !gapprompt@gap>| !gapinput@blocks[1];|
  [ (1,2)(3,4)(5,6)(7,8), (1,3)(2,4)(5,7)(6,8), (1,4)(2,3)(5,8)(6,7), 
    (1,5)(2,6)(3,7)(4,8), (1,6)(2,5)(3,8)(4,7), (1,7)(2,8)(3,5)(4,6), 
    (1,8)(2,7)(3,6)(4,5) ]
\end{Verbatim}
 

 To find the subgroup of index 15 we again use closure. Now we must be a little
bit careful to avoid confusion. \texttt{u105} is the stabilizer of \texttt{(1,2)(3,4)(5,6)(7,8)}. We know that there is a correspondence between the points of the orbit and
the cosets of \texttt{u105}. The point \texttt{(1,2)(3,4)(5,6)(7,8)} corresponds to \texttt{u105}. To get the subgroup above \texttt{u105} that has index 15 in \texttt{a8}, we must form the closure of \texttt{u105} with an element of the coset that corresponds to any other point in the first
block. If we choose the point \texttt{(1,3)(2,4)(5,8)(6,7)}, we must use an element of \texttt{a8} that maps \texttt{(1,2)(3,4)(5,6)(7,8)} to \texttt{(1,3)(2,4)(5,8)(6,7)}. The function \texttt{RepresentativeAction} (\textbf{Reference: RepresentativeAction}) does what we need. It takes a group and two points and returns an element of
the group that maps the first point to the second. In fact it also allows you
to specify the action as an optional fourth argument as usual, but we do not
need this here. If no such element exists in the group, i.e., if the two
points do not lie in one orbit under the group, \texttt{RepresentativeAction} (\textbf{Reference: RepresentativeAction}) returns \texttt{fail}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@rep := RepresentativeAction( a8, (1,2)(3,4)(5,6)(7,8),|
  !gapprompt@>| !gapinput@                                       (1,3)(2,4)(5,8)(6,7) );|
  (2,3)(6,8)
  !gapprompt@gap>| !gapinput@u15 := ClosureGroup( u105, rep );; Index( a8, u15 );|
  15
\end{Verbatim}
 

 \texttt{u15} is of course a maximal subgroup, because \texttt{a8} has no subgroups of index 3 or{\nobreakspace}5. There is in fact another class
of subgroups of index 15 above \texttt{u105} that we get by adding \texttt{(2,3)(6,7)} to \texttt{u105}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@u15b := ClosureGroup( u105, (2,3)(6,7) );; Index( a8, u15b );|
  15
  !gapprompt@gap>| !gapinput@RepresentativeAction( a8, u15, u15b );|
  fail
\end{Verbatim}
 

 \texttt{RepresentativeAction} (\textbf{Reference: RepresentativeAction}) tells us that there is no element $g$ in \texttt{a8} such that \texttt{u15 \texttt{\symbol{94}} }$g$\texttt{ = u15b}. Because \texttt{\texttt{\symbol{94}}} also denotes the conjugation of subgroups this tells us that \texttt{u15} and \texttt{u15b} are not conjugate. 

 \emph{Summary.} In this section we have demonstrated some functions from the actions package.
There is a whole class of functions that we did not mention, namely those that
take a single element instead of a whole group as first argument, e.g., \texttt{Cycle} (\textbf{Reference: Cycle}) and \texttt{Permutation} (\textbf{Reference: Permutation}). These are fully described in Chapter  (\textbf{Reference: Group Actions}). }

  
\section{\textcolor{Chapter }{Group Homomorphisms by Images}}\label{Group Homomorphisms!by Images}
\logpage{[ 5, 4, 0 ]}
\hyperdef{L}{X8131EE9182385680}{}
{
  We have already seen examples of group homomorphisms in the last sections,
namely natural homomorphisms and action homomorphisms. In this section we will
show how to construct a group homomorphism $G \rightarrow H$ by specifying a generating set for $G$ and the images of these generators in{\nobreakspace}$H$. We use the function \texttt{GroupHomomorphismByImages( \mbox{\texttt{\mdseries\slshape G}}, \mbox{\texttt{\mdseries\slshape H}}, \mbox{\texttt{\mdseries\slshape gens}}, \mbox{\texttt{\mdseries\slshape imgs}} )} where \mbox{\texttt{\mdseries\slshape gens}} is a generating set for \mbox{\texttt{\mdseries\slshape G}} and \mbox{\texttt{\mdseries\slshape imgs}} is a list whose $i$th entry is the image of $\mbox{\texttt{\mdseries\slshape gens}}[i]$ under the homomorphism. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@s4 := Group((1,2,3,4),(1,2));; s3 := Group((1,2,3),(1,2));;|
  !gapprompt@gap>| !gapinput@hom := GroupHomomorphismByImages( s4, s3,|
  !gapprompt@>| !gapinput@          GeneratorsOfGroup(s4), [(1,2),(2,3)] );|
  [ (1,2,3,4), (1,2) ] -> [ (1,2), (2,3) ]
  !gapprompt@gap>| !gapinput@Kernel( hom );|
  Group([ (1,4)(2,3), (1,3)(2,4) ])
  !gapprompt@gap>| !gapinput@Image( hom, (1,2,3) );|
  (1,2,3)
  !gapprompt@gap>| !gapinput@Image( hom, DerivedSubgroup(s4) );|
  Group([ (1,3,2), (1,3,2) ])
\end{Verbatim}
 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PreImage( hom, (1,2,3) );|
  Error, <map> must be an inj. and surj. mapping called from
  <function>( <arguments> ) called from read-eval-loop
  Entering break read-eval-print loop ...
  you can 'quit;' to quit to outer loop, or
  you can 'return;' to continue
  !gapbrkprompt@brk>| !gapinput@quit;|
\end{Verbatim}
 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PreImagesRepresentative( hom, (1,2,3) );|
  (1,4,2)
  !gapprompt@gap>| !gapinput@PreImage( hom, TrivialSubgroup(s3) );  # the kernel|
  Group([ (1,4)(2,3), (1,3)(2,4) ])
\end{Verbatim}
 

 This homomorphism from $S_4$ onto $S_3$ is well known from elementary group theory. Images of elements and subgroups
under \texttt{hom} can be calculated with the function \texttt{Image} (\textbf{Reference: Image}). But since the mapping \texttt{hom} is not bijective, we cannot use the function \texttt{PreImage} (\textbf{Reference: PreImage}) for preimages of elements (they can have several preimages). Instead, we have
to use \texttt{PreImagesRepresentative} (\textbf{Reference: PreImagesRepresentative}), which returns one preimage if at least one exists (and would return \texttt{fail} if none exists, which cannot occur for our surjective \texttt{hom}). On the other hand, we can use \texttt{PreImage} (\textbf{Reference: PreImage}) for the preimage of a set (which always exists, even if it is empty). 

 Suppose we mistype the input when trying to construct a homomorphism as below. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@GroupHomomorphismByImages( s4, s3,|
  !gapprompt@>| !gapinput@       GeneratorsOfGroup(s4), [(1,2,3),(2,3)] );|
  fail
\end{Verbatim}
 

 There is no such homomorphism, hence \texttt{fail} is returned. But note that because of this, \texttt{GroupHomomorphismByImages} (\textbf{Reference: GroupHomomorphismByImages}) must do some checks, and this was also done for the mapping \texttt{hom} above. One can avoid these checks if one is sure that the desired homomorphism
really exists. For that, the function \texttt{GroupHomomorphismByImagesNC} (\textbf{Reference: GroupHomomorphismByImagesNC}) can be used; the \texttt{NC} stands for ``no check''. 

 But note that horrible things can happen if \texttt{GroupHomomorphismByImagesNC} (\textbf{Reference: GroupHomomorphismByImagesNC}) is used when the input does not describe a homomorphism. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@hom2 := GroupHomomorphismByImagesNC( s4, s3,|
  !gapprompt@>| !gapinput@           GeneratorsOfGroup(s4), [(1,2,3),(2,3)] );|
  [ (1,2,3,4), (1,2) ] -> [ (1,2,3), (2,3) ]
  !gapprompt@gap>| !gapinput@Size( Kernel(hom2) );|
  24
\end{Verbatim}
 

 In other words, \textsf{GAP} claims that the kernel is the full \texttt{s4}, yet \texttt{hom2} obviously has some non-trivial images! Clearly there is no such thing as a
homomorphism which maps an element of order{\nobreakspace}4 (namely,
(1,2,3,4)) to an element of order{\nobreakspace}3 (namely, (1,2,3)). \emph{But if you use the command \texttt{GroupHomomorphismByImagesNC} (\textbf{Reference: GroupHomomorphismByImagesNC}), \textsf{GAP} trusts you.} 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsGroupHomomorphism( hom2 );|
  true
\end{Verbatim}
 

 And then it produces serious nonsense if the thing is not a homomorphism, as
seen above! 

 Besides the safe command \texttt{GroupHomomorphismByImages} (\textbf{Reference: GroupHomomorphismByImages}), which returns \texttt{fail} if the requested homomorphism does not exist, there is the function \texttt{GroupGeneralMappingByImages} (\textbf{Reference: GroupGeneralMappingByImages}), which returns a general mapping (that is, a possibly multi-valued mapping)
that can be tested with \texttt{IsGroupHomomorphism} (\textbf{Reference: IsGroupHomomorphism}). 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@hom2 := GroupGeneralMappingByImages( s4, s3,|
  !gapprompt@>| !gapinput@           GeneratorsOfGroup(s4), [(1,2,3),(2,3)] );;|
  !gapprompt@gap>| !gapinput@IsGroupHomomorphism( hom2 );|
  false
\end{Verbatim}
 

 \index{group general mapping}\index{cokernel}\index{kernel} \index{GroupHomomorphismByImages vs. GroupGeneralMappingByImages@\texttt{GroupHomomorphismByImages} vs. \texttt{GroupGeneralMappingByImages}} But the possibility of testing for being a homomorphism is not the only reason
why \textsf{GAP} offers \emph{group general mappings}. Another (more important?) reason is that their existence allows ``reversal of arrows'' in a homomorphism such as our original \texttt{hom}. By this we mean the \texttt{GroupHomomorphismByImages} (\textbf{Reference: GroupHomomorphismByImages}) with left and right sides exchanged, in which case it is of course merely a \texttt{GroupGeneralMappingByImages} (\textbf{Reference: GroupGeneralMappingByImages}). 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@rev := GroupGeneralMappingByImages( s3, s4,|
  !gapprompt@>| !gapinput@          [(1,2),(2,3)], GeneratorsOfGroup(s4) );;|
\end{Verbatim}
 

 Now $hom$ maps $a$ to $b$ if and only if $rev$ maps $b$ to $a$, for $a \in$ \texttt{s4} and $b \in$ \texttt{s3}. Since every such $b$ has four preimages under \texttt{hom}, it now has four images under \texttt{rev}. Just as the four preimages form a coset of the kernel $V_4 \leq $\texttt{s4} of \texttt{hom}, they also form a coset of the \emph{cokernel} $V_4 \leq $\texttt{s4} of \texttt{rev}. The cokernel itself is the set of all images of \texttt{One( s3 )}. (It is a normal subgroup in the group of all images under \texttt{rev}.) The operation \texttt{One} (\textbf{Reference: One}) returns the identity element of a group. And this is why \textsf{GAP} wants to perform such a reversal of arrows: it calculates the kernel of a
homomorphism like \texttt{hom} as the cokernel of the reversed group general mapping (here \texttt{rev}). 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@CoKernel( rev );|
  Group([ (1,4)(2,3), (1,3)(2,4) ])
\end{Verbatim}
 

 \index{group general mapping!single-valued} \index{group general mapping!total} The reason why \texttt{rev} is not a homomorphism is that it is not single-valued (because \texttt{hom} was not injective). But there is another critical condition: If we reverse the
arrows of a non-surjective homomorphism, we obtain a group general mapping
which is not defined everywhere, i.e., which is not total (although it will be
single-valued if the original homomorphism is injective). \textsf{GAP} requires that a group homomorphism be both single-valued and total, so you
will get \texttt{fail} if you say \texttt{GroupHomomorphismByImages( \mbox{\texttt{\mdseries\slshape G}}, \mbox{\texttt{\mdseries\slshape H}}, \mbox{\texttt{\mdseries\slshape gens}}, \mbox{\texttt{\mdseries\slshape imgs}} )} where \mbox{\texttt{\mdseries\slshape gens}} does not generate \mbox{\texttt{\mdseries\slshape G}} (even if this would give a decent homomorphism on the subgroup generated by \mbox{\texttt{\mdseries\slshape gens}}). For a full description, see Chapter  (\textbf{Reference: Group Homomorphisms}). 

 The last example of this section shows that the notion of kernel and cokernel
naturally extends even to the case where neither \texttt{hom2} nor its inverse general mapping (with arrows reversed) is a homomorphism. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@CoKernel( hom2 );  Kernel( hom2 );|
  Group([ (2,3), (1,3) ])
  Group([ (3,4), (2,3,4), (1,2,4) ])
  !gapprompt@gap>| !gapinput@IsGroupHomomorphism( InverseGeneralMapping( hom2 ) );|
  false
\end{Verbatim}
 

 \emph{Summary.} In this section we have constructed homomorphisms by specifying images for a
set of generators. We have seen that by reversing the direction of the
mapping, we get group general mappings, which need not be single-valued
(unless the mapping was injective) nor total (unless the mapping was
surjective). }

  
\section{\textcolor{Chapter }{Nice Monomorphisms}}\label{Nice Monomorphisms}
\logpage{[ 5, 5, 0 ]}
\hyperdef{L}{X7FFD731684606BC6}{}
{
  For some types of groups, the best method to calculate in an isomorphic group
in a ``better'' representation (say, a permutation group). We call an injective homomorphism,
that will give such an isomorphic image a ``nice monomorphism''. 

 For example in the case of a matrix group we can take the action on the
underlying vector space (or a suitable subset) to obtain such a monomorphism: 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@grp:=GL(2,3);;|
  !gapprompt@gap>| !gapinput@dom:=GF(3)^2;;|
  !gapprompt@gap>| !gapinput@hom := ActionHomomorphism( grp, dom );; IsInjective( hom );|
  true
  !gapprompt@gap>| !gapinput@p := Image( hom,grp );|
  Group([ (4,7)(5,8)(6,9), (2,7,6)(3,4,8) ])
\end{Verbatim}
 

 To demonstrate the technique of nice monomorphisms, we compute the conjugacy
classes of the permutation group and lift them back into the matrix group with
the monomorphism \texttt{hom}. Lifting back a conjugacy class means finding the preimage of the
representative and of the centralizer; the latter is called \texttt{StabilizerOfExternalSet} (\textbf{Reference: StabilizerOfExternalSet}) in \textsf{GAP} (because conjugacy classes are represented as external sets, see
Section{\nobreakspace} (\textbf{Reference: Conjugacy Classes})). 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@pcls := ConjugacyClasses( p );; gcls := [  ];;|
  !gapprompt@gap>| !gapinput@for pc  in pcls  do|
  !gapprompt@>| !gapinput@     gc:=ConjugacyClass(grp,|
  !gapprompt@>| !gapinput@                  PreImagesRepresentative(hom,Representative(pc)));|
  !gapprompt@>| !gapinput@     SetStabilizerOfExternalSet(gc,PreImage(hom,|
  !gapprompt@>| !gapinput@                                     StabilizerOfExternalSet(pc)));|
  !gapprompt@>| !gapinput@     Add( gcls, gc );|
  !gapprompt@>| !gapinput@   od;|
  !gapprompt@gap>| !gapinput@List( gcls, Size );|
  [ 1, 8, 12, 1, 8, 6, 6, 6 ]
\end{Verbatim}
 

 All the steps we have made above are automatically performed by \textsf{GAP} if you simply ask for \texttt{ConjugacyClasses( grp )}, provided that \textsf{GAP} already knows that \texttt{grp} is finite (e.g., because you asked \texttt{IsFinite( grp )} before). The reason for this is that a finite matrix group like \texttt{grp} is ``handled by a nice monomorphism''. For such groups, \textsf{GAP} uses the command \texttt{NiceMonomorphism} (\textbf{Reference: NiceMonomorphism}) to construct a monomorphism (such as the \texttt{hom} in the previous example) and then proceeds as we have done above. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@grp:=GL(2,3);;|
  !gapprompt@gap>| !gapinput@IsHandledByNiceMonomorphism( grp );|
  true
  !gapprompt@gap>| !gapinput@hom := NiceMonomorphism( grp );|
  <action isomorphism>
  !gapprompt@gap>| !gapinput@p :=Image(hom,grp);|
  Group([ (4,7)(5,8)(6,9), (2,7,6)(3,4,8) ])
  !gapprompt@gap>| !gapinput@cc := ConjugacyClasses( grp );; ForAll(cc, x-> x in gcls); |
  true
  !gapprompt@gap>| !gapinput@ForAll(gcls, x->x in cc); # cc and gcls might be ordered differently|
  true
\end{Verbatim}
 

 Note that a nice monomorphism might be defined on a larger group than \texttt{grp} {\textendash}so we have to use \texttt{Image( hom, grp )} and not only \texttt{Image( hom )}. 

 Nice monomorphisms are not only used for matrix groups, but also for other
kinds of groups in which one cannot calculate easily enough. As another
example, let us show that the automorphism group of the quaternion group of
order{\nobreakspace}8 is isomorphic to the symmetric group of
degree{\nobreakspace}4 by examining the ``nice object'' associated with that automorphism group. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@p:=Group((1,7,6,8)(2,5,3,4), (1,2,6,3)(4,8,5,7));;|
  !gapprompt@gap>| !gapinput@aut := AutomorphismGroup( p );; NiceMonomorphism(aut);;|
  !gapprompt@gap>| !gapinput@niceaut := NiceObject( aut );|
  Group([ (1,4,2,3), (1,5,4)(2,6,3), (1,2)(3,4), (3,4)(5,6) ])
  !gapprompt@gap>| !gapinput@IsomorphismGroups( niceaut, SymmetricGroup( 4 ) );|
  [ (1,4,2,3), (1,5,4)(2,6,3), (1,2)(3,4), (3,4)(5,6) ] -> 
  [ (1,2,4,3), (1,4,3), (1,4)(2,3), (1,3)(2,4) ]
\end{Verbatim}
 

 The range of a nice monomorphism is in most cases a permutation group, because
nice monomorphisms are mostly action homomorphisms. In some cases, like in our
last example, the group is solvable and you might prefer a pc group as nice
object. You cannot change the nice monomorphism of the automorphism group
(because it is the value of the attribute \texttt{NiceMonomorphism} (\textbf{Reference: NiceMonomorphism})), but you can compose it with an isomorphism from the permutation group to a
pc group to obtain your personal nicer monomorphism. If you reconstruct the
automorphism group, you can even prescribe it this nicer monomorphism as its \texttt{NiceMonomorphism} (\textbf{Reference: NiceMonomorphism}), because a newly-constructed group will not yet have a \texttt{NiceMonomorphism} (\textbf{Reference: NiceMonomorphism}) set. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@nicer := NiceMonomorphism(aut) * IsomorphismPcGroup(niceaut);;|
  !gapprompt@gap>| !gapinput@aut2 := GroupByGenerators( GeneratorsOfGroup( aut ) );;|
  !gapprompt@gap>| !gapinput@SetIsHandledByNiceMonomorphism( aut2, true );|
  !gapprompt@gap>| !gapinput@SetNiceMonomorphism( aut2, nicer );|
  !gapprompt@gap>| !gapinput@NiceObject( aut2 );  # a pc group|
  Group([ f1*f2, f2^2*f3, f4, f3 ])
\end{Verbatim}
 

 The star \texttt{*} denotes composition of mappings from the left to the right, as we have seen in
Section \ref{Actions of Groups} above. Reconstructing the automorphism group may of course result in the loss
of other information \textsf{GAP} had already gathered, besides the (not-so-)nice monomorphism. 

 \emph{Summary.} In this section we have seen how calculations in groups can be carried out in
isomorphic images in nicer groups. We have seen that \textsf{GAP} pursues this technique automatically for certain classes of groups, e.g., for
matrix groups that are known to be finite. }

  
\section{\textcolor{Chapter }{Further Information about Groups and Homomorphisms}}\label{Further Information about Groups and Homomorphisms}
\logpage{[ 5, 6, 0 ]}
\hyperdef{L}{X84579FB48474079C}{}
{
  Groups and the functions for groups are treated in Chapter{\nobreakspace} (\textbf{Reference: Groups}). There are several chapters dealing with groups in specific representations,
for example Chapter{\nobreakspace} (\textbf{Reference: Permutation Groups}) on permutation groups,  (\textbf{Reference: Polycyclic Groups}) on polycyclic (including finite solvable) groups,  (\textbf{Reference: Matrix Groups}) on matrix groups and  (\textbf{Reference: Finitely Presented Groups}) on finitely presented groups. Chapter{\nobreakspace} (\textbf{Reference: Group Actions}) deals with group actions. Group homomorphisms are the subject of
Chapter{\nobreakspace} (\textbf{Reference: Group Homomorphisms}). }

 }

            
\chapter{\textcolor{Chapter }{Vector Spaces and Algebras}}\label{Vector Spaces and Algebras}
\logpage{[ 6, 0, 0 ]}
\hyperdef{L}{X853484B982F1DF96}{}
{
  This chapter contains an introduction into vector spaces and algebras in \textsf{GAP}.  
\section{\textcolor{Chapter }{Vector Spaces}}\label{Vector Spaces}
\logpage{[ 6, 1, 0 ]}
\hyperdef{L}{X7DAD6700787EC845}{}
{
  

 A \emph{vector space} over the field $F$ is an additive group that is closed under scalar multiplication with elements
in $F$. In \textsf{GAP}, only those domains that are constructed as vector spaces are regarded as
vector spaces. In particular, an additive group that does not know about an
acting domain of scalars is not regarded as a vector space in \textsf{GAP}. 

 Probably the most common $F$-vector spaces in \textsf{GAP} are so-called \emph{row spaces}. They consist of row vectors, that is, lists whose elements lie in $F$. In the following example we compute the vector space spanned by the row
vectors \texttt{[ 1, 1, 1 ]} and \texttt{[ 1, 0, 2 ]} over the rationals. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:= Rationals;;|
  !gapprompt@gap>| !gapinput@V:= VectorSpace( F, [ [ 1, 1, 1 ], [ 1, 0, 2 ] ] );|
  <vector space over Rationals, with 2 generators>
  !gapprompt@gap>| !gapinput@[ 2, 1, 3 ] in V;|
  true
\end{Verbatim}
 

 The full row space $F^n$ is created by commands like: 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:= GF( 7 );;|
  !gapprompt@gap>| !gapinput@V:= F^3;   # The full row space over F of dimension 3. |
  ( GF(7)^3 )
  !gapprompt@gap>| !gapinput@[ 1, 2, 3 ] * One( F ) in V;  |
  true
\end{Verbatim}
 

 In the same way we can also create matrix spaces. Here the short notation \texttt{\mbox{\texttt{\mdseries\slshape field}}\texttt{\symbol{94}}[\mbox{\texttt{\mdseries\slshape dim1}},\mbox{\texttt{\mdseries\slshape dim2}}]} can be used: 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@m1:= [ [ 1, 2 ], [ 3, 4 ] ];; m2:= [ [ 0, 1 ], [ 1, 0 ] ];;|
  !gapprompt@gap>| !gapinput@V:= VectorSpace( Rationals, [ m1, m2 ] );|
  <vector space over Rationals, with 2 generators>
  !gapprompt@gap>| !gapinput@m1+m2 in V;|
  true
  !gapprompt@gap>| !gapinput@W:= Rationals^[3,2];|
  ( Rationals^[ 3, 2 ] )
  !gapprompt@gap>| !gapinput@[ [ 1, 1 ], [ 2, 2 ], [ 3, 3 ] ] in W;|
  true
\end{Verbatim}
 

 A field is naturally a vector space over itself. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsVectorSpace( Rationals );|
  true
\end{Verbatim}
 

 If $\Phi$ is an algebraic extension of $F$, then $\Phi$ is also a vector space over $F$ (and indeed over any subfield of $\Phi$ that contains $F$). This field $F$ is stored in the attribute \texttt{LeftActingDomain} (\textbf{Reference: LeftActingDomain}). In \textsf{GAP}, the default is to view fields as vector spaces over their \emph{prime} fields. By the function \texttt{AsVectorSpace} (\textbf{Reference: AsVectorSpace}), we can view fields as vector spaces over fields other than the prime field. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:= GF( 16 );;|
  !gapprompt@gap>| !gapinput@LeftActingDomain( F );|
  GF(2)
  !gapprompt@gap>| !gapinput@G:= AsVectorSpace( GF( 4 ), F );|
  AsField( GF(2^2), GF(2^4) )
  !gapprompt@gap>| !gapinput@F = G;|
  true
  !gapprompt@gap>| !gapinput@LeftActingDomain( G );|
  GF(2^2)
\end{Verbatim}
 

 A vector space has three important attributes: its \emph{field} of definition, its \emph{dimension} and a \emph{basis}. We already encountered the function \texttt{LeftActingDomain} (\textbf{Reference: LeftActingDomain}) in the example above. It extracts the field of definition of a vector space.
The function \texttt{Dimension} (\textbf{Reference: Dimension}) provides the dimension of the vector space. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:= GF( 9 );;|
  !gapprompt@gap>| !gapinput@m:= [ [ Z(3)^0, 0*Z(3), 0*Z(3) ], [ 0*Z(3), Z(3)^0, Z(3)^0 ] ];;|
  !gapprompt@gap>| !gapinput@V:= VectorSpace( F, m );|
  <vector space over GF(3^2), with 2 generators>
  !gapprompt@gap>| !gapinput@Dimension( V );|
  2
  !gapprompt@gap>| !gapinput@W:= AsVectorSpace( GF( 3 ), V );|
  <vector space over GF(3), with 4 generators>
  !gapprompt@gap>| !gapinput@V = W;|
  true
  !gapprompt@gap>| !gapinput@Dimension( W );|
  4
  !gapprompt@gap>| !gapinput@LeftActingDomain( W );|
  GF(3)
\end{Verbatim}
 

 One of the most important attributes is a \emph{basis}. For a given basis $B$ of $V$, every vector $v$ in $V$ can be expressed uniquely as $v = \sum_{b \in B} c_b b$, with coefficients $c_b \in F$. 

 In \textsf{GAP}, bases are special lists of vectors. They are used mainly for the computation
of coefficients and linear combinations. 

 Given a vector space $V$, a basis of $V$ is obtained by simply applying the function \texttt{Basis} (\textbf{Reference: Basis}) to $V$. The vectors that form the basis are extracted from the basis by \texttt{BasisVectors} (\textbf{Reference: BasisVectors}). 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@m1:= [ [ 1, 2 ], [ 3, 4 ] ];; m2:= [ [ 1, 1 ], [ 1, 0 ] ];;|
  !gapprompt@gap>| !gapinput@V:= VectorSpace( Rationals, [ m1, m2 ] );|
  <vector space over Rationals, with 2 generators>
  !gapprompt@gap>| !gapinput@B:= Basis( V );|
  SemiEchelonBasis( <vector space over Rationals, with 
  2 generators>, ... )
  !gapprompt@gap>| !gapinput@BasisVectors( Basis( V ) );|
  [ [ [ 1, 2 ], [ 3, 4 ] ], [ [ 0, 1 ], [ 2, 4 ] ] ]
\end{Verbatim}
 

 The coefficients of a vector relative to a given basis are found by the
function \texttt{Coefficients} (\textbf{Reference: Coefficients}). Furthermore, linear combinations of the basis vectors are constructed using \texttt{LinearCombination} (\textbf{Reference: LinearCombination}). 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= VectorSpace( Rationals, [ [ 1, 2 ], [ 3, 4 ] ] );|
  <vector space over Rationals, with 2 generators>
  !gapprompt@gap>| !gapinput@B:= Basis( V );|
  SemiEchelonBasis( <vector space over Rationals, with 
  2 generators>, ... )
  !gapprompt@gap>| !gapinput@BasisVectors( Basis( V ) );|
  [ [ 1, 2 ], [ 0, 1 ] ]
  !gapprompt@gap>| !gapinput@Coefficients( B, [ 1, 0 ] );|
  [ 1, -2 ]
  !gapprompt@gap>| !gapinput@LinearCombination( B, [ 1, -2 ] );|
  [ 1, 0 ]
\end{Verbatim}
 

 In the above examples we have seen that \textsf{GAP} often chooses the basis it wants to work with. It is also possible to
construct bases with prescribed basis vectors by giving a list of these
vectors as second argument to \texttt{Basis} (\textbf{Reference: Basis}). 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= VectorSpace( Rationals, [ [ 1, 2 ], [ 3, 4 ] ] );; |
  !gapprompt@gap>| !gapinput@B:= Basis( V, [ [ 1, 0 ], [ 0, 1 ] ] );|
  SemiEchelonBasis( <vector space over Rationals, with 2 generators>, 
  [ [ 1, 0 ], [ 0, 1 ] ] )
  !gapprompt@gap>| !gapinput@Coefficients( B, [ 1, 2 ] );|
  [ 1, 2 ]
\end{Verbatim}
 

 We can construct subspaces and quotient spaces of vector spaces. The natural
projection map (constructed by \texttt{NaturalHomomorphismBySubspace} (\textbf{Reference: NaturalHomomorphismBySubspace})), connects a vector space with its quotient space. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@V:= Rationals^4;|
  ( Rationals^4 )
  !gapprompt@gap>| !gapinput@W:= Subspace( V, [ [ 1, 2, 3, 4 ], [ 0, 9, 8, 7 ] ] );|
  <vector space over Rationals, with 2 generators>
  !gapprompt@gap>| !gapinput@VmodW:= V/W;|
  ( Rationals^2 )
  !gapprompt@gap>| !gapinput@h:= NaturalHomomorphismBySubspace( V, W );|
  <linear mapping by matrix, ( Rationals^4 ) -> ( Rationals^2 )>
  !gapprompt@gap>| !gapinput@Image( h, [ 1, 2, 3, 4 ] );|
  [ 0, 0 ]
  !gapprompt@gap>| !gapinput@PreImagesRepresentative( h, [ 1, 0 ] );|
  [ 1, 0, 0, 0 ]
\end{Verbatim}
 }

  
\section{\textcolor{Chapter }{Algebras}}\label{Algebras}
\logpage{[ 6, 2, 0 ]}
\hyperdef{L}{X7DDBF6F47A2E021C}{}
{
  If a multiplication is defined for the elements of a vector space, and if the
vector space is closed under this multiplication then it is called an \emph{algebra}. For example, every field is an algebra: 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@f:= GF(8); IsAlgebra( f );|
  GF(2^3)
  true
\end{Verbatim}
 

 One of the most important classes of algebras are sub-algebras of matrix
algebras. On the set of all $n \times n$ matrices over a field $F$ it is possible to define a multiplication in many ways. The most frequent are
the ordinary matrix multiplication and the Lie multiplication. 

 Each matrix constructed as $[ \mbox{\texttt{\mdseries\slshape row1}}, \mbox{\texttt{\mdseries\slshape row2}}, \ldots ]$ is regarded by \textsf{GAP} as an \emph{ordinary} matrix, its multiplication is the ordinary associative matrix multiplication.
The sum and product of two ordinary matrices are again ordinary matrices. 

 The \emph{full} matrix associative algebra can be created as follows: 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:= GF( 9 );;|
  !gapprompt@gap>| !gapinput@A:= F^[3,3];|
  ( GF(3^2)^[ 3, 3 ] )
\end{Verbatim}
 

 An algebra can be constructed from generators using the function \texttt{Algebra} (\textbf{Reference: Algebra}). It takes as arguments the field of coefficients and a list of generators. Of
course the coefficient field and the generators must fit together; if we want
to construct an algebra of ordinary matrices, we may take the field generated
by the entries of the generating matrices, or a subfield or extension field. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@m1:= [ [ 1, 1 ], [ 0, 0 ] ];; m2:= [ [ 0, 0 ], [ 0, 1 ] ];;|
  !gapprompt@gap>| !gapinput@A:= Algebra( Rationals, [ m1, m2 ] );|
  <algebra over Rationals, with 2 generators>
\end{Verbatim}
 

 An interesting class of algebras for which many special algorithms are
implemented is the class of \emph{Lie algebras}. They arise for example as algebras of matrices whose product is defined by
the Lie bracket $[ A, B ] = A * B - B * A$, where $*$ denotes the ordinary matrix product. 

 Since the multiplication of objects in \textsf{GAP} is always assumed to be the operation \texttt{*} (resp. the infix operator \texttt{*}), and since there is already the ``ordinary'' matrix product defined for ordinary matrices, as mentioned above, we must use
a different construction for matrices that occur as elements of Lie algebras.
Such Lie matrices can be constructed by \texttt{LieObject} (\textbf{Reference: LieObject}) from ordinary matrices, the sum and product of Lie matrices are again Lie
matrices. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@m:= LieObject( [ [ 1, 1 ], [ 1, 1 ] ] ); |
  LieObject( [ [ 1, 1 ], [ 1, 1 ] ] )
  !gapprompt@gap>| !gapinput@m*m;|
  LieObject( [ [ 0, 0 ], [ 0, 0 ] ] )
  !gapprompt@gap>| !gapinput@IsOrdinaryMatrix( m1 ); IsOrdinaryMatrix( m );|
  true
  false
  !gapprompt@gap>| !gapinput@IsLieMatrix( m1 ); IsLieMatrix( m );|
  false
  true
\end{Verbatim}
 

 Given a field \texttt{F} and a list \texttt{mats} of Lie objects over \texttt{F}, we can construct the Lie algebra generated by \texttt{mats} using the function \texttt{Algebra} (\textbf{Reference: Algebra}). Alternatively, if we do not want to be bothered with the function \texttt{LieObject} (\textbf{Reference: LieObject}), we can use the function \texttt{LieAlgebra} (\textbf{Reference: LieAlgebraByStructureConstants}) that takes a field and a list of ordinary matrices, and constructs the Lie
algebra generated by the corresponding Lie matrices. Note that this means that
the ordinary matrices used in the call of \texttt{LieAlgebra} (\textbf{Reference: LieAlgebraByStructureConstants}) are not contained in the returned Lie algebra. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@m1:= [ [ 0, 1 ], [ 0, 0 ] ];;|
  !gapprompt@gap>| !gapinput@m2:= [ [ 0, 0 ], [ 1, 0 ] ];; |
  !gapprompt@gap>| !gapinput@L:= LieAlgebra( Rationals, [ m1, m2 ] );|
  <Lie algebra over Rationals, with 2 generators>
  !gapprompt@gap>| !gapinput@m1 in L;|
  false
\end{Verbatim}
 

 A second way of creating an algebra is by specifying a multiplication table.
Let $A$ be a finite dimensional algebra with basis $(x_1, x_2, \ldots, x_n)$, then for $1 \leq i, j \leq n$ the product $x_i x_j$ is a linear combination of basis elements, i.e., there are $c_{ij}^k$ in the ground field such that $x_i x_j = \sum_{k=1}^n c_{ij}^k x_k.$ It is not difficult to show that the constants $c_{ij}^k$ determine the multiplication completely. Therefore, the $c_{ij}^k$ are called \emph{structure constants}. In \textsf{GAP} we can create a finite dimensional algebra by specifying an array of structure
constants. 

 In \textsf{GAP} such a table of structure constants is represented using lists. The obvious
way to do this would be to construct a ``three-dimensional'' list \texttt{T} such that \texttt{T[i][j][k]} equals $c_{ij}^k$. But it often happens that many of these constants vanish. Therefore a more
complicated structure is used in order to be able to omit the zeros. A
multiplication table of an $n$-dimensional algebra is an $n \times n$ array \texttt{T} such that \texttt{T[i][j]} describes the product of the \texttt{i}-th and the \texttt{j}-th basis element. This product is encoded in the following way. The entry \texttt{T[i][j]} is a list of two elements. The first of these is a list of indices $k$ such that $c_{ij}^k$ is nonzero. The second list contains the corresponding constants $c_{ij}^k$. Suppose, for example, that \texttt{S} is the table of an algebra with basis $(x_1, x_2, \ldots, x_8)$ and that \texttt{S[3][7]} equals \texttt{[ [ 2, 4, 6 ], [ 1/2, 2, 2/3 ] ]}. Then in the algebra we have the relation $x_3 x_7 = (1/2) x_2 + 2 x_4 + (2/3) x_6.$ Furthermore, if \texttt{S[6][1] = [ [ ], [ ] ]} then the product of the sixth and first basis elements is zero. 

 Finally two numbers are added to the table. The first number can be 1, -1, or
0. If it is 1, then the table is known to be symmetric, i.e., $c_{ij}^k = c_{ji}^k$. If this number is -1, then the table is known to be antisymmetric (this
happens for instance when the algebra is a Lie algebra). The remaining case,
0, occurs in all other cases. The second number that is added is the zero
element of the field over which the algebra is defined. 

 Empty structure constants tables are created by the function \texttt{EmptySCTable} (\textbf{Reference: EmptySCTable}), which takes a dimension $d$, a zero element $z$, and optionally one of the strings \texttt{"symmetric"}, \texttt{"antisymmetric"}, and returns an empty structure constants table $T$ corresponding to a $d$-dimensional algebra over a field with zero element $z$. Structure constants can be entered into the table $T$ using the function \texttt{SetEntrySCTable} (\textbf{Reference: SetEntrySCTable}). It takes four arguments, namely $T$, two indices $i$ and $j$, and a list of the form $[ c_{ij}^{{k_1}}, k_1, c_{ij}^{{k_2}}, k_2, \ldots ]$. In this call to \texttt{SetEntrySCTable}, the product of the $i$-th and the $j$-th basis vector in any algebra described by $T$ is set to $\sum_l c_{ij}^{{k_l}} x_{{k_l}}$. (Note that in the empty table, this product was zero.) If $T$ knows that it is (anti)symmetric, then at the same time also the product of
the $j$-th and the $i$-th basis vector is set appropriately. 

 In the following example we temporarily increase the line length limit from
its default value 80 to 82 in order to make the long output expression fit
into one line. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@T:= EmptySCTable( 2, 0, "symmetric" );|
  [ [ [ [  ], [  ] ], [ [  ], [  ] ] ], 
    [ [ [  ], [  ] ], [ [  ], [  ] ] ], 1, 0 ]
  !gapprompt@gap>| !gapinput@SetEntrySCTable( T, 1, 2, [1/2,1,1/3,2] );  T;|
  [ [ [ [  ], [  ] ], [ [ 1, 2 ], [ 1/2, 1/3 ] ] ], 
    [ [ [ 1, 2 ], [ 1/2, 1/3 ] ], [ [  ], [  ] ] ], 1, 0 ]
\end{Verbatim}
 

 If we have defined a structure constants table, then we can construct the
corresponding algebra by \texttt{AlgebraByStructureConstants} (\textbf{Reference: AlgebraByStructureConstants}). 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@A:= AlgebraByStructureConstants( Rationals, T );|
  <algebra of dimension 2 over Rationals>
\end{Verbatim}
 

 If we know that a structure constants table defines a Lie algebra, then we can
construct the corresponding Lie algebra by \texttt{LieAlgebraByStructureConstants} (\textbf{Reference: LieAlgebraByStructureConstants}); the algebra returned by this function knows that it is a Lie algebra, so \textsf{GAP} need not check the Jacobi identity. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@T:= EmptySCTable( 2, 0, "antisymmetric" );;|
  !gapprompt@gap>| !gapinput@SetEntrySCTable( T, 1, 2, [2/3,1] );|
  !gapprompt@gap>| !gapinput@L:= LieAlgebraByStructureConstants( Rationals, T );|
  <Lie algebra of dimension 2 over Rationals>
\end{Verbatim}
 

 In \textsf{GAP} an algebra is naturally a vector space. Hence all the functionality for vector
spaces is also available for algebras. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F:= GF(2);;|
  !gapprompt@gap>| !gapinput@z:= Zero( F );;  o:= One( F );;|
  !gapprompt@gap>| !gapinput@T:= EmptySCTable( 3, z, "antisymmetric" );;|
  !gapprompt@gap>| !gapinput@SetEntrySCTable( T, 1, 2, [ o, 1, o, 3 ] );|
  !gapprompt@gap>| !gapinput@SetEntrySCTable( T, 1, 3, [ o, 1 ] );|
  !gapprompt@gap>| !gapinput@SetEntrySCTable( T, 2, 3, [ o, 3 ] );|
  !gapprompt@gap>| !gapinput@A:= AlgebraByStructureConstants( F, T );|
  <algebra of dimension 3 over GF(2)>
  !gapprompt@gap>| !gapinput@Dimension( A );|
  3
  !gapprompt@gap>| !gapinput@LeftActingDomain( A );|
  GF(2)
  !gapprompt@gap>| !gapinput@Basis( A );|
  CanonicalBasis( <algebra of dimension 3 over GF(2)> )
\end{Verbatim}
 

 Subalgebras and ideals of an algebra can be constructed by specifying a set of
generators for the subalgebra or ideal. The quotient space of an algebra by an
ideal is naturally an algebra itself. 

 In the following example we temporarily increase the line length limit from
its default value 80 to 81 in order to make the long output expression fit
into one line. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@m:= [ [ 1, 2, 3 ], [ 0, 1, 6 ], [ 0, 0, 1 ] ];;|
  !gapprompt@gap>| !gapinput@A:= Algebra( Rationals, [ m ] );;|
  !gapprompt@gap>| !gapinput@subA:= Subalgebra( A, [ m-m^2 ] );|
  <algebra over Rationals, with 1 generators>
  !gapprompt@gap>| !gapinput@Dimension( subA );|
  2
  !gapprompt@gap>| !gapinput@idA:= Ideal( A, [ m-m^3 ] );|
  <two-sided ideal in <algebra of dimension 3 over Rationals>, 
    (1 generators)>
  !gapprompt@gap>| !gapinput@Dimension( idA ); |
  2
  !gapprompt@gap>| !gapinput@B:= A/idA;|
  <algebra of dimension 1 over Rationals>
\end{Verbatim}
 

 The call \texttt{B:= A/idA} creates a new algebra that does not ``know'' about its connection with \texttt{A}. If we want to connect an algebra with its factor via a homomorphism, then we
first have to create the homomorphism (\texttt{NaturalHomomorphismByIdeal} (\textbf{Reference: NaturalHomomorphismByIdeal})). After this we create the factor algebra from the homomorphism by the
function \texttt{ImagesSource} (\textbf{Reference: ImagesSource}). In the next example we divide an algebra \texttt{A} by its radical and lift the central idempotents of the factor to the original
algebra \texttt{A}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@m1:=[[1,0,0],[0,2,0],[0,0,3]];;|
  !gapprompt@gap>| !gapinput@m2:=[[0,1,0],[0,0,2],[0,0,0]];;|
  !gapprompt@gap>| !gapinput@A:= Algebra( Rationals, [ m1, m2 ] );;|
  !gapprompt@gap>| !gapinput@Dimension( A );|
  6
  !gapprompt@gap>| !gapinput@R:= RadicalOfAlgebra( A );|
  <algebra of dimension 3 over Rationals>
  !gapprompt@gap>| !gapinput@h:= NaturalHomomorphismByIdeal( A, R );|
  <linear mapping by matrix, <algebra of dimension 
  6 over Rationals> -> <algebra of dimension 3 over Rationals>>
  !gapprompt@gap>| !gapinput@AmodR:= ImagesSource( h );|
  <algebra of dimension 3 over Rationals>
  !gapprompt@gap>| !gapinput@id:= CentralIdempotentsOfAlgebra( AmodR );|
  [ v.3, v.2+(-3)*v.3, v.1+(-2)*v.2+(3)*v.3 ]
  !gapprompt@gap>| !gapinput@PreImagesRepresentative( h, id[1] );|
  [ [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 1 ] ]
  !gapprompt@gap>| !gapinput@PreImagesRepresentative( h, id[2] );|
  [ [ 0, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 0 ] ]
  !gapprompt@gap>| !gapinput@PreImagesRepresentative( h, id[3] );|
  [ [ 1, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ]
\end{Verbatim}
 

 Structure constants tables for the simple Lie algebras are present in \textsf{GAP}. They can be constructed using the function \texttt{SimpleLieAlgebra} (\textbf{Reference: SimpleLieAlgebra}). The Lie algebras constructed by this function come with a root system
attached. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra( "G", 2, Rationals );|
  <Lie algebra of dimension 14 over Rationals>
  !gapprompt@gap>| !gapinput@R:= RootSystem( L );|
  <root system of rank 2>
  !gapprompt@gap>| !gapinput@PositiveRoots( R );|
  [ [ 2, -1 ], [ -3, 2 ], [ -1, 1 ], [ 1, 0 ], [ 3, -1 ], [ 0, 1 ] ]
  !gapprompt@gap>| !gapinput@CartanMatrix( R );|
  [ [ 2, -1 ], [ -3, 2 ] ]
\end{Verbatim}
 

 Another example of algebras is provided by \emph{quaternion algebras}. We define a quaternion algebra over an extension field of the rationals,
namely the field generated by $\sqrt{{5}}$. (The number \texttt{EB(5)} is equal to $1/2 (-1+\sqrt{{5}})$. The field is printed as \texttt{NF(5,[ 1, 4 ])}.) 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@b5:= EB(5);|
  E(5)+E(5)^4
  !gapprompt@gap>| !gapinput@q:= QuaternionAlgebra( FieldByGenerators( [ b5 ] ) );|
  <algebra-with-one of dimension 4 over NF(5,[ 1, 4 ])>
  !gapprompt@gap>| !gapinput@gens:= GeneratorsOfAlgebra( q );|
  [ e, i, j, k ]
  !gapprompt@gap>| !gapinput@e:= gens[1];; i:= gens[2];; j:= gens[3];; k:= gens[4];;|
  !gapprompt@gap>| !gapinput@IsAssociative( q );|
  true
  !gapprompt@gap>| !gapinput@IsCommutative( q );|
  false
  !gapprompt@gap>| !gapinput@i*j; j*i;|
  k
  (-1)*k
  !gapprompt@gap>| !gapinput@One( q );|
  e
\end{Verbatim}
 

 If the coefficient field is a real subfield of the complex numbers then the
quaternion algebra is in fact a division ring. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsDivisionRing( q );|
  true
  !gapprompt@gap>| !gapinput@Inverse( e+i+j );|
  (1/3)*e+(-1/3)*i+(-1/3)*j
\end{Verbatim}
 

 So \textsf{GAP} knows about this fact. As in any ring, we can look at groups of units. (The
function \texttt{StarCyc} (\textbf{Reference: StarCyc}) used below computes the unique algebraic conjugate of an element in a
quadratic subfield of a cyclotomic field.) 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@c5:= StarCyc( b5 );|
  E(5)^2+E(5)^3
  !gapprompt@gap>| !gapinput@g1:= 1/2*( b5*e + i - c5*j );|
  (1/2*E(5)+1/2*E(5)^4)*e+(1/2)*i+(-1/2*E(5)^2-1/2*E(5)^3)*j
  !gapprompt@gap>| !gapinput@Order( g1 );|
  5
  !gapprompt@gap>| !gapinput@g2:= 1/2*( -c5*e + i + b5*k );|
  (-1/2*E(5)^2-1/2*E(5)^3)*e+(1/2)*i+(1/2*E(5)+1/2*E(5)^4)*k
  !gapprompt@gap>| !gapinput@Order( g2 );|
  10
  !gapprompt@gap>| !gapinput@g:=Group( g1, g2 );;|
  #I  default `IsGeneratorsOfMagmaWithInverses' method returns `true' for 
    [ (1/2*E(5)+1/2*E(5)^4)*e+(1/2)*i+(-1/2*E(5)^2-1/2*E(5)^3)*j, 
    (-1/2*E(5)^2-1/2*E(5)^3)*e+(1/2)*i+(1/2*E(5)+1/2*E(5)^4)*k ]
  !gapprompt@gap>| !gapinput@Size( g );|
  120
  !gapprompt@gap>| !gapinput@IsPerfect( g );|
  true
\end{Verbatim}
 

 Since there is only one perfect group of order 120, up to isomorphism, we see
that the group \texttt{g} is isomorphic to $SL_2(5)$. As usual, a permutation representation of the group can be constructed using
a suitable action of the group. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@cos:= RightCosets( g, Subgroup( g, [ g1 ] ) );;|
  !gapprompt@gap>| !gapinput@Length( cos );|
  24
  !gapprompt@gap>| !gapinput@hom:= ActionHomomorphism( g, cos, OnRight );;|
  !gapprompt@gap>| !gapinput@im:= Image( hom );|
  Group([ (2,3,5,9,15)(4,7,12,8,14)(10,17,23,20,24)(11,19,22,16,13), 
    (1,2,4,8,3,6,11,20,17,19)(5,10,18,7,13,22,12,21,24,15)(9,16)(14,23) ])
  !gapprompt@gap>| !gapinput@Size( im );|
  120
\end{Verbatim}
 

 To get a matrix representation of \texttt{g} or of the whole algebra \texttt{q}, we must specify a basis of the vector space on which the algebra acts, and
compute the linear action of elements w.r.t. this basis. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@bas:= CanonicalBasis( q );;|
  !gapprompt@gap>| !gapinput@BasisVectors( bas );|
  [ e, i, j, k ]
  !gapprompt@gap>| !gapinput@op:= OperationAlgebraHomomorphism( q, bas, OnRight );|
  <op. hom. AlgebraWithOne( NF(5,[ 1, 4 ]), 
  [ e, i, j, k ] ) -> matrices of dim. 4>
  !gapprompt@gap>| !gapinput@ImagesRepresentative( op, e );|
  [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ]
  !gapprompt@gap>| !gapinput@ImagesRepresentative( op, i );|
  [ [ 0, 1, 0, 0 ], [ -1, 0, 0, 0 ], [ 0, 0, 0, -1 ], [ 0, 0, 1, 0 ] ]
  !gapprompt@gap>| !gapinput@ImagesRepresentative( op, g1 );|
  [ [ 1/2*E(5)+1/2*E(5)^4, 1/2, -1/2*E(5)^2-1/2*E(5)^3, 0 ], 
    [ -1/2, 1/2*E(5)+1/2*E(5)^4, 0, -1/2*E(5)^2-1/2*E(5)^3 ], 
    [ 1/2*E(5)^2+1/2*E(5)^3, 0, 1/2*E(5)+1/2*E(5)^4, -1/2 ], 
    [ 0, 1/2*E(5)^2+1/2*E(5)^3, 1/2, 1/2*E(5)+1/2*E(5)^4 ] ]
\end{Verbatim}
 }

  
\section{\textcolor{Chapter }{Further Information about Vector Spaces and Algebras}}\label{Further Information about Vector Spaces and Algebras}
\logpage{[ 6, 3, 0 ]}
\hyperdef{L}{X843A8D6F7A7592B5}{}
{
  More information about vector spaces can be found in Chapter{\nobreakspace} (\textbf{Reference: Vector Spaces}). Chapter{\nobreakspace} (\textbf{Reference: Algebras}) deals with the functionality for general algebras. Furthermore, concerning
special functions for Lie algebras, there is Chapter{\nobreakspace} (\textbf{Reference: Lie Algebras}). }

 }

                 

  
\chapter{\textcolor{Chapter }{Domains}}\label{Domains}
\logpage{[ 7, 0, 0 ]}
\hyperdef{L}{X7BAF69417BB925F6}{}
{
  \emph{Domain} is \textsf{GAP}'s name for structured sets. We already saw examples of domains in
Chapters{\nobreakspace}\ref{Groups and Homomorphisms} and{\nobreakspace}\ref{Vector Spaces and Algebras}: the groups \texttt{s8} and \texttt{a8} in Section{\nobreakspace}\ref{Permutation groups} are domains, likewise the field \texttt{f} and the vector space \texttt{v} in Section{\nobreakspace}\ref{Vector Spaces} are domains. They were constructed by functions such as \texttt{Group} (\textbf{Reference: Groups}) and \texttt{GF} (\textbf{Reference: GF (for field size)}), and they could be passed as arguments to other functions such as \texttt{DerivedSubgroup} (\textbf{Reference: DerivedSubgroup}) and \texttt{Dimension} (\textbf{Reference: Dimension}).  
\section{\textcolor{Chapter }{Domains as Sets}}\label{Domains as Sets}
\logpage{[ 7, 1, 0 ]}
\hyperdef{L}{X7D94C6F07ACEA397}{}
{
  First of all, a domain $D$ is a set. If $D$ is finite then a list with the elements of this set can be computed with the
functions \texttt{AsList} (\textbf{Reference: AsList}) and \texttt{AsSortedList} (\textbf{Reference: AsSortedList}). For infinite $D$, \texttt{Enumerator} (\textbf{Reference: Enumerator}) and \texttt{EnumeratorSorted} (\textbf{Reference: EnumeratorSorted}) may work, but it is also possible that one gets an error message. 

 Domains can be used as arguments of set functions such as \texttt{Intersection} (\textbf{Reference: Intersection}) and \texttt{Union} (\textbf{Reference: Union}). \textsf{GAP} tries to return a domain in these cases, moreover it tries to return a domain
with as much structure as possible. For example, the intersection of two
groups is (either empty or) again a group, and \textsf{GAP} will try to return it as a group. For \texttt{Union} (\textbf{Reference: Union}), the situation is different because the union of two groups is in general not
a group. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@g:= Group( (1,2), (3,4) );;|
  !gapprompt@gap>| !gapinput@h:= Group( (3,4), (5,6) );;|
  !gapprompt@gap>| !gapinput@Intersection( g, h );|
  Group([ (3,4) ])
\end{Verbatim}
 

 Two domains are regarded as equal w.r.t. the operator ``\texttt{=}'' if and only if they are equal \emph{as sets}, regardless of the additional structure of the domains. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@mats:= [ [ [ 0*Z(2), Z(2)^0 ], [ Z(2)^0, 0*Z(2) ] ],|
  !gapprompt@>| !gapinput@            [ [ Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0 ] ] ];;|
  !gapprompt@gap>| !gapinput@Ring( mats ) = VectorSpace( GF(2), mats );|
  true
\end{Verbatim}
 

 Additionally, a domain is regarded as equal to the sorted list of its
elements. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@g:= Group( (1,2) );;|
  !gapprompt@gap>| !gapinput@l:= AsSortedList( g );|
  [ (), (1,2) ]
  !gapprompt@gap>| !gapinput@g = l;|
  true
  !gapprompt@gap>| !gapinput@IsGroup( l ); IsList( g );|
  false
  false
\end{Verbatim}
 }

  
\section{\textcolor{Chapter }{Algebraic Structure}}\label{Algebraic Structure}
\logpage{[ 7, 2, 0 ]}
\hyperdef{L}{X81F376D67BA4F5EB}{}
{
  The additional structure of $D$ is constituted by the facts that $D$ is known to be closed under certain operations such as addition or
multiplication, and that these operations have additional properties. For
example, if $D$ is a group then it is closed under multiplication ($D \times D \rightarrow D$, $(g,h) \mapsto g * h$), under taking inverses ($D \rightarrow D$, $g \mapsto g^{-1}$) and under taking the identity $g$\texttt{\texttt{\symbol{94}}0} of each element $g$ in $D$; additionally, the multiplication in $D$ is associative. 

 The same set of elements can carry different algebraic structures. For
example, a semigroup is defined as being closed under an associative
multiplication, so each group is also a semigroup. Likewise, a monoid is
defined as a semigroup $D$ in which the identity $g$\texttt{\texttt{\symbol{94}}0} is defined for every element $g$, so each group is a monoid, and each monoid is a semigroup. 

 Other examples of domains are vector spaces, which are defined as additive
groups that are closed under (left) multiplication with elements in a certain
domain of scalars. Also conjugacy classes in a group $D$ are domains, they are closed under the conjugation action of $D$. }

  
\section{\textcolor{Chapter }{Notions of Generation}}\label{Notions of Generation}
\logpage{[ 7, 3, 0 ]}
\hyperdef{L}{X7E8D59018638925F}{}
{
  \index{GeneratorsOfSomething@\texttt{GeneratorsOfSomething}} We have seen that a domain is closed under certain operations. Usually a
domain is constructed as the closure of some elements under these operations.
In this situation, we say that the elements \emph{generate} the domain. 

 For example, a list of matrices of the same shape over a common field can be
used to generate an additive group or a vector space over a suitable field; if
the matrices are square then we can also use the matrices as generators of a
semigroup, a ring, or an algebra. We illustrate some of these possibilities: 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@mats:= [ [ [ 0*Z(2), Z(2)^0 ],|
  !gapprompt@>| !gapinput@              [ Z(2)^0, 0*Z(2) ] ], |
  !gapprompt@>| !gapinput@            [ [ Z(2)^0, 0*Z(2) ],|
  !gapprompt@>| !gapinput@              [ 0*Z(2), Z(2)^0 ] ] ];;|
  !gapprompt@gap>| !gapinput@Size( AdditiveMagma( mats ) );|
  4
  !gapprompt@gap>| !gapinput@Size( VectorSpace( GF(8), mats ) );|
  64
  !gapprompt@gap>| !gapinput@Size( Algebra( GF(2), mats ) );    |
  4
  !gapprompt@gap>| !gapinput@Size( Group( mats ) );         |
  2
\end{Verbatim}
 Each combination of operations under which a domain could be closed gives a
notion of generation. So each group has group generators, and since it is a
monoid, one can also ask for monoid generators of a group. 

 Note that one cannot simply ask for ``the generators of a domain'', it is always necessary to specify what notion of generation is meant. Access
to the different generators is provided by functions with names of the form \texttt{GeneratorsOfSomething}. For example, \texttt{GeneratorsOfGroup} (\textbf{Reference: GeneratorsOfGroup}) denotes group generators, \texttt{GeneratorsOfMonoid} (\textbf{Reference: GeneratorsOfMonoid}) denotes monoid generators, and so on. The result of \texttt{GeneratorsOfVectorSpace} (\textbf{Reference: GeneratorsOfVectorSpace}) is of course to be understood relative to the field of scalars of the vector
space in question. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@GeneratorsOfVectorSpace( GF(4)^2 );|
  [ [ Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0 ] ]
  !gapprompt@gap>| !gapinput@v:= AsVectorSpace( GF(2), GF(4)^2 );;|
  !gapprompt@gap>| !gapinput@GeneratorsOfVectorSpace( v );|
  [ [ Z(2)^0, 0*Z(2) ], [ 0*Z(2), Z(2)^0 ], [ Z(2^2), 0*Z(2) ], 
    [ 0*Z(2), Z(2^2) ] ]
\end{Verbatim}
 }

  
\section{\textcolor{Chapter }{Domain Constructors}}\label{Domain Constructors}
\logpage{[ 7, 4, 0 ]}
\hyperdef{L}{X85AB533B7DE21C8B}{}
{
  \index{Something@\texttt{Something}} A group can be constructed from a list of group generators \mbox{\texttt{\mdseries\slshape gens}} by \texttt{Group( \mbox{\texttt{\mdseries\slshape gens}} )}, likewise one can construct rings and algebras with the functions \texttt{Ring} (\textbf{Reference: Ring}) and \texttt{Algebra} (\textbf{Reference: Algebra}). 

 Note that it is not always or completely checked that \mbox{\texttt{\mdseries\slshape gens}} is in fact a valid list of group generators, for example whether the elements
of \mbox{\texttt{\mdseries\slshape gens}} can be multiplied or whether they are invertible. This means that \textsf{GAP} trusts you, at least to some extent, that the desired domain \texttt{Something( \mbox{\texttt{\mdseries\slshape gens}} )} does exist. }

  
\section{\textcolor{Chapter }{Forming Closures of Domains}}\label{Forming Closures of Domains}
\logpage{[ 7, 5, 0 ]}
\hyperdef{L}{X849B1C5F8136F3A9}{}
{
  \index{ClosureSomething@\texttt{ClosureSomething}} Besides constructing domains from generators, one can also form the closure of
a given domain with an element or another domain. There are different notions
of closure, one has to specify one according to the desired result and the
structure of the given domain. The functions to compute closures have names
such as \texttt{ClosureSomething}. For example, if \mbox{\texttt{\mdseries\slshape D}} is a group and one wants to construct the group generated by \mbox{\texttt{\mdseries\slshape D}} and an element \mbox{\texttt{\mdseries\slshape g}} then one can use \texttt{ClosureGroup( \mbox{\texttt{\mdseries\slshape D}}, \mbox{\texttt{\mdseries\slshape g}} )}. }

  
\section{\textcolor{Chapter }{Changing the Structure}}\label{Changing the Structure}
\logpage{[ 7, 6, 0 ]}
\hyperdef{L}{X7EA77DE17DD8A231}{}
{
  \index{AsSomething@\texttt{AsSomething}} The same set of elements can have different algebraic structures. For example,
it may happen that a monoid $M$ does in fact contain the inverses of all of its elements, and thus $M$ is equal to the group formed by the elements of $M$. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@m:= Monoid( mats );;|
  !gapprompt@gap>| !gapinput@m = Group( mats );|
  true
  !gapprompt@gap>| !gapinput@IsGroup( m );|
  false
\end{Verbatim}
 

 The last result in the above example may be surprising. But the monoid \texttt{m} is not regarded as a group in \textsf{GAP}, and moreover there is no way to turn \texttt{m} into a group. Let us formulate this as a rule: 

 \emph{The set of operations under which the domain is closed is fixed in the
construction of a domain, and cannot be changed later.} 

 (Contrary to this, a domain \emph{can} acquire knowledge about properties such as whether the multiplication is
associative or commutative.) 

 If one needs a domain with a different structure than the given one, one can
construct a new domain with the required structure. The functions that do
these constructions have names such as \texttt{AsSomething}, they return a domain that has the same elements as the argument in question
but the structure \texttt{Something}. In the above situation, one can use \texttt{AsGroup} (\textbf{Reference: AsGroup}). 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@g:= AsGroup( m );;|
  !gapprompt@gap>| !gapinput@m = g;|
  true
  !gapprompt@gap>| !gapinput@IsGroup( g );|
  true
\end{Verbatim}
 

 If it is impossible to construct the desired domain, the \texttt{AsSomething} functions return \texttt{fail}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@AsVectorSpace( GF(4), GF(2)^2 );|
  fail
\end{Verbatim}
 

 The functions \texttt{AsList} (\textbf{Reference: AsList}) and \texttt{AsSortedList} (\textbf{Reference: AsSortedList}) mentioned above do not return domains, but they fit into the general pattern
in the sense that they forget all the structure of the argument, including the
fact that it is a domain, and return a list with the same elements as the
argument has. }

  
\section{\textcolor{Chapter }{Subdomains}}\label{Subdomains}
\logpage{[ 7, 7, 0 ]}
\hyperdef{L}{X8318352D7B5F19BA}{}
{
  \index{Subsomething@\texttt{Subsomething}} \index{SubsomethingNC@\texttt{SubsomethingNC}} It is possible to construct a domain as a subset of an existing domain. The
respective functions have names such as \texttt{Subsomething}, they return domains with the structure \texttt{Something}. (Note that the second \texttt{s} in \texttt{Subsomething} is not capitalized.) For example, if one wants to deal with the subgroup of
the domain \mbox{\texttt{\mdseries\slshape D}} that is generated by the elements in the list \mbox{\texttt{\mdseries\slshape gens}}, one can use \texttt{Subgroup( \mbox{\texttt{\mdseries\slshape D}}, \mbox{\texttt{\mdseries\slshape gens}} )}. It is not required that \mbox{\texttt{\mdseries\slshape D}} is itself a group, only that the group generated by \mbox{\texttt{\mdseries\slshape gens}} must be a subset of \mbox{\texttt{\mdseries\slshape D}}. 

 The superset of a domain \mbox{\texttt{\mdseries\slshape S}} that was constructed by a \texttt{Subsomething} function can be accessed as \texttt{Parent( \mbox{\texttt{\mdseries\slshape S}} )}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@g:= SymmetricGroup( 5 );;|
  !gapprompt@gap>| !gapinput@gens:= [ (1,2), (1,2,3,4) ];;|
  !gapprompt@gap>| !gapinput@s:= Subgroup( g, gens );;|
  !gapprompt@gap>| !gapinput@h:= Group( gens );;|
  !gapprompt@gap>| !gapinput@s = h;|
  true
  !gapprompt@gap>| !gapinput@Parent( s ) = g;|
  true
\end{Verbatim}
 

 Many functions return subdomains of their arguments, for example the result of \texttt{SylowSubgroup( \mbox{\texttt{\mdseries\slshape G}} )} is a group with parent group \mbox{\texttt{\mdseries\slshape G}}. 

 If you are sure that the domain \texttt{Something( \mbox{\texttt{\mdseries\slshape gens}} )} is contained in the domain \mbox{\texttt{\mdseries\slshape D}} then you can also call \texttt{SubsomethingNC( \mbox{\texttt{\mdseries\slshape D}}, \mbox{\texttt{\mdseries\slshape gens}} )} instead of \texttt{Subsomething( \mbox{\texttt{\mdseries\slshape D}}, \mbox{\texttt{\mdseries\slshape gens}} )}. The \texttt{NC} stands for ``no check'', and the functions whose names end with \texttt{NC} omit the check of containment. }

  
\section{\textcolor{Chapter }{Further Information about Domains}}\label{Further Information about Domains}
\logpage{[ 7, 8, 0 ]}
\hyperdef{L}{X7C83996381F67238}{}
{
  More information about domains can be found in Chapter{\nobreakspace} (\textbf{Reference: Domains}). Many other other chapters deal with specific types of domain such as groups,
vector spaces or algebras. }

 }

              

  
\chapter{\textcolor{Chapter }{Operations and Methods}}\label{Operations and Methods}
\logpage{[ 8, 0, 0 ]}
\hyperdef{L}{X7AEED9AB824CD4DA}{}
{
   
\section{\textcolor{Chapter }{Attributes}}\label{Attributes}
\logpage{[ 8, 1, 0 ]}
\hyperdef{L}{X7C701DBF7BAE649A}{}
{
  In the preceding chapters, we have seen how to obtain information about
mathematical objects in \textsf{GAP}: We have to pass the object as an argument to a function. For example, if \mbox{\texttt{\mdseries\slshape G}} is a group one can call \texttt{Size( \mbox{\texttt{\mdseries\slshape G}} )}, and the function will return a value, in our example an integer which is the
size of \mbox{\texttt{\mdseries\slshape G}}. Computing the size of a group generally requires a substantial amount of
work, therefore it seems desirable to store the size somewhere once it has
been calculated. You should imagine that \textsf{GAP} stores the size in some place associated with the object \mbox{\texttt{\mdseries\slshape G}} when \texttt{Size( \mbox{\texttt{\mdseries\slshape G}} )} is executed for the first time, and if this function call is executed again
later, the size is simply looked up and returned, without further computation. 

 \index{getter!of an attribute} \index{setter!of an attribute} \index{tester!of an attribute} \index{methods} This means that the behavior of the function \texttt{Size} (\textbf{Reference: Size}) has to depend on whether the size for the argument \mbox{\texttt{\mdseries\slshape G}} is already known, and if not, that the size must be stored after it has been
calculated. These two extra tasks are done by two other functions that
accompany \texttt{Size( \mbox{\texttt{\mdseries\slshape G}} )}, namely the \emph{tester} \texttt{HasSize( \mbox{\texttt{\mdseries\slshape G}} )} and the \emph{setter} \texttt{SetSize( \mbox{\texttt{\mdseries\slshape G}}, \mbox{\texttt{\mdseries\slshape size}} )}. The tester returns \texttt{true} or \texttt{false} according to whether \mbox{\texttt{\mdseries\slshape G}} has already stored its size, and the setter puts \mbox{\texttt{\mdseries\slshape size}} into a place from where \mbox{\texttt{\mdseries\slshape G}} can directly look it up. The function \texttt{Size} (\textbf{Reference: Size}) itself is called the \emph{getter}, and from the preceding discussion we see that there must really be at least
two \emph{methods} for the getter: One method is used when the tester returns \texttt{false}; it is the method which first does the real computation and then executes the
setter with the computed value. A second method is used when the tester
returns \texttt{true}; it simply returns the stored value. This second method is also called the \emph{system getter}. \textsf{GAP} functions for which several methods can be available are called \emph{operations}, so \texttt{Size} (\textbf{Reference: Size}) is an example of an operation. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := Group(List([1..3], i-> Random(SymmetricGroup(53))));;|
  !gapprompt@gap>| !gapinput@Size( G ); time > 0; # the time may of course vary on your machine|
  4274883284060025564298013753389399649690343788366813724672000000000000
  true
  !gapprompt@gap>| !gapinput@Size( G ); time;|
  4274883284060025564298013753389399649690343788366813724672000000000000
  0
\end{Verbatim}
 

 The convenient thing for the user is that \textsf{GAP} automatically chooses the right method for the getter, i.e., it calls a
real-work getter at most once and the system getter in all subsequent
occurrences. \emph{At most once} because the value of a function call like \texttt{Size( \mbox{\texttt{\mdseries\slshape G}} )} can also be set for \mbox{\texttt{\mdseries\slshape G}} before the getter is called at all; for example, one can call the setter
directly if one knows the size. 

 The size of a group is an example of a class of things which in \textsf{GAP} are called \emph{attributes}. Every attribute in \textsf{GAP} is represented by a triple of a getter, a setter and a tester. When a new
attribute is declared, all three functions are created together and the getter
contains references to the other two. This is necessary because when the
getter is called, it must first consult the tester, and perhaps execute the
setter in the end. Therefore the getter could be implemented as follows: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  getter := function( obj )
  local   value;
      if tester( obj )  then
          value := system_getter( obj );
      else
          value := real_work_getter( obj );
          setter( obj, value );
      fi;
      return value;
  end;
\end{Verbatim}
 The only function which depends on the mathematical nature of the attribute is
the real-work getter, and this is of course what the programmer of an
attribute has to install. In both cases, the getter returns the same value,
which we also call the value of the attribute (properly: the value of the
attribute for the object \texttt{obj}). By the way: The names for setter and tester of an attribute are always
composed from the prefix \texttt{Set} resp.{\nobreakspace}\texttt{Has} and the name of the getter. 

 As a (not typical) example, note that the \textsf{GAP} function \texttt{Random} (\textbf{Reference: Random Sources}), although it takes only one argument, is of course \emph{not} an attribute, because otherwise the first random element of a group would be
stored by the setter and returned over and over again by the system getter
every time \texttt{Random} (\textbf{Reference: Random Sources}) is called in the sequel. 

 There is a general important rule about attributes: \emph{Once the value of an attribute for an object has been set, it cannot be reset,
i.e., it cannot be changed any more.} This is achieved by having two methods not only for the getter but also for
the setter: If an object already has an attribute value stored, i.e., if the
tester returns \texttt{true}, the setter simply does nothing. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := SymmetricGroup(8);; Size(G);|
  40320
  !gapprompt@gap>| !gapinput@SetSize( G, 0 ); Size( G );|
  40320
\end{Verbatim}
 

 \emph{Summary.} In this section we have introduced attributes as triples of getter, setter and
tester and we have explained how these three functions work together behind
the scene to provide automatic storage and look-up of values that have once
been calculated. We have seen that there can be several methods for the same
function among which \textsf{GAP} automatically selects an appropriate one. }

  
\section{\textcolor{Chapter }{Properties and Filters}}\label{Properties and Filters}
\logpage{[ 8, 2, 0 ]}
\hyperdef{L}{X81C430C37B2F16D8}{}
{
  \index{filters} \index{methods!selection} Certain attributes, like \texttt{IsAbelian} (\textbf{Reference: IsAbelian}), are boolean-valued. Such attributes are known to \textsf{GAP} as \emph{properties}, because their values are stored in a slightly different way. A property also
has a getter, a setter and a tester, but in this case, the getter as well as
the tester returns a boolean value. Therefore \textsf{GAP} stores both values in the same way, namely as bits in a boolean list, thereby
treating property getters and all testers (of attributes or properties)
uniformly. These boolean-valued functions are called \emph{filters}. You can imagine a filter as a switch which is set either to \texttt{true} or to \texttt{false}. For every \textsf{GAP} object there is a boolean list which has reserved a bit for every filter \textsf{GAP} knows about. Strictly speaking, there is one bit for every \emph{simple filter}, and these simple filters can be combined with \texttt{and} to form other filters (which are then \texttt{true} if and only if all the corresponding bits are set to \texttt{true}). For example, the filter \texttt{IsPermGroup and IsSolvableGroup} is made up from several simple filters. 

 Since they allow only two values, the bits which represent filters can be
compared very quickly, and the scheme by which \textsf{GAP} chooses the method, e.g., for a getter or a setter (as we have seen in the
previous section), is mostly based on the examination of filters, not on the
examination of other attribute values. Details of this \emph{method selection} are described in chapter{\nobreakspace} (\textbf{Reference: Method Selection}). 

 We only present the following rule of thumb here: Each installed method for an
attribute, say \texttt{Size} (\textbf{Reference: Size}), has a ``required filter'', which is made up from certain simple filters which must yield \texttt{true} for the argument \mbox{\texttt{\mdseries\slshape obj}} for this method to be applicable. To execute a call of \texttt{Size( \mbox{\texttt{\mdseries\slshape obj}} )}, \textsf{GAP} selects among all applicable methods the one whose required filter combines
the most simple filters; the idea behind is that the more an algorithm
requires of \mbox{\texttt{\mdseries\slshape obj}}, the more efficient it is expected to be. For example, if \mbox{\texttt{\mdseries\slshape obj}} is a permutation group that is not (known to be) solvable, a method with
required filter \texttt{IsPermGroup and IsSolvableGroup} is not applicable, whereas a method with required filter \texttt{IsPermGroup} (\textbf{Reference: IsPermGroup}) can be chosen. On the other hand, if \mbox{\texttt{\mdseries\slshape obj}} was known to be solvable, the method with required filter \texttt{IsPermGroup and IsSolvableGroup} would be preferred to the one with required filter \texttt{IsPermGroup} (\textbf{Reference: IsPermGroup}). 

 It may happen that a method is applicable for a given argument but cannot
compute the desired value. In such cases, the method will execute the
statement \texttt{TryNextMethod();}, \index{TryNextMethod@\texttt{TryNextMethod}} and \textsf{GAP} calls the next applicable method. For example, \cite{Sims90b} describes an algorithm to compute the size of a solvable permutation group,
which can be used also to decide whether or not a permutation group is
solvable. Suppose that the function \texttt{size{\textunderscore}solvable} implements this algorithm, and that is returns the order of the group if it is
solvable and \texttt{fail} otherwise. Then we can install the following method for \texttt{Size} (\textbf{Reference: Size}) with required filter \texttt{IsPermGroup} (\textbf{Reference: IsPermGroup}). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  function( G )
  local  value;
      value := size_solvable( G );
      if value <> fail  then  return value;
                        else  TryNextMethod();  fi;
  end;
\end{Verbatim}
 This method can then be tried on every permutation group (whether known to be
solvable or not), and it would include a mandatory solvability test. 

 If no applicable method (or no next applicable method) is found, \textsf{GAP} stops with an error message of the form 
\begin{Verbatim}[commandchars=@|A,fontsize=\small,frame=single,label=Example]
  Error, no method found! For debugging hints type ?Recovery from NoMethodFound
  Error, no 1st choice method found for `Size' on 1 arguments called from
  ... lines deleted here ...
\end{Verbatim}
 

 You would get an error message as above if you asked for \texttt{Size( 1 )}. The message simply says that there is no method installed for calculating
the size of \texttt{1}. Section  (\textbf{Reference: Recovery from NoMethodFound-Errors}) contains more information on how to deal with these messages. 

 \emph{Summary.} In this section we have introduced properties as special attributes, and
filters as the general concept behind property getters and attribute testers.
The values of the filters of an object govern how the object is treated in the
selection of methods for operations. }

  
\section{\textcolor{Chapter }{Immediate and True Methods}}\label{Immediate and True Methods}
\logpage{[ 8, 3, 0 ]}
\hyperdef{L}{X85CC8C167A280043}{}
{
  \index{methods!immediate} \index{methods!true} In the example in Section{\nobreakspace}\ref{Properties and Filters}, we have mentioned that the operation \texttt{Size} (\textbf{Reference: Size}) has a method for solvable permutation groups that is so far superior to the
method for general permutation groups that it seems worthwhile to try it even
if nothing is known about solvability of the group of which the \texttt{Size} (\textbf{Reference: Size}) is to be calculated. There are other examples where certain methods are even ``cheaper'' to execute. For example, if the size of a group is known it is easy to check
whether it is odd, and if so, the Feit-Thompson theorem allows us to set \texttt{IsSolvableGroup} (\textbf{Reference: IsSolvableGroup}) to \texttt{true} for this group. \textsf{GAP} utilizes this celebrated theorem by having an \emph{immediate method} for \texttt{IsSolvableGroup} (\textbf{Reference: IsSolvableGroup}) with required filter \texttt{HasSize} which checks parity of the size and either sets \texttt{IsSolvableGroup} (\textbf{Reference: IsSolvableGroup}) or does nothing, i.e., calls \texttt{TryNextMethod()}. These immediate methods are executed automatically for an object whenever
the value of a filter changes, so solvability of a group will automatically be
detected when an odd size has been calculated for it (and therefore the value
of \texttt{HasSize} for that group has changed to \texttt{true}). 

 Some methods are even more immediate, because they do not require any
calculation at all: They allow a filter to be set if another filter is also
set. In other words, they model a mathematical implication like \texttt{IsGroup and IsCyclic} implies \texttt{IsSolvableGroup} and such implications can be installed in \textsf{GAP} as \emph{true methods}. To execute true methods, \textsf{GAP} only needs to do some bookkeeping with its filters, therefore true methods are
much faster than immediate methods. 

 How immediate and true methods are installed is described in  (\textbf{Reference: Immediate Methods}) and  (\textbf{Reference: Logical Implications}). }

  
\section{\textcolor{Chapter }{Operations and Method Selection}}\label{Operations and Method Selection}
\logpage{[ 8, 4, 0 ]}
\hyperdef{L}{X7DF5DBF9868B02C0}{}
{
  \index{operations} The method selection is not only used to select methods for attribute getters
but also for arbitrary \emph{operations}, which can have more than one argument. In this case, there is a required
filter for each argument (which must yield \texttt{true} for the corresponding arguments). 

 Additionally, a method with at least two arguments may require a certain
relation between the arguments, which is expressed in terms of the \emph{families} of the arguments. For example, the methods for \texttt{ConjugateGroup( \mbox{\texttt{\mdseries\slshape grp}}, \mbox{\texttt{\mdseries\slshape elm}} )} require that \mbox{\texttt{\mdseries\slshape elm}} lies in the family of elements from which \mbox{\texttt{\mdseries\slshape grp}} is made, i.e., that the family of \mbox{\texttt{\mdseries\slshape elm}} equals the ``elements family'' of \mbox{\texttt{\mdseries\slshape grp}}. 

 For permutation groups, the situation is quite easy: all permutations form one
family, \texttt{PermutationsFamily} (\textbf{Reference: PermutationsFamily}), and each collection of permutations, for example each permutation group,
each coset of a permutation group, or each dense list of permutations, lies in \texttt{CollectionsFamily( PermutationsFamily )}. 

 For other kinds of group elements, the situation can be different. Every call
of \texttt{FreeGroup} (\textbf{Reference: FreeGroup}) constructs a new family of free group elements. \textsf{GAP} refuses to compute \texttt{One( FreeGroup( 1 ) ) * One( FreeGroup( 1 ) )} because the two operands of the multiplication lie in different families and
no method is installed for this case. 

 For further information on family relations, see  (\textbf{Reference: Families}). 

 \index{KnownPropertiesOfObject@\texttt{KnownPropertiesOfObject}} \index{KnownTruePropertiesOfObject@\texttt{KnownTruePropertiesOfObject}} \index{KnownAttributesOfObject@\texttt{KnownAttributesOfObject}} If you want to know which properties are already known for an object \mbox{\texttt{\mdseries\slshape obj}}, or which properties are known to be true, you can use the functions \texttt{KnownPropertiesOfObject( \mbox{\texttt{\mdseries\slshape obj}} )} resp. \texttt{KnownTruePropertiesOfObject( \mbox{\texttt{\mdseries\slshape obj}} )}. This will print a list of names of properties. These names are also the
identifiers of the property getters, by which you can retrieve the value of
the properties (and confirm that they are really \texttt{true}). Analogously, there is the function \texttt{KnownAttributesOfObject} (\textbf{Reference: KnownAttributesOfObject}) which lists the names of the known attributes, leaving out the properties. 

 \index{ApplicableMethod@\texttt{ApplicableMethod}} Since \textsf{GAP} lets you know what it already knows about an object, it is only natural that
it also lets you know what methods it considers applicable for a certain
method, and in what order it will try them (in case \texttt{TryNextMethod()} occurs). \texttt{ApplicableMethod( \mbox{\texttt{\mdseries\slshape opr}}, [ arg{\textunderscore}1, arg{\textunderscore}2, ... ] )} returns the first applicable method for the call \texttt{\mbox{\texttt{\mdseries\slshape opr}}( arg{\textunderscore}1, arg{\textunderscore}2, ... )}. More generally, \texttt{ApplicableMethod( \mbox{\texttt{\mdseries\slshape opr}}, [ ... ], 0, \mbox{\texttt{\mdseries\slshape nr}} )} returns the \mbox{\texttt{\mdseries\slshape nr}}th applicable method (i.e., the one that would be chosen after $\mbox{\texttt{\mdseries\slshape nr}}-1$ calls of \texttt{TryNextMethod}) and if \mbox{\texttt{\mdseries\slshape nr}}\texttt{ = "all"}, the sorted list of all applicable methods is returned. For details, see  (\textbf{Reference: Applicable Methods and Method Selection}). 

 \index{TraceMethods@\texttt{TraceMethods}} If you want to see which methods are chosen for certain operations while \textsf{GAP} code is being executed, you can call the function \texttt{TraceMethods} (\textbf{Reference: TraceMethods (for a list of operations)}) with a list of these operations as arguments. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@TraceMethods( [ Size ] );|
  !gapprompt@gap>| !gapinput@g:= Group( (1,2,3), (1,2) );;  Size( g );|
  #I  Size: for a permutation group
  #I  Setter(Size): system setter
  #I  Size: system getter
  #I  Size: system getter
  6
\end{Verbatim}
 

 The system getter is called once to fetch the freshly computed value for
returning to the user. The second call is triggered by an immediate method. To
find out by which, we can trace the immediate methods by saying \texttt{TraceImmediateMethods( true )}. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@TraceImmediateMethods( true );|
  !gapprompt@gap>| !gapinput@g:= Group( (1,2,3), (1,2) );;|
  #I  immediate: Size
  #I  immediate: IsCyclic
  #I  immediate: IsCommutative
  #I  immediate: IsTrivial
  !gapprompt@gap>| !gapinput@Size( g );|
  #I  Size: for a permutation group
  #I  immediate: IsNonTrivial
  #I  immediate: Size
  #I  immediate: IsFreeAbelian
  #I  immediate: IsTorsionFree
  #I  immediate: IsNonTrivial
  #I  immediate: GeneralizedPcgs
  #I  Setter(Size): system setter
  #I  Size: system getter
  #I  immediate: IsPerfectGroup
  #I  Size: system getter
  #I  immediate: IsEmpty
  6
  !gapprompt@gap>| !gapinput@TraceImmediateMethods( false );|
  !gapprompt@gap>| !gapinput@UntraceMethods( [ Size ] );|
\end{Verbatim}
 

 The last two lines switch off tracing again. We now see that the system getter
was called by the immediate method for \texttt{IsPerfectGroup} (\textbf{Reference: IsPerfectGroup}). Also the above-mentioned immediate method for \texttt{IsSolvableGroup} (\textbf{Reference: IsSolvableGroup}) was not used because the solvability of \texttt{g} was already found out during the size calculation (cf.{\nobreakspace}the
example in Section{\nobreakspace}\ref{Properties and Filters}). 

 \emph{Summary.} In this section and the last we have looked some more behind the scenes and
seen that \textsf{GAP} automatically executes immediate and true methods to deduce information about
objects that is cheaply available. We have seen how this can be supervised by
tracing the methods. }

 }

    \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{../manualbib.xml}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
