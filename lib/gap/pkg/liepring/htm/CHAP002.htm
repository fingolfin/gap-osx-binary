<html><head><title>[LiePRing] 2 Lie p-rings</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP001.htm">Previous</a>] [<a href ="CHAP003.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>2 Lie p-rings</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP002.htm#SECT001">Ordinary Lie p-rings</a>
<li> <A HREF="CHAP002.htm#SECT002">Generic Lie p-rings</a>
<li> <A HREF="CHAP002.htm#SECT003">Creation of Lie p-rings</a>
<li> <A HREF="CHAP002.htm#SECT004">Subrings of Lie p-rings</a>
<li> <A HREF="CHAP002.htm#SECT005">Elementary functions for Lie p-rings and their subrings</a>
<li> <A HREF="CHAP002.htm#SECT006">Series for Lie p-rings and their subrings</a>
<li> <A HREF="CHAP002.htm#SECT007">The Lazard correspondence</a>
</ol><p>
<p>
A Lie ring <var>L</var> is an additive abelian group with a multiplication that
is alternating, bilinear and satisfies the Jacobi identity. The 
multiplication in a Lie ring is often denoted with brakets <var>[g,h]</var>, 
however, in GAP and also in this manual multiplication is denoted by
<var>g cdoth</var>. 
<p>
Let <var>L</var> be a Lie <var>p</var>-ring and thus a nilpotent Lie ring of order <var>p<sup>n</sup></var>.
Then <var>L</var> has a central series <var>L = L<sub>1</sub> geq...geqL<sub>n</sub> geq{0}</var> 
with quotients of order <var>p</var>. Choose <var>l<sub>i</sub> inL<sub>i</sub> setminusL<sub>i+1</sub></var> for 
<var>1 leqi leqn</var>. Then <var>(l<sub>1</sub>, ..., l<sub>n</sub>)</var> is a generating set of <var>L</var> 
satisfying that <var>p cdotl<sub>i</sub> inL<sub>i+1</sub></var> and <var>l<sub>i</sub> cdotl<sub>j</sub> inL<sub>i+1</sub></var> 
for <var>1 leqj &lt; i leqn</var>. We also call such a generating sequence
a <em>basis</em>for <var>L</var> and we say that <var>L</var> has <em>dimension</em><var>n</var>.
<p>
Given a basis <var>(l<sub>1</sub>, ..., l<sub>n</sub>)</var> for a Lie <var>p</var>-ring <var>L</var>, there exist 
coefficients <var>c<sub>i,j,k</sub> in{0, ..., p-1}</var> so that the following 
relations hold in <var>L</var> for <var>1 leqj &lt; i leqn</var>:
<p>
<p><var> l<sub>i</sub> cdotl<sub>j</sub> = sum<sub>k=i+1</sub><sup>n</sup> c<sub>i,j,k</sub> l<sub>k</sub>, <p></var> 
<p><var> p l<sub>i</sub> = sum<sub>k=i+1</sub><sup>n</sup> c<sub>i,i,k</sub> l<sub>k</sub>. <p></var>
<p>
These relations define the Lie <var>p</var>-ring <var>L</var>. This package contains the
definition of a datastructure <var>LiePRing</var> that allows to define Lie <var>p</var>-rings
via structure constants <var>c<sub>i,j,k</sub></var>. 
<p>
<p>
<h2><a name="SECT001">2.1 Ordinary Lie p-rings</a></h2>
<p><p>
In an ordinary Lie <var>p</var>-ring, the prime <var>p</var> is an integer and the structure
constants <var>c<sub>i,j,k</sub></var> are elements in <var>{0, ..., p-1}</var>. The following 
example takes the 9th Lie <var>p</var>-ring from the database of Lie <var>p</var>-rings of 
order <var>5<sup>4</sup></var> and does some elementary computations with it.
<p>
<pre>
gap&gt; L := LiePRingsByLibrary(4, 5)[9];
&lt;Lie ring of dimension 4 over prime 5&gt;
gap&gt; l := BasisOfLiePRing(L);
[ l1, l2, l3, l4 ]
gap&gt; l[1]*l[2];
0
gap&gt; 5*l[1];
l3
</pre>
<p>
<p>
<h2><a name="SECT002">2.2 Generic Lie p-rings</a></h2>
<p><p>
In a generic Lie <var>p</var>-ring, the structure constants are allowed to be 
polynomials in a finite set of indeterminates. In particular, the prime 
<var>p</var> may not be a fixed integer, but an indeterminate. The following examples 
takes the 9th Lie <var>p</var>-ring from the database of Lie <var>p</var>-rings of order <var>p<sup>4</sup></var> 
and does some elementary computations with it.
<p>
<pre>
gap&gt; L := LiePRingsByLibrary(4)[9];
&lt;Lie ring of dimension 4 over prime p&gt;
gap&gt; l := BasisOfLiePRing(L);
[ l1, l2, l3, l4 ]
gap&gt; p := PrimeOfLiePRing(L);
p
gap&gt; p*l[1];
l3
gap&gt; l[1]*l[2];
0
</pre>
<p>
A generic Lie <var>p</var>-ring thus defines a family of Lie <var>p</var>-rings by evaluating
the prime <var>p</var> and by evaluating the other parameters. It is generally 
assumed that <var>p</var> is evaluated to a prime and <var>w</var> is evaluated to a primitive
root of the field of <var>p</var> elements. The following functions allow to evaluate 
indeterminates in values.
<p>
<a name = "SSEC002.1"></a>
<li><code>SpecialisePrimeOfLiePRing(L, P)</code>
<p>
takes a generic Lie <var>p</var>-ring <var>L</var> and specialises its prime <var>p</var> (an 
indeterminate) to the value <var>P</var>. It also specialises the indeterminate
<var>w</var> to a primitive root of <var>GF(p)</var> if <var>w</var> occurs in the presentation 
of <var>L</var>. 
<p>
The following example shows a generic Lie <var>p</var>-ring with the parameter
<var>x</var> in the relations. This parameter <var>x</var> is not evaluated together with
the prime.
<p>
<pre>
gap&gt; L := LiePRingsByLibrary(6)[14];
&lt;Lie ring of dimension 6 over prime p with parameters [ x ]&gt;
gap&gt; ViewPCPresentation(L);
p*l1 = l4
p*l2 = x*l6
p*l4 = l5
[l2,l1] = l3
[l3,l1] = l5
[l3,l2] = l6
gap&gt; K := SpecialisePrimeOfLiePRing(L, 5);
&lt;Lie ring of dimension 6 over prime 5 with parameters [ x ]&gt;
gap&gt; ViewPCPresentation(K);
5*l1 = l4
5*l2 = x*l6
5*l4 = l5
[l2,l1] = l3
[l3,l1] = l5
[l3,l2] = l6
</pre>
<p>
The following example shows a generic Lie <var>p</var>-ring with the parameter
<var>w</var> in the relations. As <var>w</var> is evaluated to a primitive root of <var>GF(p)</var>,
it is evaluated together with the prime.
<p>
<pre>
gap&gt; L := LiePRingsByLibrary(6)[19];
&lt;Lie ring of dimension 6 over prime p with parameters [ w ]&gt;
gap&gt; ViewPCPresentation(L);
p*l1 = l4
p*l2 = w*l5
p*l4 = l6
[l2,l1] = l3
[l3,l1] = l5
gap&gt; K := SpecialisePrimeOfLiePRing(L, 17);
&lt;Lie ring of dimension 6 over prime 17&gt;
gap&gt; ViewPCPresentation(K);
17*l1 = l4
17*l2 = 3*l5
17*l4 = l6
[l2,l1] = l3
[l3,l1] = l5
</pre>
<p>
<a name = "SSEC002.2"></a>
<li><code>SpecialiseLiePRing(L, P, para, vals)</code>
<p>
takes a generic Lie <var>p</var>-ring <var>L</var> and specialises its prime <var>p</var> as above
and also specialises the indeterminates in <var>para</var> to the values <var>vals</var>.
<p>
<pre>
gap&gt; L := LiePRingsByLibrary(6)[14];
&lt;Lie ring of dimension 6 over prime p with parameters [ x ]&gt;
gap&gt; ViewPCPresentation(L);
p*l1 = l4
p*l2 = x*l6
p*l4 = l5
[l2,l1] = l3
[l3,l1] = l5
[l3,l2] = l6
gap&gt; para := ParametersOfLiePRing(L);
[ x ]
gap&gt; SpecialiseLiePRing(L, 29, para, [0]);
&lt;Lie ring of dimension 6 over prime 29&gt;
gap&gt; ViewPCPresentation(last);
29*l1 = l4
29*l4 = l5
[l2,l1] = l3
[l3,l1] = l5
[l3,l2] = l6
</pre>
<p>
The following example shows that it is possible to specialise some of
the parameters only. Again, note that <var>w</var> is always specialised together
with <var>p</var>.
<p>
<pre>
gap&gt; L := LiePRingsByLibrary(6)[267];
&lt;Lie ring of dimension 6 over prime p with parameters [ w, x, y, z, t ]&gt;
gap&gt; ViewPCPresentation(L);
p*l1 = t*l5 + x*l6
p*l2 = y*l5 + z*l6
[l2,l1] = l4
[l3,l1] = l6
[l3,l2] = w*l5
[l4,l1] = l5
[l4,l2] = l6
gap&gt; x := Indeterminate(Integers, "x");
x
gap&gt; SpecialiseLiePRing(L, 29, [x], [0]);
&lt;Lie ring of dimension 6 over prime 29 with parameters [ t, z, y ]&gt;
gap&gt; ViewPCPresentation(last);
29*l1 = t*l5
29*l2 = y*l5 + z*l6
[l2,l1] = l4
[l3,l1] = l6
[l3,l2] = 2*l5
[l4,l1] = l5
[l4,l2] = l6
</pre>
<p>
<a name = "SSEC002.3"></a>
<li><code>LiePValues(K)</code>
<p>
if <var>K</var> is obtained by specialising, then this attribute is set and 
contains the parameters that have been specialised and their values.
<p>
<pre>
gap&gt;  L := LiePRingsByLibrary(6)[14];
&lt;Lie ring of dimension 6 over prime p with parameters [ x ]&gt;
gap&gt;  K := SpecialisePrimeOfLiePRing(L, 5);
&lt;Lie ring of dimension 6 over prime 5 with parameters [ x ]&gt;
gap&gt; LiePValues(K);
[ [ p, w ], [ 5, 2 ] ]
</pre>
<p>
<p>
<h2><a name="SECT003">2.3 Creation of Lie p-rings</a></h2>
<p><p>
Lie <var>p</var>-rings can be created from certain table containing the structure
constants.
<p>
<a name = "SSEC003.1"></a>
<li><code>LiePRingBySCTable(SC)</code>
<a name = "SSEC003.1"></a>
<li><code>LiePRingBySCTableNC(SC)</code>
<p>
creates a Lie <var>p</var>-ring datastructure from <var>SC</var>. The input <var>SC</var> should be
a record with entries <var>dim</var>, <var>prime</var>, <var>tab</var> and possibly <var>param</var>. The
NC version assumes that the Jacobi identity is satisfied by <var>SC</var> and the
other version checks this. The entry <var>tab</var> is a list of lists. This list
defines <var>l<sub>i</sub> cdotl<sub>j</sub></var> for <var>j &lt; i</var> via the entry at position 
<var>1+...+j-1+i</var> and it defines <var>p cdotl<sub>i</sub></var> via the entry at position 
<var>1+...+i</var>. If an entry in this list is not bound, then it is assumed 
to be the empty list.
<p>
<a name = "SSEC003.2"></a>
<li><code>CheckIsLiePRing(L)</code>
<p>
this function assumes that <var>L</var> has been defined via <var>LiePRingBySCTableNC</var> 
and it checks the Jacobi identity for the multiplication in <var>L</var>.
<p>
<pre>
gap&gt; p := Indeterminate(Integers,"p");;
gap&gt; w := Indeterminate(Integers,"w");;
gap&gt; x := Indeterminate(Integers,"x");;
gap&gt; y := Indeterminate(Integers,"y");;
gap&gt; z := Indeterminate(Integers,"z");;
gap&gt; t := Indeterminate(Integers,"t");;
gap&gt; SC := rec( dim := 6, param := [w,x,y,z,t], prime := p, 
&gt;               tab := [ [ 5, t, 6, x ], [ 4, 1 ], [ 5, y, 6, z ],
&gt;                        [ 6, 1 ], [ 5, w ], [  ], [ 5, 1 ], [ 6, 1 ] ] );;
gap&gt; L := LiePRingBySCTable(SC);
&lt;Lie ring of dimension 6 over prime p with parameters [ w, x, y, z, t ]&gt;
gap&gt; ViewPCPresentation(L);
p*l1 = t*l5 + x*l6
p*l2 = y*l5 + z*l6
[l2,l1] = l4
[l3,l1] = l6
[l3,l2] = w*l5
[l4,l1] = l5
[l4,l2] = l6
</pre>
<p>
<p>
<h2><a name="SECT004">2.4 Subrings of Lie p-rings</a></h2>
<p><p>
Let <var>L</var> be a Lie <var>p</var>-ring defined via structure constants. Then each subring 
<var>U</var> of <var>L</var> is a Lie ring and it has <var>p</var>-power order as well. Hence it is also
a Lie <var>p</var>-ring and thus it has a basis <var>(u<sub>1</sub>, ..., u<sub>m</sub>)</var>. Suppose that 
<var>L</var> has order <var>p<sup>n</sup></var> and let <var>(l<sub>1</sub>, ..., l<sub>n</sub>)</var> denote its natural basis
corresponding to its defining structure constants. Then each <var>u<sub>i</sub></var> can be
expressed as a linear combination <var>u<sub>i</sub> = m<sub>i,1</sub> l<sub>1</sub> + ...+ m<sub>i,n</sub> l<sub>n</sub></var>
with <var>m<sub>i,j</sub> in{0, ..., p-1}</var>. Let <var>M = (m<sub>i,j</sub>)</var> denote the matrix
of coefficients. Then we say that <var>(u<sub>1</sub>, ..., u<sub>m</sub>)</var> is <em>induced</em>
if <var>M</var> is in upper triangular form. We say that <var>(u<sub>1</sub>, ..., u<sub>m</sub>)</var> is
<em>canonical</em>if <var>M</var> is in upper echelon form; that is, it is upper 
triangular, each row in <var>M</var> has leading entry <var>1</var> and there are <var>0</var>'s 
above each leading entry.
<p>
<a name = "SSEC004.1"></a>
<li><code>LiePSubring(L, gens)</code>
<p>
returns the subring of <var>L</var> generated by <var>gens</var>. This function computes
a canonical basis for the subring. Note that this function also works for
generic Lie <var>p</var>-rings <var>L</var>, but there may be strange effects in this case.
The following example shows that.
<p>
<pre>
gap&gt; L := LiePRingsByLibrary(6)[100];
&lt;Lie ring of dimension 6 over prime p&gt;
gap&gt; l := BasisOfLiePRing(L);
[ l1, l2, l3, l4, l5, l6 ]
gap&gt; U := LiePSubring(L, [5*l[1]]);
WARNING: Multiplying by 1/5
&lt;Lie ring of dimension 3 over prime p&gt;
gap&gt; BasisOfLiePRing(U);
[ l1, l4, l6 ]
gap&gt;
gap&gt; K := SpecialisePrimeOfLiePRing(L, 5);
&lt;Lie ring of dimension 6 over prime 5&gt;
gap&gt; b := BasisOfLiePRing(K);
[ l1, l2, l3, l4, l5, l6 ]
gap&gt; LiePSubring(K, [5*b[1]]);
&lt;Lie ring of dimension 2 over prime 5&gt;
gap&gt; BasisOfLiePRing(last);
[ l4, l6 ]
gap&gt;
gap&gt; K := SpecialisePrimeOfLiePRing(L, 7);
&lt;Lie ring of dimension 6 over prime 7&gt;
gap&gt; b := BasisOfLiePRing(K);
[ l1, l2, l3, l4, l5, l6 ]
gap&gt; U := LiePSubring(L, [5*b[1]]);
&lt;Lie ring of dimension 1 over prime p&gt;
gap&gt; BasisOfLiePRing(U);
[ l1 + 2*l4 ]
</pre>
<p>
<a name = "SSEC004.2"></a>
<li><code>LiePIdeal(L, gens)</code>
<p>
return the ideal of <var>L</var> generated by <var>gens</var>. This function computes a
an induced basis for the ideal.
<p>
<pre>
gap&gt; LiePIdeal(L, [l[1]]);
&lt;Lie ring of dimension 5 over prime p&gt;
gap&gt; BasisOfLiePRing(last);
[ l1, l3, l4, l5, l6 ]
</pre>
<p>
<a name = "SSEC004.3"></a>
<li><code>LiePQuotient(L, U)</code>
<p>
return a Lie <var>p</var>-ring isomorphic to <var>L/U</var> where <var>U</var> must be an ideal of
<var>L</var>. This function requires that <var>L</var> is an ordinary Lie <var>p</var>-ring.
<p>
<pre>
gap&gt; LiePIdeal(K, [b[1]]);
&lt;Lie ring of dimension 5 over prime 5&gt;
gap&gt; LiePIdeal(K, [b[2]]);
&lt;Lie ring of dimension 4 over prime 5&gt;
gap&gt; LiePQuotient(K,last);
&lt;Lie ring of dimension 2 over prime 5&gt;
</pre>
<p>
<p>
<h2><a name="SECT005">2.5 Elementary functions for Lie p-rings and their subrings</a></h2>
<p><p>
The following functions work for ordinary and generic Lie <var>p</var>-rings <var>L</var>
and their subrings.
<p>
<a name = "SSEC005.1"></a>
<li><code>PrimeOfLiePRing(L)</code>
<p>
returns the underlying prime. This can either be an integer or an
indeterminate.
<p>
<a name = "SSEC005.2"></a>
<li><code>BasisOfLiePRing(L)</code>
<p>
returns a basis for <var>L</var>.
<p>
<a name = "SSEC005.3"></a>
<li><code>DimensionOfLiePRing(L)</code>
<p>
returns <var>n</var> where <var>L</var> has order <var>p<sup>n</sup></var>.
<p>
<a name = "SSEC005.4"></a>
<li><code>ParametersOfLiePRing(L)</code>
<p>
returns the list of indeterminates involved in <var>L</var>. If <var>L</var> is a subring
of a Lie <var>p</var>-ring defined by structure constants, then the parameters of
the parent are returned.
<p>
<a name = "SSEC005.5"></a>
<li><code>ViewPCPresentation(L)</code>
<p>
prints the presentation for <var>L</var> with respect to its basis. 
<p>
<p>
<h2><a name="SECT006">2.6 Series for Lie p-rings and their subrings</a></h2>
<p><p>
<a name = "SSEC006.1"></a>
<li><code>LiePLowerCentralSeries(L)</code>
<p>
returns the lower central series of <var>L</var>. 
<p>
<a name = "SSEC006.2"></a>
<li><code>LiePLowerPCentralSeries(L)</code>
<p>
returns the lower exponent-<var>p</var> central series of <var>L</var>.
<p>
<a name = "SSEC006.3"></a>
<li><code>LiePDerivedSeries(L)</code>
<p>
returns the derived series of <var>L</var>.
<p>
<a name = "SSEC006.4"></a>
<li><code>LiePMinimalGeneratingSet(L)</code>
<p>
returns a minimal generating set of <var>L</var>.
<p>
<p>
<h2><a name="SECT007">2.7 The Lazard correspondence</a></h2>
<p><p>
The following function has been implemented by Willem de Graaf. It uses
the Baker-Campbell-Hausdorff formula as described in <a href="biblio.htm#CGV12"><cite>CGV12</cite></a> and it 
is based on the Liering package <a href="biblio.htm#CdG10"><cite>CdG10</cite></a>.
<p>
<a name = "SSEC007.1"></a>
<li><code>PGroupByLiePRing(L)</code>
<p>
returns the <var>p</var>-group <var>G</var> obtained from <var>L</var> via the Lazard correspondence.
This function requires that <var>L</var> is an ordinary Lie <var>p</var>-ring with <var>cl(L) &lt; p</var>. 
<p>
<p>
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP001.htm">Previous</a>] [<a href ="CHAP003.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>LiePRing manual<br>November 2013
</address></body></html>