% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{\textsf{Polycyclic}\mbox{}}}\\
\vfill

\hypersetup{pdftitle=\textsf{Polycyclic}}
\markright{\scriptsize \mbox{}\hfill \textsf{Polycyclic} \hfill\mbox{}}
{\Huge Version 2.11\mbox{}}\\[1cm]
{07 March 2013\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Bettina Eick     \mbox{}}}\\
{\Large \textbf{ Max Horn     \mbox{}}}\\
{\Large \textbf{ Werner Nickel   \mbox{}}}\\
\hypersetup{pdfauthor= Bettina Eick     ;  Max Horn     ;  Werner Nickel   }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{ Bettina Eick     }  Email: \href{mailto:// beick@tu-bs.de } {\texttt{ beick@tu-bs.de }}\\
  Homepage: \href{http://www.icm.tu-bs.de/~beick} {\texttt{http://www.icm.tu-bs.de/\texttt{\symbol{126}}beick}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 AG Algebra und Diskrete Mathematik\\
 Institut Computational Mathematics\\
 TU Braunschweig\\
 Pockelsstr. 14\\
 D-38106 Braunschweig\\
 Germany \end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{ Max Horn     }  Email: \href{mailto:// max.horn@math.uni-giessen.de } {\texttt{ max.horn@math.uni-giessen.de }}\\
  Homepage: \href{http://www.quendi.de/math.php} {\texttt{http://www.quendi.de/math.php}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 AG Algebra\\
 Mathematisches Institut\\
 Justus-Liebig-Universit{\"a}t Gie{\ss}en\\
 Arndtstrasse 2\\
 D-35392 Gie{\ss}en\\
 Germany \end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{ Werner Nickel   }\\
  Homepage: \href{http://www.mathematik.tu-darmstadt.de/~nickel} {\texttt{http://www.mathematik.tu-darmstadt.de/\texttt{\symbol{126}}nickel}}}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 1 ]}
 \index{License} {\copyright} 2003-2012 by Bettina Eick, Max Horn and Werner Nickel

 The \textsf{Polycyclic} package is free software; you can redistribute it and/or modify it under the
terms of the \href{http://www.fsf.org/licenses/gpl.html} {GNU General Public License} as published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version. \mbox{}}\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 2 ]}
 We appreciate very much all past and future comments, suggestions and
contributions to this package and its documentation provided by \textsf{GAP} users and developers. \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 3 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Preface}}\label{Preface}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X874E1D45845007FE}{}
{
  A group $G$ is called \emph{polycyclic} if there exists a subnormal series in $G$ with cyclic factors. Every polycyclic group is soluble and every supersoluble
group is polycyclic. The class of polycyclic groups is closed with respect to
forming subgroups, factor groups and extensions. Polycyclic groups can also be
characterised as those soluble groups in which each subgroup is finitely
generated. 

 K. A. Hirsch has initiated the investigation of polycyclic groups in 1938, see \cite{Hir38a}, \cite{Hir38b}, \cite{Hir46}, \cite{Hir52}, \cite{Hir54}, and their central position in infinite group theory has been recognised
since. 

 A well-known result of Hirsch asserts that each polycyclic group is finitely
presented. In fact, a polycyclic group has a presentation which exhibits its
polycyclic structure: a \emph{pc-presentation} as defined in the Chapter \hyperref[Introduction to polycyclic presentations]{`Introduction to polycyclic presentations'}. Pc-presentations allow efficient computations with the groups they define.
In particular, the word problem is efficiently solvable in a group given by a
pc-presentation. Further, subgroups and factor groups of groups given by a
pc-presentation can be handled effectively. 

 The \textsf{GAP} 4 package \textsf{Polycyclic} is designed for computations with polycyclic groups which are given by a
pc-presentation. The package contains methods to solve the word problem in
such groups and to handle subgroups and factor groups of polycyclic groups.
Based on these basic algorithms we present a collection of methods to
construct polycyclic groups and to investigate their structure. 

 In \cite{BCRS91} and \cite{Seg90} the theory of problems which are decidable in polycyclic-by-finite groups has
been started. As a result of these investigation we know that a large number
of group theoretic problems are decidable by algorithms in polycyclic groups.
However, practical algorithms which are suitable for computer implementations
have not been obtained by this study. We have developed a new set of practical
methods for groups given by pc-presentations, see for example \cite{Eic00}, and this package is a collection of implementations for these and other
methods. 

 We refer to \cite{Rob82}, page 147ff, and \cite{Seg83} for background on polycyclic groups. Further, in \cite{Sims94} a variation of the basic methods for groups with pc-presentation is
introduced. Finally, we note that the main GAP library contains many practical
algorithms to compute with finite polycyclic groups. This is described in the
Section on polycyclic groups in the reference manual. }

 
\chapter{\textcolor{Chapter }{Introduction to polycyclic presentations}}\label{Introduction to polycyclic presentations}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X792561B378D95B23}{}
{
  Let $G$ be a polycyclic group and let $G = C_1 \rhd C_2 \ldots C_n\rhd C_{n+1} = 1$ be a \emph{polycyclic series}, that is, a subnormal series of $G$ with non-trivial cyclic factors. For $1 \leq i \leq n$ we choose $g_i \in C_i$ such that $C_i = \langle g_i, C_{i+1} \rangle$. Then the sequence $(g_1, \ldots, g_n)$ is called a \emph{polycyclic generating sequence of $G$}. Let $I$ be the set of those $i \in \{1, \ldots, n\}$ with $r_i := [C_i : C_{i+1}]$ finite. Each element of $G$ can be written \mbox{\texttt{\mdseries\slshape uniquely}} as $g_1^{e_1}\cdots g_n^{e_n}$ with $e_i\in {\ensuremath{\mathbb Z}}$ for $1\leq i\leq n$ and $0\leq e_i < r_i$ for $i\in I$. 

 Each polycyclic generating sequence of $G$ gives rise to a \emph{power-conjugate (pc-) presentation} for $G$ with the conjugate relations 
\[g_j^{g_i} = g_{i+1}^{e(i,j,i+1)} \cdots g_n^{e(i,j,n)} \hbox{ for } 1 \leq i <
j \leq n,\]
 
\[g_j^{g_i^{-1}} = g_{i+1}^{f(i,j,i+1)} \cdots g_n^{f(i,j,n)} \hbox{ for } 1
\leq i < j \leq n,\]
 and the power relations 
\[g_i^{r_i} = g_{i+1}^{l(i,i+1)} \cdots g_n^{l(i,n)} \hbox{ for } i \in I.\]
 

 Vice versa, we say that a group $G$ is defined by a pc-presentation if $G$ is given by a presentation of the form above on generators $g_1,\ldots,g_n$. These generators are the \emph{defining generators} of $G$. Here, $I$ is the set of $1\leq i\leq n$ such that $g_i$ has a power relation. The positive integer $r_i$ for $i\in I$ is called the \emph{relative order} of $g_i$. If $G$ is given by a pc-presentation, then $G$ is polycyclic. The subgroups $C_i = \langle g_i, \ldots, g_n \rangle$ form a subnormal series $G = C_1 \geq \ldots \geq C_{n+1} = 1$ with cyclic factors and we have that $g_i^{r_i}\in C_{i+1}$. However, some of the factors of this series may be smaller than $r_i$ for $i\in I$ or finite if $i\not\in I$. 

 If $G$ is defined by a pc-presentation, then each element of $G$ can be described by a word of the form $g_1^{e_1}\cdots g_n^{e_n}$ in the defining generators with $e_i\in {\ensuremath{\mathbb Z}}$ for $1\leq i\leq n$ and $0\leq e_i < r_i$ for $i\in I$. Such a word is said to be in \emph{collected form}. In general, an element of the group can be represented by more than one
collected word. If the pc-presentation has the property that each element of $G$ has precisely one word in collected form, then the presentation is called \emph{confluent} or \emph{consistent}. If that is the case, the generators with a power relation correspond
precisely to the finite factors in the polycyclic series and $r_i$ is the order of $C_i/C_{i+1}$. 

 The \textsf{GAP} package \textsf{Polycyclic} is designed for computations with polycyclic groups which are given by
consistent pc-presentations. In particular, all the functions described below
assume that we compute with a group defined by a consistent pc-presentation.
See Chapter \hyperref[Collectors]{`Collectors'} for a routine that checks the consistency of a pc-presentation. 

 A pc-presentation can be interpreted as a \emph{rewriting system} in the following way. One needs to add a new generator $G_i$ for each generator $g_i$ together with the relations $g_iG_i = 1$ and $G_ig_i = 1$. Any occurrence in a relation of an inverse generator $g_i^{-1}$ is replaced by $G_i$. In this way one obtains a monoid presentation for the group $G$. With respect to a particular ordering on the set of monoid words in the
generators $g_1,\ldots g_n,G_1,\ldots G_n$, the \emph{wreath product ordering}, this monoid presentation is a rewriting system. If the pc-presentation is
consistent, the rewriting system is confluent. 

 In this package we do not address this aspect of pc-presentations because it
is of little relevance for the algorithms implemented here. For the definition
of rewriting systems and confluence in this context as well as further details
on the connections between pc-presentations and rewriting systems we recommend
the book \cite{Sims94}. }

 
\chapter{\textcolor{Chapter }{Collectors}}\label{Collectors}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X792305CC81E8606A}{}
{
  Let $G$ be a group defined by a pc-presentation as described in the Chapter \hyperref[Introduction to polycyclic presentations]{`Introduction to polycyclic presentations'}. 

 The process for computing the collected form for an arbitrary word in the
generators of $G$ is called \emph{collection}. The basic idea in collection is the following. Given a word in the defining
generators, one scans the word for occurrences of adjacent generators (or
their inverses) in the wrong order or occurrences of subwords $g_i^{e_i}$ with $i\in I$ and $e_i$ not in the range $0\ldots r_{i}-1$. In the first case, the appropriate conjugacy relation is used to move the
generator with the smaller index to the left. In the second case, one uses the
appropriate power relation to move the exponent of $g_i$ into the required range. These steps are repeated until a collected word is
obtained. 

 There exist a number of different strategies for collecting a given word to
collected form. The strategies implemented in this package are \emph{collection from the left} as described by \cite{LGS90} and \cite{Sims94} and \emph{combinatorial collection from the left} by \cite{MVL90}. In addition, the package provides access to Hall polynomials computed by
Deep Thought for the multiplication in a nilpotent group, see \cite{WWM97} and \cite{LGS98}. 

 The first step in defining a pc-presented group is setting up a data structure
that knows the pc-presentation and has routines that perform the collection
algorithm with words in the generators of the presentation. Such a data
structure is called \emph{a collector}. 

 To describe the right hand sides of the relations in a pc-presentation we use \emph{generator exponent lists}; the word $g_{i_1}^{e_1}g_{i_2}^{e_2}\ldots g_{i_k}^{e_k}$ is represented by the generator exponent list $[i_1,e_1,i_2,e_2,\ldots,i_k,e_k]$. 

  
\section{\textcolor{Chapter }{Constructing a Collector}}\label{Constructing a Collector}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X800FD91386C08CD8}{}
{
  A collector for a group given by a pc-presentation starts by setting up an
empty data structure for the collector. Then the relative orders, the power
relations and the conjugate relations are added into the data structure. The
construction is finalised by calling a routine that completes the data
structure for the collector. The following functions provide the necessary
tools for setting up a collector. 

\subsection{\textcolor{Chapter }{FromTheLeftCollector}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X8382A4E78706DE65}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FromTheLeftCollector({\mdseries\slshape n})\index{FromTheLeftCollector@\texttt{FromTheLeftCollector}}
\label{FromTheLeftCollector}
}\hfill{\scriptsize (operation)}}\\


 returns an empty data structure for a collector with \mbox{\texttt{\mdseries\slshape n}} generators. No generator has a relative order, no right hand sides of power
and conjugate relations are defined. Two generators for which no right hand
side of a conjugate relation is defined commute. Therefore, the collector
returned by this function can be used to define a free abelian group of rank \mbox{\texttt{\mdseries\slshape n}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ftl := FromTheLeftCollector( 4 );|
  <<from the left collector with 4 generators>>
  !gapprompt@gap>| !gapinput@PcpGroupByCollector( ftl );|
  Pcp-group with orders [ 0, 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@IsAbelian(last);|
  true
\end{Verbatim}
 If the relative order of a generators has been defined (see \texttt{SetRelativeOrder} (\ref{SetRelativeOrder})), but the right hand side of the corresponding power relation has not, then
the order and the relative order of the generator are the same. }

 

\subsection{\textcolor{Chapter }{SetRelativeOrder}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X79A308B28183493B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SetRelativeOrder({\mdseries\slshape coll, i, ro})\index{SetRelativeOrder@\texttt{SetRelativeOrder}}
\label{SetRelativeOrder}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SetRelativeOrderNC({\mdseries\slshape coll, i, ro})\index{SetRelativeOrderNC@\texttt{SetRelativeOrderNC}}
\label{SetRelativeOrderNC}
}\hfill{\scriptsize (operation)}}\\


 set the relative order in collector \mbox{\texttt{\mdseries\slshape coll}} for generator \mbox{\texttt{\mdseries\slshape i}} to \mbox{\texttt{\mdseries\slshape ro}}. The parameter \mbox{\texttt{\mdseries\slshape coll}} is a collector as returned by the function \texttt{FromTheLeftCollector} (\ref{FromTheLeftCollector}), \mbox{\texttt{\mdseries\slshape i}} is a generator number and \mbox{\texttt{\mdseries\slshape ro}} is a non-negative integer. The generator number \mbox{\texttt{\mdseries\slshape i}} is an integer in the range $1,\ldots,n$ where $n$ is the number of generators of the collector. 

 If \mbox{\texttt{\mdseries\slshape ro}} is $0,$ then the generator with number \mbox{\texttt{\mdseries\slshape i}} has infinite order and no power relation can be specified. As a side effect in
this case, a previously defined power relation is deleted. 

 If \mbox{\texttt{\mdseries\slshape ro}} is the relative order of a generator with number \mbox{\texttt{\mdseries\slshape i}} and no power relation is set for that generator, then \mbox{\texttt{\mdseries\slshape ro}} is the order of that generator. 

 The NC version of the function bypasses checks on the range of \mbox{\texttt{\mdseries\slshape i}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ftl := FromTheLeftCollector( 4 );|
  <<from the left collector with 4 generators>>
  !gapprompt@gap>| !gapinput@for i in [1..4] do SetRelativeOrder( ftl, i, 3 ); od;|
  !gapprompt@gap>| !gapinput@G := PcpGroupByCollector( ftl );|
  Pcp-group with orders [ 3, 3, 3, 3 ]
  !gapprompt@gap>| !gapinput@IsElementaryAbelian( G );|
  true
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{SetPower}}
\logpage{[ 3, 1, 3 ]}\nobreak
\hyperdef{L}{X7BC319BA8698420C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SetPower({\mdseries\slshape coll, i, rhs})\index{SetPower@\texttt{SetPower}}
\label{SetPower}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SetPowerNC({\mdseries\slshape coll, i, rhs})\index{SetPowerNC@\texttt{SetPowerNC}}
\label{SetPowerNC}
}\hfill{\scriptsize (operation)}}\\


 set the right hand side of the power relation for generator \mbox{\texttt{\mdseries\slshape i}} in collector \mbox{\texttt{\mdseries\slshape coll}} to (a copy of) \mbox{\texttt{\mdseries\slshape rhs}}. An attempt to set the right hand side for a generator without a relative
order results in an error. 

 Right hand sides are by default assumed to be trivial. 

 The parameter \mbox{\texttt{\mdseries\slshape coll}} is a collector, \mbox{\texttt{\mdseries\slshape i}} is a generator number and \mbox{\texttt{\mdseries\slshape rhs}} is a generators exponent list or an element from a free group. 

 The no-check (NC) version of the function bypasses checks on the range of \mbox{\texttt{\mdseries\slshape i}} and stores \mbox{\texttt{\mdseries\slshape rhs}} (instead of a copy) in the collector. }

 

\subsection{\textcolor{Chapter }{SetConjugate}}
\logpage{[ 3, 1, 4 ]}\nobreak
\hyperdef{L}{X86A08D887E049347}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SetConjugate({\mdseries\slshape coll, j, i, rhs})\index{SetConjugate@\texttt{SetConjugate}}
\label{SetConjugate}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SetConjugateNC({\mdseries\slshape coll, j, i, rhs})\index{SetConjugateNC@\texttt{SetConjugateNC}}
\label{SetConjugateNC}
}\hfill{\scriptsize (operation)}}\\


 set the right hand side of the conjugate relation for the generators \mbox{\texttt{\mdseries\slshape j}} and \mbox{\texttt{\mdseries\slshape i}} with \mbox{\texttt{\mdseries\slshape j}} larger than \mbox{\texttt{\mdseries\slshape i}}. The parameter \mbox{\texttt{\mdseries\slshape coll}} is a collector, \mbox{\texttt{\mdseries\slshape j}} and \mbox{\texttt{\mdseries\slshape i}} are generator numbers and \mbox{\texttt{\mdseries\slshape rhs}} is a generator exponent list or an element from a free group. Conjugate
relations are by default assumed to be trivial. 

 The generator number \mbox{\texttt{\mdseries\slshape i}} can be negative in order to define conjugation by the inverse of a generator. 

 The no-check (NC) version of the function bypasses checks on the range of \mbox{\texttt{\mdseries\slshape i}} and \mbox{\texttt{\mdseries\slshape j}} and stores \mbox{\texttt{\mdseries\slshape rhs}} (instead of a copy) in the collector. }

 

\subsection{\textcolor{Chapter }{SetCommutator}}
\logpage{[ 3, 1, 5 ]}\nobreak
\hyperdef{L}{X7B25997C7DF92B6D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SetCommutator({\mdseries\slshape coll, j, i, rhs})\index{SetCommutator@\texttt{SetCommutator}}
\label{SetCommutator}
}\hfill{\scriptsize (operation)}}\\


 set the right hand side of the conjugate relation for the generators \mbox{\texttt{\mdseries\slshape j}} and \mbox{\texttt{\mdseries\slshape i}} with \mbox{\texttt{\mdseries\slshape j}} larger than \mbox{\texttt{\mdseries\slshape i}} by specifying the commutator of \mbox{\texttt{\mdseries\slshape j}} and \mbox{\texttt{\mdseries\slshape i}}. The parameter \mbox{\texttt{\mdseries\slshape coll}} is a collector, \mbox{\texttt{\mdseries\slshape j}} and \mbox{\texttt{\mdseries\slshape i}} are generator numbers and \mbox{\texttt{\mdseries\slshape rhs}} is a generator exponent list or an element from a free group. 

 The generator number \mbox{\texttt{\mdseries\slshape i}} can be negative in order to define the right hand side of a commutator
relation with the second generator being the inverse of a generator. }

 

\subsection{\textcolor{Chapter }{UpdatePolycyclicCollector}}
\logpage{[ 3, 1, 6 ]}\nobreak
\hyperdef{L}{X7E9903F57BC5CC24}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UpdatePolycyclicCollector({\mdseries\slshape coll})\index{UpdatePolycyclicCollector@\texttt{UpdatePolycyclicCollector}}
\label{UpdatePolycyclicCollector}
}\hfill{\scriptsize (operation)}}\\


 completes the data structures of a collector. This is usually the last step in
setting up a collector. Among the steps performed is the completion of the
conjugate relations. For each non-trivial conjugate relation of a generator,
the corresponding conjugate relation of the inverse generator is calculated. 

 Note that \texttt{UpdatePolycyclicCollector} is automatically called by the function \texttt{PcpGroupByCollector} (see \texttt{PcpGroupByCollector} (\ref{PcpGroupByCollector})). }

 

\subsection{\textcolor{Chapter }{IsConfluent}}
\logpage{[ 3, 1, 7 ]}\nobreak
\hyperdef{L}{X8006790B86328CE8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsConfluent({\mdseries\slshape coll})\index{IsConfluent@\texttt{IsConfluent}}
\label{IsConfluent}
}\hfill{\scriptsize (property)}}\\


 tests if the collector \mbox{\texttt{\mdseries\slshape coll}} is confluent. The function returns true or false accordingly. 

 Compare Chapter \ref{Introduction to polycyclic presentations} for a definition of confluence. 

 Note that confluence is automatically checked by the function \texttt{PcpGroupByCollector} (see \texttt{PcpGroupByCollector} (\ref{PcpGroupByCollector})). 

 The following example defines a collector for a semidirect product of the
cyclic group of order $3$ with the free abelian group of rank $2$. The action of the cyclic group on the free abelian group is given by the
matrix 
\[\pmatrix{ 0 & 1 \cr -1 & -1}.\]
 This leads to the following polycyclic presentation: 
\[\langle g_1,g_2,g_3 | g_1^3, g_2^{g_1}=g_3, g_3^{g_1}=g_2^{-1}g_3^{-1},
g_3^{g_2}=g_3\rangle.\]
 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ftl := FromTheLeftCollector( 3 );|
  <<from the left collector with 3 generators>>
  !gapprompt@gap>| !gapinput@SetRelativeOrder( ftl, 1, 3 );|
  !gapprompt@gap>| !gapinput@SetConjugate( ftl, 2, 1, [3,1] );|
  !gapprompt@gap>| !gapinput@SetConjugate( ftl, 3, 1, [2,-1,3,-1] );|
  !gapprompt@gap>| !gapinput@UpdatePolycyclicCollector( ftl );|
  !gapprompt@gap>| !gapinput@IsConfluent( ftl );|
  true
\end{Verbatim}
 The action of the inverse of $g_1$ on $\langle g_2,g_2\rangle$ is given by the matrix 
\[\pmatrix{ -1 & -1 \cr 1 & 0}.\]
 The corresponding conjugate relations are automatically computed by \texttt{UpdatePolycyclicCollector}. It is also possible to specify the conjugation by inverse generators. Note
that you need to run \texttt{UpdatePolycyclicCollector} after one of the set functions has been used. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SetConjugate( ftl, 2, -1, [2,-1,3,-1] );|
  !gapprompt@gap>| !gapinput@SetConjugate( ftl, 3, -1, [2,1] );|
  !gapprompt@gap>| !gapinput@IsConfluent( ftl );|
  Error, Collector is out of date called from
  CollectWordOrFail( coll, ev1, [ j, 1, i, 1 ] ); called from
  <function>( <arguments> ) called from read-eval-loop
  Entering break read-eval-print loop ...
  you can 'quit;' to quit to outer loop, or
  you can 'return;' to continue
  !gapbrkprompt@brk>| !gapinput@|
  !gapprompt@gap>| !gapinput@UpdatePolycyclicCollector( ftl );|
  !gapprompt@gap>| !gapinput@IsConfluent( ftl );|
  true
\end{Verbatim}
 }

 }

  
\section{\textcolor{Chapter }{Accessing Parts of a Collector}}\label{Accessing Parts of a Collector}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X818484817C3BAAE6}{}
{
  

\subsection{\textcolor{Chapter }{RelativeOrders}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X7DD0DF677AC1CF10}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RelativeOrders({\mdseries\slshape coll})\index{RelativeOrders@\texttt{RelativeOrders}}
\label{RelativeOrders}
}\hfill{\scriptsize (attribute)}}\\


 returns (a copy of) the list of relative order stored in the collector \mbox{\texttt{\mdseries\slshape coll}}. }

 

\subsection{\textcolor{Chapter }{GetPower}}
\logpage{[ 3, 2, 2 ]}\nobreak
\hyperdef{L}{X844C0A478735EF4B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GetPower({\mdseries\slshape coll, i})\index{GetPower@\texttt{GetPower}}
\label{GetPower}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GetPowerNC({\mdseries\slshape coll, i})\index{GetPowerNC@\texttt{GetPowerNC}}
\label{GetPowerNC}
}\hfill{\scriptsize (operation)}}\\


 returns a copy of the generator exponent list stored for the right hand side
of the power relation of the generator \mbox{\texttt{\mdseries\slshape i}} in the collector \mbox{\texttt{\mdseries\slshape coll}}. 

 The no-check (NC) version of the function bypasses checks on the range of \mbox{\texttt{\mdseries\slshape i}} and does not create a copy before returning the right hand side of the power
relation. }

 

\subsection{\textcolor{Chapter }{GetConjugate}}
\logpage{[ 3, 2, 3 ]}\nobreak
\hyperdef{L}{X865160E07FA93E00}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GetConjugate({\mdseries\slshape coll, j, i})\index{GetConjugate@\texttt{GetConjugate}}
\label{GetConjugate}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GetConjugateNC({\mdseries\slshape coll, j, i})\index{GetConjugateNC@\texttt{GetConjugateNC}}
\label{GetConjugateNC}
}\hfill{\scriptsize (operation)}}\\


 returns a copy of the right hand side of the conjugate relation stored for the
generators \mbox{\texttt{\mdseries\slshape j}} and \mbox{\texttt{\mdseries\slshape i}} in the collector \mbox{\texttt{\mdseries\slshape coll}} as generator exponent list. The generator \mbox{\texttt{\mdseries\slshape j}} must be larger than \mbox{\texttt{\mdseries\slshape i}}. 

 The no-check (NC) version of the function bypasses checks on the range of \mbox{\texttt{\mdseries\slshape i}} and \mbox{\texttt{\mdseries\slshape j}} and does not create a copy before returning the right hand side of the power
relation. }

 

\subsection{\textcolor{Chapter }{NumberOfGenerators}}
\logpage{[ 3, 2, 4 ]}\nobreak
\hyperdef{L}{X7D6A26A4871FF51A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NumberOfGenerators({\mdseries\slshape coll})\index{NumberOfGenerators@\texttt{NumberOfGenerators}}
\label{NumberOfGenerators}
}\hfill{\scriptsize (operation)}}\\


 returns the number of generators of the collector \mbox{\texttt{\mdseries\slshape coll}}. }

 

\subsection{\textcolor{Chapter }{ObjByExponents}}
\logpage{[ 3, 2, 5 ]}\nobreak
\hyperdef{L}{X873ECF388503E5DE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ObjByExponents({\mdseries\slshape coll, expvec})\index{ObjByExponents@\texttt{ObjByExponents}}
\label{ObjByExponents}
}\hfill{\scriptsize (operation)}}\\


 returns a generator exponent list for the exponent vector \mbox{\texttt{\mdseries\slshape expvec}}. This is the inverse operation to \texttt{ExponentsByObj}. See \texttt{ExponentsByObj} (\ref{ExponentsByObj}) for an example. }

 

\subsection{\textcolor{Chapter }{ExponentsByObj}}
\logpage{[ 3, 2, 6 ]}\nobreak
\hyperdef{L}{X85BCB97B8021EAD6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ExponentsByObj({\mdseries\slshape coll, genexp})\index{ExponentsByObj@\texttt{ExponentsByObj}}
\label{ExponentsByObj}
}\hfill{\scriptsize (operation)}}\\


 returns an exponent vector for the generator exponent list \mbox{\texttt{\mdseries\slshape genexp}}. This is the inverse operation to \texttt{ObjByExponents}. The function assumes that the generators in \mbox{\texttt{\mdseries\slshape genexp}} are given in the right order and that the exponents are in the right range. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := UnitriangularPcpGroup( 4, 0 );|
  Pcp-group with orders [ 0, 0, 0, 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@coll := Collector ( G );|
  <<from the left collector with 6 generators>>
  !gapprompt@gap>| !gapinput@ObjByExponents( coll, [6,-5,4,3,-2,1] );|
  [ 1, 6, 2, -5, 3, 4, 4, 3, 5, -2, 6, 1 ]
  !gapprompt@gap>| !gapinput@ExponentsByObj( coll, last );|
  [ 6, -5, 4, 3, -2, 1 ]
\end{Verbatim}
 }

 }

  
\section{\textcolor{Chapter }{Special Features}}\label{Special Features}
\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X79AEB3477800DC16}{}
{
  In this section we descibe collectors for nilpotent groups which make use of
the special structure of the given pc-presentation. 

\subsection{\textcolor{Chapter }{IsWeightedCollector}}
\logpage{[ 3, 3, 1 ]}\nobreak
\hyperdef{L}{X82EE2ACD7B8C178B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsWeightedCollector({\mdseries\slshape coll})\index{IsWeightedCollector@\texttt{IsWeightedCollector}}
\label{IsWeightedCollector}
}\hfill{\scriptsize (property)}}\\


 checks if there is a function $w$ from the generators of the collector \mbox{\texttt{\mdseries\slshape coll}} into the positive integers such that $w(g) \geq w(x)+w(y)$ for all generators $x$, $y$ and all generators $g$ in (the normal of) $[x,y]$. If such a function does not exist, false is returned. If such a function
exists, it is computed and stored in the collector. In addition, the default
collection strategy for this collector is set to combinatorial collection. }

 

\subsection{\textcolor{Chapter }{AddHallPolynomials}}
\logpage{[ 3, 3, 2 ]}\nobreak
\hyperdef{L}{X7A1D7ED68334282C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AddHallPolynomials({\mdseries\slshape coll})\index{AddHallPolynomials@\texttt{AddHallPolynomials}}
\label{AddHallPolynomials}
}\hfill{\scriptsize (function)}}\\


 is applicable to a collector which passes \texttt{IsWeightedCollector} and computes the Hall multiplication polynomials for the presentation stored
in \mbox{\texttt{\mdseries\slshape coll}}. The default strategy for this collector is set to evaluating those
polynomial when multiplying two elements. }

 

\subsection{\textcolor{Chapter }{String}}
\logpage{[ 3, 3, 3 ]}\nobreak
\hyperdef{L}{X81FB5BE27903EC32}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{String({\mdseries\slshape coll})\index{String@\texttt{String}}
\label{String}
}\hfill{\scriptsize (attribute)}}\\


 converts a collector \mbox{\texttt{\mdseries\slshape coll}} into a string. }

 

\subsection{\textcolor{Chapter }{FTLCollectorPrintTo}}
\logpage{[ 3, 3, 4 ]}\nobreak
\hyperdef{L}{X7ED466B6807D16FE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FTLCollectorPrintTo({\mdseries\slshape file, name, coll})\index{FTLCollectorPrintTo@\texttt{FTLCollectorPrintTo}}
\label{FTLCollectorPrintTo}
}\hfill{\scriptsize (function)}}\\


 stores a collector \mbox{\texttt{\mdseries\slshape coll}} in the file \mbox{\texttt{\mdseries\slshape file}} such that the file can be read back using the function 'Read' into \textsf{GAP} and would then be stored in the variable \mbox{\texttt{\mdseries\slshape name}}. }

 

\subsection{\textcolor{Chapter }{FTLCollectorAppendTo}}
\logpage{[ 3, 3, 5 ]}\nobreak
\hyperdef{L}{X789D9EB37ECFA9D7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FTLCollectorAppendTo({\mdseries\slshape file, name, coll})\index{FTLCollectorAppendTo@\texttt{FTLCollectorAppendTo}}
\label{FTLCollectorAppendTo}
}\hfill{\scriptsize (function)}}\\


 appends a collector \mbox{\texttt{\mdseries\slshape coll}} in the file \mbox{\texttt{\mdseries\slshape file}} such that the file can be read back into \textsf{GAP} and would then be stored in the variable \mbox{\texttt{\mdseries\slshape name}}. }

 

\subsection{\textcolor{Chapter }{UseLibraryCollector}}
\logpage{[ 3, 3, 6 ]}\nobreak
\hyperdef{L}{X808A26FB873A354F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UseLibraryCollector\index{UseLibraryCollector@\texttt{UseLibraryCollector}}
\label{UseLibraryCollector}
}\hfill{\scriptsize (global variable)}}\\


 this property can be set to \texttt{true} for a collector to force a simple from-the-left collection strategy
implemented in the \textsf{GAP} language to be used. Its main purpose is to help debug the collection
routines. }

 

\subsection{\textcolor{Chapter }{USE{\textunderscore}LIBRARY{\textunderscore}COLLECTOR}}
\logpage{[ 3, 3, 7 ]}\nobreak
\hyperdef{L}{X844E195C7D55F8BD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{USE{\textunderscore}LIBRARY{\textunderscore}COLLECTOR\index{USELIBRARYCOLLECTOR@\texttt{USE{\textunderscore}}\-\texttt{L}\-\texttt{I}\-\texttt{B}\-\texttt{R}\-\texttt{A}\-\texttt{R}\-\texttt{Y{\textunderscore}}\-\texttt{C}\-\texttt{O}\-\texttt{L}\-\texttt{L}\-\texttt{E}\-\texttt{CTOR}}
\label{USELIBRARYCOLLECTOR}
}\hfill{\scriptsize (global variable)}}\\


 this global variable can be set to \texttt{true} to force all collectors to use a simple from-the-left collection strategy
implemented in the \textsf{GAP} language to be used. Its main purpose is to help debug the collection
routines. }

 

\subsection{\textcolor{Chapter }{DEBUG{\textunderscore}COMBINATORIAL{\textunderscore}COLLECTOR}}
\logpage{[ 3, 3, 8 ]}\nobreak
\hyperdef{L}{X7945C6B97BECCDA8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DEBUG{\textunderscore}COMBINATORIAL{\textunderscore}COLLECTOR\index{DEBUGCOMBINATORIALCOLLECTOR@\texttt{DEB}\-\texttt{U}\-\texttt{G{\textunderscore}}\-\texttt{C}\-\texttt{O}\-\texttt{M}\-\texttt{B}\-\texttt{I}\-\texttt{N}\-\texttt{A}\-\texttt{T}\-\texttt{O}\-\texttt{R}\-\texttt{I}\-\texttt{A}\-\texttt{L{\textunderscore}}\-\texttt{C}\-\texttt{O}\-\texttt{L}\-\texttt{L}\-\texttt{E}\-\texttt{CTOR}}
\label{DEBUGCOMBINATORIALCOLLECTOR}
}\hfill{\scriptsize (global variable)}}\\


 this global variable can be set to \texttt{true} to force the comparison of results from the combinatorial collector with the
result of an identical collection performed by a simple from-the-left
collector. Its main purpose is to help debug the collection routines. }

 

\subsection{\textcolor{Chapter }{USE{\textunderscore}COMBINATORIAL{\textunderscore}COLLECTOR}}
\logpage{[ 3, 3, 9 ]}\nobreak
\hyperdef{L}{X7BDFB55D7CB33543}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{USE{\textunderscore}COMBINATORIAL{\textunderscore}COLLECTOR\index{USECOMBINATORIALCOLLECTOR@\texttt{USE{\textunderscore}}\-\texttt{C}\-\texttt{O}\-\texttt{M}\-\texttt{B}\-\texttt{I}\-\texttt{N}\-\texttt{A}\-\texttt{T}\-\texttt{O}\-\texttt{R}\-\texttt{I}\-\texttt{A}\-\texttt{L{\textunderscore}}\-\texttt{C}\-\texttt{O}\-\texttt{L}\-\texttt{L}\-\texttt{E}\-\texttt{CTOR}}
\label{USECOMBINATORIALCOLLECTOR}
}\hfill{\scriptsize (global variable)}}\\


 this global variable can be set to \texttt{false} in order to prevent the combinatorial collector to be used. }

 }

 }

 
\chapter{\textcolor{Chapter }{Pcp-groups - polycyclically presented groups}}\label{Pcp-groups - polycyclically presented groups}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X7E2AF25881CF7307}{}
{
   
\section{\textcolor{Chapter }{Pcp-elements -- elements of a pc-presented group}}\label{Pcp-elements -- elements of a pc-presented group}
\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X7882F0F57ABEB680}{}
{
  A \emph{pcp-element} is an element of a group defined by a consistent pc-presentation given by a
collector. Suppose that $g_1, \ldots, g_n$ are the defining generators of the collector. Recall that each element $g$ in this group can be written uniquely as a collected word $g_1^{e_1} \cdots g_n^{e_n}$ with $e_i \in {\ensuremath{\mathbb Z}}$ and $0 \leq e_i < r_i$ for $i \in I$. The integer vector $[e_1, \ldots, e_n]$ is called the \emph{exponent vector} of $g$. The following functions can be used to define pcp-elements via their
exponent vector or via an arbitrary generator exponent word as introduced in
Chapter \ref{Collectors}. 

\subsection{\textcolor{Chapter }{PcpElementByExponentsNC}}
\logpage{[ 4, 1, 1 ]}\nobreak
\hyperdef{L}{X786DB93F7862D903}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PcpElementByExponentsNC({\mdseries\slshape coll, exp})\index{PcpElementByExponentsNC@\texttt{PcpElementByExponentsNC}}
\label{PcpElementByExponentsNC}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PcpElementByExponents({\mdseries\slshape coll, exp})\index{PcpElementByExponents@\texttt{PcpElementByExponents}}
\label{PcpElementByExponents}
}\hfill{\scriptsize (function)}}\\


 returns the pcp-element with exponent vector \mbox{\texttt{\mdseries\slshape exp}}. The exponent vector is considered relative to the defining generators of the
pc-presentation. }

 

\subsection{\textcolor{Chapter }{PcpElementByGenExpListNC}}
\logpage{[ 4, 1, 2 ]}\nobreak
\hyperdef{L}{X7BBB358C7AA64135}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PcpElementByGenExpListNC({\mdseries\slshape coll, word})\index{PcpElementByGenExpListNC@\texttt{PcpElementByGenExpListNC}}
\label{PcpElementByGenExpListNC}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PcpElementByGenExpList({\mdseries\slshape coll, word})\index{PcpElementByGenExpList@\texttt{PcpElementByGenExpList}}
\label{PcpElementByGenExpList}
}\hfill{\scriptsize (function)}}\\


 returns the pcp-element with generators exponent list \mbox{\texttt{\mdseries\slshape word}}. This list \mbox{\texttt{\mdseries\slshape word}} consists of a sequence of generator numbers and their corresponding exponents
and is of the form $[i_1, e_{i_1}, i_2, e_{i_2}, \ldots, i_r, e_{i_r}]$. The generators exponent list is considered relative to the defining
generators of the pc-presentation. 

 These functions return pcp-elements in the category \texttt{IsPcpElement}. Presently, the only representation implemented for this category is \texttt{IsPcpElementRep}. (This allows us to be a little sloppy right now. The basic set of operations
for \texttt{IsPcpElement} has not been defined yet. This is going to happen in one of the next version,
certainly as soon as the need for different representations arises.) }

 

\subsection{\textcolor{Chapter }{IsPcpElement}}
\logpage{[ 4, 1, 3 ]}\nobreak
\hyperdef{L}{X86083E297D68733B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPcpElement({\mdseries\slshape obj})\index{IsPcpElement@\texttt{IsPcpElement}}
\label{IsPcpElement}
}\hfill{\scriptsize (Category)}}\\


 returns true if the object \mbox{\texttt{\mdseries\slshape obj}} is a pcp-element. }

 

\subsection{\textcolor{Chapter }{IsPcpElementRep}}
\logpage{[ 4, 1, 4 ]}\nobreak
\hyperdef{L}{X7F2C83AD862910B9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPcpElementRep({\mdseries\slshape obj})\index{IsPcpElementRep@\texttt{IsPcpElementRep}}
\label{IsPcpElementRep}
}\hfill{\scriptsize (Representation)}}\\


 returns true if the object \mbox{\texttt{\mdseries\slshape obj}} is represented as a pcp-element. }

 }

  
\section{\textcolor{Chapter }{Methods for pcp-elements}}\label{Methods for pcp-elements}
\logpage{[ 4, 2, 0 ]}
\hyperdef{L}{X790471D07A953E12}{}
{
  Now we can describe attributes and functions for pcp-elements. The four basic
attributes of a pcp-element, \texttt{Collector}, \texttt{Exponents}, \texttt{GenExpList} and \texttt{NameTag} are computed at the creation of the pcp-element. All other attributes are
determined at runtime. 

 Let \mbox{\texttt{\mdseries\slshape g}} be a pcp-element and $g_1, \ldots, g_n$ a polycyclic generating sequence of the underlying pc-presented group. Let $C_1, \ldots, C_n$ be the polycyclic series defined by $g_1, \ldots, g_n$. 

 The \emph{depth} of a non-trivial element $g$ of a pcp-group (with respect to the defining generators) is the integer $i$ such that $g \in C_i \setminus C_{i+1}$. The depth of the trivial element is defined to be $n+1$. If $g\not=1$ has depth $i$ and $g_i^{e_i} \cdots g_n^{e_n}$ is the collected word for $g$, then $e_i$ is the \emph{leading exponent} of $g$. 

 If $g$ has depth $i$, then we call $r_i = [C_i:C_{i+1}]$ the \emph{factor order} of $g$. If $r < \infty$, then the smallest positive integer $l$ with $g^l \in C_{i+1}$ is the called \emph{relative order} of $g$. If $r=\infty$, then the relative order of $g$ is defined to be $0$. The index $e$ of $\langle g,C_{i+1}\rangle$ in $C_i$ is called \emph{relative index} of $g$. We have that $r = el$. 

 We call a pcp-element \emph{normed}, if its leading exponent is equal to its relative index. For each pcp-element $g$ there exists an integer $e$ such that $g^e$ is normed. 

\subsection{\textcolor{Chapter }{Collector}}
\logpage{[ 4, 2, 1 ]}\nobreak
\hyperdef{L}{X7E2D258B7DCE8AC9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Collector({\mdseries\slshape g})\index{Collector@\texttt{Collector}}
\label{Collector}
}\hfill{\scriptsize (operation)}}\\


 the collector to which the pcp-element \mbox{\texttt{\mdseries\slshape g}} belongs. }

 

\subsection{\textcolor{Chapter }{Exponents}}
\logpage{[ 4, 2, 2 ]}\nobreak
\hyperdef{L}{X85C672E78630C507}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Exponents({\mdseries\slshape g})\index{Exponents@\texttt{Exponents}}
\label{Exponents}
}\hfill{\scriptsize (operation)}}\\


 returns the exponent vector of the pcp-element \mbox{\texttt{\mdseries\slshape g}} with respect to the defining generating set of the underlying collector. }

 

\subsection{\textcolor{Chapter }{GenExpList}}
\logpage{[ 4, 2, 3 ]}\nobreak
\hyperdef{L}{X8571F6FB7E74346C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GenExpList({\mdseries\slshape g})\index{GenExpList@\texttt{GenExpList}}
\label{GenExpList}
}\hfill{\scriptsize (operation)}}\\


 returns the generators exponent list of the pcp-element \mbox{\texttt{\mdseries\slshape g}} with respect to the defining generating set of the underlying collector. }

 

\subsection{\textcolor{Chapter }{NameTag}}
\logpage{[ 4, 2, 4 ]}\nobreak
\hyperdef{L}{X82252C5E7B011559}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NameTag({\mdseries\slshape g})\index{NameTag@\texttt{NameTag}}
\label{NameTag}
}\hfill{\scriptsize (operation)}}\\


 the name used for printing the pcp-element \mbox{\texttt{\mdseries\slshape g}}. Printing is done by using the name tag and appending the generator number of \mbox{\texttt{\mdseries\slshape g}}. }

 

\subsection{\textcolor{Chapter }{Depth}}
\logpage{[ 4, 2, 5 ]}\nobreak
\hyperdef{L}{X840D32D9837E99F5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Depth({\mdseries\slshape g})\index{Depth@\texttt{Depth}}
\label{Depth}
}\hfill{\scriptsize (operation)}}\\


 returns the depth of the pcp-element \mbox{\texttt{\mdseries\slshape g}} relative to the defining generators. }

 

\subsection{\textcolor{Chapter }{LeadingExponent}}
\logpage{[ 4, 2, 6 ]}\nobreak
\hyperdef{L}{X874F1EC178721833}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LeadingExponent({\mdseries\slshape g})\index{LeadingExponent@\texttt{LeadingExponent}}
\label{LeadingExponent}
}\hfill{\scriptsize (operation)}}\\


 returns the leading exponent of pcp-element \mbox{\texttt{\mdseries\slshape g}} relative to the defining generators. If \mbox{\texttt{\mdseries\slshape g}} is the identity element, the functions returns 'fail' }

 

\subsection{\textcolor{Chapter }{RelativeOrder}}
\logpage{[ 4, 2, 7 ]}\nobreak
\hyperdef{L}{X8008AB61823A76B7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RelativeOrder({\mdseries\slshape g})\index{RelativeOrder@\texttt{RelativeOrder}}
\label{RelativeOrder}
}\hfill{\scriptsize (attribute)}}\\


 returns the relative order of the pcp-element \mbox{\texttt{\mdseries\slshape g}} with respect to the defining generators. }

 

\subsection{\textcolor{Chapter }{RelativeIndex}}
\logpage{[ 4, 2, 8 ]}\nobreak
\hyperdef{L}{X875D04288577015B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RelativeIndex({\mdseries\slshape g})\index{RelativeIndex@\texttt{RelativeIndex}}
\label{RelativeIndex}
}\hfill{\scriptsize (attribute)}}\\


 returns the relative index of the pcp-element \mbox{\texttt{\mdseries\slshape g}} with respect to the defining generators. }

 

\subsection{\textcolor{Chapter }{FactorOrder}}
\logpage{[ 4, 2, 9 ]}\nobreak
\hyperdef{L}{X87E070747955F2C1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FactorOrder({\mdseries\slshape g})\index{FactorOrder@\texttt{FactorOrder}}
\label{FactorOrder}
}\hfill{\scriptsize (attribute)}}\\


 returns the factor order of the pcp-element \mbox{\texttt{\mdseries\slshape g}} with respect to the defining generators. }

 

\subsection{\textcolor{Chapter }{NormingExponent}}
\logpage{[ 4, 2, 10 ]}\nobreak
\hyperdef{L}{X79A247797F0A8583}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NormingExponent({\mdseries\slshape g})\index{NormingExponent@\texttt{NormingExponent}}
\label{NormingExponent}
}\hfill{\scriptsize (function)}}\\


 returns a positive integer $e$ such that the pcp-element \mbox{\texttt{\mdseries\slshape g}} raised to the power of $e$ is normed. }

 

\subsection{\textcolor{Chapter }{NormedPcpElement}}
\logpage{[ 4, 2, 11 ]}\nobreak
\hyperdef{L}{X798BB22B80833441}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NormedPcpElement({\mdseries\slshape g})\index{NormedPcpElement@\texttt{NormedPcpElement}}
\label{NormedPcpElement}
}\hfill{\scriptsize (function)}}\\


 returns the normed element corresponding to the pcp-element \mbox{\texttt{\mdseries\slshape g}}. }

 }

  
\section{\textcolor{Chapter }{Pcp-groups - groups of pcp-elements}}\label{pcpgroup}
\logpage{[ 4, 3, 0 ]}
\hyperdef{L}{X7A4EF7C68151905A}{}
{
  A \emph{pcp-group} is a group consisting of pcp-elements such that all pcp-elements in the group
share the same collector. Thus the group $G$ defined by a polycyclic presentation and all its subgroups are pcp-groups. 

\subsection{\textcolor{Chapter }{PcpGroupByCollector}}
\logpage{[ 4, 3, 1 ]}\nobreak
\hyperdef{L}{X7C8FBCAB7F63FACB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PcpGroupByCollector({\mdseries\slshape coll})\index{PcpGroupByCollector@\texttt{PcpGroupByCollector}}
\label{PcpGroupByCollector}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PcpGroupByCollectorNC({\mdseries\slshape coll})\index{PcpGroupByCollectorNC@\texttt{PcpGroupByCollectorNC}}
\label{PcpGroupByCollectorNC}
}\hfill{\scriptsize (function)}}\\


 returns a pcp-group build from the collector \mbox{\texttt{\mdseries\slshape coll}}. 

 The function calls \texttt{UpdatePolycyclicCollector} (\ref{UpdatePolycyclicCollector}) and checks the confluence (see \texttt{IsConfluent} (\ref{IsConfluent})) of the collector. 

 The non-check version bypasses these checks. }

 

\subsection{\textcolor{Chapter }{Group}}
\logpage{[ 4, 3, 2 ]}\nobreak
\hyperdef{L}{X7D7B075385435151}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Group({\mdseries\slshape gens, id})\index{Group@\texttt{Group}}
\label{Group}
}\hfill{\scriptsize (function)}}\\


 returns the group generated by the pcp-elements \mbox{\texttt{\mdseries\slshape gens}} with identity \mbox{\texttt{\mdseries\slshape id}}. }

 

\subsection{\textcolor{Chapter }{Subgroup}}
\logpage{[ 4, 3, 3 ]}\nobreak
\hyperdef{L}{X7C82AA387A42DCA0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Subgroup({\mdseries\slshape G, gens})\index{Subgroup@\texttt{Subgroup}}
\label{Subgroup}
}\hfill{\scriptsize (function)}}\\


 returns a subgroup of the pcp-group \mbox{\texttt{\mdseries\slshape G}} generated by the list \mbox{\texttt{\mdseries\slshape gens}} of pcp-elements from \mbox{\texttt{\mdseries\slshape G}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ ftl := FromTheLeftCollector( 2 );;|
  !gapprompt@gap>| !gapinput@ SetRelativeOrder( ftl, 1, 2 );|
  !gapprompt@gap>| !gapinput@ SetConjugate( ftl, 2, 1, [2,-1] );|
  !gapprompt@gap>| !gapinput@ UpdatePolycyclicCollector( ftl );|
  !gapprompt@gap>| !gapinput@ G:= PcpGroupByCollectorNC( ftl );|
  Pcp-group with orders [ 2, 0 ]
  !gapprompt@gap>| !gapinput@Subgroup( G, GeneratorsOfGroup(G){[2]} );|
  Pcp-group with orders [ 0 ]
\end{Verbatim}
 }

 }

 }

 
\chapter{\textcolor{Chapter }{Basic methods and functions for pcp-groups}}\label{Basic methods and functions for pcp-groups}
\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X7B9B85AE7C9B13EE}{}
{
  Pcp-groups are groups in the \textsf{GAP} sense and hence all generic \textsf{GAP} methods for groups can be applied for pcp-groups. However, for a number of
group theoretic questions \textsf{GAP} does not provide generic methods that can be applied to pcp-groups. For some
of these questions there are functions provided in \textsf{Polycyclic}.  
\section{\textcolor{Chapter }{Elementary methods for pcp-groups}}\label{methods}
\logpage{[ 5, 1, 0 ]}
\hyperdef{L}{X821360107E355B88}{}
{
  In this chapter we describe some important basic functions which are available
for pcp-groups. A number of higher level functions are outlined in later
sections and chapters. 

 Let $U, V$ and $N$ be subgroups of a pcp-group. 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}=}}
\logpage{[ 5, 1, 1 ]}\nobreak
\hyperdef{L}{X806A4814806A4814}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}=({\mdseries\slshape U, V})\index{=@\texttt{\texttt{\symbol{92}}=}}
\label{=}
}\hfill{\scriptsize (method)}}\\


 decides if \mbox{\texttt{\mdseries\slshape U}} and \mbox{\texttt{\mdseries\slshape V}} are equal as sets. }

 

\subsection{\textcolor{Chapter }{Size}}
\logpage{[ 5, 1, 2 ]}\nobreak
\hyperdef{L}{X858ADA3B7A684421}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Size({\mdseries\slshape U})\index{Size@\texttt{Size}}
\label{Size}
}\hfill{\scriptsize (method)}}\\


 returns the size of \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{Random}}
\logpage{[ 5, 1, 3 ]}\nobreak
\hyperdef{L}{X79730D657AB219DB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Random({\mdseries\slshape U})\index{Random@\texttt{Random}}
\label{Random}
}\hfill{\scriptsize (method)}}\\


 returns a random element of \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{Index}}
\logpage{[ 5, 1, 4 ]}\nobreak
\hyperdef{L}{X83A0356F839C696F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Index({\mdseries\slshape U, V})\index{Index@\texttt{Index}}
\label{Index}
}\hfill{\scriptsize (method)}}\\


 returns the index of \mbox{\texttt{\mdseries\slshape V}} in \mbox{\texttt{\mdseries\slshape U}} if \mbox{\texttt{\mdseries\slshape V}} is a subgroup of \mbox{\texttt{\mdseries\slshape U}}. The function does not check if \mbox{\texttt{\mdseries\slshape V}} is a subgroup of \mbox{\texttt{\mdseries\slshape U}} and if it is not, the result is not meaningful. }

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}in}}
\logpage{[ 5, 1, 5 ]}\nobreak
\hyperdef{L}{X87BDB89B7AAFE8AD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}in({\mdseries\slshape g, U})\index{in@\texttt{\texttt{\symbol{92}}in}}
\label{in}
}\hfill{\scriptsize (method)}}\\


 checks if \mbox{\texttt{\mdseries\slshape g}} is an element of \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{Elements}}
\logpage{[ 5, 1, 6 ]}\nobreak
\hyperdef{L}{X79B130FC7906FB4C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Elements({\mdseries\slshape U})\index{Elements@\texttt{Elements}}
\label{Elements}
}\hfill{\scriptsize (method)}}\\


 returns a list containing all elements of \mbox{\texttt{\mdseries\slshape U}} if \mbox{\texttt{\mdseries\slshape U}} is finite and it returns the list [fail] otherwise. }

 

\subsection{\textcolor{Chapter }{ClosureGroup}}
\logpage{[ 5, 1, 7 ]}\nobreak
\hyperdef{L}{X7D13FC1F8576FFD8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ClosureGroup({\mdseries\slshape U, V})\index{ClosureGroup@\texttt{ClosureGroup}}
\label{ClosureGroup}
}\hfill{\scriptsize (method)}}\\


 returns the group generated by \mbox{\texttt{\mdseries\slshape U}} and \mbox{\texttt{\mdseries\slshape V}}. }

 

\subsection{\textcolor{Chapter }{NormalClosure}}
\logpage{[ 5, 1, 8 ]}\nobreak
\hyperdef{L}{X7BDEA0A98720D1BB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NormalClosure({\mdseries\slshape U, V})\index{NormalClosure@\texttt{NormalClosure}}
\label{NormalClosure}
}\hfill{\scriptsize (method)}}\\


 returns the normal closure of \mbox{\texttt{\mdseries\slshape V}} under action of \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{HirschLength}}
\logpage{[ 5, 1, 9 ]}\nobreak
\hyperdef{L}{X839B42AE7A1DD544}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HirschLength({\mdseries\slshape U})\index{HirschLength@\texttt{HirschLength}}
\label{HirschLength}
}\hfill{\scriptsize (method)}}\\


 returns the Hirsch length of \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{CommutatorSubgroup}}
\logpage{[ 5, 1, 10 ]}\nobreak
\hyperdef{L}{X7A9A3D5578CE33A0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CommutatorSubgroup({\mdseries\slshape U, V})\index{CommutatorSubgroup@\texttt{CommutatorSubgroup}}
\label{CommutatorSubgroup}
}\hfill{\scriptsize (method)}}\\


 returns the group generated by all commutators $[u,v]$ with $u$ in \mbox{\texttt{\mdseries\slshape U}} and $v$ in \mbox{\texttt{\mdseries\slshape V}}. }

 

\subsection{\textcolor{Chapter }{PRump}}
\logpage{[ 5, 1, 11 ]}\nobreak
\hyperdef{L}{X796DA805853FAC90}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PRump({\mdseries\slshape U, p})\index{PRump@\texttt{PRump}}
\label{PRump}
}\hfill{\scriptsize (method)}}\\


 returns the subgroup $U'U^p$ of \mbox{\texttt{\mdseries\slshape U}} where \mbox{\texttt{\mdseries\slshape p}} is a prime number. }

 

\subsection{\textcolor{Chapter }{SmallGeneratingSet}}
\logpage{[ 5, 1, 12 ]}\nobreak
\hyperdef{L}{X814DBABC878D5232}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SmallGeneratingSet({\mdseries\slshape U})\index{SmallGeneratingSet@\texttt{SmallGeneratingSet}}
\label{SmallGeneratingSet}
}\hfill{\scriptsize (method)}}\\


 returns a small generating set for \mbox{\texttt{\mdseries\slshape U}}. }

 }

  
\section{\textcolor{Chapter }{Elementary properties of pcp-groups}}\label{Elementary properties of pcp-groups}
\logpage{[ 5, 2, 0 ]}
\hyperdef{L}{X80E88168866D54F3}{}
{
  

\subsection{\textcolor{Chapter }{IsSubgroup}}
\logpage{[ 5, 2, 1 ]}\nobreak
\hyperdef{L}{X7839D8927E778334}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSubgroup({\mdseries\slshape U, V})\index{IsSubgroup@\texttt{IsSubgroup}}
\label{IsSubgroup}
}\hfill{\scriptsize (function)}}\\


 tests if \mbox{\texttt{\mdseries\slshape V}} is a subgroup of \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{IsNormal}}
\logpage{[ 5, 2, 2 ]}\nobreak
\hyperdef{L}{X838186F9836F678C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsNormal({\mdseries\slshape U, V})\index{IsNormal@\texttt{IsNormal}}
\label{IsNormal}
}\hfill{\scriptsize (function)}}\\


 tests if \mbox{\texttt{\mdseries\slshape V}} is normal in \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{IsNilpotentGroup}}
\logpage{[ 5, 2, 3 ]}\nobreak
\hyperdef{L}{X87D062608719F2CD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsNilpotentGroup({\mdseries\slshape U})\index{IsNilpotentGroup@\texttt{IsNilpotentGroup}}
\label{IsNilpotentGroup}
}\hfill{\scriptsize (method)}}\\


 checks whether \mbox{\texttt{\mdseries\slshape U}} is nilpotent. }

 

\subsection{\textcolor{Chapter }{IsAbelian}}
\logpage{[ 5, 2, 4 ]}\nobreak
\hyperdef{L}{X7C12AA7479A6C103}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsAbelian({\mdseries\slshape U})\index{IsAbelian@\texttt{IsAbelian}}
\label{IsAbelian}
}\hfill{\scriptsize (method)}}\\


 checks whether \mbox{\texttt{\mdseries\slshape U}} is abelian. }

 

\subsection{\textcolor{Chapter }{IsElementaryAbelian}}
\logpage{[ 5, 2, 5 ]}\nobreak
\hyperdef{L}{X813C952F80E775D4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsElementaryAbelian({\mdseries\slshape U})\index{IsElementaryAbelian@\texttt{IsElementaryAbelian}}
\label{IsElementaryAbelian}
}\hfill{\scriptsize (method)}}\\


 checks whether \mbox{\texttt{\mdseries\slshape U}} is elementary abelian. }

 

\subsection{\textcolor{Chapter }{IsFreeAbelian}}
\logpage{[ 5, 2, 6 ]}\nobreak
\hyperdef{L}{X84FFC668832F9ED6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsFreeAbelian({\mdseries\slshape U})\index{IsFreeAbelian@\texttt{IsFreeAbelian}}
\label{IsFreeAbelian}
}\hfill{\scriptsize (property)}}\\


 checks whether \mbox{\texttt{\mdseries\slshape U}} is free abelian. }

 }

  
\section{\textcolor{Chapter }{Subgroups of pcp-groups}}\label{Subgroups of pcp-groups}
\logpage{[ 5, 3, 0 ]}
\hyperdef{L}{X85A7E26C7E14AFBA}{}
{
  A subgroup of a pcp-group $G$ can be defined by a set of generators as described in Section \ref{pcpgroup}. However, many computations with a subgroup $U$ need an \emph{induced generating sequence} or \emph{igs} of $U$. An igs is a sequence of generators of $U$ whose list of exponent vectors form a matrix in upper triangular form. Note
that there may exist many igs of $U$. The first one calculated for $U$ is stored as an attribute. 

 An induced generating sequence of a subgroup of a pcp-group $G$ is a list of elements of $G$. An igs is called \emph{normed}, if each element in the list is normed. Moreover, it is \emph{canonical}, if the exponent vector matrix is in Hermite Normal Form. The following
functions can be used to compute induced generating sequence for a given
subgroup \mbox{\texttt{\mdseries\slshape U}} of \mbox{\texttt{\mdseries\slshape G}}. 

\subsection{\textcolor{Chapter }{Igs}}
\logpage{[ 5, 3, 1 ]}\nobreak
\hyperdef{L}{X833011AD7DFD2C50}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Igs({\mdseries\slshape U})\index{Igs@\texttt{Igs}}
\label{Igs}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Igs({\mdseries\slshape gens})\index{Igs@\texttt{Igs}}
\label{Igs}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IgsParallel({\mdseries\slshape gens, gens2})\index{IgsParallel@\texttt{IgsParallel}}
\label{IgsParallel}
}\hfill{\scriptsize (function)}}\\


 returns an induced generating sequence of the subgroup \mbox{\texttt{\mdseries\slshape U}} of a pcp-group. In the second form the subgroup is given via a generating set \mbox{\texttt{\mdseries\slshape gens}}. The third form computes an igs for the subgroup generated by \mbox{\texttt{\mdseries\slshape gens}} carrying \mbox{\texttt{\mdseries\slshape gens2}} through as shadows. This means that each operation that is applied to the
first list is also applied to the second list. }

 

\subsection{\textcolor{Chapter }{Ngs}}
\logpage{[ 5, 3, 2 ]}\nobreak
\hyperdef{L}{X8364E0C5841B650A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Ngs({\mdseries\slshape U})\index{Ngs@\texttt{Ngs}}
\label{Ngs}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Ngs({\mdseries\slshape igs})\index{Ngs@\texttt{Ngs}}
\label{Ngs}
}\hfill{\scriptsize (function)}}\\


 returns a normed induced generating sequence of the subgroup \mbox{\texttt{\mdseries\slshape U}} of a pcp-group. The second form takes an igs as input and norms it. }

 

\subsection{\textcolor{Chapter }{Cgs}}
\logpage{[ 5, 3, 3 ]}\nobreak
\hyperdef{L}{X83E969F083F072C1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Cgs({\mdseries\slshape U})\index{Cgs@\texttt{Cgs}}
\label{Cgs}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Cgs({\mdseries\slshape igs})\index{Cgs@\texttt{Cgs}}
\label{Cgs}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CgsParallel({\mdseries\slshape gens, gens2})\index{CgsParallel@\texttt{CgsParallel}}
\label{CgsParallel}
}\hfill{\scriptsize (function)}}\\


 returns a canonical generating sequence of the subgroup \mbox{\texttt{\mdseries\slshape U}} of a pcp-group. In the second form the function takes an igs as input and
returns a canonical generating sequence. The third version takes a generating
set and computes a canonical generating sequence carrying \mbox{\texttt{\mdseries\slshape gens2}} through as shadows. This means that each operation that is applied to the
first list is also applied to the second list. 

 For a large number of methods for pcp-groups \mbox{\texttt{\mdseries\slshape U}} we will first of all determine an \mbox{\texttt{\mdseries\slshape igs}} for \mbox{\texttt{\mdseries\slshape U}}. Hence it might speed up computations, if a known \mbox{\texttt{\mdseries\slshape igs}} for a group \mbox{\texttt{\mdseries\slshape U}} is set \emph{a priori}. The following functions can be used for this purpose. }

 

\subsection{\textcolor{Chapter }{SubgroupByIgs}}
\logpage{[ 5, 3, 4 ]}\nobreak
\hyperdef{L}{X83B92A2679EAB1EB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SubgroupByIgs({\mdseries\slshape G, igs})\index{SubgroupByIgs@\texttt{SubgroupByIgs}}
\label{SubgroupByIgs}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SubgroupByIgs({\mdseries\slshape G, igs, gens})\index{SubgroupByIgs@\texttt{SubgroupByIgs}}
\label{SubgroupByIgs}
}\hfill{\scriptsize (function)}}\\


 returns the subgroup of the pcp-group \mbox{\texttt{\mdseries\slshape G}} generated by the elements of the induced generating sequence \mbox{\texttt{\mdseries\slshape igs}}. Note that \mbox{\texttt{\mdseries\slshape igs}} must be an induced generating sequence of the subgroup generated by the
elements of the \mbox{\texttt{\mdseries\slshape igs}}. In the second form \mbox{\texttt{\mdseries\slshape igs}} is a igs for a subgroup and \mbox{\texttt{\mdseries\slshape gens}} are some generators. The function returns the subgroup generated by \mbox{\texttt{\mdseries\slshape igs}} and \mbox{\texttt{\mdseries\slshape gens}}. }

 

\subsection{\textcolor{Chapter }{AddToIgs}}
\logpage{[ 5, 3, 5 ]}\nobreak
\hyperdef{L}{X78107DE78728B26B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AddToIgs({\mdseries\slshape igs, gens})\index{AddToIgs@\texttt{AddToIgs}}
\label{AddToIgs}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AddToIgsParallel({\mdseries\slshape igs, gens, igs2, gens2})\index{AddToIgsParallel@\texttt{AddToIgsParallel}}
\label{AddToIgsParallel}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AddIgsToIgs({\mdseries\slshape igs, igs2})\index{AddIgsToIgs@\texttt{AddIgsToIgs}}
\label{AddIgsToIgs}
}\hfill{\scriptsize (function)}}\\


 sifts the elements in the list $gens$ into $igs$. The second version has the same functionality and carries shadows. This
means that each operation that is applied to the first list and the element \mbox{\texttt{\mdseries\slshape gens}} is also applied to the second list and the element \mbox{\texttt{\mdseries\slshape gens2}}. The third version is available for efficiency reasons and assumes that the
second list \mbox{\texttt{\mdseries\slshape igs2}} is not only a generating set, but an igs. }

 }

  
\section{\textcolor{Chapter }{Polycyclic presentation sequences for subfactors}}\label{pcps}
\logpage{[ 5, 4, 0 ]}
\hyperdef{L}{X803D62BC86EF07D0}{}
{
  A subfactor of a pcp-group $G$ is again a polycyclic group for which a polycyclic presentation can be
computed. However, to compute a polycyclic presentation for a given subfactor
can be time-consuming. Hence we introduce \emph{polycyclic presentation sequences} or \emph{Pcp} to compute more efficiently with subfactors. (Note that a subgroup is also a
subfactor and thus can be handled by a pcp) 

 A pcp for a pcp-group $U$ or a subfactor $U / N$ can be created with one of the following functions. 

\subsection{\textcolor{Chapter }{Pcp}}
\logpage{[ 5, 4, 1 ]}\nobreak
\hyperdef{L}{X7DD931697DD93169}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Pcp({\mdseries\slshape U[, flag]})\index{Pcp@\texttt{Pcp}}
\label{Pcp}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Pcp({\mdseries\slshape U, N[, flag]})\index{Pcp@\texttt{Pcp}}
\label{Pcp}
}\hfill{\scriptsize (function)}}\\


 returns a polycyclic presentation sequence for the subgroup \mbox{\texttt{\mdseries\slshape U}} or the quotient group \mbox{\texttt{\mdseries\slshape U}} modulo \mbox{\texttt{\mdseries\slshape N}}. If the parameter \mbox{\texttt{\mdseries\slshape flag}} is present and equals the string ``snf'', the function can only be applied to an abelian subgroup \mbox{\texttt{\mdseries\slshape U}} or abelian subfactor \mbox{\texttt{\mdseries\slshape U}}/\mbox{\texttt{\mdseries\slshape N}}. The pcp returned will correspond to a decomposition of the abelian group
into a direct product of cyclic groups. }

 A pcp is a component object which behaves similar to a list representing an
igs of the subfactor in question. The basic functions to obtain the stored
values of this component object are as follows. Let $pcp$ be a pcp for a subfactor $U/N$ of the defining pcp-group $G$. 

\subsection{\textcolor{Chapter }{GeneratorsOfPcp}}
\logpage{[ 5, 4, 2 ]}\nobreak
\hyperdef{L}{X821FF77086E38B3A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GeneratorsOfPcp({\mdseries\slshape pcp})\index{GeneratorsOfPcp@\texttt{GeneratorsOfPcp}}
\label{GeneratorsOfPcp}
}\hfill{\scriptsize (function)}}\\


 this returns a list of elements of $U$ corresponding to an igs of $U/N$. }

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}[\texttt{\symbol{92}}]}}
\logpage{[ 5, 4, 3 ]}\nobreak
\hyperdef{L}{X8297BBCD79642BE6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}[\texttt{\symbol{92}}]({\mdseries\slshape pcp, i})\index{[]@\texttt{\texttt{\symbol{92}}[\texttt{\symbol{92}}]}}
\label{[]}
}\hfill{\scriptsize (method)}}\\


 returns the \mbox{\texttt{\mdseries\slshape i}}-th element of \mbox{\texttt{\mdseries\slshape pcp}}. }

 

\subsection{\textcolor{Chapter }{Length}}
\logpage{[ 5, 4, 4 ]}\nobreak
\hyperdef{L}{X780769238600AFD1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Length({\mdseries\slshape pcp})\index{Length@\texttt{Length}}
\label{Length}
}\hfill{\scriptsize (method)}}\\


 returns the number of generators in \mbox{\texttt{\mdseries\slshape pcp}}. }

 

\subsection{\textcolor{Chapter }{RelativeOrdersOfPcp}}
\logpage{[ 5, 4, 5 ]}\nobreak
\hyperdef{L}{X7ABCA7F2790E1673}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RelativeOrdersOfPcp({\mdseries\slshape pcp})\index{RelativeOrdersOfPcp@\texttt{RelativeOrdersOfPcp}}
\label{RelativeOrdersOfPcp}
}\hfill{\scriptsize (function)}}\\


 the relative orders of the igs in \mbox{\texttt{\mdseries\slshape U/N}}. }

 

\subsection{\textcolor{Chapter }{DenominatorOfPcp}}
\logpage{[ 5, 4, 6 ]}\nobreak
\hyperdef{L}{X7D16C299825887AA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DenominatorOfPcp({\mdseries\slshape pcp})\index{DenominatorOfPcp@\texttt{DenominatorOfPcp}}
\label{DenominatorOfPcp}
}\hfill{\scriptsize (function)}}\\


 returns an igs of \mbox{\texttt{\mdseries\slshape N}}. }

 

\subsection{\textcolor{Chapter }{NumeratorOfPcp}}
\logpage{[ 5, 4, 7 ]}\nobreak
\hyperdef{L}{X803AED1A84FCBEE8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NumeratorOfPcp({\mdseries\slshape pcp})\index{NumeratorOfPcp@\texttt{NumeratorOfPcp}}
\label{NumeratorOfPcp}
}\hfill{\scriptsize (function)}}\\


 returns an igs of \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{GroupOfPcp}}
\logpage{[ 5, 4, 8 ]}\nobreak
\hyperdef{L}{X80BCCF0B81344933}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GroupOfPcp({\mdseries\slshape pcp})\index{GroupOfPcp@\texttt{GroupOfPcp}}
\label{GroupOfPcp}
}\hfill{\scriptsize (function)}}\\


 returns \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{OneOfPcp}}
\logpage{[ 5, 4, 9 ]}\nobreak
\hyperdef{L}{X87F0BA5F7BA0F4B4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OneOfPcp({\mdseries\slshape pcp})\index{OneOfPcp@\texttt{OneOfPcp}}
\label{OneOfPcp}
}\hfill{\scriptsize (function)}}\\


 returns the identity element of \mbox{\texttt{\mdseries\slshape G}}. }

 The main feature of a pcp are the possibility to compute exponent vectors
without having to determine an explicit pcp-group corresponding to the
subfactor that is represented by the pcp. Nonetheless, it is possible to
determine this subfactor. 

\subsection{\textcolor{Chapter }{ExponentsByPcp}}
\logpage{[ 5, 4, 10 ]}\nobreak
\hyperdef{L}{X7A8C8BBC81581E09}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ExponentsByPcp({\mdseries\slshape pcp, g})\index{ExponentsByPcp@\texttt{ExponentsByPcp}}
\label{ExponentsByPcp}
}\hfill{\scriptsize (function)}}\\


 returns the exponent vector of \mbox{\texttt{\mdseries\slshape g}} with respect to the generators of \mbox{\texttt{\mdseries\slshape pcp}}. This is the exponent vector of \mbox{\texttt{\mdseries\slshape g}}$N$ with respect to the igs of \mbox{\texttt{\mdseries\slshape U/N}}. }

 

\subsection{\textcolor{Chapter }{PcpGroupByPcp}}
\logpage{[ 5, 4, 11 ]}\nobreak
\hyperdef{L}{X87D75F7F86FEF203}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PcpGroupByPcp({\mdseries\slshape pcp})\index{PcpGroupByPcp@\texttt{PcpGroupByPcp}}
\label{PcpGroupByPcp}
}\hfill{\scriptsize (function)}}\\


 let \mbox{\texttt{\mdseries\slshape pcp}} be a Pcp of a subgroup or a factor group of a pcp-group. This function
computes a new pcp-group whose defining generators correspond to the
generators in \mbox{\texttt{\mdseries\slshape pcp}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ G := DihedralPcpGroup(0);|
  Pcp-group with orders [ 2, 0 ]
  !gapprompt@gap>| !gapinput@ pcp := Pcp(G);|
  Pcp [ g1, g2 ] with orders [ 2, 0 ]
  !gapprompt@gap>| !gapinput@ pcp[1];|
  g1
  !gapprompt@gap>| !gapinput@ Length(pcp);|
  2
  !gapprompt@gap>| !gapinput@ RelativeOrdersOfPcp(pcp);|
  [ 2, 0 ]
  !gapprompt@gap>| !gapinput@ DenominatorOfPcp(pcp);|
  [  ]
  !gapprompt@gap>| !gapinput@ NumeratorOfPcp(pcp);|
  [ g1, g2 ]
  !gapprompt@gap>| !gapinput@ GroupOfPcp(pcp);|
  Pcp-group with orders [ 2, 0 ]
  !gapprompt@gap>| !gapinput@OneOfPcp(pcp);|
  identity
\end{Verbatim}
 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := ExamplesOfSomePcpGroups(5);|
  Pcp-group with orders [ 2, 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@D := DerivedSubgroup( G );|
  Pcp-group with orders [ 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@ GeneratorsOfGroup( G );|
  [ g1, g2, g3, g4 ]
  !gapprompt@gap>| !gapinput@ GeneratorsOfGroup( D );|
  [ g2^-2, g3^-2, g4^2 ]
  
  # an ordinary pcp for G / D
  !gapprompt@gap>| !gapinput@pcp1 := Pcp( G, D );|
  Pcp [ g1, g2, g3, g4 ] with orders [ 2, 2, 2, 2 ]
  
  # a pcp for G/D in independent generators
  !gapprompt@gap>| !gapinput@ pcp2 := Pcp( G, D, "snf" );|
  Pcp [ g2, g3, g1 ] with orders [ 2, 2, 4 ]
  
  !gapprompt@gap>| !gapinput@ g := Random( G );|
  g1*g2^-4*g3*g4^2
  
  # compute the exponent vector of g in G/D with respect to pcp1
  !gapprompt@gap>| !gapinput@ExponentsByPcp( pcp1, g );|
  [ 1, 0, 1, 0 ]
  
  # compute the exponent vector of g in G/D with respect to pcp2
  !gapprompt@gap>| !gapinput@ ExponentsByPcp( pcp2, g );|
  [ 0, 1, 1 ]
\end{Verbatim}
 }

 }

  
\section{\textcolor{Chapter }{Factor groups of pcp-groups}}\label{Factor groups of pcp-groups}
\logpage{[ 5, 5, 0 ]}
\hyperdef{L}{X845D29B478CA7656}{}
{
  Pcp's for subfactors of pcp-groups have already been described above. These
are usually used within algorithms to compute with pcp-groups. However, it is
also possible to explicitly construct factor groups and their corresponding
natural homomorphisms. 

\subsection{\textcolor{Chapter }{NaturalHomomorphism}}
\logpage{[ 5, 5, 1 ]}\nobreak
\hyperdef{L}{X7E3F6CCD7C793211}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NaturalHomomorphism({\mdseries\slshape G, N})\index{NaturalHomomorphism@\texttt{NaturalHomomorphism}}
\label{NaturalHomomorphism}
}\hfill{\scriptsize (method)}}\\


 returns the natural homomorphism $G \to G/N$. Its image is the factor group $G/N$. }

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}/}}
\logpage{[ 5, 5, 2 ]}\nobreak
\hyperdef{L}{X7F51DF007F51DF00}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{\texttt{\symbol{92}}/({\mdseries\slshape G, N})\index{/@\texttt{\texttt{\symbol{92}}/}}
\label{/}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FactorGroup({\mdseries\slshape G, N})\index{FactorGroup@\texttt{FactorGroup}}
\label{FactorGroup}
}\hfill{\scriptsize (method)}}\\


 returns the desired factor as pcp-group without giving the explicit
homomorphism. This function is just a wrapper for \texttt{PcpGroupByPcp( Pcp( G, N ) )}. }

 }

  
\section{\textcolor{Chapter }{Homomorphisms for pcp-groups}}\label{Homomorphisms for pcp-groups}
\logpage{[ 5, 6, 0 ]}
\hyperdef{L}{X82E643F178E765EA}{}
{
  \textsf{Polycyclic} provides code for defining group homomorphisms by generators and images where
either the source or the range or both are pcp groups. All methods provided by
GAP for such group homomorphisms are supported, in particular the following: 

\subsection{\textcolor{Chapter }{GroupHomomorphismByImages}}
\logpage{[ 5, 6, 1 ]}\nobreak
\hyperdef{L}{X7F348F497C813BE0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GroupHomomorphismByImages({\mdseries\slshape G, H, gens, imgs})\index{GroupHomomorphismByImages@\texttt{GroupHomomorphismByImages}}
\label{GroupHomomorphismByImages}
}\hfill{\scriptsize (function)}}\\


 returns the homomorphism from the (pcp-) group \mbox{\texttt{\mdseries\slshape G}} to the pcp-group \mbox{\texttt{\mdseries\slshape H}} mapping the generators of \mbox{\texttt{\mdseries\slshape G}} in the list \mbox{\texttt{\mdseries\slshape gens}} to the corresponding images in the list \mbox{\texttt{\mdseries\slshape imgs}} of elements of \mbox{\texttt{\mdseries\slshape H}}. }

 

\subsection{\textcolor{Chapter }{Kernel}}
\logpage{[ 5, 6, 2 ]}\nobreak
\hyperdef{L}{X7DCD99628504B810}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Kernel({\mdseries\slshape hom})\index{Kernel@\texttt{Kernel}}
\label{Kernel}
}\hfill{\scriptsize (function)}}\\


 returns the kernel of the homomorphism \mbox{\texttt{\mdseries\slshape hom}} from a pcp-group to a pcp-group. }

 

\subsection{\textcolor{Chapter }{Image}}
\logpage{[ 5, 6, 3 ]}\nobreak
\hyperdef{L}{X87F4D35A826599C6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Image({\mdseries\slshape hom})\index{Image@\texttt{Image}}
\label{Image}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Image({\mdseries\slshape hom, U})\index{Image@\texttt{Image}}
\label{Image}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Image({\mdseries\slshape hom, g})\index{Image@\texttt{Image}}
\label{Image}
}\hfill{\scriptsize (function)}}\\


 returns the image of the whole group, of \mbox{\texttt{\mdseries\slshape U}} and of \mbox{\texttt{\mdseries\slshape g}}, respectively, under the homomorphism \mbox{\texttt{\mdseries\slshape hom}}. }

 

\subsection{\textcolor{Chapter }{PreImage}}
\logpage{[ 5, 6, 4 ]}\nobreak
\hyperdef{L}{X836FAEAC78B55BF4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreImage({\mdseries\slshape hom, U})\index{PreImage@\texttt{PreImage}}
\label{PreImage}
}\hfill{\scriptsize (function)}}\\


 returns the complete preimage of the subgroup \mbox{\texttt{\mdseries\slshape U}} under the homomorphism \mbox{\texttt{\mdseries\slshape hom}}. If the domain of \mbox{\texttt{\mdseries\slshape hom}} is not a pcp-group, then this function only works properly if \mbox{\texttt{\mdseries\slshape hom}} is injective. }

 

\subsection{\textcolor{Chapter }{PreImagesRepresentative}}
\logpage{[ 5, 6, 5 ]}\nobreak
\hyperdef{L}{X7AE24A1586B7DE79}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreImagesRepresentative({\mdseries\slshape hom, g})\index{PreImagesRepresentative@\texttt{PreImagesRepresentative}}
\label{PreImagesRepresentative}
}\hfill{\scriptsize (method)}}\\


 returns a preimage of the element \mbox{\texttt{\mdseries\slshape g}} under the homomorphism \mbox{\texttt{\mdseries\slshape hom}}. }

 

\subsection{\textcolor{Chapter }{IsInjective}}
\logpage{[ 5, 6, 6 ]}\nobreak
\hyperdef{L}{X7F065FD7822C0A12}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsInjective({\mdseries\slshape hom})\index{IsInjective@\texttt{IsInjective}}
\label{IsInjective}
}\hfill{\scriptsize (method)}}\\


 checks if the homomorphism \mbox{\texttt{\mdseries\slshape hom}} is injective. }

 }

  
\section{\textcolor{Chapter }{Changing the defining pc-presentation}}\label{Changing the defining pc-presentation}
\logpage{[ 5, 7, 0 ]}
\hyperdef{L}{X7C873F807D4F3A3C}{}
{
  

\subsection{\textcolor{Chapter }{RefinedPcpGroup}}
\logpage{[ 5, 7, 1 ]}\nobreak
\hyperdef{L}{X80E9B60E853B2E05}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RefinedPcpGroup({\mdseries\slshape G})\index{RefinedPcpGroup@\texttt{RefinedPcpGroup}}
\label{RefinedPcpGroup}
}\hfill{\scriptsize (function)}}\\


 returns a new pcp-group isomorphic to \mbox{\texttt{\mdseries\slshape G}} whose defining polycyclic presentation is refined; that is, the corresponding
polycyclic series has prime or infinite factors only. If $H$ is the new group, then $H!.bijection$ is the isomorphism $G \to H$. }

 

\subsection{\textcolor{Chapter }{PcpGroupBySeries}}
\logpage{[ 5, 7, 2 ]}\nobreak
\hyperdef{L}{X7F88F5548329E279}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PcpGroupBySeries({\mdseries\slshape ser[, flag]})\index{PcpGroupBySeries@\texttt{PcpGroupBySeries}}
\label{PcpGroupBySeries}
}\hfill{\scriptsize (function)}}\\


 returns a new pcp-group isomorphic to the first subgroup $G$ of the given series \mbox{\texttt{\mdseries\slshape ser}} such that its defining pcp refines the given series. The series must be
subnormal and $H!.bijection$ is the isomorphism $G \to H$. If the parameter \mbox{\texttt{\mdseries\slshape flag}} is present and equals the string ``snf'', the series must have abelian factors. The pcp of the group returned
corresponds to a decomposition of each abelian factor into a direct product of
cyclic groups. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := DihedralPcpGroup(0);|
  Pcp-group with orders [ 2, 0 ]
  !gapprompt@gap>| !gapinput@ U := Subgroup( G, [Pcp(G)[2]^1440]);|
  Pcp-group with orders [ 0 ]
  !gapprompt@gap>| !gapinput@ F := G/U;|
  Pcp-group with orders [ 2, 1440 ]
  !gapprompt@gap>| !gapinput@RefinedPcpGroup(F);|
  Pcp-group with orders [ 2, 2, 2, 2, 2, 2, 3, 3, 5 ]
  
  !gapprompt@gap>| !gapinput@ser := [G, U, TrivialSubgroup(G)];|
  [ Pcp-group with orders [ 2, 0 ],
    Pcp-group with orders [ 0 ],
    Pcp-group with orders [  ] ]
  !gapprompt@gap>| !gapinput@ PcpGroupBySeries(ser);|
  Pcp-group with orders [ 2, 1440, 0 ]
\end{Verbatim}
 }

 }

  
\section{\textcolor{Chapter }{Printing a pc-presentation}}\label{Printing a pc-presentation}
\logpage{[ 5, 8, 0 ]}
\hyperdef{L}{X85E681027AF19B1E}{}
{
  By default, a pcp-group is printed using its relative orders only. The
following methods can be used to view the pcp presentation of the group. 

\subsection{\textcolor{Chapter }{PrintPcpPresentation}}
\logpage{[ 5, 8, 1 ]}\nobreak
\hyperdef{L}{X863EE3547C3629C6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PrintPcpPresentation({\mdseries\slshape G[, flag]})\index{PrintPcpPresentation@\texttt{PrintPcpPresentation}}
\label{PrintPcpPresentation}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PrintPcpPresentation({\mdseries\slshape pcp[, flag]})\index{PrintPcpPresentation@\texttt{PrintPcpPresentation}}
\label{PrintPcpPresentation}
}\hfill{\scriptsize (function)}}\\


 prints the pcp presentation defined by the igs of \mbox{\texttt{\mdseries\slshape G}} or the pcp \mbox{\texttt{\mdseries\slshape pcp}}. By default, the trivial conjugator relations are omitted from this
presentation to shorten notation. Also, the relations obtained from
conjugating with inverse generators are included only if the conjugating
generator has infinite order. If this generator has finite order, then the
conjugation relation is a consequence of the remaining relations. If the
parameter \mbox{\texttt{\mdseries\slshape flag}} is present and equals the string ``all'', all conjugate relations are printed, including the trivial conjugate
relations as well as those involving conjugation with inverses. }

 }

  
\section{\textcolor{Chapter }{Converting to and from a presentation}}\label{Converting to and from a presentation}
\logpage{[ 5, 9, 0 ]}
\hyperdef{L}{X826ACBBB7A977206}{}
{
  

\subsection{\textcolor{Chapter }{IsomorphismPcpGroup}}
\logpage{[ 5, 9, 1 ]}\nobreak
\hyperdef{L}{X8771540F7A235763}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsomorphismPcpGroup({\mdseries\slshape G})\index{IsomorphismPcpGroup@\texttt{IsomorphismPcpGroup}}
\label{IsomorphismPcpGroup}
}\hfill{\scriptsize (attribute)}}\\


 returns an isomorphism from \mbox{\texttt{\mdseries\slshape G}} onto a pcp-group \mbox{\texttt{\mdseries\slshape H}}. There are various methods installed for this operation and some of these
methods are part of the \textsf{Polycyclic} package, while others may be part of other packages. 

 For example, \textsf{Polycyclic} contains methods for this function in the case that \mbox{\texttt{\mdseries\slshape G}} is a finite pc-group or a finite solvable permutation group. 

 Other examples for methods for IsomorphismPcpGroup are the methods for the
case that \mbox{\texttt{\mdseries\slshape G}} is a crystallographic group (see \textsf{Cryst}) or the case that \mbox{\texttt{\mdseries\slshape G}} is an almost crystallographic group (see \textsf{AClib}). A method for the case that \mbox{\texttt{\mdseries\slshape G}} is a rational polycyclic matrix group is included in the \textsf{Polenta} package. }

 

\subsection{\textcolor{Chapter }{IsomorphismPcpGroupFromFpGroupWithPcPres}}
\logpage{[ 5, 9, 2 ]}\nobreak
\hyperdef{L}{X7F5EBF1C831B4BA9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsomorphismPcpGroupFromFpGroupWithPcPres({\mdseries\slshape G})\index{IsomorphismPcpGroupFromFpGroupWithPcPres@\texttt{Isomorphism}\-\texttt{Pcp}\-\texttt{Group}\-\texttt{From}\-\texttt{Fp}\-\texttt{Group}\-\texttt{With}\-\texttt{Pc}\-\texttt{Pres}}
\label{IsomorphismPcpGroupFromFpGroupWithPcPres}
}\hfill{\scriptsize (function)}}\\


 This function can convert a finitely presented group with a polycyclic
presentation into a pcp group. }

 

\subsection{\textcolor{Chapter }{IsomorphismPcGroup}}
\logpage{[ 5, 9, 3 ]}\nobreak
\hyperdef{L}{X873CEB137BA1CD6E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsomorphismPcGroup({\mdseries\slshape G})\index{IsomorphismPcGroup@\texttt{IsomorphismPcGroup}}
\label{IsomorphismPcGroup}
}\hfill{\scriptsize (method)}}\\


 pc-groups are a representation for finite polycyclic groups. This function can
convert finite pcp-groups to pc-groups. }

 

\subsection{\textcolor{Chapter }{IsomorphismFpGroup}}
\logpage{[ 5, 9, 4 ]}\nobreak
\hyperdef{L}{X7F28268F850F454E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsomorphismFpGroup({\mdseries\slshape G})\index{IsomorphismFpGroup@\texttt{IsomorphismFpGroup}}
\label{IsomorphismFpGroup}
}\hfill{\scriptsize (method)}}\\


 This function can convert pcp-groups to a finitely presented group. }

 }

 }

 
\chapter{\textcolor{Chapter }{Libraries and examples of pcp-groups}}\label{Libraries and examples of pcp-groups}
\logpage{[ 6, 0, 0 ]}
\hyperdef{L}{X78CEF1F27ED8D7BB}{}
{
   
\section{\textcolor{Chapter }{Libraries of various types of polycyclic groups}}\label{Libraries of various types of polycyclic groups}
\logpage{[ 6, 1, 0 ]}
\hyperdef{L}{X84A48FAB83934263}{}
{
  There are the following generic pcp-groups available. 

\subsection{\textcolor{Chapter }{AbelianPcpGroup}}
\logpage{[ 6, 1, 1 ]}\nobreak
\hyperdef{L}{X7AEDE1BA82014B86}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AbelianPcpGroup({\mdseries\slshape n, rels})\index{AbelianPcpGroup@\texttt{AbelianPcpGroup}}
\label{AbelianPcpGroup}
}\hfill{\scriptsize (function)}}\\


 constructs the abelian group on \mbox{\texttt{\mdseries\slshape n}} generators such that generator $i$ has order $rels[i]$. If this order is infinite, then $rels[i]$ should be either unbound or 0. }

 

\subsection{\textcolor{Chapter }{DihedralPcpGroup}}
\logpage{[ 6, 1, 2 ]}\nobreak
\hyperdef{L}{X7ACF57737D0F12DB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DihedralPcpGroup({\mdseries\slshape n})\index{DihedralPcpGroup@\texttt{DihedralPcpGroup}}
\label{DihedralPcpGroup}
}\hfill{\scriptsize (function)}}\\


 constructs the dihedral group of order \mbox{\texttt{\mdseries\slshape n}}. If \mbox{\texttt{\mdseries\slshape n}} is an odd integer, then 'fail' is returned. If \mbox{\texttt{\mdseries\slshape n}} is zero or not an integer, then the infinite dihedral group is returned. }

 

\subsection{\textcolor{Chapter }{UnitriangularPcpGroup}}
\logpage{[ 6, 1, 3 ]}\nobreak
\hyperdef{L}{X864CEDAB7911CC79}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UnitriangularPcpGroup({\mdseries\slshape n, c})\index{UnitriangularPcpGroup@\texttt{UnitriangularPcpGroup}}
\label{UnitriangularPcpGroup}
}\hfill{\scriptsize (function)}}\\


 returns a pcp-group isomorphic to the group of upper triangular in $GL(n, R)$ where $R = {\ensuremath{\mathbb Z}}$ if $c = 0$ and $R = \mathbb{F}_p$ if $c = p$. The natural unitriangular matrix representation of the returned pcp-group $G$ can be obtained as $G!.isomorphism$. }

 

\subsection{\textcolor{Chapter }{SubgroupUnitriangularPcpGroup}}
\logpage{[ 6, 1, 4 ]}\nobreak
\hyperdef{L}{X812E35B17AADBCD5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SubgroupUnitriangularPcpGroup({\mdseries\slshape mats})\index{SubgroupUnitriangularPcpGroup@\texttt{SubgroupUnitriangularPcpGroup}}
\label{SubgroupUnitriangularPcpGroup}
}\hfill{\scriptsize (function)}}\\


 \mbox{\texttt{\mdseries\slshape mats}} should be a list of upper unitriangular $n \times n$ matrices over ${\ensuremath{\mathbb Z}}$ or over $\mathbb{F}_p$. This function returns the subgroup of the corresponding
'UnitriangularPcpGroup' generated by the matrices in \mbox{\texttt{\mdseries\slshape mats}}. }

 

\subsection{\textcolor{Chapter }{InfiniteMetacyclicPcpGroup}}
\logpage{[ 6, 1, 5 ]}\nobreak
\hyperdef{L}{X7A80F7F27FDA6810}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{InfiniteMetacyclicPcpGroup({\mdseries\slshape n, m, r})\index{InfiniteMetacyclicPcpGroup@\texttt{InfiniteMetacyclicPcpGroup}}
\label{InfiniteMetacyclicPcpGroup}
}\hfill{\scriptsize (function)}}\\


 Infinite metacyclic groups are classified in \cite{B-K00}. Every infinite metacyclic group $G$ is isomorphic to a finitely presented group $G(m,n,r)$ with two generators $a$ and $b$ and relations of the form $a^n = b^m = 1$ and $[a,b] = a^{1-r}$, where $m,n,r$ are three non-negative integers with $mn=0$ and $r$ relatively prime to $m$. If $r \equiv -1$ mod $m$ then $n$ is even, and if $r \equiv 1$ mod $m$ then $m=0$. Also $m$ and $n$ must not be $1$. 

 Moreover, $G(m,n,r)\cong G(m',n',s)$ if and only if $m=m'$, $n=n'$, and either $r \equiv s$ or $r \equiv s^{-1}$ mod $m$. 

 This function returns the metacyclic group with parameters \mbox{\texttt{\mdseries\slshape n}}, \mbox{\texttt{\mdseries\slshape m}} and \mbox{\texttt{\mdseries\slshape r}} as a pcp-group with the pc-presentation $\langle x,y | x^n, y^m, y^x = y^r\rangle$. This presentation is easily transformed into the one above via the mapping $x \mapsto b^{-1}, y \mapsto a$. }

 

\subsection{\textcolor{Chapter }{HeisenbergPcpGroup}}
\logpage{[ 6, 1, 6 ]}\nobreak
\hyperdef{L}{X81BEC875827D1CC2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HeisenbergPcpGroup({\mdseries\slshape n})\index{HeisenbergPcpGroup@\texttt{HeisenbergPcpGroup}}
\label{HeisenbergPcpGroup}
}\hfill{\scriptsize (function)}}\\


 returns the Heisenberg group on $2\mbox{\texttt{\mdseries\slshape n}}$ generators as pcp-group. This gives a group of Hirsch length $3\mbox{\texttt{\mdseries\slshape n}}$. }

 

\subsection{\textcolor{Chapter }{MaximalOrderByUnitsPcpGroup}}
\logpage{[ 6, 1, 7 ]}\nobreak
\hyperdef{L}{X87F9B9C9786430D7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MaximalOrderByUnitsPcpGroup({\mdseries\slshape f})\index{MaximalOrderByUnitsPcpGroup@\texttt{MaximalOrderByUnitsPcpGroup}}
\label{MaximalOrderByUnitsPcpGroup}
}\hfill{\scriptsize (function)}}\\


 takes as input a normed, irreducible polynomial over the integers. Thus \mbox{\texttt{\mdseries\slshape f}} defines a field extension \mbox{\texttt{\mdseries\slshape F}} over the rationals. This function returns the split extension of the maximal
order \mbox{\texttt{\mdseries\slshape O}} of \mbox{\texttt{\mdseries\slshape F}} by the unit group \mbox{\texttt{\mdseries\slshape U}} of \mbox{\texttt{\mdseries\slshape O}}, where \mbox{\texttt{\mdseries\slshape U}} acts by right multiplication on \mbox{\texttt{\mdseries\slshape O}}. }

 

\subsection{\textcolor{Chapter }{BurdeGrunewaldPcpGroup}}
\logpage{[ 6, 1, 8 ]}\nobreak
\hyperdef{L}{X852283A77A2C93DD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BurdeGrunewaldPcpGroup({\mdseries\slshape s, t})\index{BurdeGrunewaldPcpGroup@\texttt{BurdeGrunewaldPcpGroup}}
\label{BurdeGrunewaldPcpGroup}
}\hfill{\scriptsize (function)}}\\


 returns a nilpotent group of Hirsch length 11 which has been constructed by
Burde und Grunewald. If \mbox{\texttt{\mdseries\slshape s}} is not 0, then this group has no faithful 12-dimensional linear
representation. }

 }

  
\section{\textcolor{Chapter }{Some assorted example groups}}\label{Some asorted example groups}
\logpage{[ 6, 2, 0 ]}
\hyperdef{L}{X806FBA4A7CB8FB71}{}
{
  The functions in this section provide some more example groups to play with.
They come with no further description and their investigation is left to the
interested user. 

\subsection{\textcolor{Chapter }{ExampleOfMetabelianPcpGroup}}
\logpage{[ 6, 2, 1 ]}\nobreak
\hyperdef{L}{X86293081865CDFC3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ExampleOfMetabelianPcpGroup({\mdseries\slshape a, k})\index{ExampleOfMetabelianPcpGroup@\texttt{ExampleOfMetabelianPcpGroup}}
\label{ExampleOfMetabelianPcpGroup}
}\hfill{\scriptsize (function)}}\\


 returns an example of a metabelian group. The input parameters must be two
positive integers greater than 1. }

 

\subsection{\textcolor{Chapter }{ExamplesOfSomePcpGroups}}
\logpage{[ 6, 2, 2 ]}\nobreak
\hyperdef{L}{X83A74A6E7E232FD6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ExamplesOfSomePcpGroups({\mdseries\slshape n})\index{ExamplesOfSomePcpGroups@\texttt{ExamplesOfSomePcpGroups}}
\label{ExamplesOfSomePcpGroups}
}\hfill{\scriptsize (function)}}\\


 this function takes values \mbox{\texttt{\mdseries\slshape n}} in 1 up to 16 and returns for each input an example of a pcp-group. The groups
in this example list have been used as test groups for the functions in this
package. }

 }

 }

 
\chapter{\textcolor{Chapter }{Higher level methods for pcp-groups}}\label{Higher level methods for pcp-groups}
\logpage{[ 7, 0, 0 ]}
\hyperdef{L}{X85BB6FE078679DAF}{}
{
  This is a description of some higher level functions of the \textsf{Polycyclic} package of GAP 4. Throughout this chapter we let \mbox{\texttt{\mdseries\slshape G}} be a pc-presented group and we consider algorithms for subgroups \mbox{\texttt{\mdseries\slshape U}} and \mbox{\texttt{\mdseries\slshape V}} of \mbox{\texttt{\mdseries\slshape G}}. For background and a description of the underlying algorithms we refer to \cite{Eic01b}. 

  
\section{\textcolor{Chapter }{Subgroup series in pcp-groups}}\label{Subgroup series in pcp-groups}
\logpage{[ 7, 1, 0 ]}
\hyperdef{L}{X8266A0A2821D98A1}{}
{
  Many algorithm for pcp-groups work by induction using some series through the
group. In this section we provide a number of useful series for pcp-groups. An \emph{efa series} is a normal series with elementary or free abelian factors. See \cite{Eic00} for outlines on the algorithms of a number of the available series. 

\subsection{\textcolor{Chapter }{PcpSeries}}
\logpage{[ 7, 1, 1 ]}\nobreak
\hyperdef{L}{X8037DAD77A19D9B2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PcpSeries({\mdseries\slshape U})\index{PcpSeries@\texttt{PcpSeries}}
\label{PcpSeries}
}\hfill{\scriptsize (function)}}\\


 returns the polycyclic series of \mbox{\texttt{\mdseries\slshape U}} defined by an igs of \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{EfaSeries}}
\logpage{[ 7, 1, 2 ]}\nobreak
\hyperdef{L}{X86C633357ACD342C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{EfaSeries({\mdseries\slshape U})\index{EfaSeries@\texttt{EfaSeries}}
\label{EfaSeries}
}\hfill{\scriptsize (attribute)}}\\


 returns a normal series of \mbox{\texttt{\mdseries\slshape U}} with elementary or free abelian factors. }

 

\subsection{\textcolor{Chapter }{SemiSimpleEfaSeries}}
\logpage{[ 7, 1, 3 ]}\nobreak
\hyperdef{L}{X80ED4F8380DC477E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SemiSimpleEfaSeries({\mdseries\slshape U})\index{SemiSimpleEfaSeries@\texttt{SemiSimpleEfaSeries}}
\label{SemiSimpleEfaSeries}
}\hfill{\scriptsize (attribute)}}\\


 returns an efa series of \mbox{\texttt{\mdseries\slshape U}} such that every factor in the series is semisimple as a module for \mbox{\texttt{\mdseries\slshape U}} over a finite field or over the rationals. }

 

\subsection{\textcolor{Chapter }{DerivedSeriesOfGroup}}
\logpage{[ 7, 1, 4 ]}\nobreak
\hyperdef{L}{X7A879948834BD889}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DerivedSeriesOfGroup({\mdseries\slshape U})\index{DerivedSeriesOfGroup@\texttt{DerivedSeriesOfGroup}}
\label{DerivedSeriesOfGroup}
}\hfill{\scriptsize (method)}}\\


 the derived series of \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{RefinedDerivedSeries}}
\logpage{[ 7, 1, 5 ]}\nobreak
\hyperdef{L}{X866D4C5C79F26611}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RefinedDerivedSeries({\mdseries\slshape U})\index{RefinedDerivedSeries@\texttt{RefinedDerivedSeries}}
\label{RefinedDerivedSeries}
}\hfill{\scriptsize (function)}}\\


 the derived series of \mbox{\texttt{\mdseries\slshape U}} refined to an efa series such that in each abelian factor of the derived
series the free abelian factor is at the top. }

 

\subsection{\textcolor{Chapter }{RefinedDerivedSeriesDown}}
\logpage{[ 7, 1, 6 ]}\nobreak
\hyperdef{L}{X86F7DE927DE3B5CD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RefinedDerivedSeriesDown({\mdseries\slshape U})\index{RefinedDerivedSeriesDown@\texttt{RefinedDerivedSeriesDown}}
\label{RefinedDerivedSeriesDown}
}\hfill{\scriptsize (function)}}\\


 the derived series of \mbox{\texttt{\mdseries\slshape U}} refined to an efa series such that in each abelian factor of the derived
series the free abelian factor is at the bottom. }

 

\subsection{\textcolor{Chapter }{LowerCentralSeriesOfGroup}}
\logpage{[ 7, 1, 7 ]}\nobreak
\hyperdef{L}{X879D55A67DB42676}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LowerCentralSeriesOfGroup({\mdseries\slshape U})\index{LowerCentralSeriesOfGroup@\texttt{LowerCentralSeriesOfGroup}}
\label{LowerCentralSeriesOfGroup}
}\hfill{\scriptsize (method)}}\\


 the lower central series of \mbox{\texttt{\mdseries\slshape U}}. If \mbox{\texttt{\mdseries\slshape U}} does not have a largest nilpotent quotient group, then this function may not
terminate. }

 

\subsection{\textcolor{Chapter }{UpperCentralSeriesOfGroup}}
\logpage{[ 7, 1, 8 ]}\nobreak
\hyperdef{L}{X8428592E8773CD7B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UpperCentralSeriesOfGroup({\mdseries\slshape U})\index{UpperCentralSeriesOfGroup@\texttt{UpperCentralSeriesOfGroup}}
\label{UpperCentralSeriesOfGroup}
}\hfill{\scriptsize (method)}}\\


 the upper central series of \mbox{\texttt{\mdseries\slshape U}}. This function always terminates, but it may terminate at a proper subgroup
of \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{TorsionByPolyEFSeries}}
\logpage{[ 7, 1, 9 ]}\nobreak
\hyperdef{L}{X83CA5DE785AE3F2C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TorsionByPolyEFSeries({\mdseries\slshape U})\index{TorsionByPolyEFSeries@\texttt{TorsionByPolyEFSeries}}
\label{TorsionByPolyEFSeries}
}\hfill{\scriptsize (function)}}\\


 returns an efa series of \mbox{\texttt{\mdseries\slshape U}} such that all torsion-free factors are at the top and all finite factors are
at the bottom. Such a series might not exist for \mbox{\texttt{\mdseries\slshape U}} and in this case the function returns fail. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := ExamplesOfSomePcpGroups(5);|
  Pcp-group with orders [ 2, 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@Igs(G);|
  [ g1, g2, g3, g4 ]
  
  !gapprompt@gap>| !gapinput@PcpSeries(G);|
  [ Pcp-group with orders [ 2, 0, 0, 0 ],
    Pcp-group with orders [ 0, 0, 0 ],
    Pcp-group with orders [ 0, 0 ],
    Pcp-group with orders [ 0 ],
    Pcp-group with orders [  ] ]
  
  !gapprompt@gap>| !gapinput@List( PcpSeries(G), Igs );|
  [ [ g1, g2, g3, g4 ], [ g2, g3, g4 ], [ g3, g4 ], [ g4 ], [  ] ]
\end{Verbatim}
 }

 Algorithms for pcp-groups often use an efa series of $G$ and work down over the factors of this series. Usually, pcp's of the factors
are more useful than the actual factors. Hence we provide the following. 

\subsection{\textcolor{Chapter }{PcpsBySeries}}
\logpage{[ 7, 1, 10 ]}\nobreak
\hyperdef{L}{X7E39431286969377}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PcpsBySeries({\mdseries\slshape ser[, flag]})\index{PcpsBySeries@\texttt{PcpsBySeries}}
\label{PcpsBySeries}
}\hfill{\scriptsize (function)}}\\


 returns a list of pcp's corresponding to the factors of the series. If the
parameter \mbox{\texttt{\mdseries\slshape flag}} is present and equals the string ``snf'', then each pcp corresponds to a decomposition of the abelian groups into
direct factors. }

 

\subsection{\textcolor{Chapter }{PcpsOfEfaSeries}}
\logpage{[ 7, 1, 11 ]}\nobreak
\hyperdef{L}{X79789A1C82139854}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PcpsOfEfaSeries({\mdseries\slshape U})\index{PcpsOfEfaSeries@\texttt{PcpsOfEfaSeries}}
\label{PcpsOfEfaSeries}
}\hfill{\scriptsize (attribute)}}\\


 returns a list of pcps corresponding to an efa series of \mbox{\texttt{\mdseries\slshape U}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := ExamplesOfSomePcpGroups(5);|
  Pcp-group with orders [ 2, 0, 0, 0 ]
  
  !gapprompt@gap>| !gapinput@PcpsBySeries( DerivedSeriesOfGroup(G));|
  [ Pcp [ g1, g2, g3, g4 ] with orders [ 2, 2, 2, 2 ],
    Pcp [ g2^-2, g3^-2, g4^2 ] with orders [ 0, 0, 4 ],
    Pcp [ g4^8 ] with orders [ 0 ] ]
  !gapprompt@gap>| !gapinput@PcpsBySeries( RefinedDerivedSeries(G));|
  [ Pcp [ g1, g2, g3 ] with orders [ 2, 2, 2 ],
    Pcp [ g4 ] with orders [ 2 ],
    Pcp [ g2^2, g3^2 ] with orders [ 0, 0 ],
    Pcp [ g4^2 ] with orders [ 2 ],
    Pcp [ g4^4 ] with orders [ 2 ],
    Pcp [ g4^8 ] with orders [ 0 ] ]
  
  !gapprompt@gap>| !gapinput@PcpsBySeries( DerivedSeriesOfGroup(G), "snf" );|
  [ Pcp [ g2, g3, g1 ] with orders [ 2, 2, 4 ],
    Pcp [ g4^2, g3^-2, g2^2*g4^2 ] with orders [ 4, 0, 0 ],
    Pcp [ g4^8 ] with orders [ 0 ] ]
  !gapprompt@gap>| !gapinput@G.1^4 in DerivedSubgroup( G );|
  true
  !gapprompt@gap>| !gapinput@G.1^2 = G.4;|
  true
  
  !gapprompt@gap>| !gapinput@ PcpsOfEfaSeries( G );|
  [ Pcp [ g1 ] with orders [ 2 ],
    Pcp [ g2 ] with orders [ 0 ],
    Pcp [ g3 ] with orders [ 0 ],
    Pcp [ g4 ] with orders [ 0 ] ]
\end{Verbatim}
 }

 }

  
\section{\textcolor{Chapter }{Orbit stabilizer methods for pcp-groups}}\label{Orbit stabilizer methods for pcp-groups}
\logpage{[ 7, 2, 0 ]}
\hyperdef{L}{X7CE2DA437FD2B383}{}
{
  Let \mbox{\texttt{\mdseries\slshape U}} be a pcp-group which acts on a set $\Omega$. One of the fundamental problems in algorithmic group theory is the
determination of orbits and stabilizers of points in $\Omega$ under the action of \mbox{\texttt{\mdseries\slshape U}}. We distinguish two cases: the case that all considered orbits are finite and
the case that there are infinite orbits. In the latter case, an orbit cannot
be listed and a description of the orbit and its corresponding stabilizer is
much harder to obtain. 

 If the considered orbits are finite, then the following two functions can be
applied to compute the considered orbits and their corresponding stabilizers. 

\subsection{\textcolor{Chapter }{PcpOrbitStabilizer}}
\logpage{[ 7, 2, 1 ]}\nobreak
\hyperdef{L}{X83E17DB483B33AB5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PcpOrbitStabilizer({\mdseries\slshape point, gens, acts, oper})\index{PcpOrbitStabilizer@\texttt{PcpOrbitStabilizer}}
\label{PcpOrbitStabilizer}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PcpOrbitsStabilizers({\mdseries\slshape points, gens, acts, oper})\index{PcpOrbitsStabilizers@\texttt{PcpOrbitsStabilizers}}
\label{PcpOrbitsStabilizers}
}\hfill{\scriptsize (function)}}\\


 The input \mbox{\texttt{\mdseries\slshape gens}} can be an igs or a pcp of a pcp-group \mbox{\texttt{\mdseries\slshape U}}. The elements in the list \mbox{\texttt{\mdseries\slshape gens}} act as the elements in the list \mbox{\texttt{\mdseries\slshape acts}} via the function \mbox{\texttt{\mdseries\slshape oper}} on the given points; that is, \mbox{\texttt{\mdseries\slshape oper( point, acts[i] )}} applies the $i$th generator to a given point. Thus the group defined by \mbox{\texttt{\mdseries\slshape acts}} must be a homomorphic image of the group defined by \mbox{\texttt{\mdseries\slshape gens}}. The first function returns a record containing the orbit as component
'orbit' and and igs for the stabilizer as component 'stab'. The second
function returns a list of records, each record contains 'repr' and 'stab'.
Both of these functions run forever on infinite orbits. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := DihedralPcpGroup( 0 );|
  Pcp-group with orders [ 2, 0 ]
  !gapprompt@gap>| !gapinput@mats := [ [[-1,0],[0,1]], [[1,1],[0,1]] ];;|
  !gapprompt@gap>| !gapinput@pcp := Pcp(G);|
  Pcp [ g1, g2 ] with orders [ 2, 0 ]
  !gapprompt@gap>| !gapinput@PcpOrbitStabilizer( [0,1], pcp, mats, OnRight );|
  rec( orbit := [ [ 0, 1 ] ],
       stab := [ g1, g2 ],
       word := [ [ [ 1, 1 ] ], [ [ 2, 1 ] ] ] )
\end{Verbatim}
 If the considered orbits are infinite, then it may not always be possible to
determine a description of the orbits and their stabilizers. However, as shown
in \cite{EOs01} and \cite{Eic02}, it is possible to determine stabilizers and check if two elements are
contained in the same orbit if the given action of the polycyclic group is a
unimodular linear action on a vector space. The following functions are
available for this case. }

 

\subsection{\textcolor{Chapter }{StabilizerIntegralAction}}
\logpage{[ 7, 2, 2 ]}\nobreak
\hyperdef{L}{X80694BA480F69A0E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{StabilizerIntegralAction({\mdseries\slshape U, mats, v})\index{StabilizerIntegralAction@\texttt{StabilizerIntegralAction}}
\label{StabilizerIntegralAction}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OrbitIntegralAction({\mdseries\slshape U, mats, v, w})\index{OrbitIntegralAction@\texttt{OrbitIntegralAction}}
\label{OrbitIntegralAction}
}\hfill{\scriptsize (function)}}\\


 The first function computes the stabilizer in \mbox{\texttt{\mdseries\slshape U}} of the vector \mbox{\texttt{\mdseries\slshape v}} where the pcp group \mbox{\texttt{\mdseries\slshape U}} acts via \mbox{\texttt{\mdseries\slshape mats}} on an integral space and \mbox{\texttt{\mdseries\slshape v}} and \mbox{\texttt{\mdseries\slshape w}} are elements in this integral space. The second function checks whether \mbox{\texttt{\mdseries\slshape v}} and \mbox{\texttt{\mdseries\slshape w}} are in the same orbit and the function returns either \mbox{\texttt{\mdseries\slshape false}} or a record containing an element in \mbox{\texttt{\mdseries\slshape U}} mapping \mbox{\texttt{\mdseries\slshape v}} to \mbox{\texttt{\mdseries\slshape w}} and the stabilizer of \mbox{\texttt{\mdseries\slshape v}}. }

 

\subsection{\textcolor{Chapter }{NormalizerIntegralAction}}
\logpage{[ 7, 2, 3 ]}\nobreak
\hyperdef{L}{X875BE4077B32A411}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NormalizerIntegralAction({\mdseries\slshape U, mats, B})\index{NormalizerIntegralAction@\texttt{NormalizerIntegralAction}}
\label{NormalizerIntegralAction}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConjugacyIntegralAction({\mdseries\slshape U, mats, B, C})\index{ConjugacyIntegralAction@\texttt{ConjugacyIntegralAction}}
\label{ConjugacyIntegralAction}
}\hfill{\scriptsize (function)}}\\


 The first function computes the normalizer in \mbox{\texttt{\mdseries\slshape U}} of the lattice with the basis \mbox{\texttt{\mdseries\slshape B}}, where the pcp group \mbox{\texttt{\mdseries\slshape U}} acts via \mbox{\texttt{\mdseries\slshape mats}} on an integral space and \mbox{\texttt{\mdseries\slshape B}} is a subspace of this integral space. The second functions checks whether the
two lattices with the bases \mbox{\texttt{\mdseries\slshape B}} and \mbox{\texttt{\mdseries\slshape C}} are contained in the same orbit under \mbox{\texttt{\mdseries\slshape U}}. The function returns either \mbox{\texttt{\mdseries\slshape false}} or a record with an element in \mbox{\texttt{\mdseries\slshape U}} mapping \mbox{\texttt{\mdseries\slshape B}} to \mbox{\texttt{\mdseries\slshape C}} and the stabilizer of \mbox{\texttt{\mdseries\slshape B}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  # get a pcp group and a free abelian normal subgroup
  !gapprompt@gap>| !gapinput@G := ExamplesOfSomePcpGroups(8);|
  Pcp-group with orders [ 0, 0, 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@efa := EfaSeries(G);|
  [ Pcp-group with orders [ 0, 0, 0, 0, 0 ],
    Pcp-group with orders [ 0, 0, 0, 0 ],
    Pcp-group with orders [ 0, 0, 0 ],
    Pcp-group with orders [  ] ]
  !gapprompt@gap>| !gapinput@N := efa[3];|
  Pcp-group with orders [ 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@IsFreeAbelian(N);|
  true
  
  # create conjugation action on N
  !gapprompt@gap>| !gapinput@mats := LinearActionOnPcp(Igs(G), Pcp(N));|
  [ [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ],
    [ [ 0, 0, 1 ], [ 1, -1, 1 ], [ 0, 1, 0 ] ],
    [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ],
    [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ],
    [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] ]
  
  # take an arbitrary vector and compute its stabilizer
  !gapprompt@gap>| !gapinput@StabilizerIntegralAction(G,mats, [2,3,4]);|
  Pcp-group with orders [ 0, 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@Igs(last);|
  [ g1, g3, g4, g5 ]
  
  # check orbits with some other vectors
  !gapprompt@gap>| !gapinput@OrbitIntegralAction(G,mats, [2,3,4],[3,1,5]);|
  rec( stab := Pcp-group with orders [ 0, 0, 0, 0 ], prei := g2 )
  
  !gapprompt@gap>| !gapinput@OrbitIntegralAction(G,mats, [2,3,4], [4,6,8]);|
  false
  
  # compute the orbit of a subgroup of Z^3 under the action of G
  !gapprompt@gap>| !gapinput@NormalizerIntegralAction(G, mats, [[1,0,0],[0,1,0]]);|
  Pcp-group with orders [ 0, 0, 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@Igs(last);|
  [ g1, g2^2, g3, g4, g5 ]
\end{Verbatim}
 }

 }

  
\section{\textcolor{Chapter }{Centralizers, Normalizers and Intersections}}\label{Centralizers, Normalizers and Intersections}
\logpage{[ 7, 3, 0 ]}
\hyperdef{L}{X80E3B42E792532B3}{}
{
  In this section we list a number of operations for which there are methods
installed to compute the corresponding features in polycyclic groups. 

\subsection{\textcolor{Chapter }{Centralizer}}
\logpage{[ 7, 3, 1 ]}\nobreak
\hyperdef{L}{X7A2BF4527E08803C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Centralizer({\mdseries\slshape U, g})\index{Centralizer@\texttt{Centralizer}}
\label{Centralizer}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsConjugate({\mdseries\slshape U, g, h})\index{IsConjugate@\texttt{IsConjugate}}
\label{IsConjugate}
}\hfill{\scriptsize (method)}}\\


 These functions solve the conjugacy problem for elements in pcp-groups and
they can be used to compute centralizers. The first method returns a subgroup
of the given group \mbox{\texttt{\mdseries\slshape U}}, the second method either returns a conjugating element or false if no such
element exists. 

 The methods are based on the orbit stabilizer algorithms described in \cite{EOs01}. For nilpotent groups, an algorithm to solve the conjugacy problem for
elements is described in \cite{Sims94}. }

 

\subsection{\textcolor{Chapter }{Centralizer}}
\logpage{[ 7, 3, 2 ]}\nobreak
\hyperdef{L}{X7A2BF4527E08803C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Centralizer({\mdseries\slshape U, V})\index{Centralizer@\texttt{Centralizer}}
\label{Centralizer}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Normalizer({\mdseries\slshape U, V})\index{Normalizer@\texttt{Normalizer}}
\label{Normalizer}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsConjugate({\mdseries\slshape U, V, W})\index{IsConjugate@\texttt{IsConjugate}}
\label{IsConjugate}
}\hfill{\scriptsize (method)}}\\


 These three functions solve the conjugacy problem for subgroups and compute
centralizers and normalizers of subgroups. The first two functions return
subgroups of the input group \mbox{\texttt{\mdseries\slshape U}}, the third function returns a conjugating element or false if no such element
exists. 

 The methods are based on the orbit stabilizer algorithms described in \cite{Eic02}. For nilpotent groups, an algorithm to solve the conjugacy problems for
subgroups is described in \cite{Lo98}. }

 

\subsection{\textcolor{Chapter }{Intersection}}
\logpage{[ 7, 3, 3 ]}\nobreak
\hyperdef{L}{X851069107CACF98E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Intersection({\mdseries\slshape U, N})\index{Intersection@\texttt{Intersection}}
\label{Intersection}
}\hfill{\scriptsize (function)}}\\


 A general method to compute intersections of subgroups of a pcp-group is
described in \cite{Eic01b}, but it is not yet implemented here. However, intersections of subgroups $U, N \leq G$ can be computed if $N$ is normalising $U$. See \cite{Sims94} for an outline of the algorithm. }

 }

  
\section{\textcolor{Chapter }{Finite subgroups}}\label{Finite subgroups}
\logpage{[ 7, 4, 0 ]}
\hyperdef{L}{X7CF015E87A2B2388}{}
{
  There are various finite subgroups of interest in polycyclic groups. See \cite{Eic00} for a description of the algorithms underlying the functions in this section. 

\subsection{\textcolor{Chapter }{TorsionSubgroup}}
\logpage{[ 7, 4, 1 ]}\nobreak
\hyperdef{L}{X8036FA507A170DC4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TorsionSubgroup({\mdseries\slshape U})\index{TorsionSubgroup@\texttt{TorsionSubgroup}}
\label{TorsionSubgroup}
}\hfill{\scriptsize (attribute)}}\\


 If the set of elements of finite order forms a subgroup, then we call it the \emph{torsion subgroup}. This function determines the torsion subgroup of \mbox{\texttt{\mdseries\slshape U}}, if it exists, and returns fail otherwise. Note that a torsion subgroup does
always exist if \mbox{\texttt{\mdseries\slshape U}} is nilpotent. }

 

\subsection{\textcolor{Chapter }{NormalTorsionSubgroup}}
\logpage{[ 7, 4, 2 ]}\nobreak
\hyperdef{L}{X8082CD337972DC63}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NormalTorsionSubgroup({\mdseries\slshape U})\index{NormalTorsionSubgroup@\texttt{NormalTorsionSubgroup}}
\label{NormalTorsionSubgroup}
}\hfill{\scriptsize (attribute)}}\\


 Each polycyclic groups has a unique largest finite normal subgroup. This
function computes it for \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{IsTorsionFree}}
\logpage{[ 7, 4, 3 ]}\nobreak
\hyperdef{L}{X86D92DA17DCE22DD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsTorsionFree({\mdseries\slshape U})\index{IsTorsionFree@\texttt{IsTorsionFree}}
\label{IsTorsionFree}
}\hfill{\scriptsize (property)}}\\


 This function checks if \mbox{\texttt{\mdseries\slshape U}} is torsion free. It returns true or false. }

 

\subsection{\textcolor{Chapter }{FiniteSubgroupClasses}}
\logpage{[ 7, 4, 4 ]}\nobreak
\hyperdef{L}{X819058217B4F3DC0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FiniteSubgroupClasses({\mdseries\slshape U})\index{FiniteSubgroupClasses@\texttt{FiniteSubgroupClasses}}
\label{FiniteSubgroupClasses}
}\hfill{\scriptsize (attribute)}}\\


 There exist only finitely many conjugacy classes of finite subgroups in a
polycyclic group \mbox{\texttt{\mdseries\slshape U}} and this function can be used to compute them. The algorithm underlying this
function proceeds by working down a normal series of \mbox{\texttt{\mdseries\slshape U}} with elementary or free abelian factors. The following function can be used to
give the algorithm a specific series. }

 

\subsection{\textcolor{Chapter }{FiniteSubgroupClassesBySeries}}
\logpage{[ 7, 4, 5 ]}\nobreak
\hyperdef{L}{X7E7C32EA81A297B6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FiniteSubgroupClassesBySeries({\mdseries\slshape U, pcps})\index{FiniteSubgroupClassesBySeries@\texttt{FiniteSubgroupClassesBySeries}}
\label{FiniteSubgroupClassesBySeries}
}\hfill{\scriptsize (function)}}\\


 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := ExamplesOfSomePcpGroups(15);|
  Pcp-group with orders [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 0 ]
  !gapprompt@gap>| !gapinput@TorsionSubgroup(G);|
  Pcp-group with orders [ 5, 2 ]
  !gapprompt@gap>| !gapinput@NormalTorsionSubgroup(G);|
  Pcp-group with orders [ 5, 2 ]
  !gapprompt@gap>| !gapinput@IsTorsionFree(G);|
  false
  !gapprompt@gap>| !gapinput@FiniteSubgroupClasses(G);|
  [ Pcp-group with orders [ 5, 2 ]^G,
    Pcp-group with orders [ 2 ]^G,
    Pcp-group with orders [ 5 ]^G,
    Pcp-group with orders [  ]^G ]
  
  !gapprompt@gap>| !gapinput@G := DihedralPcpGroup( 0 );|
  Pcp-group with orders [ 2, 0 ]
  !gapprompt@gap>| !gapinput@TorsionSubgroup(G);|
  fail
  !gapprompt@gap>| !gapinput@NormalTorsionSubgroup(G);|
  Pcp-group with orders [  ]
  !gapprompt@gap>| !gapinput@IsTorsionFree(G);|
  false
  !gapprompt@gap>| !gapinput@FiniteSubgroupClasses(G);|
  [ Pcp-group with orders [ 2 ]^G,
    Pcp-group with orders [ 2 ]^G,
    Pcp-group with orders [  ]^G ]
\end{Verbatim}
 }

 }

  
\section{\textcolor{Chapter }{Subgroups of finite index and maximal subgroups}}\label{Subgroups of finite index and maximal subgroups}
\logpage{[ 7, 5, 0 ]}
\hyperdef{L}{X7D9F737F80F6E396}{}
{
  Here we outline functions to determine various types of subgroups of finite
index in polycyclic groups. Again, see \cite{Eic00} for a description of the algorithms underlying the functions in this section.
Also, we refer to \cite{Lo99} for an alternative approach. 

\subsection{\textcolor{Chapter }{MaximalSubgroupClassesByIndex}}
\logpage{[ 7, 5, 1 ]}\nobreak
\hyperdef{L}{X87D62D497A8715FB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MaximalSubgroupClassesByIndex({\mdseries\slshape U, p})\index{MaximalSubgroupClassesByIndex@\texttt{MaximalSubgroupClassesByIndex}}
\label{MaximalSubgroupClassesByIndex}
}\hfill{\scriptsize (operation)}}\\


 Each maximal subgroup of a polycyclic group \mbox{\texttt{\mdseries\slshape U}} has \mbox{\texttt{\mdseries\slshape p}}-power index for some prime \mbox{\texttt{\mdseries\slshape p}}. This function can be used to determine the conjugacy classes of all maximal
subgroups of \mbox{\texttt{\mdseries\slshape p}}-power index for a given prime \mbox{\texttt{\mdseries\slshape p}}. }

 

\subsection{\textcolor{Chapter }{LowIndexSubgroupClasses}}
\logpage{[ 7, 5, 2 ]}\nobreak
\hyperdef{L}{X7800133F81BC7674}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LowIndexSubgroupClasses({\mdseries\slshape U, n})\index{LowIndexSubgroupClasses@\texttt{LowIndexSubgroupClasses}}
\label{LowIndexSubgroupClasses}
}\hfill{\scriptsize (operation)}}\\


 There are only finitely many subgroups of a given index in a polycyclic group \mbox{\texttt{\mdseries\slshape U}}. This function computes conjugacy classes of all subgroups of index \mbox{\texttt{\mdseries\slshape n}} in \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{LowIndexNormalSubgroups}}
\logpage{[ 7, 5, 3 ]}\nobreak
\hyperdef{L}{X7F7067C77F2DC32C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LowIndexNormalSubgroups({\mdseries\slshape U, n})\index{LowIndexNormalSubgroups@\texttt{LowIndexNormalSubgroups}}
\label{LowIndexNormalSubgroups}
}\hfill{\scriptsize (operation)}}\\


 This function computes the normal subgroups of index \mbox{\texttt{\mdseries\slshape n}} in \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{NilpotentByAbelianNormalSubgroup}}
\logpage{[ 7, 5, 4 ]}\nobreak
\hyperdef{L}{X85A5BC447D83175F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NilpotentByAbelianNormalSubgroup({\mdseries\slshape U})\index{NilpotentByAbelianNormalSubgroup@\texttt{NilpotentByAbelianNormalSubgroup}}
\label{NilpotentByAbelianNormalSubgroup}
}\hfill{\scriptsize (function)}}\\


 This function returns a normal subgroup \mbox{\texttt{\mdseries\slshape N}} of finite index in \mbox{\texttt{\mdseries\slshape U}} such that \mbox{\texttt{\mdseries\slshape N}} is nilpotent-by-abelian. Such a subgroup exists in every polycyclic group and
this function computes such a subgroup using LowIndexNormal. However, we note
that this function is not very efficient and the function
NilpotentByAbelianByFiniteSeries may well be more efficient on this task. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := ExamplesOfSomePcpGroups(2);|
  Pcp-group with orders [ 0, 0, 0, 0, 0, 0 ]
  
  !gapprompt@gap>| !gapinput@MaximalSubgroupClassesByIndex( G, 61 );;|
  !gapprompt@gap>| !gapinput@max := List( last, Representative );;|
  !gapprompt@gap>| !gapinput@List( max, x -> Index( G, x ) );|
  [ 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
    61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
    61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
    61, 61, 61, 61, 61, 61, 226981 ]
  
  !gapprompt@gap>| !gapinput@LowIndexSubgroupClasses( G, 61 );;|
  !gapprompt@gap>| !gapinput@low := List( last, Representative );;|
  !gapprompt@gap>| !gapinput@List( low, x -> Index( G, x ) );|
  [ 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
    61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
    61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
    61, 61, 61, 61, 61, 61 ]
\end{Verbatim}
 }

 }

  
\section{\textcolor{Chapter }{Further attributes for pcp-groups based on the Fitting subgroup}}\label{Further attributes for pcp-groups based on the Fitting subgroup}
\logpage{[ 7, 6, 0 ]}
\hyperdef{L}{X785E0E877AB1D549}{}
{
  In this section we provide a variety of other attributes for pcp-groups. Most
of the methods below are based or related to the Fitting subgroup of the given
group. We refer to \cite{Eic01} for a description of the underlying methods. 

\subsection{\textcolor{Chapter }{FittingSubgroup}}
\logpage{[ 7, 6, 1 ]}\nobreak
\hyperdef{L}{X780552B57C30DD8F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FittingSubgroup({\mdseries\slshape U})\index{FittingSubgroup@\texttt{FittingSubgroup}}
\label{FittingSubgroup}
}\hfill{\scriptsize (attribute)}}\\


 returns the Fitting subgroup of \mbox{\texttt{\mdseries\slshape U}}; that is, the largest nilpotent normal subgroup of \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{IsNilpotentByFinite}}
\logpage{[ 7, 6, 2 ]}\nobreak
\hyperdef{L}{X86BD63DC844731DF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsNilpotentByFinite({\mdseries\slshape U})\index{IsNilpotentByFinite@\texttt{IsNilpotentByFinite}}
\label{IsNilpotentByFinite}
}\hfill{\scriptsize (property)}}\\


 checks whether the Fitting subgroup of \mbox{\texttt{\mdseries\slshape U}} has finite index. }

 

\subsection{\textcolor{Chapter }{Centre}}
\logpage{[ 7, 6, 3 ]}\nobreak
\hyperdef{L}{X847ABE6F781C7FE8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Centre({\mdseries\slshape U})\index{Centre@\texttt{Centre}}
\label{Centre}
}\hfill{\scriptsize (method)}}\\


 returns the centre of \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{FCCentre}}
\logpage{[ 7, 6, 4 ]}\nobreak
\hyperdef{L}{X861C36368435EB09}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FCCentre({\mdseries\slshape U})\index{FCCentre@\texttt{FCCentre}}
\label{FCCentre}
}\hfill{\scriptsize (method)}}\\


 returns the FC-centre of \mbox{\texttt{\mdseries\slshape U}}; that is, the subgroup containing all elements having a finite conjugacy
class in \mbox{\texttt{\mdseries\slshape U}}. }

 

\subsection{\textcolor{Chapter }{PolyZNormalSubgroup}}
\logpage{[ 7, 6, 5 ]}\nobreak
\hyperdef{L}{X7E75E2BC806746AC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolyZNormalSubgroup({\mdseries\slshape U})\index{PolyZNormalSubgroup@\texttt{PolyZNormalSubgroup}}
\label{PolyZNormalSubgroup}
}\hfill{\scriptsize (function)}}\\


 returns a normal subgroup \mbox{\texttt{\mdseries\slshape N}} of finite index in \mbox{\texttt{\mdseries\slshape U}}, such that \mbox{\texttt{\mdseries\slshape N}} has a polycyclic series with infinite factors only. }

 

\subsection{\textcolor{Chapter }{NilpotentByAbelianByFiniteSeries}}
\logpage{[ 7, 6, 6 ]}\nobreak
\hyperdef{L}{X86800BF783E30D4A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NilpotentByAbelianByFiniteSeries({\mdseries\slshape U})\index{NilpotentByAbelianByFiniteSeries@\texttt{NilpotentByAbelianByFiniteSeries}}
\label{NilpotentByAbelianByFiniteSeries}
}\hfill{\scriptsize (function)}}\\


 returns a normal series $1 \leq F \leq A \leq U$ such that $F$ is nilpotent, $A/F$ is abelian and $U/A$ is finite. This series is computed using the Fitting subgroup and the centre
of the Fitting factor. }

 }

  
\section{\textcolor{Chapter }{Functions for nilpotent groups}}\label{Functions for nilpotent groups}
\logpage{[ 7, 7, 0 ]}
\hyperdef{L}{X878DBDC77CCA4F7E}{}
{
  There are (very few) functions which are available for nilpotent groups only.
First, there are the different central series. These are available for all
groups, but for nilpotent groups they terminate and provide series though the
full group. Secondly, the determination of a minimal generating set is
available for nilpotent groups only. 

\subsection{\textcolor{Chapter }{MinimalGeneratingSet}}
\logpage{[ 7, 7, 1 ]}\nobreak
\hyperdef{L}{X81D15723804771E2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MinimalGeneratingSet({\mdseries\slshape U})\index{MinimalGeneratingSet@\texttt{MinimalGeneratingSet}}
\label{MinimalGeneratingSet}
}\hfill{\scriptsize (method)}}\\


 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := ExamplesOfSomePcpGroups(14);|
  Pcp-group with orders [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 0, 5, 5, 4, 0, 6,
    5, 5, 4, 0, 10, 6 ]
  !gapprompt@gap>| !gapinput@IsNilpotent(G);|
  true
  
  !gapprompt@gap>| !gapinput@PcpsBySeries( LowerCentralSeriesOfGroup(G));|
  [ Pcp [ g1, g2 ] with orders [ 0, 0 ],
    Pcp [ g3 ] with orders [ 0 ],
    Pcp [ g4 ] with orders [ 0 ],
    Pcp [ g5 ] with orders [ 0 ],
    Pcp [ g6, g7 ] with orders [ 0, 0 ],
    Pcp [ g8 ] with orders [ 0 ],
    Pcp [ g9, g10 ] with orders [ 0, 0 ],
    Pcp [ g11, g12, g13 ] with orders [ 5, 4, 0 ],
    Pcp [ g14, g15, g16, g17, g18 ] with orders [ 5, 5, 4, 0, 6 ],
    Pcp [ g19, g20, g21, g22, g23, g24 ] with orders [ 5, 5, 4, 0, 10, 6 ] ]
  
  !gapprompt@gap>| !gapinput@PcpsBySeries( UpperCentralSeriesOfGroup(G));|
  [ Pcp [ g1, g2 ] with orders [ 0, 0 ],
    Pcp [ g3 ] with orders [ 0 ],
    Pcp [ g4 ] with orders [ 0 ],
    Pcp [ g5 ] with orders [ 0 ],
    Pcp [ g6, g7 ] with orders [ 0, 0 ],
    Pcp [ g8 ] with orders [ 0 ],
    Pcp [ g9, g10 ] with orders [ 0, 0 ],
    Pcp [ g11, g12, g13 ] with orders [ 5, 4, 0 ],
    Pcp [ g14, g15, g16, g17, g18 ] with orders [ 5, 5, 4, 0, 6 ],
    Pcp [ g19, g20, g21, g22, g23, g24 ] with orders [ 5, 5, 4, 0, 10, 6 ] ]
  
  !gapprompt@gap>| !gapinput@MinimalGeneratingSet(G);|
  [ g1, g2 ]
\end{Verbatim}
 }

 }

  
\section{\textcolor{Chapter }{Random methods for pcp-groups}}\label{Random methods for pcp-groups}
\logpage{[ 7, 8, 0 ]}
\hyperdef{L}{X8640F9D47A1F7434}{}
{
     Below we introduce a function which computes orbit and stabilizer using a
random method. This function tries to approximate the orbit and the
stabilizer, but the returned orbit or stabilizer may be incomplete. This
function is used in the random methods to compute normalizers and
centralizers. Note that deterministic methods for these purposes are also
available. 

     

\subsection{\textcolor{Chapter }{RandomCentralizerPcpGroup}}
\logpage{[ 7, 8, 1 ]}\nobreak
\hyperdef{L}{X7E5FE3E879D4E6BF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RandomCentralizerPcpGroup({\mdseries\slshape U, g})\index{RandomCentralizerPcpGroup@\texttt{RandomCentralizerPcpGroup}}
\label{RandomCentralizerPcpGroup}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RandomCentralizerPcpGroup({\mdseries\slshape U, V})\index{RandomCentralizerPcpGroup@\texttt{RandomCentralizerPcpGroup}}
\label{RandomCentralizerPcpGroup}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RandomNormalizerPcpGroup({\mdseries\slshape U, V})\index{RandomNormalizerPcpGroup@\texttt{RandomNormalizerPcpGroup}}
\label{RandomNormalizerPcpGroup}
}\hfill{\scriptsize (function)}}\\


 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := DihedralPcpGroup(0);|
  Pcp-group with orders [ 2, 0 ]
  !gapprompt@gap>| !gapinput@mats := [[[-1, 0],[0,1]], [[1,1],[0,1]]];|
  [ [ [ -1, 0 ], [ 0, 1 ] ], [ [ 1, 1 ], [ 0, 1 ] ] ]
  !gapprompt@gap>| !gapinput@pcp := Pcp(G);|
  Pcp [ g1, g2 ] with orders [ 2, 0 ]
  
  !gapprompt@gap>| !gapinput@RandomPcpOrbitStabilizer( [1,0], pcp, mats, OnRight ).stab;|
  #I  Orbit longer than limit: exiting.
  [  ]
  
  !gapprompt@gap>| !gapinput@g := Igs(G)[1];|
  g1
  !gapprompt@gap>| !gapinput@RandomCentralizerPcpGroup( G, g );|
  #I  Stabilizer not increasing: exiting.
  Pcp-group with orders [ 2 ]
  !gapprompt@gap>| !gapinput@Igs(last);|
  [ g1 ]
\end{Verbatim}
 }

 }

  
\section{\textcolor{Chapter }{Non-abelian tensor product and Schur extensions}}\label{Non-abelian tensor product and Schur extensions}
\logpage{[ 7, 9, 0 ]}
\hyperdef{L}{X824142B784453DB9}{}
{
  

\subsection{\textcolor{Chapter }{SchurExtension}}
\logpage{[ 7, 9, 1 ]}\nobreak
\hyperdef{L}{X79EF28D9845878C9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SchurExtension({\mdseries\slshape G})\index{SchurExtension@\texttt{SchurExtension}}
\label{SchurExtension}
}\hfill{\scriptsize (attribute)}}\\


 Let \mbox{\texttt{\mdseries\slshape G}} be a polycyclic group with a polycyclic generating sequence consisting of $n$ elements. This function computes the largest central extension \mbox{\texttt{\mdseries\slshape H}} of \mbox{\texttt{\mdseries\slshape G}} such that \mbox{\texttt{\mdseries\slshape H}} is generated by $n$ elements. If $F/R$ is the underlying polycyclic presentation for \mbox{\texttt{\mdseries\slshape G}}, then \mbox{\texttt{\mdseries\slshape H}} is isomorphic to $F/[R,F]$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := DihedralPcpGroup( 0 );|
  Pcp-group with orders [ 2, 0 ]
  !gapprompt@gap>| !gapinput@Centre( G );|
  Pcp-group with orders [  ]
  !gapprompt@gap>| !gapinput@H := SchurExtension( G );|
  Pcp-group with orders [ 2, 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@Centre( H );|
  Pcp-group with orders [ 0, 0 ]
  !gapprompt@gap>| !gapinput@H/Centre(H);|
  Pcp-group with orders [ 2, 0 ]
  !gapprompt@gap>| !gapinput@Subgroup( H, [H.1,H.2] ) = H;|
  true
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{SchurExtensionEpimorphism}}
\logpage{[ 7, 9, 2 ]}\nobreak
\hyperdef{L}{X84B60EC978A9A05E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SchurExtensionEpimorphism({\mdseries\slshape G})\index{SchurExtensionEpimorphism@\texttt{SchurExtensionEpimorphism}}
\label{SchurExtensionEpimorphism}
}\hfill{\scriptsize (attribute)}}\\


 returns the projection from the Schur extension $G^{*}$ of \mbox{\texttt{\mdseries\slshape G}} onto \mbox{\texttt{\mdseries\slshape G}}. See the function \texttt{SchurExtension}. The kernel of this epimorphism is the direct product of the Schur
multiplicator of \mbox{\texttt{\mdseries\slshape G}} and a direct product of $n$ copies of ${\ensuremath{\mathbb Z}}$ where $n$ is the number of generators in the polycyclic presentation for \mbox{\texttt{\mdseries\slshape G}}. The Schur multiplicator is the intersection of the kernel and the derived
group of the source. See also the function \texttt{SchurCover}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@gl23 := Range( IsomorphismPcpGroup( GL(2,3) ) );|
  Pcp-group with orders [ 2, 3, 2, 2, 2 ]
  !gapprompt@gap>| !gapinput@SchurExtensionEpimorphism( gl23 );|
  [ g1, g2, g3, g4, g5, g6, g7, g8, g9, g10 ] -> [ g1, g2, g3, g4, g5,
  id, id, id, id, id ]
  !gapprompt@gap>| !gapinput@Kernel( last );|
  Pcp-group with orders [ 0, 0, 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@SchurMultiplicator( gl23 );|
  [  ]
  !gapprompt@gap>| !gapinput@Intersection( Kernel(epi), DerivedSubgroup( Source(epi) ) );|
  [  ]
\end{Verbatim}
 There is a crossed pairing from \mbox{\texttt{\mdseries\slshape G}} into $(G^{*})'$ which can be defined via this epimorphism: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := DihedralPcpGroup(0);|
  Pcp-group with orders [ 2, 0 ]
  !gapprompt@gap>| !gapinput@epi := SchurExtensionEpimorphism( G );|
  [ g1, g2, g3, g4 ] -> [ g1, g2, id, id ]
  !gapprompt@gap>| !gapinput@PreImagesRepresentative( epi, G.1 );|
  g1
  !gapprompt@gap>| !gapinput@PreImagesRepresentative( epi, G.2 );|
  g2
  !gapprompt@gap>| !gapinput@Comm( last, last2 );|
  g2^-2*g4
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{SchurCover}}
\logpage{[ 7, 9, 3 ]}\nobreak
\hyperdef{L}{X7DD1E37987612042}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SchurCover({\mdseries\slshape G})\index{SchurCover@\texttt{SchurCover}}
\label{SchurCover}
}\hfill{\scriptsize (function)}}\\


 computes a Schur covering group of the polycyclic group \mbox{\texttt{\mdseries\slshape G}}. A Schur covering is a largest central extension \mbox{\texttt{\mdseries\slshape H}} of \mbox{\texttt{\mdseries\slshape G}} such that the kernel \mbox{\texttt{\mdseries\slshape M}} of the projection of \mbox{\texttt{\mdseries\slshape H}} onto \mbox{\texttt{\mdseries\slshape G}} is contained in the commutator subgroup of \mbox{\texttt{\mdseries\slshape H}}. 

 If \mbox{\texttt{\mdseries\slshape G}} is given by a presentation $F/R$, then \mbox{\texttt{\mdseries\slshape M}} is isomorphic to the subgroup $R \cap [F,F] / [R,F]$. Let $C$ be a complement to $R \cap [F,F] / [R,F]$ in $R/[R,F]$. Then $F/C$ is isomorphic to \mbox{\texttt{\mdseries\slshape H}} and $R/C$ is isomorphic to \mbox{\texttt{\mdseries\slshape M}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := AbelianPcpGroup( 3,[] );|
  Pcp-group with orders [ 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@ext := SchurCover( G );|
  Pcp-group with orders [ 0, 0, 0, 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@Centre( ext );|
  Pcp-group with orders [ 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@IsSubgroup( DerivedSubgroup( ext ), last );|
  true
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{AbelianInvariantsMultiplier}}
\logpage{[ 7, 9, 4 ]}\nobreak
\hyperdef{L}{X792BC39D7CEB1D27}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AbelianInvariantsMultiplier({\mdseries\slshape G})\index{AbelianInvariantsMultiplier@\texttt{AbelianInvariantsMultiplier}}
\label{AbelianInvariantsMultiplier}
}\hfill{\scriptsize (attribute)}}\\


 returns a list of the abelian invariants of the Schur multiplier of G. 

 Note that the Schur multiplicator of a polycyclic group is a finitely
generated abelian group. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := DihedralPcpGroup( 0 );|
  Pcp-group with orders [ 2, 0 ]
  !gapprompt@gap>| !gapinput@DirectProduct( G, AbelianPcpGroup( 2, [] ) );|
  Pcp-group with orders [ 0, 0, 2, 0 ]
  !gapprompt@gap>| !gapinput@AbelianInvariantsMultiplier( last );|
  [ 0, 2, 2, 2, 2 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{NonAbelianExteriorSquareEpimorphism}}
\logpage{[ 7, 9, 5 ]}\nobreak
\hyperdef{L}{X822ED5978647C93B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NonAbelianExteriorSquareEpimorphism({\mdseries\slshape G})\index{NonAbelianExteriorSquareEpimorphism@\texttt{NonAbelianExteriorSquareEpimorphism}}
\label{NonAbelianExteriorSquareEpimorphism}
}\hfill{\scriptsize (function)}}\\


 returns the epimorphism of the non-abelian exterior square of a polycyclic
group \mbox{\texttt{\mdseries\slshape G}} onto the derived group of \mbox{\texttt{\mdseries\slshape G}}. The non-abelian exterior square can be defined as the derived subgroup of a
Schur cover of \mbox{\texttt{\mdseries\slshape G}}. The isomorphism type of the non-abelian exterior square is unique despite
the fact that the isomorphism type of a Schur cover of a polycyclic groups
need not be unique. The derived group of a Schur cover has a natural
projection onto the derived group of \mbox{\texttt{\mdseries\slshape G}} which is what the function returns. 

 The kernel of the epimorphism is isomorphic to the Schur multiplicator of \mbox{\texttt{\mdseries\slshape G}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := ExamplesOfSomePcpGroups( 3 );|
  Pcp-group with orders [ 0, 0 ]
  !gapprompt@gap>| !gapinput@G := DirectProduct( G,G );|
  Pcp-group with orders [ 0, 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@SchurMultiplicator( G );|
  [ [ 0, 1 ], [ 2, 3 ] ]
  !gapprompt@gap>| !gapinput@epi := NonAbelianExteriorSquareEpimorphism( G );|
  [ g2^-2*g5, g4^-2*g10, g6, g7, g8, g9 ] -> [ g2^-2, g4^-2, id, id, id, id ]
  !gapprompt@gap>| !gapinput@Kernel( epi );|
  Pcp-group with orders [ 0, 2, 2, 2 ]
  !gapprompt@gap>| !gapinput@Collected( AbelianInvariants( last ) );|
  [ [ 0, 1 ], [ 2, 3 ] ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{NonAbelianExteriorSquare}}
\logpage{[ 7, 9, 6 ]}\nobreak
\hyperdef{L}{X8739CD4686301A0E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NonAbelianExteriorSquare({\mdseries\slshape G})\index{NonAbelianExteriorSquare@\texttt{NonAbelianExteriorSquare}}
\label{NonAbelianExteriorSquare}
}\hfill{\scriptsize (attribute)}}\\


 computes the non-abelian exterior square of a polycylic group \mbox{\texttt{\mdseries\slshape G}}. See the explanation for \texttt{NonAbelianExteriorSquareEpimorphism}. The natural projection of the non-abelian exterior square onto the derived
group of \mbox{\texttt{\mdseries\slshape G}} is stored in the component \texttt{!.epimorphism}. 

 There is a crossed pairing from \mbox{\texttt{\mdseries\slshape G}} into $G\wedge G$. See the function \texttt{SchurExtensionEpimorphism} for details. The crossed pairing is stored in the component \texttt{!.crossedPairing}. This is the crossed pairing $\lambda$ in \cite{EickNickel07}. 
\begin{Verbatim}[commandchars=@|B,fontsize=\small,frame=single,label=Example]
  @gapprompt|gap>B @gapinput|G := DihedralPcpGroup(0);B
  Pcp-group with orders [ 2, 0 ]
  @gapprompt|gap>B @gapinput|GwG := NonAbelianExteriorSquare( G );B
  Pcp-group with orders [ 0 ]
  @gapprompt|gap>B @gapinput|lambda := GwG!.crossedPairing;B
  function( g, h ) ... end
  @gapprompt|gap>B @gapinput|lambda( G.1, G.2 );B
  g2^2*g4^-1
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{NonAbelianTensorSquareEpimorphism}}
\logpage{[ 7, 9, 7 ]}\nobreak
\hyperdef{L}{X86553D7B7DABF38F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NonAbelianTensorSquareEpimorphism({\mdseries\slshape G})\index{NonAbelianTensorSquareEpimorphism@\texttt{NonAbelianTensorSquareEpimorphism}}
\label{NonAbelianTensorSquareEpimorphism}
}\hfill{\scriptsize (function)}}\\


 returns for a polycyclic group \mbox{\texttt{\mdseries\slshape G}} the projection of the non-abelian tensor square $G\otimes G$ onto the non-abelian exterior square $G\wedge G$. The range of that epimorphism has the component \texttt{!.epimorphism} set to the projection of the non-abelian exterior square onto the derived
group of \mbox{\texttt{\mdseries\slshape G}}. See also the function \texttt{NonAbelianExteriorSquare}. 

 With the result of this function one can compute the groups in the commutative
diagram at the beginning of the paper \cite{EickNickel07}. The kernel of the returned epimorphism is the group $\nabla(G)$. The kernel of the composition of this epimorphism and the above mention
projection onto $G'$ is the group $J(G)$. 
\begin{Verbatim}[commandchars=@|B,fontsize=\small,frame=single,label=Example]
  @gapprompt|gap>B @gapinput|G := DihedralPcpGroup(0);B
  Pcp-group with orders [ 2, 0 ]
  @gapprompt|gap>B @gapinput|G := DirectProduct(G,G);B
  Pcp-group with orders [ 2, 0, 2, 0 ]
  @gapprompt|gap>B @gapinput|alpha := NonAbelianTensorSquareEpimorphism( G );B
  [ g9*g25^-1, g10*g26^-1, g11*g27, g12*g28, g13*g29, g14*g30, g15, g16,
  g17,
    g18, g19, g20, g21, g22, g23, g24 ] -> [ g2^-2*g6, g4^-2*g12, g8,
    g9, g10,
    g11, id, id, id, id, id, id, id, id, id, id ]
  @gapprompt|gap>B @gapinput|gamma := Range( alpha )!.epimorphism;B
  [ g2^-2*g6, g4^-2*g12, g8, g9, g10, g11 ] -> [ g2^-2, g4^-2, id, id,
  id, id ]
  @gapprompt|gap>B @gapinput|JG := Kernel( alpha * gamma );B
  Pcp-group with orders [ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 ]
  @gapprompt|gap>B @gapinput|Image( alpha, JG );B
  Pcp-group with orders [ 2, 2, 2, 2 ]
  @gapprompt|gap>B @gapinput|SchurMultiplicator( G );B
  [ [ 2, 4 ] ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{NonAbelianTensorSquare}}
\logpage{[ 7, 9, 8 ]}\nobreak
\hyperdef{L}{X7C0DF7C97F78C666}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NonAbelianTensorSquare({\mdseries\slshape G})\index{NonAbelianTensorSquare@\texttt{NonAbelianTensorSquare}}
\label{NonAbelianTensorSquare}
}\hfill{\scriptsize (attribute)}}\\


 computes for a polycyclic group \mbox{\texttt{\mdseries\slshape G}} the non-abelian tensor square $G\otimes G$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@G := AlternatingGroup( IsPcGroup, 4 );|
  <pc group of size 12 with 3 generators>
  !gapprompt@gap>| !gapinput@PcGroupToPcpGroup( G );|
  Pcp-group with orders [ 3, 2, 2 ]
  !gapprompt@gap>| !gapinput@NonAbelianTensorSquare( last );|
  Pcp-group with orders [ 2, 2, 2, 3 ]
  !gapprompt@gap>| !gapinput@PcpGroupToPcGroup( last );|
  <pc group of size 24 with 4 generators>
  !gapprompt@gap>| !gapinput@DirectFactorsOfGroup( last );|
  [ Group([ f1, f2, f3 ]), Group([ f4 ]) ]
  !gapprompt@gap>| !gapinput@List( last, Size );|
  [ 8, 3 ]
  !gapprompt@gap>| !gapinput@IdGroup( last2[1] );|
  [ 8, 4 ]       # the quaternion group of Order 8
  
  !gapprompt@gap>| !gapinput@G := DihedralPcpGroup( 0 );|
  Pcp-group with orders [ 2, 0 ]
  !gapprompt@gap>| !gapinput@ten := NonAbelianTensorSquare( G );|
  Pcp-group with orders [ 0, 2, 2, 2 ]
  !gapprompt@gap>| !gapinput@IsAbelian( ten );|
  true
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{NonAbelianExteriorSquarePlusEmbedding}}
\logpage{[ 7, 9, 9 ]}\nobreak
\hyperdef{L}{X7AE75EC1860FFE7A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NonAbelianExteriorSquarePlusEmbedding({\mdseries\slshape G})\index{NonAbelianExteriorSquarePlusEmbedding@\texttt{Non}\-\texttt{Abelian}\-\texttt{Exterior}\-\texttt{Square}\-\texttt{Plus}\-\texttt{Embedding}}
\label{NonAbelianExteriorSquarePlusEmbedding}
}\hfill{\scriptsize (function)}}\\


 returns an embedding from the non-abelian exterior square $G\wedge G$ into an extensions of $G\wedge G$ by $G\times G$. For the significance of the group see the paper \cite{EickNickel07}. The range of the epimorphism is the group $\tau(G)$ in that paper. }

 

\subsection{\textcolor{Chapter }{NonAbelianTensorSquarePlusEpimorphism}}
\logpage{[ 7, 9, 10 ]}\nobreak
\hyperdef{L}{X7D96C84E87925B0F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NonAbelianTensorSquarePlusEpimorphism({\mdseries\slshape G})\index{NonAbelianTensorSquarePlusEpimorphism@\texttt{Non}\-\texttt{Abelian}\-\texttt{Tensor}\-\texttt{Square}\-\texttt{Plus}\-\texttt{Epimorphism}}
\label{NonAbelianTensorSquarePlusEpimorphism}
}\hfill{\scriptsize (function)}}\\


 returns an epimorphisms of $\nu(G)$ onto $\tau(G)$. The group $\nu(G)$ is an extension of the non-abelian tensor square $G\otimes G$ of $G$ by $G\times G$. The group $\tau(G)$ is an extension of the non-abelian exterior square $G\wedge G$ by $G\times G$. For details see \cite{EickNickel07}. }

 

\subsection{\textcolor{Chapter }{NonAbelianTensorSquarePlus}}
\logpage{[ 7, 9, 11 ]}\nobreak
\hyperdef{L}{X8746533787C4E8BC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NonAbelianTensorSquarePlus({\mdseries\slshape G})\index{NonAbelianTensorSquarePlus@\texttt{NonAbelianTensorSquarePlus}}
\label{NonAbelianTensorSquarePlus}
}\hfill{\scriptsize (function)}}\\


 returns the group $\nu(G)$ in \cite{EickNickel07}. }

 

\subsection{\textcolor{Chapter }{WhiteheadQuadraticFunctor}}
\logpage{[ 7, 9, 12 ]}\nobreak
\hyperdef{L}{X78F9184078B2761A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WhiteheadQuadraticFunctor({\mdseries\slshape G})\index{WhiteheadQuadraticFunctor@\texttt{WhiteheadQuadraticFunctor}}
\label{WhiteheadQuadraticFunctor}
}\hfill{\scriptsize (function)}}\\


 returns Whitehead's universal quadratic functor of $G$, see \cite{EickNickel07} for a description. }

 }

  
\section{\textcolor{Chapter }{Schur covers and Schur towers}}\label{Schur covers and Schur towers}
\logpage{[ 7, 10, 0 ]}
\hyperdef{L}{X7DE87290816C52C4}{}
{
  A finite $p$-group \mbox{\texttt{\mdseries\slshape G}} is a Schur tower, if $G/\gamma_{i+1}(G)$ is a Schur cover of $G/\gamma_i(G)$ for every $i$, where $\gamma_i(G)$ is the $i$-th term of the lower central series of $G$. This section contains a function to determine the Schur covers of a finite $p$-group up to isomorphism and it gives access to two libraries of Schur tower $p$-groups. 

\subsection{\textcolor{Chapter }{SchurCovers}}
\logpage{[ 7, 10, 1 ]}\nobreak
\hyperdef{L}{X7D90B44E7B96AFF1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SchurCovers({\mdseries\slshape G})\index{SchurCovers@\texttt{SchurCovers}}
\label{SchurCovers}
}\hfill{\scriptsize (function)}}\\


 Let \mbox{\texttt{\mdseries\slshape G}} be a finite $p$-group defined as a pcp group. This function returns a complete and
irredundant set of isomorphism types of Schur covers of \mbox{\texttt{\mdseries\slshape G}}. The algorithm implements a method of Nickel's Phd Thesis. }

 }

 }

 
\chapter{\textcolor{Chapter }{Cohomology for pcp-groups}}\label{Cohomology for pcp-groups}
\logpage{[ 8, 0, 0 ]}
\hyperdef{L}{X796AB9787E2A752C}{}
{
  The \textsf{GAP} 4 package \textsf{Polycyclic} provides methods to compute the first and second cohomology group for a
pcp-group $U$ and a finite dimensional ${\ensuremath{\mathbb Z}} U$ or $FU$ module $A$ where $F$ is a finite field. The algorithm for determining the first cohomology group is
outlined in \cite{Eic00}. 

 As a preparation for the cohomology computation, we introduce the cohomology
records. These records provide the technical setup for our cohomology
computations. 
\section{\textcolor{Chapter }{Cohomology records}}\label{Cohomology records}
\logpage{[ 8, 1, 0 ]}
\hyperdef{L}{X875758FA7C6F5CE1}{}
{
  Cohomology records provide the necessary technical setup for the cohomology
computations for polycyclic groups. 

\subsection{\textcolor{Chapter }{CRRecordByMats}}
\logpage{[ 8, 1, 1 ]}\nobreak
\hyperdef{L}{X7C97442C7B78806C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CRRecordByMats({\mdseries\slshape U, mats})\index{CRRecordByMats@\texttt{CRRecordByMats}}
\label{CRRecordByMats}
}\hfill{\scriptsize (function)}}\\


 creates an external module. Let \mbox{\texttt{\mdseries\slshape U}} be a pcp group which acts via the list of matrices \mbox{\texttt{\mdseries\slshape mats}} on a vector space of the form ${\ensuremath{\mathbb Z}}^n$ or $\mathbb{F}_p^n$. Then this function creates a record which can be used as input for the
cohomology computations. }

 

\subsection{\textcolor{Chapter }{CRRecordBySubgroup}}
\logpage{[ 8, 1, 2 ]}\nobreak
\hyperdef{L}{X8646DFA1804D2A11}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CRRecordBySubgroup({\mdseries\slshape U, A})\index{CRRecordBySubgroup@\texttt{CRRecordBySubgroup}}
\label{CRRecordBySubgroup}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CRRecordByPcp({\mdseries\slshape U, pcp})\index{CRRecordByPcp@\texttt{CRRecordByPcp}}
\label{CRRecordByPcp}
}\hfill{\scriptsize (function)}}\\


 creates an internal module. Let \mbox{\texttt{\mdseries\slshape U}} be a pcp group and let \mbox{\texttt{\mdseries\slshape A}} be a normal elementary or free abelian normal subgroup of \mbox{\texttt{\mdseries\slshape U}} or let \mbox{\texttt{\mdseries\slshape pcp}} be a pcp of a normal elementary of free abelian subfactor of \mbox{\texttt{\mdseries\slshape U}}. Then this function creates a record which can be used as input for the
cohomology computations. 

 The returned cohomology record \mbox{\texttt{\mdseries\slshape C}} contains the following entries: 
\begin{description}
\item[{\mbox{\texttt{\mdseries\slshape factor}}}]  a pcp of the acting group. If the module is external, then this is \mbox{\texttt{\mdseries\slshape Pcp(U)}}. If the module is internal, then this is \mbox{\texttt{\mdseries\slshape Pcp(U, A)}} or \mbox{\texttt{\mdseries\slshape Pcp(U, GroupOfPcp(pcp))}}. 
\item[{\mbox{\texttt{\mdseries\slshape mats}}, \mbox{\texttt{\mdseries\slshape invs}} and \mbox{\texttt{\mdseries\slshape one}}}]  the matrix action of \mbox{\texttt{\mdseries\slshape factor}} with acting matrices, their inverses and the identity matrix. 
\item[{\mbox{\texttt{\mdseries\slshape dim}} and \mbox{\texttt{\mdseries\slshape char}}}]  the dimension and characteristic of the matrices. 
\item[{\mbox{\texttt{\mdseries\slshape relators}} and \mbox{\texttt{\mdseries\slshape enumrels}}}]  the right hand sides of the polycyclic relators of \mbox{\texttt{\mdseries\slshape factor}} as generator exponents lists and a description for the corresponding left hand
sides. 
\item[{\mbox{\texttt{\mdseries\slshape central}}}]  is true, if the matrices \mbox{\texttt{\mdseries\slshape mats}} are all trivial. This is used locally for efficiency reasons. 
\end{description}
 And additionally, if $C$ defines an internal module, then it contains: 
\begin{description}
\item[{\mbox{\texttt{\mdseries\slshape group}}}]  the original group \mbox{\texttt{\mdseries\slshape U}}. 
\item[{\mbox{\texttt{\mdseries\slshape normal}}}]  this is either \mbox{\texttt{\mdseries\slshape Pcp(A)}} or the input \mbox{\texttt{\mdseries\slshape pcp}}. 
\item[{\mbox{\texttt{\mdseries\slshape extension}}}]  information on the extension of \mbox{\texttt{\mdseries\slshape A}} by \mbox{\texttt{\mdseries\slshape U/A}}. 
\end{description}
 }

 }

  
\section{\textcolor{Chapter }{Cohomology groups}}\label{Cohomology groups}
\logpage{[ 8, 2, 0 ]}
\hyperdef{L}{X874759D582393441}{}
{
  Let $U$ be a pcp-group and $A$ a free or elementary abelian pcp-group and a $U$-module. By $Z^i(U, A)$ be denote the group of $i$-th cocycles and by $B^i(U, A)$ the $i$-th coboundaries. The factor $Z^i(U,A) / B^i(U,A)$ is the $i$-th cohomology group. Since $A$ is elementary or free abelian, the groups $Z^i(U, A)$ and $B^i(U, A)$ are elementary or free abelian groups as well. 

 The \textsf{Polycyclic} package provides methods to compute first and second cohomology group for a
polycyclic group \mbox{\texttt{\mdseries\slshape U}}. We write all involved groups additively and we use an explicit description
by bases for them. Let $C$ be the cohomology record corresponding to $U$ and $A$. 

 Let $f_1, \ldots, f_n$ be the elements in the entry $factor$ of the cohomology record $C$. Then we use the following embedding of the first cocycle group to describe
1-cocycles and 1-coboundaries: $Z^1(U, A) \to A^n : \delta \mapsto (\delta(f_1), \ldots, \delta(f_n))$ 

 For the second cohomology group we recall that each element of $Z^2(U, A)$ defines an extension $H$ of $A$ by $U$. Thus there is a pc-presentation of $H$ extending the pc-presentation of $U$ given by the record $C$. The extended presentation is defined by tails in $A$; that is, each relator in the record entry $relators$ is extended by an element of $A$. The concatenation of these tails yields a vector in $A^l$ where $l$ is the length of the record entry $relators$ of $C$. We use these tail vectors to describe $Z^2(U, A)$ and $B^2(U, A)$. Note that this description is dependent on the chosen presentation in $C$. However, the factor $Z^2(U, A)/ B^2(U, A)$ is independent of the chosen presentation. 

 The following functions are available to compute explicitly the first and
second cohomology group as described above. 

\subsection{\textcolor{Chapter }{OneCoboundariesCR}}
\logpage{[ 8, 2, 1 ]}\nobreak
\hyperdef{L}{X85EF170387D39D4A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OneCoboundariesCR({\mdseries\slshape C})\index{OneCoboundariesCR@\texttt{OneCoboundariesCR}}
\label{OneCoboundariesCR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OneCocyclesCR({\mdseries\slshape C})\index{OneCocyclesCR@\texttt{OneCocyclesCR}}
\label{OneCocyclesCR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TwoCoboundariesCR({\mdseries\slshape C})\index{TwoCoboundariesCR@\texttt{TwoCoboundariesCR}}
\label{TwoCoboundariesCR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TwoCocyclesCR({\mdseries\slshape C})\index{TwoCocyclesCR@\texttt{TwoCocyclesCR}}
\label{TwoCocyclesCR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OneCohomologyCR({\mdseries\slshape C})\index{OneCohomologyCR@\texttt{OneCohomologyCR}}
\label{OneCohomologyCR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TwoCohomologyCR({\mdseries\slshape C})\index{TwoCohomologyCR@\texttt{TwoCohomologyCR}}
\label{TwoCohomologyCR}
}\hfill{\scriptsize (function)}}\\


 The first 4 functions return bases of the corresponding group. The last 2
functions need to describe a factor of additive abelian groups. They return
the following descriptions for these factors. 
\begin{description}
\item[{\mbox{\texttt{\mdseries\slshape gcc}}}]  the basis of the cocycles of \mbox{\texttt{\mdseries\slshape C}}. 
\item[{\mbox{\texttt{\mdseries\slshape gcb}}}]  the basis of the coboundaries of \mbox{\texttt{\mdseries\slshape C}}. 
\item[{\mbox{\texttt{\mdseries\slshape factor}}}]  a description of the factor of cocycles by coboundaries. Usually, it would be
most convenient to use additive mappings here. However, these are not
available in case that \mbox{\texttt{\mdseries\slshape A}} is free abelian and thus we use a description of this additive map as record.
This record contains 
\begin{description}
\item[{\mbox{\texttt{\mdseries\slshape gens}}}]  a base for the image. 
\item[{\mbox{\texttt{\mdseries\slshape rels}}}]  relative orders for the image. 
\item[{\mbox{\texttt{\mdseries\slshape imgs}}}]  the images for the elements in \mbox{\texttt{\mdseries\slshape gcc}}. 
\item[{\mbox{\texttt{\mdseries\slshape prei}}}]  preimages for the elements in \mbox{\texttt{\mdseries\slshape gens}}. 
\item[{\mbox{\texttt{\mdseries\slshape denom}}}]  the kernel of the map; that is, another basis for \mbox{\texttt{\mdseries\slshape gcb}}. 
\end{description}
 
\end{description}
 There is an additional function which can be used to compute the second
cohomology group over an arbitrary finitely generated abelian group. The
finitely generated abelian group should be realized as a factor of a free
abelian group modulo a lattice. The function is called as }

 

\subsection{\textcolor{Chapter }{TwoCohomologyModCR}}
\logpage{[ 8, 2, 2 ]}\nobreak
\hyperdef{L}{X79B48D697A8A84C8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TwoCohomologyModCR({\mdseries\slshape C, lat})\index{TwoCohomologyModCR@\texttt{TwoCohomologyModCR}}
\label{TwoCohomologyModCR}
}\hfill{\scriptsize (function)}}\\


 where \mbox{\texttt{\mdseries\slshape C}} is a cohomology record and \mbox{\texttt{\mdseries\slshape lat}} is a basis for a sublattice of a free abelian module. The output format is the
same as for \texttt{TwoCohomologyCR}. }

 }

  
\section{\textcolor{Chapter }{Extended 1-cohomology}}\label{Extended 1-cohomology}
\logpage{[ 8, 3, 0 ]}
\hyperdef{L}{X79610E9178BD0C54}{}
{
  In some cases more information on the first cohomology group is of interest.
In particular, if we have an internal module given and we want to compute the
complements using the first cohomology group, then we need additional
information. This extended version of first cohomology is obtained by the
following functions. 

\subsection{\textcolor{Chapter }{OneCoboundariesEX}}
\logpage{[ 8, 3, 1 ]}\nobreak
\hyperdef{L}{X7E87E3EA81C84621}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OneCoboundariesEX({\mdseries\slshape C})\index{OneCoboundariesEX@\texttt{OneCoboundariesEX}}
\label{OneCoboundariesEX}
}\hfill{\scriptsize (function)}}\\


 returns a record consisting of the entries 
\begin{description}
\item[{\mbox{\texttt{\mdseries\slshape basis}}}]  a basis for $B^1(U, A) \leq A^n$. 
\item[{\mbox{\texttt{\mdseries\slshape transf}}}]  There is a derivation mapping from $A$ to $B^1(U,A)$. This mapping is described here as transformation from $A$ to \mbox{\texttt{\mdseries\slshape basis}}. 
\item[{\mbox{\texttt{\mdseries\slshape fixpts}}}]  the fixpoints of $A$. This is also the kernel of the derivation mapping. 
\end{description}
 }

 

\subsection{\textcolor{Chapter }{OneCocyclesEX}}
\logpage{[ 8, 3, 2 ]}\nobreak
\hyperdef{L}{X8111D2087C16CC0C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OneCocyclesEX({\mdseries\slshape C})\index{OneCocyclesEX@\texttt{OneCocyclesEX}}
\label{OneCocyclesEX}
}\hfill{\scriptsize (function)}}\\


 returns a record consisting of the entries 
\begin{description}
\item[{\mbox{\texttt{\mdseries\slshape basis}}}]  a basis for $Z^1(U, A) \leq A^n$. 
\item[{\mbox{\texttt{\mdseries\slshape transl}}}]  a special solution. This is only of interest in case that $C$ is an internal module and in this case it gives the translation vector in $A^n$ used to obtain complements corresponding to the elements in $basis$. If $C$ is not an internal module, then this vector is always the zero vector. 
\end{description}
 }

 

\subsection{\textcolor{Chapter }{OneCohomologyEX}}
\logpage{[ 8, 3, 3 ]}\nobreak
\hyperdef{L}{X84718DDE792FB212}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OneCohomologyEX({\mdseries\slshape C})\index{OneCohomologyEX@\texttt{OneCohomologyEX}}
\label{OneCohomologyEX}
}\hfill{\scriptsize (function)}}\\


 returns the combined information on the first cohomology group. }

 }

  
\section{\textcolor{Chapter }{Extensions and Complements}}\label{Extensions and Complements}
\logpage{[ 8, 4, 0 ]}
\hyperdef{L}{X853E51787A24AE00}{}
{
  The natural applications of first and second cohomology group is the
determination of extensions and complements. Let $C$ be a cohomology record. 

\subsection{\textcolor{Chapter }{ ComplementCR}}
\logpage{[ 8, 4, 1 ]}\nobreak
\hyperdef{L}{X7DA9162085058006}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ ComplementCR({\mdseries\slshape C, c})\index{ ComplementCR@\texttt{ ComplementCR}}
\label{ ComplementCR}
}\hfill{\scriptsize (function)}}\\


 returns the complement corresponding to the 1-cocycle \mbox{\texttt{\mdseries\slshape c}}. In the case that \mbox{\texttt{\mdseries\slshape C}} is an external module, we construct the split extension of $U$ with $A$ first and then determine the complement. In the case that \mbox{\texttt{\mdseries\slshape C}} is an internal module, the vector \mbox{\texttt{\mdseries\slshape c}} must be an element of the affine space corresponding to the complements as
described by \texttt{OneCocyclesEX}. }

 

\subsection{\textcolor{Chapter }{ ComplementsCR}}
\logpage{[ 8, 4, 2 ]}\nobreak
\hyperdef{L}{X7F8984D386A813D6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ ComplementsCR({\mdseries\slshape C})\index{ ComplementsCR@\texttt{ ComplementsCR}}
\label{ ComplementsCR}
}\hfill{\scriptsize (function)}}\\


 returns all complements using the correspondence to $Z^1(U,A)$. Further, this function returns fail, if $Z^1(U,A)$ is infinite. }

 

\subsection{\textcolor{Chapter }{ ComplementClassesCR}}
\logpage{[ 8, 4, 3 ]}\nobreak
\hyperdef{L}{X7FAB3EB0803197FA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ ComplementClassesCR({\mdseries\slshape C})\index{ ComplementClassesCR@\texttt{ ComplementClassesCR}}
\label{ ComplementClassesCR}
}\hfill{\scriptsize (function)}}\\


 returns complement classes using the correspondence to $H^1(U,A)$. Further, this function returns fail, if $H^1(U,A)$ is infinite. }

 

\subsection{\textcolor{Chapter }{ ComplementClassesEfaPcps}}
\logpage{[ 8, 4, 4 ]}\nobreak
\hyperdef{L}{X8759DC59799DD508}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ ComplementClassesEfaPcps({\mdseries\slshape U, N, pcps})\index{ ComplementClassesEfaPcps@\texttt{ ComplementClassesEfaPcps}}
\label{ ComplementClassesEfaPcps}
}\hfill{\scriptsize (function)}}\\


 Let $N$ be a normal subgroup of $U$. This function returns the complement classes to $N$ in $U$. The classes are computed by iteration over the $U$-invariant efa series of $N$ described by \mbox{\texttt{\mdseries\slshape pcps}}. If at some stage in this iteration infinitely many complements are
discovered, then the function returns fail. (Even though there might be only
finitely many conjugacy classes of complements to $N$ in $U$.) }

 

\subsection{\textcolor{Chapter }{ ComplementClasses}}
\logpage{[ 8, 4, 5 ]}\nobreak
\hyperdef{L}{X7B0EC76D81A056AB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ ComplementClasses({\mdseries\slshape [V, ]U, N})\index{ ComplementClasses@\texttt{ ComplementClasses}}
\label{ ComplementClasses}
}\hfill{\scriptsize (function)}}\\


 Let $N$ and $U$ be normal subgroups of $V$ with $N \leq U \leq V$. This function attempts to compute the $V$-conjugacy classes of complements to $N$ in $U$. The algorithm proceeds by iteration over a $V$-invariant efa series of $N$. If at some stage in this iteration infinitely many complements are
discovered, then the algorithm returns fail. }

 

\subsection{\textcolor{Chapter }{ExtensionCR}}
\logpage{[ 8, 4, 6 ]}\nobreak
\hyperdef{L}{X85F3B55C78CF840B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ExtensionCR({\mdseries\slshape C, c})\index{ExtensionCR@\texttt{ExtensionCR}}
\label{ExtensionCR}
}\hfill{\scriptsize (function)}}\\


 returns the extension corresponding to the 2-cocycle $c$. }

 

\subsection{\textcolor{Chapter }{ExtensionsCR}}
\logpage{[ 8, 4, 7 ]}\nobreak
\hyperdef{L}{X81DC85907E0948FD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ExtensionsCR({\mdseries\slshape C})\index{ExtensionsCR@\texttt{ExtensionsCR}}
\label{ExtensionsCR}
}\hfill{\scriptsize (function)}}\\


 returns all extensions using the correspondence to $Z^2(U,A)$. Further, this function returns fail, if $Z^2(U,A)$ is infinite. }

 

\subsection{\textcolor{Chapter }{ExtensionClassesCR}}
\logpage{[ 8, 4, 8 ]}\nobreak
\hyperdef{L}{X7AE16E3687E14B24}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ExtensionClassesCR({\mdseries\slshape C})\index{ExtensionClassesCR@\texttt{ExtensionClassesCR}}
\label{ExtensionClassesCR}
}\hfill{\scriptsize (function)}}\\


 returns extension classes using the correspondence to $H^2(U,A)$. Further, this function returns fail, if $H^2(U,A)$ is infinite. }

 

\subsection{\textcolor{Chapter }{SplitExtensionPcpGroup}}
\logpage{[ 8, 4, 9 ]}\nobreak
\hyperdef{L}{X7986997B78AD3292}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SplitExtensionPcpGroup({\mdseries\slshape U, mats})\index{SplitExtensionPcpGroup@\texttt{SplitExtensionPcpGroup}}
\label{SplitExtensionPcpGroup}
}\hfill{\scriptsize (function)}}\\


 returns the split extension of \mbox{\texttt{\mdseries\slshape U}} by the $U$-module described by \mbox{\texttt{\mdseries\slshape mats}}. }

 }

  
\section{\textcolor{Chapter }{Constructing pcp groups as extensions}}\label{Constructing pcp groups as extensions}
\logpage{[ 8, 5, 0 ]}
\hyperdef{L}{X823771527DBD857D}{}
{
  This section contains an example application of the second cohomology group to
the construction of pcp groups as extensions. The following constructs
extensions of the group of upper unitriangular matrices with its natural
lattice. 
\begin{Verbatim}[commandchars=@|A,fontsize=\small,frame=single,label=Example]
  # get the group and its matrix action
  @gapprompt|gap>A @gapinput|G := UnitriangularPcpGroup(3,0);A
  Pcp-group with orders [ 0, 0, 0 ]
  @gapprompt|gap>A @gapinput|mats := G!.mats;A
  [ [ [ 1, 1, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ],
    [ [ 1, 0, 0 ], [ 0, 1, 1 ], [ 0, 0, 1 ] ],
    [ [ 1, 0, 1 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] ]
  
  # set up the cohomology record
  @gapprompt|gap>A @gapinput|C := CRRecordByMats(G,mats);;A
  
  # compute the second cohomology group
  @gapprompt|gap>A @gapinput|cc := TwoCohomologyCR(C);;A
  
  # the abelian invariants of H^2(G,M)
  @gapprompt|gap>A @gapinput|cc.factor.rels;A
  [ 2, 0, 0 ]
  
  # construct an extension which corresponds to a cocycle that has
  # infinite image in H^2(G,M)
  @gapprompt|gap>A @gapinput|c := cc.factor.prei[2];A
  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, -1, 1 ]
  @gapprompt|gap>A @gapinput|H := ExtensionCR( CR, c);A
  Pcp-group with orders [ 0, 0, 0, 0, 0, 0 ]
  
  # check that the extension does not split - get the normal subgroup
  @gapprompt|gap>A @gapinput|N := H!.module;A
  Pcp-group with orders [ 0, 0, 0 ]
  
  # create the interal module
  @gapprompt|gap>A @gapinput|C := CRRecordBySubgroup(H,N);;A
  
  # use the complements routine
  @gapprompt|gap>A @gapinput|ComplementClassesCR(C);A
  [  ]
\end{Verbatim}
 }

 }

 
\chapter{\textcolor{Chapter }{Matrix Representations}}\label{Matrix Representations}
\logpage{[ 9, 0, 0 ]}
\hyperdef{L}{X858D1BB07A8FBF87}{}
{
  This chapter describes functions which compute with matrix representations for
pcp-groups. So far the routines in this package are only able to compute
matrix representations for torsion-free nilpotent groups. 
\section{\textcolor{Chapter }{Unitriangular matrix groups}}\label{Unitriangular matrix groups}
\logpage{[ 9, 1, 0 ]}
\hyperdef{L}{X7D0ED06C7E6A457D}{}
{
  

\subsection{\textcolor{Chapter }{UnitriangularMatrixRepresentation}}
\logpage{[ 9, 1, 1 ]}\nobreak
\hyperdef{L}{X7E6F320F865E309C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UnitriangularMatrixRepresentation({\mdseries\slshape G})\index{UnitriangularMatrixRepresentation@\texttt{UnitriangularMatrixRepresentation}}
\label{UnitriangularMatrixRepresentation}
}\hfill{\scriptsize (operation)}}\\


 computes a faithful representation of a torsion-free nilpotent group \mbox{\texttt{\mdseries\slshape G}} as unipotent lower triangular matrices over the integers. The pc-presentation
for \mbox{\texttt{\mdseries\slshape G}} must not contain any power relations. The algorithm is described in \cite{dGN02}. }

 

\subsection{\textcolor{Chapter }{IsMatrixRepresentation}}
\logpage{[ 9, 1, 2 ]}\nobreak
\hyperdef{L}{X7F5E7F5F7DDB2E2C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsMatrixRepresentation({\mdseries\slshape G, matrices})\index{IsMatrixRepresentation@\texttt{IsMatrixRepresentation}}
\label{IsMatrixRepresentation}
}\hfill{\scriptsize (function)}}\\


 checks if the map defined by mapping the $i$-th generator of the pcp-group \mbox{\texttt{\mdseries\slshape G}} to the $i$-th matrix of \mbox{\texttt{\mdseries\slshape matrices}} defines a homomorphism. }

 }

  
\section{\textcolor{Chapter }{Upper unitriangular matrix groups}}\label{Upper unitriangular matrix groups}
\logpage{[ 9, 2, 0 ]}
\hyperdef{L}{X79A8A51B84E4BF8C}{}
{
  We call a matrix upper unitriangular if it is an upper triangular matrix with
ones on the main diagonal. The weight of an upper unitriangular matrix is the
number of diagonals above the main diagonal that contain zeroes only. 

 The subgroup of all upper unitriangular matrices of $GL(n,{\ensuremath{\mathbb Z}})$ is torsion-free nilpotent. The $k$-th term of its lower central series is the set of all matrices of weight $k-1$. The ${\ensuremath{\mathbb Z}}$-rank of the $k$-th term of the lower central series modulo the $(k+1)$-th term is $n-k$. 

\subsection{\textcolor{Chapter }{IsomorphismUpperUnitriMatGroupPcpGroup}}
\logpage{[ 9, 2, 1 ]}\nobreak
\hyperdef{L}{X8434972E7DDB68C1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsomorphismUpperUnitriMatGroupPcpGroup({\mdseries\slshape G})\index{IsomorphismUpperUnitriMatGroupPcpGroup@\texttt{Isomorphism}\-\texttt{Upper}\-\texttt{Unitri}\-\texttt{Mat}\-\texttt{Group}\-\texttt{Pcp}\-\texttt{Group}}
\label{IsomorphismUpperUnitriMatGroupPcpGroup}
}\hfill{\scriptsize (function)}}\\


 takes a group \mbox{\texttt{\mdseries\slshape G}} generated by upper unitriangular matrices over the integers and computes a
polycylic presentation for the group. The function returns an isomorphism from
the matrix group to the pcp group. Note that a group generated by upper
unitriangular matrices is necessarily torsion-free nilpotent. }

 

\subsection{\textcolor{Chapter }{SiftUpperUnitriMatGroup}}
\logpage{[ 9, 2, 2 ]}\nobreak
\hyperdef{L}{X843C9D427FFA2487}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SiftUpperUnitriMatGroup({\mdseries\slshape G})\index{SiftUpperUnitriMatGroup@\texttt{SiftUpperUnitriMatGroup}}
\label{SiftUpperUnitriMatGroup}
}\hfill{\scriptsize (function)}}\\


 takes a group \mbox{\texttt{\mdseries\slshape G}} generated by upper unitriangular matrices over the integers and returns a
recursive data structure \mbox{\texttt{\mdseries\slshape L}} with the following properties: \mbox{\texttt{\mdseries\slshape L}} contains a polycyclic generating sequence for \mbox{\texttt{\mdseries\slshape G}}, using \mbox{\texttt{\mdseries\slshape L}} one can decide if a given upper unitriangular matrix is contained in \mbox{\texttt{\mdseries\slshape G}}, a given element of \mbox{\texttt{\mdseries\slshape G}} can be written as a word in the polycyclic generating sequence. \mbox{\texttt{\mdseries\slshape L}} is a representation of a chain of subgroups of \mbox{\texttt{\mdseries\slshape G}} refining the lower centrals series of \mbox{\texttt{\mdseries\slshape G}}.. It contains for each subgroup in the chain a minimal generating set. }

 

\subsection{\textcolor{Chapter }{RanksLevels}}
\logpage{[ 9, 2, 3 ]}\nobreak
\hyperdef{L}{X7CF8B8F981931846}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RanksLevels({\mdseries\slshape L})\index{RanksLevels@\texttt{RanksLevels}}
\label{RanksLevels}
}\hfill{\scriptsize (function)}}\\


 takes the data structure returned by \texttt{SiftUpperUnitriMat} and prints the ${\ensuremath{\mathbb Z}}$-rank of each the subgroup in \mbox{\texttt{\mdseries\slshape L}}. }

 

\subsection{\textcolor{Chapter }{MakeNewLevel}}
\logpage{[ 9, 2, 4 ]}\nobreak
\hyperdef{L}{X81F3760186734EA7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MakeNewLevel({\mdseries\slshape m})\index{MakeNewLevel@\texttt{MakeNewLevel}}
\label{MakeNewLevel}
}\hfill{\scriptsize (function)}}\\


 creates one level of the data structure returned by \texttt{SiftUpperUnitriMat} and initialises it with weight \mbox{\texttt{\mdseries\slshape m}}. }

 

\subsection{\textcolor{Chapter }{SiftUpperUnitriMat}}
\logpage{[ 9, 2, 5 ]}\nobreak
\hyperdef{L}{X851A216C85B74574}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SiftUpperUnitriMat({\mdseries\slshape gens, level, M})\index{SiftUpperUnitriMat@\texttt{SiftUpperUnitriMat}}
\label{SiftUpperUnitriMat}
}\hfill{\scriptsize (function)}}\\


 takes the generators \mbox{\texttt{\mdseries\slshape gens}} of an upper unitriangular group, the data structure returned \mbox{\texttt{\mdseries\slshape level}} by \texttt{SiftUpperUnitriMat} and another upper unitriangular matrix \mbox{\texttt{\mdseries\slshape M}}. It sift \mbox{\texttt{\mdseries\slshape M}} through \mbox{\texttt{\mdseries\slshape level}} and adds \mbox{\texttt{\mdseries\slshape M}} at the appropriate place if \mbox{\texttt{\mdseries\slshape M}} is not contained in the subgroup represented by \mbox{\texttt{\mdseries\slshape level}}. 

 The function \texttt{SiftUpperUnitriMatGroup} illustrates the use of \texttt{SiftUpperUnitriMat}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  InstallGlobalFunction( "SiftUpperUnitriMatGroup", function( G )
      local   firstlevel,  g;
  
      firstlevel := MakeNewLevel( 0 );
      for g in GeneratorsOfGroup(G) do
          SiftUpperUnitriMat( GeneratorsOfGroup(G), firstlevel, g );
      od;
      return firstlevel;
  end );
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{DecomposeUpperUnitriMat}}
\logpage{[ 9, 2, 6 ]}\nobreak
\hyperdef{L}{X86D711217C639C2C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DecomposeUpperUnitriMat({\mdseries\slshape level, M})\index{DecomposeUpperUnitriMat@\texttt{DecomposeUpperUnitriMat}}
\label{DecomposeUpperUnitriMat}
}\hfill{\scriptsize (function)}}\\


 takes the data structure \mbox{\texttt{\mdseries\slshape level}} returned by \texttt{SiftUpperUnitriMatGroup} and a upper unitriangular matrix \mbox{\texttt{\mdseries\slshape M}} and decomposes \mbox{\texttt{\mdseries\slshape M}} into a word in the polycyclic generating sequence of \mbox{\texttt{\mdseries\slshape level}}. }

 }

 }

 

\appendix


\chapter{\textcolor{Chapter }{Obsolete Functions and Name Changes}}\label{app:Obsolete}
\logpage{[ "A", 0, 0 ]}
\hyperdef{L}{X874ECE907CAF380D}{}
{
  Over time, the interface of \textsf{Polycyclic} has changed. This was done to get the names of \textsf{Polycyclic} functions to agree with the general naming conventions used throughout GAP.
Also, some \textsf{Polycyclic} operations duplicated functionality that was already available in the core of
GAP under a different name. In these cases, whenever possible we now install
the \textsf{Polycyclic} code as methods for the existing GAP operations instead of introducing new
operations. 

 For backward compatibility, we still provide the old, obsolete names as
aliases. However, please consider switching to the new names as soon as
possible. The old names may be completely removed at some point in the future. 

 The following function names were changed. 

 \index{SchurCovering@\texttt{SchurCovering}} \index{SchurMultPcpGroup@\texttt{SchurMultPcpGroup}} \begin{center}
\begin{tabular}{l|l}\emph{OLD}&
\emph{NOW USE}\\
\hline
\texttt{SchurCovering}&
\texttt{SchurCover} (\ref{SchurCover})\\
\texttt{SchurMultPcpGroup}&
\texttt{AbelianInvariantsMultiplier} (\ref{AbelianInvariantsMultiplier})\\
\end{tabular}\\[2mm]
\end{center}

 }

\def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{polycyclicbib.xml}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
