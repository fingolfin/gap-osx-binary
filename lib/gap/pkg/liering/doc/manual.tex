% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{\textsf{LieRing}\mbox{}}}\\
\vfill

\hypersetup{pdftitle=\textsf{LieRing}}
\markright{\scriptsize \mbox{}\hfill \textsf{LieRing} \hfill\mbox{}}
{\Huge \textbf{Lie Rings\mbox{}}}\\
\vfill

{\Huge Version 2.2\mbox{}}\\[1cm]
{December 2013\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Serena Cical{\a`o}   \mbox{}}}\\
{\Large \textbf{ Willem de Graaf    \mbox{}}}\\
\hypersetup{pdfauthor= Serena Cical{\a`o}   ;  Willem de Graaf    }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{ Serena Cical{\a`o}   }  Email: \href{mailto://cicalo@science.unitn.it} {\texttt{cicalo@science.unitn.it}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Dipartimento di Matematica e Informatica\\
 Via Ospedale, 72\\
 09124 Cagliari\\
 Italy\\
 \end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{ Willem de Graaf    }  Email: \href{mailto://degraaf@science.unitn.it} {\texttt{degraaf@science.unitn.it}}\\
  Homepage: \href{http://www.science.unitn.it/~degraaf/} {\texttt{http://www.science.unitn.it/\texttt{\symbol{126}}degraaf/}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Dipartimento di Matematica\\
 Via Sommarive 14\\
 I-38050 Povo (Trento)\\
 Italy\\
 \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Abstract}
\logpage{[ 0, 0, 1 ]}
 This package provides functions for constructing and working with Lie rings.
There are functions for dealing with finitely-presented Lie rings, and for
performing the Lazard correspondence. The package also contains a small
database of finitely-generated Lie rings satisfying an Engel condition. \mbox{}}\\[1cm]
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 2 ]}
 {\copyright} 2013 Serena Cical{\a`o} and Willem de Graaf \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 3 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Introduction}}\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  
\section{\textcolor{Chapter }{Preliminaries}}\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X8749E1888244CC3D}{}
{
  A Lie ring $L$ is a $\mathbb{Z}$-module equipped with a multiplication, denoted by a bracket $[~,~]$ with 
\begin{itemize}
\item  $[x,x]=0$ for all $x$ in $L$,
\item  $[x,[y,z]]+[z,[x,y]]+[y,[z,x]]=0$ for all $x,y,z$ in $L$. 
\end{itemize}
 Contrary to Lie algebras (which are defined over a field), Lie rings may have
torsion elements, i.e., elements $x \neq 0$ such that $mx=0$ for some $m\in \mathbb{Z}$. 

 We say that a Lie ring is finite-dimensional if it is finitely-generated as
abelian group. All functions of this package deal with finite-dimensional Lie
rings. 

 Here is an example of a Lie ring $L$ of order $5^6$. As abelian group $L$ is generated by $x_1,x_2,x_3,x_4,x_5$. We have $5x_i=0$ for $i=1,\ldots,4$, and $25x_5=0$. Furthermore, 
\[ [x_1,x_4] = 4x_2+5x_5,~ [x_3,x_4] = 4x_1,~ [x_3,x_5]=4x_2,~ [x_4,x_5]=4x_3. \]
 One of the main functions of this package constructs a Lie ring given by a
multiplication table (as above) from a finite presentation. The Lie ring above
can be obtained as follows. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= FreeLieRing( Integers, ["a","b"] );|
  <Free algebra over Integers generators: a, b >
  !gapprompt@gap>| !gapinput@a:= L.1; b:= L.2;|
  a
  b
  !gapprompt@gap>| !gapinput@S:= [ 5*a-(b*a)*a-((b*a)*b)*b,5*b];|
  [ (5)*a+(-1)*(a,(a,b))+(b,(b,(a,b))), (5)*b ]
  !gapprompt@gap>| !gapinput@K:= FpLieRing( L, S : maxdeg:= 4 );|
  <Lie ring with 5 generators>
  !gapprompt@gap>| !gapinput@v:=BasisVectors( Basis(K) );|
  [ v_1, v_2, v_3, v_4, v_5 ]
  !gapprompt@gap>| !gapinput@v[1]*v[4];|
  4*v_2+5*v_5
  !gapprompt@gap>| !gapinput@Torsion( Basis(K) );|
  [ 5, 5, 5, 5, 25 ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{The free Lie ring }}\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X865892E97C9D1E6D}{}
{
  Let $X$ be a set of letters, which we denote by $ x_1,\ldots,x_n$. Then the free magma $M(X)$ on $X$ is defined to be the set of all bracketed expressions in the elements of $X$. More precisely, we have that $X$ is a subset of $M(X)$ and if $a,b\in M(X)$, then also $(a,b)\in M(X)$. The free magma has a natural binary operation $m$ with $m(a,b) = (a,b)$.

 The elements of the free magma have a degree which is defined as $\deg(a,b) = \deg(a)+\deg(b)$. The degree of the elements of $X$ can be set to be any positive integer. (Usually this is 1, but it is possible
to use different degrees for the elements of $X$.) 

 Let $R$ be a ring; then the free algebra $A_R(X)$ on $X$ over $R$ is the $R$-span of $M(X)$. The product on $A_R(X)$ is obtained by bilinearly extending the map $m$. 

 The elements of $M(X)$ are called monomials of $A_R(X)$. We use the following ordering on them. The elements of $X$ are ordered arbitrarily. Then $ (a,b) < (c,d)$ if $\deg(a,b) < \deg(c,d)$. If these two numbers are equal, then $ (a,b) < (c,d)$ if $a < c$, and in case $a=c$, if $b < d$. Using this ordering we can speak of leading monomial, and leading
coefficient of an element of $A_R(X)$. Using these notions one can develop a Groebner basis theory for ideals in $A_R(X)$ (see \cite{cicgra1} and \cite{cicgra2}). 

 Let $J$ be the ideal of $A_R(X)$ generated by all elements 
\begin{itemize}
\item  $(a,a)$,
\item  $(a,b)+(b,a)$,
\item  $(a,(b,c))+(c,(a,b))+(b,(c,a))$,
\end{itemize}
 for $a,b,c\in M(X)$. Set $L_R(X) = A_R(X)/J$, which is called the free Lie ring over $R$ generated by $X$. 

 The free Lie ring is one of the central objects of this package. It can be
defined over the integers, or over a field. The free Lie rings that can be
constructed using this package rewrite their elements using anticommutativity.
The Jacobi identity is not used for rewriting; this is because that would lead
to expression swell, and sometimes tedious rewriting of elements to a form in
which that can no longer be recognised. So, strictly speaking, we work with
the free anticommutative algebra. }

 
\section{\textcolor{Chapter }{The Lazard correspondence }}\logpage{[ 1, 3, 0 ]}
\hyperdef{L}{X7994DA6587ABDA2D}{}
{
  Using the Baker-Campbell-Hausdorff (or BCH) formula one can define an
associative multiplication on a nilpotent Lie ring of order $p^n$ and nilpotency class $ < p $. This makes the Lie ring into a $p$-group of the same order and nilpotency class. The BCH-formula also has
inverses, which can be used to define an addition and a Lie bracket on a $p$-group of class $ < p $. These make the group into a Lie ring of the same order and nilpotency class. 

 These two operations are mutually inverse, and so define an equivalence of the
categories of $p$-groups of class $ < p $ and nilpotent Lie rings of the same order and nilpotency class. This
equivalence is known as the \emph{Lazard correspondence} (see \cite{khukhro98}). This package has functions for performing this correspondence, i.e., to
make a $p$-group into a Lie ring and vice versa. For the algorithms used we refer to \cite{cicgravl}. }

 }

 
\chapter{\textcolor{Chapter }{The functions}}\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X8173135A7D187358}{}
{
  
\section{\textcolor{Chapter }{The free Lie ring}}\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X865892E97C9D1E6D}{}
{
  

\subsection{\textcolor{Chapter }{FreeLieRing}}
\logpage{[ 2, 1, 1 ]}\nobreak
\hyperdef{L}{X7E52D2B884457822}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FreeLieRing({\mdseries\slshape R, names})\index{FreeLieRing@\texttt{FreeLieRing}}
\label{FreeLieRing}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FreeLieRing({\mdseries\slshape R, names, deg})\index{FreeLieRing@\texttt{FreeLieRing}}
\label{FreeLieRing}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FreeLieRing({\mdseries\slshape R, k})\index{FreeLieRing@\texttt{FreeLieRing}}
\label{FreeLieRing}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FreeLieRing({\mdseries\slshape R, k, deg})\index{FreeLieRing@\texttt{FreeLieRing}}
\label{FreeLieRing}
}\hfill{\scriptsize (method)}}\\


 Here \mbox{\texttt{\mdseries\slshape R}} is a ring, which has to be either the integers, or a field. \mbox{\texttt{\mdseries\slshape names}} is a list of strings, which will be the names of the generators. This function
returns the free Lie ring over \mbox{\texttt{\mdseries\slshape R}}, with generators named as in \mbox{\texttt{\mdseries\slshape names }}. If \mbox{\texttt{\mdseries\slshape L}} denotes the output, then \mbox{\texttt{\mdseries\slshape L.i}} will be the i-th generator. If a third argument \mbox{\texttt{\mdseries\slshape deg}} is given then this must be a list of positive integers. Then each generator
will have a degree equal to the corresponding element of the list \mbox{\texttt{\mdseries\slshape deg}}. 

 Monomials in the free Lie ring of the form $(a,b)$ with $a>b$ are automatically rewritten as $-(b,a)$. Monomials of the form $(a,a)$ are rewritten as zero. There is no other rewriting done. Therefore, the object
returned by this function is strictly speaking not the same as the free Lie
ring, it rather is the free anticommutative algebra. 

 Monomials in the free Lie ring are printed as bracketed expressions. In a
printed element the monomials appear in increasing order; in particular the
last monomial is the leading monomial. 

 If instead of the list \mbox{\texttt{\mdseries\slshape names}} a positive integer \mbox{\texttt{\mdseries\slshape k}} is given, then the free Lie ring on that number of generators is returned.
Again we can give each generator a degree different from 1 by adding a third
argument \mbox{\texttt{\mdseries\slshape deg}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= FreeLieRing( Integers, ["a","b"] );|
  <Free algebra over Integers generators: a, b >
  !gapprompt@gap>| !gapinput@a:= L.1; b:= L.2;|
  a
  b
  !gapprompt@gap>| !gapinput@(a*b)*b+2*a*b;       |
  (2)*(a,b)+(-1)*(b,(a,b))
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{Degree}}
\logpage{[ 2, 1, 2 ]}\nobreak
\hyperdef{L}{X826A861E7E7D944E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Degree({\mdseries\slshape f})\index{Degree@\texttt{Degree}}
\label{Degree}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape f}} is an element of a free Lie ring. Its degree is returned. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= FreeLieRing( Integers, ["a","b"] );;|
  !gapprompt@gap>| !gapinput@a:= L.1;; b:= L.2;;|
  !gapprompt@gap>| !gapinput@f:=(a*b)*b+2*a*b;|
  (2)*(a,b)+(-1)*(b,(a,b))
  !gapprompt@gap>| !gapinput@Degree(f);|
  3
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{ Creating Lie rings }}\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X7BDAF9F47EBC6C0E}{}
{
  The package can deal with finite-dimensional Lie rings given by a
multiplication table (which follow the format for multiplication tables in the \textsf{GAP} library), and a list of moduli. This list has to have the same length as the
number of basis elements of the Lie ring. If the i-th element of this list is $m$ then the additive order of the i-th basis edlement if $m$. If $m=0$ then the additive order is infinite. 

\subsection{\textcolor{Chapter }{IsLieRing}}
\logpage{[ 2, 2, 1 ]}\nobreak
\hyperdef{L}{X784B8B28809EAC37}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsLieRing\index{IsLieRing@\texttt{IsLieRing}}
\label{IsLieRing}
}\hfill{\scriptsize (filter)}}\\


 This is the category of finite-dimensional Lie rings. }

 

\subsection{\textcolor{Chapter }{LieRingByStructureConstants}}
\logpage{[ 2, 2, 2 ]}\nobreak
\hyperdef{L}{X7DEFFA797BB7E432}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LieRingByStructureConstants({\mdseries\slshape tor, T})\index{LieRingByStructureConstants@\texttt{LieRingByStructureConstants}}
\label{LieRingByStructureConstants}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape T}} is a multiplication table, and \mbox{\texttt{\mdseries\slshape tor}} is a list of moduli. This function returns the corresponding Lie ring. In the
example below we create the Lie ring with basis elements $x,y,z$, with $[x,y]=z$, $3x=6y=3z=0$. 

 The multiplication table has to be created using the \textsf{GAP} functions for constructing multiplication tables of Lie algebras. In
particular, we refer to the \textsf{GAP} reference manual for descriptions of the functions \texttt{EmptySCTable} (\textbf{Reference: EmptySCTable}) \texttt{SetEntrySCTable} (\textbf{Reference: SetEntrySCTable}) 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@T:= EmptySCTable( 3, 0, "antisymmetric" );;|
  !gapprompt@gap>| !gapinput@SetEntrySCTable( T, 1, 2, [1,3] );|
  !gapprompt@gap>| !gapinput@LieRingByStructureConstants( [3,6,3], T );|
  <Lie ring with 3 generators>
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{FpLieRing}}
\logpage{[ 2, 2, 3 ]}\nobreak
\hyperdef{L}{X7D58E7AB7B2788D2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FpLieRing({\mdseries\slshape L, R})\index{FpLieRing@\texttt{FpLieRing}}
\label{FpLieRing}
}\hfill{\scriptsize (function)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a free Lie ring defined over the integers, and \mbox{\texttt{\mdseries\slshape R}} is a set of elements of \mbox{\texttt{\mdseries\slshape L}}. This function returns the Lie ring given by structure constants, that is
isomorphic to \mbox{\texttt{\mdseries\slshape L}} modulo the ideal generated by \mbox{\texttt{\mdseries\slshape R}}. 

 It is possible to set the option \mbox{\texttt{\mdseries\slshape maxdeg}} to a positive value \mbox{\texttt{\mdseries\slshape d}}. Then a nilpotent quotient is computed, i.e., all elements of \mbox{\texttt{\mdseries\slshape L}} of degree strictly greater than \mbox{\texttt{\mdseries\slshape d}} will be treated as relations. 

 The algebra that is output by this function has an attribute, \mbox{\texttt{\mdseries\slshape CanonicalProjection}}, which is a function mapping elements of the free Lie ring \mbox{\texttt{\mdseries\slshape L}} to their projections in the output algebra. 

 The algorithm behind this function has been described in \cite{cicgra1} and \cite{cicgra2}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= FreeLieRing( Integers, ["x","y"], [1,2] );                   |
  <Free algebra over Integers generators: x, y >
  !gapprompt@gap>| !gapinput@x:= L.1;; y:= L.2;;|
  !gapprompt@gap>| !gapinput@R:= [((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];|
  [ (-1)*(x,(x,(x,y)))+(-6)*(y,(x,y)), 
    (-3)*(x,(x,(x,(x,(x,y)))))+(-20)*(y,(x,(x,(x,y)))) ]
  !gapprompt@gap>| !gapinput@K:= FpLieRing( L, R : maxdeg:= 15 ); time;|
  <Lie ring with 75 generators>
  944
  !gapprompt@gap>| !gapinput@f:=CanonicalProjection(K);|
  function( elm ) ... end
  !gapprompt@gap>| !gapinput@f(R[1]);|
  0
  !gapprompt@gap>| !gapinput@f(x);|
  v_1
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{FpLieAlgebra}}
\logpage{[ 2, 2, 4 ]}\nobreak
\hyperdef{L}{X7D2CC3FF80F73EF8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FpLieAlgebra({\mdseries\slshape L, R})\index{FpLieAlgebra@\texttt{FpLieAlgebra}}
\label{FpLieAlgebra}
}\hfill{\scriptsize (function)}}\\


 This is similar to \mbox{\texttt{\mdseries\slshape FpLieRing}}, with the difference that the free Lie ring \mbox{\texttt{\mdseries\slshape L}} must be defined over a field. Then the algorithms become a lot faster (in most
cases). The result however is a Lie algebra, and not a Lie ring. }

 }

 
\section{\textcolor{Chapter }{ Working with Lie rings }}\logpage{[ 2, 3, 0 ]}
\hyperdef{L}{X7876A08584CBABAE}{}
{
  

\subsection{\textcolor{Chapter }{Basis}}
\logpage{[ 2, 3, 1 ]}\nobreak
\hyperdef{L}{X837BE54C80DE368E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Basis({\mdseries\slshape L})\index{Basis@\texttt{Basis}}
\label{Basis}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} a Lie ring. Its basis is returned. 

 We note that in \textsf{LieRing} Lie rings have one basis that is computed by the system; one should not try to
set a basis. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@T:= EmptySCTable( 3, 0, "antisymmetric" );;|
  !gapprompt@gap>| !gapinput@SetEntrySCTable( T, 1, 2, [1,3] );|
  !gapprompt@gap>| !gapinput@K:= LieRingByStructureConstants( [3,6,3], T );|
  <Lie ring with 3 generators>
  !gapprompt@gap>| !gapinput@Basis(K); |
  Basis( <Lie ring with 3 generators>, [ v_1, v_2, v_3 ] )
  !gapprompt@gap>| !gapinput@BasisVectors( Basis(K) );|
  [ v_1, v_2, v_3 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{StructureConstantsTable}}
\logpage{[ 2, 3, 2 ]}\nobreak
\hyperdef{L}{X804ADF0280F67CDC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{StructureConstantsTable({\mdseries\slshape B})\index{StructureConstantsTable@\texttt{StructureConstantsTable}}
\label{StructureConstantsTable}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape B}} is the basis of a Lie ring. Its structure constants table is returned. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@T:= EmptySCTable( 3, 0, "antisymmetric" );;|
  !gapprompt@gap>| !gapinput@SetEntrySCTable( T, 1, 2, [1,3] );|
  !gapprompt@gap>| !gapinput@K:= LieRingByStructureConstants( [3,6,3], T );|
  <Lie ring with 3 generators>
  !gapprompt@gap>| !gapinput@StructureConstantsTable( Basis(K) );|
  [ [ [ [  ], [  ] ], [ [ 3 ], [ 1 ] ], [ [  ], [  ] ] ], 
    [ [ [ 3 ], [ -1 ] ], [ [  ], [  ] ], [ [  ], [  ] ] ], 
    [ [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ] ], -1, 0 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{Torsion}}
\logpage{[ 2, 3, 3 ]}\nobreak
\hyperdef{L}{X7BF95CA07861A1AF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Torsion({\mdseries\slshape B})\index{Torsion@\texttt{Torsion}}
\label{Torsion}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape B}} is the basis of a Lie ring. The list of torsion moduli of its basis elements
is returned. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@T:= EmptySCTable( 3, 0, "antisymmetric" );;|
  !gapprompt@gap>| !gapinput@SetEntrySCTable( T, 1, 2, [1,3] );|
  !gapprompt@gap>| !gapinput@K:= LieRingByStructureConstants( [3,6,3], T );|
  <Lie ring with 3 generators>
  !gapprompt@gap>| !gapinput@Torsion( Basis(K) );|
  [ 3, 6, 3 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{Coefficients}}
\logpage{[ 2, 3, 4 ]}\nobreak
\hyperdef{L}{X80B32F667BF6AFD8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Coefficients({\mdseries\slshape B, elm})\index{Coefficients@\texttt{Coefficients}}
\label{Coefficients}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape B}} is the basis of a Lie ring, and \mbox{\texttt{\mdseries\slshape elm}} is an element of the same Lie ring. The coefficients of \mbox{\texttt{\mdseries\slshape elm}} with respect to \mbox{\texttt{\mdseries\slshape B}} are returned. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= FreeLieRing( Integers, ["x","y"] );; x:= L.1;; y:= L.2;;|
  !gapprompt@gap>| !gapinput@rr:=[((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];;|
  !gapprompt@gap>| !gapinput@K:= FpLieRing( L, rr : maxdeg:= 6 );;|
  !gapprompt@gap>| !gapinput@C:=LieCentre(K);|
  <Lie ring with 9 generators>
  !gapprompt@gap>| !gapinput@Coefficients( Basis(K), Basis(C)[6] );|
  [ 5, 5, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@Coefficients( Basis(C), Basis(C)[6] );|
  [ 0, 0, 0, 0, 0, 1, 0, 0, 0 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{SubLieRing}}
\logpage{[ 2, 3, 5 ]}\nobreak
\hyperdef{L}{X7BC3398686B25634}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SubLieRing({\mdseries\slshape L, gens[, string]})\index{SubLieRing@\texttt{SubLieRing}}
\label{SubLieRing}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a Lie ring, and \mbox{\texttt{\mdseries\slshape gens}} a list of elements of \mbox{\texttt{\mdseries\slshape L}}. This function constructs the subring generated by the elements in \mbox{\texttt{\mdseries\slshape gens}}. If these elements are known to form a basis of the subalgebra, then as a
third argument the string \mbox{\texttt{\mdseries\slshape "basis"}} can be added. That makes the execution of the function a lot faster. 

 This function depends on hermite and Smith normal form computations. Therefore
in practice, for bigger inputs, it can be slow. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= FreeLieRing( Integers, ["x","y"] );;                         |
  !gapprompt@gap>| !gapinput@x:= L.1;; y:= L.2;;|
  !gapprompt@gap>| !gapinput@rr:=[((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];; |
  !gapprompt@gap>| !gapinput@K:= FpLieRing( L, rr : maxdeg:= 8 );|
  <Lie ring with 41 generators>
  !gapprompt@gap>| !gapinput@b:= Basis(K);;|
  !gapprompt@gap>| !gapinput@M:= SubLieRing( K, [ b[30], b[40] ] );|
  <Lie ring with 6 generators>
  !gapprompt@gap>| !gapinput@Torsion(Basis(M));|
  [ 3, 6, 6, 12, 360, 0 ]
  !gapprompt@gap>| !gapinput@Basis(M)[2];|
  3*v_2+2*v_3+2*v_10+4*v_12+4*v_13+5*v_14+v_15+3*v_17+3*v_18+6*v_20+10*v_22+6*v_
  24+6*v_25+10*v_26+4*v_27+18*v_28+30*v_29+60*v_30+360*v_31+5040*v_32
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{LieRingIdeal}}
\logpage{[ 2, 3, 6 ]}\nobreak
\hyperdef{L}{X7E97DBD778358F19}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LieRingIdeal({\mdseries\slshape L, gens[, string]})\index{LieRingIdeal@\texttt{LieRingIdeal}}
\label{LieRingIdeal}
}\hfill{\scriptsize (operation)}}\\


 This is the same as \mbox{\texttt{\mdseries\slshape SubLieRing}} except that the output is an ideal (on the level of data structures that is
the same as a Lie subring). }

 

\subsection{\textcolor{Chapter }{NaturalHomomorphismByIdeal}}
\logpage{[ 2, 3, 7 ]}\nobreak
\hyperdef{L}{X83D53D98809EC461}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NaturalHomomorphismByIdeal({\mdseries\slshape L, I})\index{NaturalHomomorphismByIdeal@\texttt{NaturalHomomorphismByIdeal}}
\label{NaturalHomomorphismByIdeal}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a Lie ring, and \mbox{\texttt{\mdseries\slshape I}} an ideal of \mbox{\texttt{\mdseries\slshape L}}. This function constructs the canonical projection of \mbox{\texttt{\mdseries\slshape L}} on the quotient of \mbox{\texttt{\mdseries\slshape L}} by \mbox{\texttt{\mdseries\slshape I}}. 

 We remark that it is \emph{not checked} whether \mbox{\texttt{\mdseries\slshape I}} is an ideal or not. if \mbox{\texttt{\mdseries\slshape I}} is just a subalgebra, then nothing is guaranteed about the result of this
function. 

 Also this function depends on Smith normal form computations; therefore it can
be slow on bigger inputs. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= FreeLieRing( Integers, ["x","y"] );;                         |
  !gapprompt@gap>| !gapinput@x:= L.1;; y:= L.2;;|
  !gapprompt@gap>| !gapinput@rr:=[((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];; |
  !gapprompt@gap>| !gapinput@K:= FpLieRing( L, rr : maxdeg:= 8 );;|
  !gapprompt@gap>| !gapinput@b:= Basis(K);;|
  !gapprompt@gap>| !gapinput@I:= LieRingIdeal( K, [ b[29] ] );|
  <Lie ring with 23 generators>
  !gapprompt@gap>| !gapinput@f:= NaturalHomomorphismByIdeal( K, I );;|
  !gapprompt@gap>| !gapinput@M:= Range(f);|
  <Lie ring with 27 generators>
  !gapprompt@gap>| !gapinput@Torsion(Basis(M));|
  [ 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 6, 12, 12, 12, 120, 720, 10080, 0, 0, 0, 
    0, 0, 0, 0, 0, 0 ]
  !gapprompt@gap>| !gapinput@Image( f, b[30] );|
  v_16+716*v_17
  !gapprompt@gap>| !gapinput@PreImagesRepresentative( f, Basis(M)[10] );|
  4*v_2+4*v_3+4*v_4+4*v_5+5*v_6+v_7+5*v_8+v_9+5*v_10+v_11+5*v_12+v_13+5*v_14+v_
  24+v_25+11*v_26+v_29+10*v_30+100*v_31
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{LieLowerCentralSeries}}
\logpage{[ 2, 3, 8 ]}\nobreak
\hyperdef{L}{X7900D17E7BA26A48}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LieLowerCentralSeries({\mdseries\slshape L})\index{LieLowerCentralSeries@\texttt{LieLowerCentralSeries}}
\label{LieLowerCentralSeries}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a Lie ring. Its lower central series is returned. 

 This repeatedly constructs ideals of \mbox{\texttt{\mdseries\slshape L}}; therefore also this function can be rather slow on bigger inputs. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= FreeLieRing( Integers, ["x","y"] );; x:= L.1;; y:= L.2;;|
  !gapprompt@gap>| !gapinput@rr:=[((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];;|
  !gapprompt@gap>| !gapinput@K:= FpLieRing( L, rr : maxdeg:= 7 );;|
  !gapprompt@gap>| !gapinput@LieLowerCentralSeries(K);|
  [ <Lie ring with 26 generators>, <Lie ring with 24 generators>, 
    <Lie ring with 23 generators>, <Lie ring with 22 generators>, 
    <Lie ring with 21 generators>, <Lie ring with 19 generators>, 
    <Lie ring with 16 generators>, <Lie ring with 0 generators> ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{LieLowerPCentralSeries}}
\logpage{[ 2, 3, 9 ]}\nobreak
\hyperdef{L}{X790A24857D0E559A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LieLowerPCentralSeries({\mdseries\slshape L, p})\index{LieLowerPCentralSeries@\texttt{LieLowerPCentralSeries}}
\label{LieLowerPCentralSeries}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a Lie ring, and \mbox{\texttt{\mdseries\slshape p}} is a prime. The lower \mbox{\texttt{\mdseries\slshape p}}-central series of \mbox{\texttt{\mdseries\slshape L}} is returned. This is the series where the $L^{k+1}$ is generated by $[L,L^k]$ and $pL^k$. Note that this may not be a finite series, if $L$ is not of exponent $p^n$ (as abelian group). The function does not check this; if the series is
infinite, then it will loop forever. 

 This repeatedly constructs ideals of \mbox{\texttt{\mdseries\slshape L}}; therefore also this function can be rather slow on bigger inputs. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= FreeLieRing( Integers, ["x","y"] );; x:= L.1;; y:= L.2;;|
  !gapprompt@gap>| !gapinput@rr:=[((y*x)*x)*x-7*(y*x)*y, 7*((((y*x)*x)*x)*x)*x-49*(((y*x)*x)*x)*y, |
  !gapprompt@>| !gapinput@7*x, 49*y ];;|
  !gapprompt@gap>| !gapinput@K:= FpLieRing( L, rr : maxdeg:= 5 );;|
  !gapprompt@gap>| !gapinput@LieLowerPCentralSeries(K,7);|
  [ <Lie ring with 11 generators>, <Lie ring with 10 generators>, 
    <Lie ring with 8 generators>, <Lie ring with 6 generators>,
    <Lie ring with 4 generators>, <Lie ring with 0 generators> ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{LieCentre}}
\logpage{[ 2, 3, 10 ]}\nobreak
\hyperdef{L}{X8111F58E7DE3E25C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LieCentre({\mdseries\slshape L})\index{LieCentre@\texttt{LieCentre}}
\label{LieCentre}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a Lie ring. Its centre is returned. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= FreeLieRing( Integers, ["x","y"] );; x:= L.1;; y:= L.2;;|
  !gapprompt@gap>| !gapinput@rr:=[((y*x)*x)*x-6*(y*x)*y, 3*((((y*x)*x)*x)*x)*x-20*(((y*x)*x)*x)*y ];;|
  !gapprompt@gap>| !gapinput@K:= FpLieRing( L, rr : maxdeg:= 7 );;|
  !gapprompt@gap>| !gapinput@LieCentre(K);|
  <Lie ring with 16 generators>
  !gapprompt@gap>| !gapinput@Torsion( Basis(K) );|
  [ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 360, 5040, 0, 0, 0, 0, 
    0, 0, 0, 0 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{TensorWithField}}
\logpage{[ 2, 3, 11 ]}\nobreak
\hyperdef{L}{X819C15027E16E335}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TensorWithField({\mdseries\slshape L, F})\index{TensorWithField@\texttt{TensorWithField}}
\label{TensorWithField}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a Lie ring, and \mbox{\texttt{\mdseries\slshape F}} is a field. This function returns the Lie algebra that is obtained by
tensoring \mbox{\texttt{\mdseries\slshape L}} with \mbox{\texttt{\mdseries\slshape F}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@T:= EmptySCTable( 3, 0, "antisymmetric" );;|
  !gapprompt@gap>| !gapinput@SetEntrySCTable( T, 1, 2, [1,3] );|
  !gapprompt@gap>| !gapinput@K:= LieRingByStructureConstants( [3,6,3], T );;|
  !gapprompt@gap>| !gapinput@TensorWithField( K, GF(3) );|
  <Lie algebra of dimension 3 over GF(3)>
  !gapprompt@gap>| !gapinput@TensorWithField( K, GF(2) );|
  <Lie algebra of dimension 1 over GF(2)>
  !gapprompt@gap>| !gapinput@TensorWithField( K, GF(5) );|
  <Lie algebra over GF(5), with 0 generators>
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{The Lazard correspondence}}\logpage{[ 2, 4, 0 ]}
\hyperdef{L}{X7994DA6587ABDA2D}{}
{
  By the Lazard correspondence we can put a Lie ring structure on a $p$-group of class $<p$. Conversely, we can define a group structure on a nilpotent Lie ring of order $p^n$ and class $<p$. The package contains functions for doing this effectively. However, we do
not work with a single object having both the structure of a $p$-group and a Lie ring. Rather we define two objects, a $p$-group and a Lie ring, along with bijections between the two. Our programs use
the BCH-formula and its inverses, that have been stored in a file, truncated
at weight 14. This means that currently the package is able to deal with
groups and algebras up to class 14. The underlying algorithms have been
described in \cite{cicgravl} 

\subsection{\textcolor{Chapter }{PGroupToLieRing}}
\logpage{[ 2, 4, 1 ]}\nobreak
\hyperdef{L}{X81FC256983DC2A94}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PGroupToLieRing({\mdseries\slshape G})\index{PGroupToLieRing@\texttt{PGroupToLieRing}}
\label{PGroupToLieRing}
}\hfill{\scriptsize (attribute)}}\\


 Here \mbox{\texttt{\mdseries\slshape G}} is a $p$-group of class $<p$. This function returns a record with four components: \mbox{\texttt{\mdseries\slshape pgroup}} (the group \mbox{\texttt{\mdseries\slshape G}}), \mbox{\texttt{\mdseries\slshape liering}} (the corresponding Lie ring), \mbox{\texttt{\mdseries\slshape GtoL}} (a function mapping elements of the group to elements of the Lie ring), \mbox{\texttt{\mdseries\slshape LtoG}} (a function mapping elements of the Lie ring to elements of the group). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@F := FreeGroup(IsSyllableWordsFamily,"a","b","c","d", "e", "f", "g");;|
  !gapprompt@gap>| !gapinput@a := F.1;; b := F.2;; c := F.3;; d := F.4;; e := F.5;; f := F.6;; g:=F.7;;|
  !gapprompt@gap>| !gapinput@rels := [ a^13, b^13/g, c^13, d^13, e^13, f^13, g^13,  |
  !gapprompt@>| !gapinput@Comm(b,a)/c, Comm(c,a)/d, Comm(d,a)/e, Comm(e,a)/f, Comm(f,a), Comm(g,a),|
  !gapprompt@>| !gapinput@Comm(c,b)/(g^11), Comm(d,b)/g, Comm(e,b)/g, Comm(g,b), Comm(d,c)/(g^12),|
  !gapprompt@>| !gapinput@Comm(e,c), Comm(f,c), Comm(g,c), Comm(e,d), Comm(f,d), Comm(g,d), Comm(f,e), |
  !gapprompt@>| !gapinput@Comm(g,e), Comm(g,f)];;|
  !gapprompt@gap>| !gapinput@G := PcGroupFpGroup( F/rels );|
  <pc group of size 62748517 with 7 generators>
  !gapprompt@gap>| !gapinput@r:= PGroupToLieRing(G);|
  rec( pgroup := <pc group of size 62748517 with 7 generators>, 
  liering := <Lie ring with 6 generators>, 
  GtoL := function( g0 ) ... end, LtoG := function( x0 ) ... end )
  !gapprompt@gap>| !gapinput@f:= r.GtoL; h:= r.LtoG;|
  function( g0 ) ... end
  function( x0 ) ... end
  !gapprompt@gap>| !gapinput@L:= r.liering;|
  <Lie ring with 6 generators>
  !gapprompt@gap>| !gapinput@b:= Basis(L);|
  Basis( <Lie ring with 6 generators>, [ v_1, v_2, v_3, v_4, v_5, v_6 ] )
  !gapprompt@gap>| !gapinput@h(b[1]);|
  a^12*c*d^5*e^3*f^8*g^7
  !gapprompt@gap>| !gapinput@f(h(b[1]));|
  v_1
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{LieRingToPGroup}}
\logpage{[ 2, 4, 2 ]}\nobreak
\hyperdef{L}{X7E683E5F80B27375}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LieRingToPGroup({\mdseries\slshape L})\index{LieRingToPGroup@\texttt{LieRingToPGroup}}
\label{LieRingToPGroup}
}\hfill{\scriptsize (attribute)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a nilpotent Lie ring of class $<p$ and order $p^n$. This function returns a record with four components: \mbox{\texttt{\mdseries\slshape pgroup}} (the $p$-group corresponding to \mbox{\texttt{\mdseries\slshape L}}), \mbox{\texttt{\mdseries\slshape liering}} (the Lie ring \mbox{\texttt{\mdseries\slshape L}}), \mbox{\texttt{\mdseries\slshape GtoL}} (a function mapping elements of the group to elements of the Lie ring), \mbox{\texttt{\mdseries\slshape LtoG}} (a function mapping elements of the Lie ring to elements of the group). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= FreeLieRing( Integers, ["a","b","c"] );; |
  !gapprompt@gap>| !gapinput@a:= L.1;; b:= L.2;; c:= L.3;;|
  !gapprompt@gap>| !gapinput@rels:= [ (b*a)*b, c*a, c*b-(b*a)*a, 7^2*a, 7*b-((b*a)*a)*a, |
  !gapprompt@>| !gapinput@7*c-((b*a)*a)*a];;|
  !gapprompt@gap>| !gapinput@K:= FpLieRing( L, rels );|
  <Lie ring with 5 generators>
  !gapprompt@gap>| !gapinput@r:= LieRingToPGroup(K);|
  rec( pgroup := <pc group of size 823543 with 7 generators>, 
  liering := <Lie ring with 5 generators>, 
  LtoG := function( x0 ) ... end, GtoL := function( g0 ) ... end )
  !gapprompt@gap>| !gapinput@G:= r.pgroup;; f:= r.LtoG;; h:= r.GtoL;;|
  !gapprompt@gap>| !gapinput@u:= 5*Basis(K)[2]+9*Basis(K)[5];|
  5*v_2+9*v_5
  !gapprompt@gap>| !gapinput@f(u);|
  f3^2*f4^2*f5^6*f7^3
  !gapprompt@gap>| !gapinput@h(f(u));|
  5*v_2+9*v_5
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{The database of $n$-Engel Lie rings}}\logpage{[ 2, 5, 0 ]}
\hyperdef{L}{X7E857411859A0725}{}
{
  A Lie ring $L$ is said to satisfy the $n$-Engel condition if for all $x,y \in L$ we have $(ad x)^n (y) = 0$. The package \textsf{LieRing} contains a small database of Lie rings that satisfy an $n$-Engel condition. They have been computed with the algorithms described in \cite{cicgra1} and \cite{cicgra2}. 



 Currently the database contains the "freeest" (or "largest") $n$-Engel Lie rings with $k$ generators for $(n,k) = (3,2), (3,3), (3,4), (4,2), (4,3)$. 

\subsection{\textcolor{Chapter }{SmallNEngelLieRing}}
\logpage{[ 2, 5, 1 ]}\nobreak
\hyperdef{L}{X7F6C2B1D82E381D0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SmallNEngelLieRing({\mdseries\slshape n, k})\index{SmallNEngelLieRing@\texttt{SmallNEngelLieRing}}
\label{SmallNEngelLieRing}
}\hfill{\scriptsize (operation)}}\\


 This returns the biggest \mbox{\texttt{\mdseries\slshape n}}-Engel Lie ring with \mbox{\texttt{\mdseries\slshape k}} generators, for the values of \mbox{\texttt{\mdseries\slshape n,k}} indicated above. For other values an error is raised. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= SmallNEngelLieRing( 4, 3 );|
  <Lie ring with 133 generators>
  !gapprompt@gap>| !gapinput@x:= 10*Basis(L)[1]+7*Basis(L)[10]+19*Basis(L)[89];|
  7*v_10+19*v_89
  !gapprompt@gap>| !gapinput@ForAll( Basis(L), y -> IsZero( x*(x*(x*(x*y))) ) );|
  true
  !gapprompt@gap>| !gapinput@K:= TensorWithField( L, GF(3) );|
  <Lie algebra of dimension 83 over GF(3)>
  !gapprompt@gap>| !gapinput@x:= Random(K);;|
  !gapprompt@gap>| !gapinput@ForAll( Basis(K), y -> IsZero( x*(x*(x*(x*y))) ) );|
  true
\end{Verbatim}
 }

 }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{liering}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
