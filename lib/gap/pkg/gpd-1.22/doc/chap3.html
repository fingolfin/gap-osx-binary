<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (Gpd) - Chapter 3: Groupoids</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>

<p><a id="X82F6A1AB798648F4" name="X82F6A1AB798648F4"></a></p>
<div class="ChapSects"><a href="chap3.html#X82F6A1AB798648F4">3 <span class="Heading">Groupoids</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7AC321DC7E3C6167">3.1 <span class="Heading">Groupoids: their properties and attributes</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8406913B7ED86CFE">3.1-1 SinglePieceGroupoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8511D3EE845CC930">3.1-2 IsPermGroupoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79877FAA8556A726">3.1-3 UnionOfPieces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X855F318181808814">3.1-4 HomogeneousGroupoid</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X831F3EBF7AD211DB">3.2 <span class="Heading">Groupoid elements; stars; costars and homsets</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D028B3B8385ED07">3.2-1 GroupoidElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E30871D78B9F81C">3.2-2 IdentityElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B561BAE7D471C60">3.2-3 ObjectStar</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7BDBA72C852C4625">3.3 <span class="Heading">Subgroupoids</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80780D287EDDB7BB">3.3-1 Subgroupoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X873E0914871858E8">3.3-2 SubgroupoidWithRays</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X831AA9E8780235F2">3.4 <span class="Heading">Left, right and double cosets</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8412ABD57986B9FC">3.4-1 RightCoset</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X8653FC9786E3209A">3.5 <span class="Heading">Conjugation</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7ECA0B0984310646">3.5-1 ConjugateGroupoidElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C2727D285BA2EBE">3.5-2 SinglePieceGroupoidByGenerators</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X78218F357BFEDE82">3.5-3 ConjugateGroupoid</a></span>
</div></div>
</div>

<h3>3 <span class="Heading">Groupoids</span></h3>

<p>A <em>groupoid</em> is a (mathematical) category in which every element is invertible. It consists of a set of <em>pieces</em>, each of which is a connected groupoid. (The usual terminology is `connected component', but in <strong class="pkg">GAP</strong> `component' is used for `record component'.)</p>

<p>A <em>single piece groupoid</em> is determined by a set of <em>objects</em> <code class="code">obs</code> and an <em>object group</em> <code class="code">grp</code>. The objects of a single piece groupoid are generally chosen to be consecutive negative integers, but any suitable ordered set is acceptable, and `consecutive' is not a requirement. The object groups will usually be taken to be permutation groups, but pc-groups and fp-groups are also supported.</p>

<p>A <em>group</em> is a single piece groupoid with one object.</p>

<p>A <em>groupoid</em> is a set of one or more single piece groupoids, its <em>pieces</em>, and is represented as <code class="code">IsGroupoidRep</code>, with attribute <code class="code">PiecesOfGroupoid</code>.</p>

<p>A groupoid is <em>homogeneous</em> if it has two of more isomorphic pieces, with identical groups. The special case of <em>homogeneous, discrete</em> groupoids, where each piece has a single object, is given its own representation. These groupoids are used in the <strong class="pkg">XMod</strong> package as the source of many crossed modules of groupoids.</p>

<p>For the definitions of the standard properties of groupoids we refer to R. Brown's book ``Topology'' <a href="chapBib.html#biBBrTop">[Bro88]</a>, recently revised and reissued as ``Topology and Groupoids'' <a href="chapBib.html#biBBrTopGpd">[Bro06]</a>.</p>

<p><a id="X7AC321DC7E3C6167" name="X7AC321DC7E3C6167"></a></p>

<h4>3.1 <span class="Heading">Groupoids: their properties and attributes</span></h4>

<p><a id="X8406913B7ED86CFE" name="X8406913B7ED86CFE"></a></p>

<h5>3.1-1 SinglePieceGroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SinglePieceGroupoid</code>( <var class="Arg">grp</var>, <var class="Arg">obs</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Groupoid</code>( <var class="Arg">args</var> )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RootObject</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>As for magmas with objects, the simplest construction of a groupoid is as the direct product of a group and a complete graph. Some subgroupoids of such a groupoid do not have this simple form, and will be considered in a later section. As usual, the <code class="code">RootObject</code> is the object with least label.</p>

<p>The global function <code class="code">Groupoid</code> will normally find the appropriate constructor to call, the options being:</p>


<ul>
<li><p>the object group, a list of objects;</p>

</li>
<li><p>a group being converted to a groupoid, a single object;</p>

</li>
<li><p>a list of groupoids which have already been constructed.</p>

</li>
</ul>
<p>Methods for <code class="code">ViewObj</code>, <code class="code">PrintObj</code> and <code class="code">Display</code> are provided for groupoids and the other types of object in this package. Users are advised to supply names for all the groups and groupoids they construct.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s4 := Group( (1,2,3,4), (3,4) );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d8 := Subgroup( s4, [ (1,2,3,4), (1,3) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( s4, "s4" );  SetName( d8, "d8" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gs4 := SinglePieceGroupoid( s4, [-15 .. -11] ); </span>
single piece groupoid: &lt; s4, [ -15 .. -11 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gd8 := Groupoid( d8, [-9,-8,-7] );</span>
single piece groupoid: &lt; d8, [ -9, -8, -7 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c6 := Group( (5,6,7)(8,9) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( c6, "c6" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gc6 := DomainWithSingleObject( c6, -6 );</span>
single piece groupoid: &lt; c6, [ -6 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( Gs4, "Gs4" );  SetName( Gd8, "Gd8" );  SetName( Gc6, "Gc6" );  </span>

</pre></div>

<p><a id="X8511D3EE845CC930" name="X8511D3EE845CC930"></a></p>

<h5>3.1-2 IsPermGroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPermGroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( property )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPcGroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( property )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFpGroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>A groupoid is a permutation groupoid if all its pieces have permutation groups. Most of the examples in this chapter are permutation groupoids, but in principle any type of group known to <strong class="pkg">GAP</strong> may be used. In the following example <code class="code">Gf2</code> is an fp-groupoid, while <code class="code">Gq8</code> is a pc-groupoid.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f2 := FreeGroup( 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gf2 := Groupoid( f2, -22 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( f2, "f2" );  SetName( Gf2, "Gf2" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q8 := SmallGroup( 8, 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gq8 := Groupoid( q8, [ -28, -27 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( q8, "q8" );  SetName( Gq8, "Gq8" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ IsFpGroupoid( Gf2 ), IsPcGroupoid( Gq8 ), IsPermGroupoid( Gs4 ) ]; </span>
[ true, true, true ]

</pre></div>

<p><a id="X79877FAA8556A726" name="X79877FAA8556A726"></a></p>

<h5>3.1-3 UnionOfPieces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnionOfPieces</code>( <var class="Arg">pieces</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ReplaceOnePieceInUnion</code>( <var class="Arg">gpd</var>, <var class="Arg">old_piece</var>, <var class="Arg">new_piece</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Size</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>When a groupoid consists of two or more pieces, we require their object lists to be disjoint. <code class="code">UnionOfPieces</code> from section <a href="chap1.html#X87B3A56F8231D0F3"><span class="RefLink">1.4</span></a> is also used for groupoids. The pieces are sorted by the least object in their object lists. The <code class="code">ObjectList</code> is the sorted concatenation of the objects in the pieces. The <code class="code">Size</code> of a groupoid is the number of its elements which, for a single piece groupoid, is the product of the size of the group with the square of the number of objects.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U3 := UnionOfPieces( [ Gs4, Gd8, Gc6 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( U3, "Gs4+Gd8+Gc6" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( U3 );</span>
groupoid with 3 pieces:
&lt; objects: [ -15 .. -11 ]
    group: s4 = &lt;[ (1,2,3,4), (3,4) ]&gt; &gt;
&lt; objects: [ -9, -8, -7 ]
    group: d8 = &lt;[ (1,2,3,4), (1,3) ]&gt; &gt;
&lt; objects: [ -6 ]
    group: c6 = &lt;[ (5,6,7)(8,9) ]&gt; &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Pieces( U3 );</span>
[ Gs4, Gd8, Gc6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectList( U3 );</span>
[ -15, -14, -13, -12, -11, -9, -8, -7, -6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U2 := Groupoid( [ Gf2, Gq8 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ Size(Gs4), Size(Gd8), Size(Gc6), Size(U3), Size(U2) ];</span>
[ 600, 72, 6, 678, infinity ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U5 := UnionOfPieces( [ U3, Gf2, Gq8 ] );</span>
groupoid with 5 pieces:
[ Gq8, Gf2, Gs4, Gd8, Gc6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( U5 );</span>
groupoid with 5 pieces:
&lt; objects: [ -28, -27 ]
    group: q8 = &lt;[ f1, f2, f3 ]&gt; &gt;
&lt; objects: [ -22 ]
    group: f2 = &lt;[ f1, f2 ]&gt; &gt;
&lt; objects: [ -15, -14, -13, -12, -11 ]
    group: s4 = &lt;[ (1,2,3,4), (3,4) ]&gt; &gt;
&lt; objects: [ -9, -8, -7 ]
    group: d8 = &lt;[ (1,2,3,4), (1,3) ]&gt; &gt;
&lt; objects: [ -6 ]
    group: c6 = &lt;[ (5,6,7)(8,9) ]&gt; &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V5 := Groupoid( [ U2, U3 ] );</span>
groupoid with 5 pieces:
[ Gq8, Gf2, Gs4, Gd8, Gc6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U5 = V5;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rs4 := Groupoid( s4, [-30,-29] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( Rs4, "Rs4" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W5 := ReplaceOnePieceInUnion( U5, Gs4, Rs4 ); </span>
groupoid with 5 pieces:
[ Rs4, Gq8, Gf2, Gd8, Gc6 ]

</pre></div>

<p><a id="X855F318181808814" name="X855F318181808814"></a></p>

<h5>3.1-4 HomogeneousGroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HomogeneousGroupoid</code>( <var class="Arg">gpd</var>, <var class="Arg">oblist</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HomogeneousDiscreteGroupoid</code>( <var class="Arg">gp</var>, <var class="Arg">obs</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Special functions are provided for the case where a groupoid consists of identical connected components. We call these groupoids <em>homogeneous</em>. The operation <code class="code">HomogeneousGroupoid</code> is used when the components each contain more than one object, while the operation <code class="code">HomogeneousDiscreteGroupoid</code> is used when the components each have a single object. Both types of groupoid have the property <code class="code">IsHomogeneousDomainWithObjects</code>, and in the latter case a separate representation <code class="code">IsHomogeneousDiscreteGroupoidRep</code> is used.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hd8 := HomogeneousGroupoid( Gd8, [ [-12,-11,-10], [-16,-15,-14] ] ); </span>
homogeneous groupoid with 2 pieces:
1:  single piece groupoid: &lt; d8, [ -16, -15, -14 ] &gt;
2:  single piece groupoid: &lt; d8, [ -12, -11, -10 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsHomogeneousDomainWithObjects(Hd8);               </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hc6 := HomogeneousDiscreteGroupoid( c6, [-7..-4] );</span>
homogeneous, discrete groupoid: &lt; c6, [ -7 .. -4 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentationsOfObject(Gd8);</span>
[ "IsComponentObjectRep", "IsAttributeStoringRep", "IsMWOSinglePieceRep" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentationsOfObject(Hd8);</span>
[ "IsComponentObjectRep", "IsAttributeStoringRep", "IsPiecesRep" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentationsOfObject(Hc6);</span>
[ "IsComponentObjectRep", "IsAttributeStoringRep", 
  "IsHomogeneousDiscreteGroupoidRep" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KnownTruePropertiesOfObject(Hc6); </span>
[ "CanEasilyCompareElements", "CanEasilySortElements", "IsDuplicateFree", 
  "IsAssociative", "IsCommutative", "IsDiscreteDomainWithObjects", 
  "IsHomogeneousDomainWithObjects" ]

</pre></div>

<p><a id="X831F3EBF7AD211DB" name="X831F3EBF7AD211DB"></a></p>

<h4>3.2 <span class="Heading">Groupoid elements; stars; costars and homsets</span></h4>

<p><a id="X7D028B3B8385ED07" name="X7D028B3B8385ED07"></a></p>

<h5>3.2-1 GroupoidElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GroupoidElement</code>( <var class="Arg">gpd</var>, <var class="Arg">elt</var>, <var class="Arg">tail</var>, <var class="Arg">head</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsElementOfGroupoid</code>( <var class="Arg">elt</var> )</td><td class="tdright">( property )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementOfArrow</code>( <var class="Arg">elt</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TailOfArrow</code>( <var class="Arg">elt</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeadOfArrow</code>( <var class="Arg">elt</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>A <em>groupoid element</em> <code class="code">e</code> is a triple consisting of a group element, <code class="code">ElementOfArrow(e)</code> or <code class="code">e![1]</code>; the tail (source) object, <code class="code">TailOfArrow(e)</code> or <code class="code">e![2]</code>; and the head (target) object, <code class="code">HeadOfArrow(e)</code> or <code class="code">e![3]</code>. Note that <code class="code">GroupoidElement</code> is essentially a synonym, in the groupoid case, for <code class="code">MultiplicativeElementWithObjects</code>.</p>

<p>As for elements in any magma with objects, groupoid elements have a <em>partial composition</em>: two elements may be multiplied when the head of the first coincides with the tail of the second.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e1 := GroupoidElement( Gd8, (1,2,3,4), -9, -8 );</span>
[(1,2,3,4) : -9 -&gt; -8]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e2 := GroupoidElement( Gd8, (1,3), -8, -7 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print( [ Arrowelt(e2), Arrowtail(e2), Arrowhead(e2) ], "\n" );</span>
[ (1,3), -8, -7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prod := e1*e2;</span>
[(1,2)(3,4) : -9 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e3 := GroupoidElement( Gd8, (2,4), -7, -9 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cycle := prod*e3;</span>
[(1,4,3,2) : -9 -&gt; -9]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cycle^2;</span>
[(1,3)(2,4) : -9 -&gt; -9]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order(cycle);</span>
4

</pre></div>

<p><a id="X7E30871D78B9F81C" name="X7E30871D78B9F81C"></a></p>

<h5>3.2-2 IdentityElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IdentityElement</code>( <var class="Arg">gpd</var>, <var class="Arg">obj</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The identity groupoid element <span class="SimpleMath">1_o</span> of <span class="SimpleMath">G</span> at object <span class="SimpleMath">o</span> is <span class="SimpleMath">(e:o -&gt; o)</span> where <span class="SimpleMath">e</span> is the identity element in the object group. The inverse <span class="SimpleMath">e^-1</span> of <span class="SimpleMath">e = (c : p -&gt; q)</span> is <span class="SimpleMath">(c^-1 : q -&gt; p)</span>, so that <span class="SimpleMath">e*e^-1=1_p</span> and <span class="SimpleMath">e^-1*e = 1_q</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i8 := IdentityElement( Gd8, -8 );</span>
[() : -8 -&gt; -8]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ e1*i8, i8*e1, e1^-1]; </span>
[ [(1,2,3,4) : -9 -&gt; -8], fail, [(1,4,3,2) : -8 -&gt; -9] ]

</pre></div>

<p><a id="X7B561BAE7D471C60" name="X7B561BAE7D471C60"></a></p>

<h5>3.2-3 ObjectStar</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ObjectStar</code>( <var class="Arg">gpd</var>, <var class="Arg">obj</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ObjectCostar</code>( <var class="Arg">gpd</var>, <var class="Arg">obj</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Homset</code>( <var class="Arg">gpd</var>, <var class="Arg">tail</var>, <var class="Arg">head</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The <em>star</em> at <code class="code">obj</code> is the set of groupoid elements which have <code class="code">obj</code> as tail, while the <em>costar</em> is the set of elements which have <code class="code">obj</code> as head. The <em>homset</em> from <code class="code">obj1</code> to <code class="code">obj2</code> is the set of elements with the specified tail and head, and so is bijective with the elements of the group. Thus every star and every costar is a union of homsets. The identity element at an object is a left identity for the star and a right identity for the costar at that object.</p>

<p>In order not to create unneccessary long lists, these operations return objects of type <code class="code">IsHomsetCosetsRep</code> for which an <code class="code">Iterator</code> is provided. (An <code class="code">Enumerator</code> is not yet implemented.)</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">star9 := ObjectStar( Gd8, -9 );</span>
&lt;star at [ -9 ] with group d8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( star9 ); </span>
24
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for e in star9 do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if ( Order( e![1] ) = 4 ) then Print( e, "\n" ); fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
[(1,4,3,2) : -9 -&gt; -9]
[(1,4,3,2) : -9 -&gt; -8]
[(1,4,3,2) : -9 -&gt; -7]
[(1,2,3,4) : -9 -&gt; -9]
[(1,2,3,4) : -9 -&gt; -8]
[(1,2,3,4) : -9 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">costar6 := ObjectCostar( Gc6, -6 );</span>
&lt;costar at [ -6 ] with group c6&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( costar6 ); </span>
6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hsetq8 := Homset( Gq8, -28, -27 );</span>
&lt;homset -28 -&gt; -27 with group q8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for e in hsetq8 do Print(e,"\n"); od;</span>
[&lt;identity&gt; of ... : -28 -&gt; -27]
[f3 : -28 -&gt; -27]
[f2 : -28 -&gt; -27]
[f2*f3 : -28 -&gt; -27]
[f1 : -28 -&gt; -27]
[f1*f3 : -28 -&gt; -27]
[f1*f2 : -28 -&gt; -27]
[f1*f2*f3 : -28 -&gt; -27]

</pre></div>

<p><a id="X7BDBA72C852C4625" name="X7BDBA72C852C4625"></a></p>

<h4>3.3 <span class="Heading">Subgroupoids</span></h4>

<p><a id="X80780D287EDDB7BB" name="X80780D287EDDB7BB"></a></p>

<h5>3.3-1 Subgroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Subgroupoid</code>( <var class="Arg">args</var> )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubgroupoidByPieces</code>( <var class="Arg">gpd</var>, <var class="Arg">obhoms</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSubgroupoid</code>( <var class="Arg">gpd</var>, <var class="Arg">sgpd</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FullSubgroupoid</code>( <var class="Arg">gpd</var>, <var class="Arg">obs</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MaximalDiscreteSubgroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DiscreteSubgroupoid</code>( <var class="Arg">gpd</var>, <var class="Arg">sgps</var>, <var class="Arg">obs</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FullTrivialSubgroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DiscreteTrivialSubgroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsWide</code>( <var class="Arg">gpd</var>, <var class="Arg">sgpd</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>A <em>subgroupoid</em> <code class="code">sgpd</code> of <code class="code">gpd</code> has as objects some subset of the objects of <code class="code">gpd</code>. It is <em>wide</em> if all the objects are included. It is <em>full</em> if, for any two objects in <code class="code">sgpd</code>, the <code class="code">Homset</code> is the same as that in <code class="code">gpd</code>. The elements of <code class="code">sgpd</code> are a subset of those of <code class="code">gpd</code>, closed under multiplication and with tail and head in the chosen object set.</p>

<p>There are a variety of constructors for a subgroupoid of a groupoid, and the most general is the operation <code class="code">SubgroupoidByPieces</code>. Its two parameters are a groupoid and a list of pieces, each piece being specified as a list <code class="code">[sgp,obs]</code>, where <code class="code">sgp</code> is a subgroup of the root group in that piece, and <code class="code">obs</code> is a subset of the objects in that piece. The <code class="code">FullSubgroupoid</code> of a groupoid <code class="code">gpd</code> on a subset <code class="code">obs</code> of its objects contains all the elements of <code class="code">gpd</code> with tail and head in <code class="code">obs</code>. A subgroupoid is <em>discrete</em> if it is a union of groups. The <code class="code">MaximalDiscreteSubgroupoid</code> of <code class="code">gpd</code> is the union of all the single-object full subgroupoids of <code class="code">gpd</code>. A <em>trivial subgroupoid</em> has trivial object groups, but need not be discrete. A single piece trivial groupoid is sometimes called a <em>tree groupoid</em>. (The term <em>identity subgroupoid</em> was used in versions up to 1.14.) The global function <code class="code">Subgroupoid</code> should call the appropriate operation.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c4 := Subgroup( d8, [ (1,2,3,4) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k4 := Subgroup( d8, [ (1,2)(3,4), (1,3)(2,4) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( c4, "c4" );  SetName( k4, "k4" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ud8 := Subgroupoid( Gd8, [ [ k4, [-9] ], [ c4, [-8,-7] ] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( Ud8, "Ud8" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Ud8 );</span>
groupoid with 2 pieces:
&lt; objects: [ -9 ]
    group: k4 = &lt;[ (1,2)(3,4), (1,3)(2,4) ]&gt; &gt;
&lt; objects: [ -8, -7 ]
    group: c4 = &lt;[ (1,2,3,4) ]&gt; &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ Parent( Ud8 ), IsWide( Gd8, Ud8 ) ]; </span>
[ Gd8, true ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">genf2b := List( GeneratorsOfGroup(f2), g -&gt; g^2 );</span>
[ f1^2, f2^2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f2b := Subgroup( f2, genf2b );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubgroupoidByPieces( U2, [ [q8,[-27]], [f2b,[-22]] ] );</span>
groupoid with 2 pieces:
1:  single piece groupoid: &lt; q8, [ -27 ] &gt;
2:  single piece groupoid: &lt; Group( [ f1^2, f2^2 ] ), [ -22 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubgroupoid( Gf2, Groupoid( f2b, [-22] ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FullSubgroupoid( U3, [-7,-6] );</span>
groupoid with 2 pieces:
1:  single piece groupoid: &lt; d8, [ -7 ] &gt;
2:  single piece groupoid: &lt; c6, [ -6 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DiscreteSubgroupoid( U3, [ c4, k4 ], [-9,-7] );</span>
groupoid with 2 pieces:
1:  single piece groupoid: &lt; c4, [ -9 ] &gt;
2:  single piece groupoid: &lt; k4, [ -7 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FullTrivialSubgroupoid( Ud8 );</span>
groupoid with 2 pieces:
1:  single piece groupoid: &lt; id(k4), [ -9 ] &gt;
2:  single piece groupoid: &lt; id(c4), [ -8, -7 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MaximalDiscreteSubgroupoid(U2);</span>
groupoid with 3 pieces:
1:  single piece groupoid: &lt; q8, [ -28 ] &gt;
2:  single piece groupoid: &lt; q8, [ -27 ] &gt;
3:  single piece groupoid: &lt; f2, [ -22 ] &gt;

</pre></div>

<p><a id="X873E0914871858E8" name="X873E0914871858E8"></a></p>

<h5>3.3-2 SubgroupoidWithRays</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubgroupoidWithRays</code>( <var class="Arg">gpd</var>, <var class="Arg">sgp</var>, <var class="Arg">rays</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RaysOfGroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>If groupoid <span class="SimpleMath">G</span> is of type <code class="code">IsDirectProductWithCompleteGraph</code> with group <span class="SimpleMath">g</span> and <span class="SimpleMath">n</span> objects, then a typical wide subgroupoid <span class="SimpleMath">H</span> of <span class="SimpleMath">G</span> is formed by choosing a subgroup <span class="SimpleMath">h</span> of <span class="SimpleMath">g</span> to be the object group at the root object <span class="SimpleMath">q</span>, and an element <span class="SimpleMath">r : q -&gt; p</span> for each of the objects <span class="SimpleMath">p</span>. The chosen loop element at <span class="SimpleMath">q</span> must be the identity element. These <span class="SimpleMath">n</span> elements are called the <em>rays</em> of the subgroupoid. The elements in the homset from <span class="SimpleMath">p</span> to <span class="SimpleMath">p'</span> have the form <span class="SimpleMath">r^-1xr'</span> for all rays <span class="SimpleMath">r,r'</span> and all <span class="SimpleMath">x</span> in <span class="SimpleMath">h</span>.</p>

<p>In the following example a subgroupoid with rays is to be constructed on four of the five objects. It is therefore necessary to construct the full subgroupoid on these four objects first.</p>

<p>It is also possible to construct a subgroupoid with rays of a subgroupoid with rays.</p>

<p>Note that the function <code class="code">Ancestor</code> provides an iteration of <code class="code">Parent</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hs4 := FullSubgroupoid( Gs4, [-14,-13,-12] );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( Hs4, "Hs4" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hd8a := SubgroupoidWithRays( Hs4, d8, [(),(2,3),(3,4)] );</span>
single piece groupoid with rays: &lt; d8, [ -14, -13, -12 ], [ (), (2,3), (3,4)
 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hs1413 := Homset( Hd8a, -14, -13 );</span>
&lt;homset -14 -&gt; -13 with group d8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for e in hs1413 do  Print(e,", "); od;  Print( "\n");</span>
[(2,3) : -14 -&gt; -13], [(1,2,4,3) : -14 -&gt; -13], [(1,4,2) : -14 -&gt; -13], [
(1,3,4) : -14 -&gt; -13], [(2,4,3) : -14 -&gt; -13], [(1,2,3) : -14 -&gt; -13], [
(1,4) : -14 -&gt; -13], [(1,3,4,2) : -14 -&gt; -13], 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hd8b := SubgroupoidWithRays( Hs4, d8, [(),(1,2,3),(1,2,4)] );</span>
single piece groupoid with rays: &lt; d8, [ -14, -13, -12 ],
[ (), (1,2,3), (1,2,4) ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hd8a = Hd8b; </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RaysOfGroupoid( Hd8b ); </span>
[ (), (1,2,3), (1,2,4) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Parent( Hd8a );</span>
Hs4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ancestor( Hd8a ); </span>
Gs4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fd8a := FullSubgroupoid( Hd8a, [-14,-13]);</span>
single piece groupoid with rays: &lt; d8, [ -14, -13 ], [ (), (2,3) ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fd8b := FullSubgroupoid( Hd8a, [-13,-12]);</span>
single piece groupoid with rays: &lt; Group( [ (1,3,2,4), (1,2) ] ), 
[ -13, -12 ], [ (), (2,4,3) ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fd8a := FullSubgroupoid( Hd8a, [-13,-12] );            </span>
single piece groupoid with rays: &lt; Group( [ (1,3,2,4), (1,2) ] ), 
[ -13, -12 ], [ (), (2,4,3) ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Kd8a := SubgroupoidWithRays( Fd8a, k4, [ (), (1,3) ] ); </span>
single piece groupoid with rays: &lt; k4, [ -13, -12 ], [ (), (1,3) ] &gt;

</pre></div>

<p><a id="X831AA9E8780235F2" name="X831AA9E8780235F2"></a></p>

<h4>3.4 <span class="Heading">Left, right and double cosets</span></h4>

<p><a id="X8412ABD57986B9FC" name="X8412ABD57986B9FC"></a></p>

<h5>3.4-1 RightCoset</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightCoset</code>( <var class="Arg">G</var>, <var class="Arg">U</var>, <var class="Arg">elt</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightCosetRepresentatives</code>( <var class="Arg">G</var>, <var class="Arg">U</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftCoset</code>( <var class="Arg">G</var>, <var class="Arg">U</var>, <var class="Arg">elt</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftCosetRepresentatives</code>( <var class="Arg">G</var>, <var class="Arg">U</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftCosetRepresentativesFromObject</code>( <var class="Arg">G</var>, <var class="Arg">U</var>, <var class="Arg">obj</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DoubleCoset</code>( <var class="Arg">G</var>, <var class="Arg">U</var>, <var class="Arg">elt</var>, <var class="Arg">V</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DoubleCosetRepresentatives</code>( <var class="Arg">G</var>, <var class="Arg">U</var>, <var class="Arg">V</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>If <code class="code">U</code> is a wide subgroupoid of <span class="SimpleMath">G</span>, the <em>right cosets</em> <span class="SimpleMath">Ug</span> of <span class="SimpleMath">U</span> in <span class="SimpleMath">G</span> are the equivalence classes for the relation on the elements of <span class="SimpleMath">G</span> where <span class="SimpleMath">g1</span> is related to <span class="SimpleMath">g2</span> if and only if <span class="SimpleMath">g2 = u*g1</span> for some element <span class="SimpleMath">u</span> of <span class="SimpleMath">U</span>. The right coset containing <span class="SimpleMath">g</span> is written <span class="SimpleMath">Ug</span>. These right cosets partition the costars of <span class="SimpleMath">G</span> and, in particular, the costar <span class="SimpleMath">U1_o</span> of <span class="SimpleMath">U</span> at object <span class="SimpleMath">o</span>, so that (unlike groups) <span class="SimpleMath">U</span> is itself a coset only when <span class="SimpleMath">G</span> has a single object.</p>

<p>The <em>right coset representatives</em> for <span class="SimpleMath">U</span> in <span class="SimpleMath">G</span> form a list containing one groupoid element for each coset where, in a particular piece of <span class="SimpleMath">U</span>, the group element chosen is the right coset representative of the group of <span class="SimpleMath">U</span> in the group of <span class="SimpleMath">G</span>.</p>

<p>Similarly, the <em>left cosets</em> <span class="SimpleMath">gU</span> refine the stars of <span class="SimpleMath">G</span>, while <em>double cosets</em> are unions of left cosets and right cosets. The operation <code class="code">LeftCosetRepresentativesFromObject( G, U, obj )</code> is used in Chapter 4, and returns only those representatives which have tail at <code class="code">obj</code>.</p>

<p>As with stars and homsets, these cosets are implemented with representation <code class="code">IsHomsetCosetsRep</code> and provided with an iterator. Note that, when <span class="SimpleMath">U</span> has more than one piece, cosets may have differing lengths.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">re2 := RightCoset( Gd8, Ud8, e2 );</span>
RightCoset(single piece groupoid: &lt; c4, [ -8, -7 ] &gt;,[(1,3) : -8 -&gt; -7])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for x in re2 do Print( x, "\n" ); od;</span>
[(1,3) : -8 -&gt; -7]
[(1,3) : -7 -&gt; -7]
[(2,4) : -8 -&gt; -7]
[(2,4) : -7 -&gt; -7]
[(1,4)(2,3) : -8 -&gt; -7]
[(1,4)(2,3) : -7 -&gt; -7]
[(1,2)(3,4) : -8 -&gt; -7]
[(1,2)(3,4) : -7 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rcrd8 := RightCosetRepresentatives( Gd8, Ud8 );</span>
[ [() : -9 -&gt; -9], [() : -9 -&gt; -8], [() : -9 -&gt; -7], [(2,4) : -9 -&gt; -9],
  [(2,4) : -9 -&gt; -8], [(2,4) : -9 -&gt; -7], [() : -8 -&gt; -9], [() : -8 -&gt; -8],
  [() : -8 -&gt; -7], [(2,4) : -8 -&gt; -9], [(2,4) : -8 -&gt; -8], [(2,4) : -8 -&gt; -7]
 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lcr7 := LeftCosetRepresentativesFromObject( Gd8, Ud8, -7 );</span>
[ [() : -7 -&gt; -9], [(2,4) : -7 -&gt; -9], [() : -7 -&gt; -8], [(2,4) : -7 -&gt; -8] ]

</pre></div>

<p><a id="X8653FC9786E3209A" name="X8653FC9786E3209A"></a></p>

<h4>3.5 <span class="Heading">Conjugation</span></h4>

<p><a id="X7ECA0B0984310646" name="X7ECA0B0984310646"></a></p>

<h5>3.5-1 ConjugateGroupoidElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConjugateGroupoidElement</code>( <var class="Arg">e1</var>, <var class="Arg">e</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>When <span class="SimpleMath">e = (c : p -&gt; q)</span> conjugation by <span class="SimpleMath">e</span> is the groupoid automorphism defined as follows. In the case <span class="SimpleMath">p ≠ q</span>,</p>


<ul>
<li><p>objects <span class="SimpleMath">p,q</span> are interchanged, and the remaining objects are fixed;</p>

</li>
<li><p>loops at <span class="SimpleMath">p,q</span>: <span class="SimpleMath">(b: p -&gt; p) ↦ (b^c : q -&gt; q)</span> and <span class="SimpleMath">(b: q -&gt; q) ↦ (b^c^-1} : p -&gt; p)</span>;</p>

</li>
<li><p>arrows between <span class="SimpleMath">p</span> and <span class="SimpleMath">q</span>: <span class="SimpleMath">(b : p -&gt; q) ↦ (c^-1bc^-1 : q -&gt; p)</span> and <span class="SimpleMath">(b : q -&gt; p) ↦ (cbc : p -&gt; q)</span>;</p>

</li>
<li><p>costar at <span class="SimpleMath">p,q</span>: <span class="SimpleMath">(b : r -&gt; p) ↦ (bc : r -&gt; q)</span> and <span class="SimpleMath">(b : r -&gt; q) ↦ (bc^-1 : r -&gt; p)</span>;</p>

</li>
<li><p>star at <span class="SimpleMath">p,q</span>: <span class="SimpleMath">(b : p -&gt; r) ↦ (c^-1b : -&gt; q)</span> and <span class="SimpleMath">(b : q -&gt; r) ↦ (cb : p -&gt; r)</span>;</p>

</li>
<li><p>the remaining arrows are unchanged.</p>

</li>
</ul>
<p>In the case <span class="SimpleMath">p=q</span> all the objects are fixed; loops at <span class="SimpleMath">p</span> are conjugated by <span class="SimpleMath">c</span>, <span class="SimpleMath">(b : p -&gt; p) ↦ (b^c : p -&gt; p)</span>; the rest of the costar and star at <span class="SimpleMath">p</span> are permuted, <span class="SimpleMath">(b : r -&gt; p) ↦ (bc : r -&gt; p)</span> and <span class="SimpleMath">(b : p -&gt; r) ↦ (c^-1b : p -&gt; r)</span>; the remaining arrows are unchanged.</p>

<p>The details of this construction may be found in <a href="chapBib.html#biBAlWe">[AW10]</a>.</p>

<p>(Note that it is more desirable to use the command <code class="code">e1^e2</code>, but it has not yet been possible to get this to work!)</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := GroupoidElement( Gd8, (1,3), -9, -9 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y := GroupoidElement( Gd8, (1,2,3,4), -8, -9 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := GroupoidElement( Gd8, (1,2)(3,4), -9, -7 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := GroupoidElement( Gd8, (1,2,3,4), -7, -8 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##  conjugation with elements x, y, and z in Gd8: </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateGroupoidElement(x,y);</span>
[(2,4) : -8 -&gt; -8]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateGroupoidElement(x,z);</span>
[(2,4) : -7 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateGroupoidElement(y,x);</span>
[() : -8 -&gt; -9]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateGroupoidElement(y,z);</span>
[(2,4) : -8 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateGroupoidElement(z,x);</span>
[(1,4,3,2) : -9 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateGroupoidElement(z,y);</span>
[(2,4) : -8 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateGroupoidElement(w,y);</span>
[(1,3)(2,4) : -7 -&gt; -9]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateGroupoidElement(w,z);</span>
[(1,3) : -9 -&gt; -8]

</pre></div>

<p><a id="X7C2727D285BA2EBE" name="X7C2727D285BA2EBE"></a></p>

<h5>3.5-2 SinglePieceGroupoidByGenerators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SinglePieceGroupoidByGenerators</code>( <var class="Arg">parent</var>, <var class="Arg">gens</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>A set of groupoid elements generates a groupoid by taking all possible products and inverses. So far, the only implementation is for the case of loops generating a group at an object <span class="SimpleMath">o</span> andf a set of rays from <span class="SimpleMath">o</span>, where <span class="SimpleMath">o</span> is <em>not</em> the least object. A suitably large supergroupoid, which must be a direct product with a complete graph, should be provided. This is the case needed for <code class="code">ConjugateGroupoid</code> in the following section. Other cases will be added as time permits.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := GroupoidElement( Gs4, (1,2,3), -15, -13 ); </span>
[(1,2,3) : -15 -&gt; -13]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gensa := GeneratorsOfGroupoid( Hd8a );</span>
[ [(1,2,3,4) : -14 -&gt; -14], [(1,3) : -14 -&gt; -14], [(2,3) : -14 -&gt; -13], 
  [(3,4) : -14 -&gt; -12] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">imsa := List( gensa, g -&gt; ConjugateGroupoidElement( g, u ) ); </span>
[ [(1,2,3,4) : -14 -&gt; -14], [(1,3) : -14 -&gt; -14], [(1,3) : -14 -&gt; -15], 
  [(3,4) : -14 -&gt; -12] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := SinglePieceGroupoidByGenerators( Gs4, imsa ); </span>
single piece groupoid with rays: &lt; Group( [ (1,4,3,2), (1,3) ] ), 
[ -15, -14, -12 ], [ (), (1,3), (1,4,3) ] &gt;

</pre></div>

<p><a id="X78218F357BFEDE82" name="X78218F357BFEDE82"></a></p>

<h5>3.5-3 ConjugateGroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConjugateGroupoid</code>( <var class="Arg">gpd</var>, <var class="Arg">e</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>When <span class="SimpleMath">H</span> is a subgroupoid of a groupoid <span class="SimpleMath">G</span> and <span class="SimpleMath">e</span> is an element of <span class="SimpleMath">G</span>, then the conjugate of <span class="SimpleMath">H</span> by <span class="SimpleMath">e</span> is the subgroupoid generated by the conjugates of the generators of <span class="SimpleMath">H</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateGroupoid( Hd8a, u^-1 ); </span>
single piece groupoid with rays: &lt; Group( [ (1,4,3,2), (1,3) ] ), 
[ -15, -14, -12 ], [ (), (1,3), (1,4,3) ] &gt;

</pre></div>

<p>More examples of all these operations may be found in the example file <code class="file">gpd/examples/gpd.g</code>.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
