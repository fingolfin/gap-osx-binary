<html><head><title>[ANUPQ] A Examples</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP007.htm">Previous</a>] [<a href = "theindex.htm">Index</a>]
<h1>A Examples</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP00A.htm#SECT001">The Relators Option</a>
<li> <A HREF="CHAP00A.htm#SECT002">The Identities Option and PqEvaluateIdentities Function</a>
<li> <A HREF="CHAP00A.htm#SECT003">A Large Example</a>
<li> <A HREF="CHAP00A.htm#SECT004">Developing descendants trees</a>
</ol><p>
<p>
There are a large number of  examples provided with the <font face="Gill Sans,Helvetica,Arial">ANUPQ</font> package. 
These  may  be  executed   or  displayed  via  the  function  <code>PqExample</code>
(see&nbsp;<a href="CHAP003.htm#SSEC004.4">PqExample</a>). Each example resides in a file of the same name in the
directory <code>examples</code>. Most of the  examples are translations to <font face="Gill Sans,Helvetica,Arial">GAP</font> of
examples  provided  for  the  <code>pq</code>  standalone  by  Eamonn  O'Brien;  the
standalone  examples  are   found  in  directories  <code>standalone/examples</code>
(<var>p</var>-quotient  and <var>p</var>-group  generation examples)  and <code>standalone/isom</code>
(standard  presentation  examples).   The  first  line  of  each  example
indicates its origin.  All the examples seen in  earlier chapters of this
manual are also  available as examples, in a  slightly modified form (the
example which  one can run  in order to  see something very close  to the
text  example ``live'' is  always indicated  near --  usually immediately
after -- the  text example). The format of  the (<code>PqExample</code>) examples is
such that they can be read by the standard <code>Read</code> function of <font face="Gill Sans,Helvetica,Arial">GAP</font>, but
certain features and comments are interpreted by the function <code>PqExample</code>
to do somewhat more than <code>Read</code> does. In particular, any function without
a <code>-i</code>, <code>-ni</code>  or <code>.g</code> suffix has both  a non-interactive and interactive
form; in these  cases, the default form is  the non-interactive form, and
giving <code>PqStart</code> as second argument generates the interactive form.
<p>
Running <code>PqExample</code> without an argument or with  a  non-existent  example
<code>Info</code>s the available examples and some hints on usage:
<p>
<pre>
gap&gt; PqExample();
#I                   PqExample Index (Table of Contents)
#I                   -----------------------------------
#I  This table of possible examples is displayed when calling `PqExample'
#I  with no arguments, or with the argument: "index" (meant in the  sense
#I  of ``list''), or with a non-existent example name.
#I  
#I  Examples that have a name ending in `-ni' are  non-interactive  only.
#I  Examples that have a  name  ending  in  `-i'  are  interactive  only.
#I  Examples with names ending in `.g' also have  only  one  form.  Other
#I  examples have both a non-interactive and an  interactive  form;  call
#I  `PqExample' with 2nd argument `PqStart' to get the  interactive  form
#I  of the example. The substring `PG' in an  example  name  indicates  a
#I  p-Group Generation example, `SP' indicates  a  Standard  Presentation
#I  example, `Rel' indicates it uses  the  `Relators'  option,  and  `Id'
#I  indicates it uses the `Identities' option.
#I  
#I  The following ANUPQ examples are available:
#I  
#I   p-Quotient examples:
#I    general:
#I     "Pq"                   "Pq-ni"                "PqEpimorphism"        
#I     "PqPCover"             "PqSupplementInnerAutomorphisms"
#I    2-groups:
#I     "2gp-Rel"              "2gp-Rel-i"            "2gp-a-Rel-i"
#I     "B2-4"                 "B2-4-Id"              "B2-8-i"
#I     "B4-4-i"               "B4-4-a-i"             "B5-4.g"
#I    3-groups:
#I     "3gp-Rel-i"            "3gp-a-Rel"            "3gp-a-Rel-i"
#I     "3gp-a-x-Rel-i"        "3gp-maxoccur-Rel-i"
#I    5-groups:
#I     "5gp-Rel-i"            "5gp-a-Rel-i"          "5gp-b-Rel-i"
#I     "5gp-c-Rel-i"          "5gp-metabelian-Rel-i" "5gp-maxoccur-Rel-i"
#I     "F2-5-i"               "B2-5-i"               "R2-5-i"
#I     "R2-5-x-i"             "B5-5-Engel3-Id"
#I    7-groups:
#I     "7gp-Rel-i"
#I    11-groups:
#I     "11gp-i"               "11gp-Rel-i"           "11gp-a-Rel-i"
#I     "11gp-3-Engel-Id"      "11gp-3-Engel-Id-i"
#I  
#I   p-Group Generation examples:
#I    general:
#I     "PqDescendants-1"      "PqDescendants-2"      "PqDescendants-3"
#I     "PqDescendants-1-i"
#I    2-groups:
#I     "2gp-PG-i"             "2gp-PG-2-i"           "2gp-PG-3-i"
#I     "2gp-PG-4-i"           "2gp-PG-e4-i"
#I     "PqDescendantsTreeCoclassOne-16-i"
#I    3-groups:
#I     "3gp-PG-i"             "3gp-PG-4-i"           "3gp-PG-x-i"
#I     "3gp-PG-x-1-i"         "PqDescendants-treetraverse-i"
#I     "PqDescendantsTreeCoclassOne-9-i"
#I    5-groups:
#I     "5gp-PG-i"             "Nott-PG-Rel-i"        "Nott-APG-Rel-i"
#I     "PqDescendantsTreeCoclassOne-25-i"
#I    7,11-groups:
#I     "7gp-PG-i"             "11gp-PG-i"
#I  
#I   Standard Presentation examples:
#I    general:
#I     "StandardPresentation" "StandardPresentation-i"
#I     "EpimorphismStandardPresentation"
#I     "EpimorphismStandardPresentation-i"           "IsIsomorphicPGroup-ni"
#I    2-groups:
#I     "2gp-SP-Rel-i"         "2gp-SP-1-Rel-i"       "2gp-SP-2-Rel-i"
#I     "2gp-SP-3-Rel-i"       "2gp-SP-4-Rel-i"       "2gp-SP-d-Rel-i"
#I     "gp-256-SP-Rel-i"      "B2-4-SP-i"            "G2-SP-Rel-i"
#I    3-groups:
#I     "3gp-SP-Rel-i"         "3gp-SP-1-Rel-i"       "3gp-SP-2-Rel-i"
#I     "3gp-SP-3-Rel-i"       "3gp-SP-4-Rel-i"       "G3-SP-Rel-i"
#I    5-groups:
#I     "5gp-SP-Rel-i"         "5gp-SP-a-Rel-i"       "5gp-SP-b-Rel-i"
#I     "5gp-SP-big-Rel-i"     "5gp-SP-d-Rel-i"       "G5-SP-Rel-i"
#I     "G5-SP-a-Rel-i"        "Nott-SP-Rel-i"
#I    7-groups:
#I     "7gp-SP-Rel-i"         "7gp-SP-a-Rel-i"       "7gp-SP-b-Rel-i"
#I    11-groups:
#I     "11gp-SP-a-i"          "11gp-SP-a-Rel-i"      "11gp-SP-a-Rel-1-i"
#I     "11gp-SP-b-i"          "11gp-SP-b-Rel-i"      "11gp-SP-c-Rel-i"
#I  
#I  Notes
#I  -----
#I  1. The example (first) argument of  `PqExample'  is  a  string;  each
#I     example above is in double quotes to remind you to include them.
#I  2. Some examples accept options. To find  out  whether  a  particular
#I     example accepts options, display it first (by including  `Display'
#I     as  last  argument)  which  will  also  indicate  how  `PqExample'
#I     interprets the options, e.g. `PqExample("11gp-SP-a-i", Display);'.
#I  3. Try `SetInfoLevel(InfoANUPQ, &lt;n&gt;);' for  some  &lt;n&gt;  in  [2  ..  4]
#I     before calling PqExample, to see what's going on behind the scenes.
#I  
</pre>
<p>
If on your terminal you are unable to  scroll  back,  an  alternative  to
typing <code>PqExample();</code> to see the displayed examples  is  to  use  on-line
help, i.e.&nbsp; you may type:
<p>
<pre>
gap&gt; ?anupq:examples
</pre>
<p>
which will display this appendix in a <font face="Gill Sans,Helvetica,Arial">GAP</font>  session.  If  you  are  not
fussed  about  the  order  in   which   the   examples   are   organised,
<code>AllPqExamples();</code> lists  the  available  examples  relatively  compactly
(see&nbsp;<a href="CHAP003.htm#SSEC004.5">AllPqExamples</a>).
<p>
In the remainder of this appendix  we  will  discuss  particular  aspects
related  to  the  <code>Relators</code>  (see&nbsp;<a href="CHAP006.htm#SSEC001.5">option  Relators</a>)  and  <code>Identities</code>
(see&nbsp;<a href="CHAP006.htm#SSEC001.8">option Identities</a>) options, and the construction of  the  Burnside
group <var>B(5, 4)</var>.
<p>
<p>
<h2><a name="SECT001">A.1 The Relators Option</a></h2>
<p><p>
The <code>Relators</code> option was included because computations  involving  words
containing commutators that  are  pre-expanded  by  <font face="Gill Sans,Helvetica,Arial">GAP</font>  before  being
passed to the <code>pq</code> program may run considerably  more  slowly,  than  the
same computations being  run  with  <font face="Gill Sans,Helvetica,Arial">GAP</font>  pre-expansions  avoided.  The
following examples demonstrate a case where the performance  hit  due  to
pre-expansion of commutators by <font face="Gill Sans,Helvetica,Arial">GAP</font> is a factor of order 100 (in order
to see timing information from the <code>pq</code> program, we set  the  <code>InfoANUPQ</code>
level to 2).
<p>
Firstly, we run the example that allows pre-expansion of commutators (the
function  <code>PqLeftNormComm</code>  is  provided   by   the   <font face="Gill Sans,Helvetica,Arial">ANUPQ</font>   package;
see&nbsp;<a href="CHAP007.htm#SSEC004.1">PqLeftNormComm</a>). Note  that  since  the  two  commutators  of  this
example are <strong>very</strong> long (taking more than an  page  to  print),  we  have
edited the output at this point.
<p>
<pre>
gap&gt; SetInfoLevel(InfoANUPQ, 2); #to see timing information
gap&gt; PqExample("11gp-i");
#I  #Example: "11gp-i" . . . based on: examples/11gp
#I  F, a, b, c, R, procId are local to `PqExample'
gap&gt; F := FreeGroup("a", "b", "c"); a := F.1; b := F.2; c := F.3;
&lt;free group on the generators [ a, b, c ]&gt;
a
b
c
gap&gt; R := [PqLeftNormComm([b, a, a, b, c])^11, 
&gt;          PqLeftNormComm([a, b, b, a, b, c])^11, (a * b)^11];
[ b^-1*a^-2*b^-1*a*b*a*b^-1*a^-1*b*a*b*a^-1*b^-1*a*b*a^-1*b^-1*a^-1*b*a^2*c^
    ... 22 lines deleted here ...
    -1*a*b*a^-1*b^-1*a^-1*b*a^2*b*c, b^-1*a^-1*b^-2*a^-1*b*a*b*a^-1*b^
    ... 43 lines deleted here ...
    -1*b^-1*a^-1*b*a*b^-1*a^-1*b^-1*a*b^2*a*b*c, 
  a*b*a*b*a*b*a*b*a*b*a*b*a*b*a*b*a*b*a*b*a*b ]
gap&gt; procId := PqStart(F/R : Prime := 11);
1
gap&gt; PqPcPresentation(procId : ClassBound := 7, 
&gt;                              OutputLevel := 1);
#I  Lower exponent-11 central series for [grp]
#I  Group: [grp] to lower exponent-11 central class 1 has order 11^3
#I  Group: [grp] to lower exponent-11 central class 2 has order 11^8
#I  Group: [grp] to lower exponent-11 central class 3 has order 11^19
#I  Group: [grp] to lower exponent-11 central class 4 has order 11^42
#I  Group: [grp] to lower exponent-11 central class 5 has order 11^98
#I  Group: [grp] to lower exponent-11 central class 6 has order 11^228
#I  Group: [grp] to lower exponent-11 central class 7 has order 11^563
#I  Computation of presentation took 27.04 seconds
gap&gt; PqSavePcPresentation(procId, ANUPQData.outfile);
#I  Variables used in `PqExample' are saved in `ANUPQData.example.vars'.
</pre>
<p>
Now we do the same calculation using the <code>Relators</code> option. In this  way,
the commutators are passed directly as strings to the  <code>pq</code>  program,  so
that <font face="Gill Sans,Helvetica,Arial">GAP</font> does not ``see'' them and pre-expand them.
<p>
<pre>
gap&gt; PqExample("11gp-Rel-i");
#I  #Example: "11gp-Rel-i" . . . based on: examples/11gp
#I  #(equivalent to "11gp-i" example but uses `Relators' option)
#I  F, rels, procId are local to `PqExample'
gap&gt; F := FreeGroup("a", "b", "c");
&lt;free group on the generators [ a, b, c ]&gt;
gap&gt; rels := ["[b, a, a, b, c]^11", "[a, b, b, a, b, c]^11", "(a * b)^11"];
[ "[b, a, a, b, c]^11", "[a, b, b, a, b, c]^11", "(a * b)^11" ]
gap&gt; procId := PqStart(F : Prime := 11, Relators := rels);
2
gap&gt; PqPcPresentation(procId : ClassBound := 7, 
&gt;                              OutputLevel := 1);
#I  Relators parsed ok.
#I  Lower exponent-11 central series for [grp]
#I  Group: [grp] to lower exponent-11 central class 1 has order 11^3
#I  Group: [grp] to lower exponent-11 central class 2 has order 11^8
#I  Group: [grp] to lower exponent-11 central class 3 has order 11^19
#I  Group: [grp] to lower exponent-11 central class 4 has order 11^42
#I  Group: [grp] to lower exponent-11 central class 5 has order 11^98
#I  Group: [grp] to lower exponent-11 central class 6 has order 11^228
#I  Group: [grp] to lower exponent-11 central class 7 has order 11^563
#I  Computation of presentation took 0.27 seconds
gap&gt; PqSavePcPresentation(procId, ANUPQData.outfile);
#I  Variables used in `PqExample' are saved in `ANUPQData.example.vars'.
</pre>
<p>
<p>
<h2><a name="SECT002">A.2 The Identities Option and PqEvaluateIdentities Function</a></h2>
<p><p>
Please pay heed  to  the  warnings  given  for  the  <code>Identities</code>  option
(see&nbsp;<a href="CHAP006.htm#SSEC001.8">option Identities</a>); it is written mainly at the <font face="Gill Sans,Helvetica,Arial">GAP</font>  level  and
is not particularly optimised. The  <code>Identities</code>  option  allows  one  to
compute <var>p</var>-quotients that satisfy an identity. A trivial example  better
done using the <code>Exponent</code> option, but which nevertheless demonstrates the
usage of the <code>Identities</code> option, is as follows:
<p>
<pre>
gap&gt; SetInfoLevel(InfoANUPQ, 1);
gap&gt; PqExample("B2-4-Id");
#I  #Example: "B2-4-Id" . . . alternative way to generate B(2, 4)
#I  #Generates B(2, 4) by using the `Identities' option
#I  #... this is not as efficient as using `Exponent' but
#I  #demonstrates the usage of the `Identities' option.
#I  F, f, procId are local to `PqExample'
gap&gt; F := FreeGroup("a", "b");
&lt;free group on the generators [ a, b ]&gt;
gap&gt; # All words w in the pc generators of B(2, 4) satisfy f(w) = 1 
gap&gt; f := w -&gt; w^4;
function( w ) ... end
gap&gt; Pq( F : Prime := 2, Identities := [ f ] );
#I  Class 1 with 2 generators.
#I  Class 2 with 5 generators.
#I  Class 3 with 7 generators.
#I  Class 4 with 10 generators.
#I  Class 5 with 12 generators.
#I  Class 5 with 12 generators.
&lt;pc group of size 4096 with 12 generators&gt;
#I  Variables used in `PqExample' are saved in `ANUPQData.example.vars'.
gap&gt; time; 
1400
</pre>
<p>
Note that the <code>time</code> statement gives the time in  milliseconds  spent  by
<font face="Gill Sans,Helvetica,Arial">GAP</font> in executing the <code>PqExample("B2-4-Id");</code> command  (i.e.&nbsp;everything
up to the <code>Info</code>-ing of the variables used), but over 90% of  that  time
is spent in the final <code>Pq</code> statement. The time spent by the <code>pq</code> program,
which is negligible anyway (you can check this  by  running  the  example
while the <code>InfoANUPQ</code> level is set to 2), is not counted by <code>time</code>.
<p>
Since the identity used in the above construction of <var>B(2, 4)</var> is just an
exponent law, the ``right'' way to  compute  it  is  via  the  <code>Exponent</code>
option (see&nbsp;<a href="CHAP006.htm#SSEC001.4">option Exponent</a>), which is implemented at the C  level  and
<strong>is</strong>  highly  optimised.   Consequently,   the   <code>Exponent</code>   option   is
significantly faster, generally by several orders of magnitude:
<p>
<pre>
gap&gt; SetInfoLevel(InfoANUPQ, 2); # to see time spent by the `pq' program
gap&gt; PqExample("B2-4");
#I  #Example: "B2-4" . . . the ``right'' way to generate B(2, 4)
#I  #Generates B(2, 4) by using the `Exponent' option
#I  F, procId are local to `PqExample'
gap&gt; F := FreeGroup("a", "b");
&lt;free group on the generators [ a, b ]&gt;
gap&gt; Pq( F : Prime := 2, Exponent := 4 );
#I  Computation of presentation took 0.00 seconds
&lt;pc group of size 4096 with 12 generators&gt;
#I  Variables used in `PqExample' are saved in `ANUPQData.example.vars'.
gap&gt; time; # time spent by GAP in executing `PqExample("B2-4");' 
50
</pre>
<p>
The following example uses the <code>Identities</code> option to compute  a  3-Engel
group for the prime 11. As is the case for the example  <code>"B2-4-Id"</code>,  the
example has both a non-interactive and an  interactive  form;  below,  we
demonstrate the interactive form.
<p>
<pre>
gap&gt; SetInfoLevel(InfoANUPQ, 1); # reset InfoANUPQ to default level
gap&gt; PqExample("11gp-3-Engel-Id", PqStart);
#I  #Example: "11gp-3-Engel-Id" . . . 3-Engel group for prime 11
#I  #Non-trivial example of using the `Identities' option
#I  F, a, b, G, f, procId, Q are local to `PqExample'
gap&gt; F := FreeGroup("a", "b"); a := F.1; b := F.2;
&lt;free group on the generators [ a, b ]&gt;
a
b
gap&gt; G := F/[ a^11, b^11 ];
&lt;fp group on the generators [ a, b ]&gt;
gap&gt; # All word pairs u, v in the pc generators of the 11-quotient Q of G 
gap&gt; # must satisfy the Engel identity: [u, v, v, v] = 1.
gap&gt; f := function(u, v) return PqLeftNormComm( [u, v, v, v] ); end;
function( u, v ) ... end
gap&gt; procId := PqStart( G );
3
gap&gt; Q := Pq( procId : Prime := 11, Identities := [ f ] );
#I  Class 1 with 2 generators.
#I  Class 2 with 3 generators.
#I  Class 3 with 5 generators.
#I  Class 3 with 5 generators.
&lt;pc group of size 161051 with 5 generators&gt;
gap&gt; # We do a ``sample'' check that pairs of elements of Q do satisfy
gap&gt; # the given identity:
gap&gt; f( Random(Q), Random(Q) );
&lt;identity&gt; of ...
gap&gt; f( Q.1, Q.2 );
&lt;identity&gt; of ...
#I  Variables used in `PqExample' are saved in `ANUPQData.example.vars'.
</pre>
<p>
The (interactive) call to <code>Pq</code>  above is essentially equivalent to a call
to <code>PqPcPresentation</code> with  the same arguments and options  followed by a
call to  <code>PqCurrentGroup</code>. Moreover,  the call to  <code>PqPcPresentation</code> (as
described in&nbsp;<a href="CHAP005.htm#SSEC004.10">PqPcPresentation</a>)  is equivalent to a ``class  1'' call to
<code>PqPcPresentation</code>  followed   by  the  requisite  number   of  calls  to
<code>PqNextClass</code>,   and    with   the   <code>Identities</code>    option   set,   both
<code>PqPcPresentation</code> and  <code>PqNextClass</code> ``quietly'' perform  the equivalent
of a <code>PqEvaluateIdentities</code> call. In  the following example we break down
the  <code>Pq</code> call  into its  low-level equivalents,  and set  and  unset the
<code>Identities</code> option  to show where <code>PqEvaluateIdentities</code>  fits into this
scheme.
<p>
<pre>
gap&gt; PqExample("11gp-3-Engel-Id-i");
#I  #Example: "11gp-3-Engel-Id-i" . . . 3-Engel grp for prime 11
#I  #Variation of "11gp-3-Engel-Id" broken down into its lower-level component
#I  #command parts.
#I  F, a, b, G, f, procId, Q are local to `PqExample'
gap&gt; F := FreeGroup("a", "b"); a := F.1; b := F.2;
&lt;free group on the generators [ a, b ]&gt;
a
b
gap&gt; G := F/[ a^11, b^11 ];
&lt;fp group on the generators [ a, b ]&gt;
gap&gt; # All word pairs u, v in the pc generators of the 11-quotient Q of G 
gap&gt; # must satisfy the Engel identity: [u, v, v, v] = 1.
gap&gt; f := function(u, v) return PqLeftNormComm( [u, v, v, v] ); end;
function( u, v ) ... end
gap&gt; procId := PqStart( G : Prime := 11 );
4
gap&gt; PqPcPresentation( procId : ClassBound := 1);
gap&gt; PqEvaluateIdentities( procId : Identities := [f] );
#I  Class 1 with 2 generators.
gap&gt; for c in [2 .. 4] do
&gt;      PqNextClass( procId : Identities := [] ); #reset `Identities' option
&gt;      PqEvaluateIdentities( procId : Identities := [f] );
&gt;    od;
#I  Class 2 with 3 generators.
#I  Class 3 with 5 generators.
#I  Class 3 with 5 generators.
gap&gt; Q := PqCurrentGroup( procId );
&lt;pc group of size 161051 with 5 generators&gt;
gap&gt; # We do a ``sample'' check that pairs of elements of Q do satisfy
gap&gt; # the given identity:
gap&gt; f( Random(Q), Random(Q) );
&lt;identity&gt; of ...
gap&gt; f( Q.1, Q.2 );
&lt;identity&gt; of ...
#I  Variables used in `PqExample' are saved in `ANUPQData.example.vars'.
</pre>
<p>
<p>
<h2><a name="SECT003">A.3 A Large Example</a></h2>
<p><p>
<a name = "I0"></a>

An example demonstrating how a large computation can be organised with the
<font face="Gill Sans,Helvetica,Arial">ANUPQ</font> package  is the computation of the Burnside group <var>B(5, 4)</var>, the
largest  group of  exponent  4 generated  by  5 elements.   It has  order
<var>2<sup>2728</sup></var>  and   lower  exponent-<var>p</var>  central  class   13.  The  example
<code>"B5-4.g"</code> computes  <var>B(5, 4)</var>;  it is based  on a <code>pq</code>  standalone input
file written by M.&nbsp;F.&nbsp;Newman.
<p>
To be able to do examples like this was part of the motivation to provide
access to the  low-level functions of the standalone  program from within
<font face="Gill Sans,Helvetica,Arial">GAP</font>.
<p>
Please note that the construction uses the knowledge gained by Newman and
O'Brien in their  initial  construction  of  <var>B(5,  4)</var>,  in  particular,
insight into the commutator structure of the group and the  knowledge  of
the <var>p</var>-central  class  and  the  order  of  <var>B(5,  4)</var>.  Therefore,  the
construction cannot be used to prove that <var>B(5, 4)</var>  has  the  order  and
class mentioned above. It is merely a reconstruction of the  group.  More
information is contained in the header of the file <code>examples/B5-4.g</code>.
<p>
<pre>
procId := PqStart( FreeGroup(5) : Exponent := 4, Prime := 2 );
Pq( procId : ClassBound := 2 );
PqSupplyAutomorphisms( procId,
      [
        [ [ 1, 1, 0, 0, 0],      # first automorphism
          [ 0, 1, 0, 0, 0],
          [ 0, 0, 1, 0, 0],
          [ 0, 0, 0, 1, 0],
          [ 0, 0, 0, 0, 1] ],

        [ [ 0, 0, 0, 0, 1],      # second automorphism
          [ 1, 0, 0, 0, 0],
          [ 0, 1, 0, 0, 0],
          [ 0, 0, 1, 0, 0],
          [ 0, 0, 0, 1, 0] ]
                             ] );;

Relations :=
  [ [],          ## class 1
    [],          ## class 2
    [],          ## class 3
    [],          ## class 4
    [],          ## class 5
    [],          ## class 6
    ## class 7     
    [ [ "x2","x1","x1","x3","x4","x4","x4" ] ],
    ## class 8
    [ [ "x2","x1","x1","x3","x4","x5","x5","x5" ] ],
    ## class 9
    [ [ "x2","x1","x1","x3","x4","x4","x5","x5","x5" ],
      [ "x2","x1","x1","x2","x3","x4","x5","x5","x5" ],
      [ "x2","x1","x1","x3","x3","x4","x5","x5","x5" ] ],
    ## class 10
    [ [ "x2","x1","x1","x2","x3","x3","x4","x5","x5","x5" ],
      [ "x2","x1","x1","x3","x3","x4","x4","x5","x5","x5" ] ],
    ## class 11
    [ [ "x2","x1","x1","x2","x3","x3","x4","x4","x5","x5","x5" ],
      [ "x2","x1","x1","x2","x3","x1","x3","x4","x2","x4","x3" ] ],
    ## class 12
    [ [ "x2","x1","x1","x2","x3","x1","x3","x4","x2","x5","x5","x5" ],
      [ "x2","x1","x1","x3","x2","x4","x3","x5","x4","x5","x5","x5" ] ],
    ## class 13
    [ [ "x2","x1","x1","x2","x3","x1","x3","x4","x2","x4","x5","x5","x5" 
        ] ]
];

for class in [ 3 .. 13 ] do
    Print( "Computing class ", class, "\n" );
    PqSetupTablesForNextClass( procId );

    for w in [ class, class-1 .. 7 ] do

        PqAddTails( procId, w );   
        PqDisplayPcPresentation( procId );

        if Relations[ w ] &lt;&gt; [] then
            # recalculate automorphisms
            PqExtendAutomorphisms( procId );

            for r in Relations[ w ] do
                Print( "Collecting ", r, "\n" );
                PqCommutator( procId, r, 1 );
                PqEchelonise( procId );
                PqApplyAutomorphisms( procId, 15 ); #queue factor = 15
            od;

            PqEliminateRedundantGenerators( procId );
        fi;   
        PqComputeTails( procId, w );
    od;
    PqDisplayPcPresentation( procId );

    smallclass := Minimum( class, 6 );
    for w in [ smallclass, smallclass-1 .. 2 ] do
        PqTails( procId, w );
    od;
    # recalculate automorphisms
    PqExtendAutomorphisms( procId );
    PqCollect( procId, "x5^4" );
    PqEchelonise( procId );
    PqApplyAutomorphisms( procId, 15 ); #queue factor = 15
    PqEliminateRedundantGenerators( procId );
    PqDisplayPcPresentation( procId );
od;
</pre>
<p>
<p>
<h2><a name="SECT004">A.4 Developing descendants trees</a></h2>
<p><p>
In the following example we will explore  the  3-groups  of  rank  2  and
3-coclass 1 up to 3-class 5.  This  will  be  done  using  the  <var>p</var>-group
generation machinery of the package. We start with the elementary abelian
3-group   of   rank   2.   From   within   <font face="Gill Sans,Helvetica,Arial">GAP</font>,   run   the    example
<code>"PqDescendants-treetraverse-i"</code> via <code>PqExample</code> (see&nbsp;<a href="CHAP003.htm#SSEC004.4">PqExample</a>).
<p>
<pre>
gap&gt; G := ElementaryAbelianGroup( 9 );
&lt;pc group of size 9 with 2 generators&gt;
gap&gt; procId := PqStart( G );
5
gap&gt; #
gap&gt; #  Below, we use the option StepSize in order to construct descendants
gap&gt; #  of coclass 1. This is equivalent to setting the StepSize to 1 in
gap&gt; #  each descendant calculation.
gap&gt; #
gap&gt; #  The elementary abelian group of order 9 has 3 descendants of
gap&gt; #  3-class 2 and 3-coclass 1, as the result of the next command
gap&gt; #  shows. 
gap&gt; #
gap&gt; PqDescendants( procId : StepSize := 1 );
[ &lt;pc group of size 27 with 3 generators&gt;, 
  &lt;pc group of size 27 with 3 generators&gt;, 
  &lt;pc group of size 27 with 3 generators&gt; ]
gap&gt; #
gap&gt; #  Now we will compute the descendants of coclass 1 for each of the
gap&gt; #  groups above. Then we will compute the descendants  of coclass 1
gap&gt; #  of each descendant and so  on.  Note  that the  pq program keeps
gap&gt; #  one file for each class at a time.  For example, the descendants
gap&gt; #  calculation for  the  second  group  of class  2  overwrites the
gap&gt; #  descendant file  obtained  from  the  first  group  of  class 2.
gap&gt; #  Hence,  we have to traverse the descendants tree  in depth first
gap&gt; #  order.
gap&gt; #
gap&gt; PqPGSetDescendantToPcp( procId, 2, 1 );
gap&gt; PqPGExtendAutomorphisms( procId );
gap&gt; PqPGConstructDescendants( procId : StepSize := 1 );
2
gap&gt; PqPGSetDescendantToPcp( procId, 3, 1 );
gap&gt; PqPGExtendAutomorphisms( procId );
gap&gt; PqPGConstructDescendants( procId : StepSize := 1 );
2
gap&gt; PqPGSetDescendantToPcp( procId, 4, 1 );
gap&gt; PqPGExtendAutomorphisms( procId );
gap&gt; PqPGConstructDescendants( procId : StepSize := 1 );
2
gap&gt; #
gap&gt; #  At this point we stop traversing the ``left most'' branch of the
gap&gt; #  descendants tree and move upwards.
gap&gt; #
gap&gt; PqPGSetDescendantToPcp( procId, 4, 2 );
gap&gt; PqPGExtendAutomorphisms( procId );
gap&gt; PqPGConstructDescendants( procId : StepSize := 1 );
#I  group restored from file is incapable
0
gap&gt; PqPGSetDescendantToPcp( procId, 3, 2 );
gap&gt; PqPGExtendAutomorphisms( procId );
gap&gt; PqPGConstructDescendants( procId : StepSize := 1 );
#I  group restored from file is incapable
0
gap&gt; #  
gap&gt; #  The computations above indicate that the descendants subtree under
gap&gt; #  the first descendant of the elementary abelian group of order 9
gap&gt; #  will have only one path of infinite length.
gap&gt; #
gap&gt; PqPGSetDescendantToPcp( procId, 2, 2 );
gap&gt; PqPGExtendAutomorphisms( procId );
gap&gt; PqPGConstructDescendants( procId : StepSize := 1 );
4
gap&gt; #
gap&gt; #  We get four descendants here, three of which will turn out to be
gap&gt; #  incapable, i.e., they have no descendants and are terminal nodes
gap&gt; #  in the descendants tree.
gap&gt; #
gap&gt; PqPGSetDescendantToPcp( procId, 2, 3 );
gap&gt; PqPGExtendAutomorphisms( procId );
gap&gt; PqPGConstructDescendants( procId : StepSize := 1 );
#I  group restored from file is incapable
0
gap&gt; #
gap&gt; #  The third descendant of class three is incapable.  Let us return
gap&gt; #  to the second descendant of class 2.
gap&gt; #
gap&gt; PqPGSetDescendantToPcp( procId, 2, 2 );
gap&gt; PqPGExtendAutomorphisms( procId );
gap&gt; PqPGConstructDescendants( procId : StepSize := 1 );
4
gap&gt; PqPGSetDescendantToPcp( procId, 3, 1 );
gap&gt; PqPGExtendAutomorphisms( procId );
gap&gt; PqPGConstructDescendants( procId : StepSize := 1 );
#I  group restored from file is incapable
0
gap&gt; PqPGSetDescendantToPcp( procId, 3, 2 );
gap&gt; PqPGExtendAutomorphisms( procId );
gap&gt; PqPGConstructDescendants( procId : StepSize := 1 );
#I  group restored from file is incapable
0
gap&gt; #
gap&gt; #  We skip the third descendant for the moment ... 
gap&gt; #
gap&gt; PqPGSetDescendantToPcp( procId, 3, 4 );
gap&gt; PqPGExtendAutomorphisms( procId );
gap&gt; PqPGConstructDescendants( procId : StepSize := 1 );
#I  group restored from file is incapable
0
gap&gt; #
gap&gt; #  ... and look at it now.
gap&gt; #
gap&gt; PqPGSetDescendantToPcp( procId, 3, 3 );
gap&gt; PqPGExtendAutomorphisms( procId );
gap&gt; PqPGConstructDescendants( procId : StepSize := 1 );
6
gap&gt; #
gap&gt; #  In this branch of the descendant tree we get 6 descendants of class
gap&gt; #  three.  Of those 5 will turn out to be incapable and one will have
gap&gt; #  7 descendants.
gap&gt; #
gap&gt; PqPGSetDescendantToPcp( procId, 4, 1 );
gap&gt; PqPGExtendAutomorphisms( procId );
gap&gt; PqPGConstructDescendants( procId : StepSize := 1 );
#I  group restored from file is incapable
0
gap&gt; PqPGSetDescendantToPcp( procId, 4, 2 );
gap&gt; PqPGExtendAutomorphisms( procId );
gap&gt; PqPGConstructDescendants( procId : StepSize := 1 );
7
gap&gt; PqPGSetDescendantToPcp( procId, 4, 3 );
gap&gt; PqPGExtendAutomorphisms( procId );
gap&gt; PqPGConstructDescendants( procId : StepSize := 1 );
#I  group restored from file is incapable
0
</pre>
<p>
To automate the above procedure to some extent we provide:
<p>
<a name = "SSEC004.1"></a>
<li><code>PqDescendantsTreeCoclassOne( </code><var>i</var><code> ) F</code>
<li><code>PqDescendantsTreeCoclassOne() F</code>
<p>
for the  <var>i</var>th  or  default  interactive  <font face="Gill Sans,Helvetica,Arial">ANUPQ</font>  process,  generate  a
descendant tree for the  group  of  the  process  (which  must  be  a  pc
<var>p</var>-group) consisting of descendants of <var>p</var>-coclass 1  and  extending  to
the class determined by the option <code>TreeDepth</code> (or 6  if  the  option  is
omitted). In an  <font face="Gill Sans,Helvetica,Arial">XGAP</font>  session,  a  graphical  representation  of  the
descendants tree appears  in  a  separate  window.  Subsequent  calls  to
<code>PqDescendantsTreeCoclassOne</code> for the same process may be used to  extend
the descendant tree from the last descendant  computed  that  itself  has
more than one descendant. <code>PqDescendantsTreeCoclassOne</code> also accepts  the
options  <code>CapableDescendants</code>  (or  <code>AllDescendants</code>)  and  any   options
accepted     by     the     interactive     <code>PqDescendants</code>      function
(see&nbsp;<a href="CHAP005.htm#SSEC003.6">PqDescendants!interactive</a>).
<p>
<strong>Notes</strong>
<p>
<ol>
<p>
<li>
<code>PqDescendantsTreeCoclassOne</code>    first    calls    <code>PqDescendants</code>.    If
<code>PqDescendants</code> has already been called for  the  process,  the  previous
value computed is used and a warning is <code>Info</code>-ed at <code>InfoANUPQ</code> level 1.
<p>
<li>
As each descendant is processed its unique  label  defined  by  the  <code>pq</code>
program and number of descendants is <code>Info</code>-ed at <code>InfoANUPQ</code> level 1.
<p>
<li>
<code>PqDescendantsTreeCoclassOne</code> is an  ``experimental''  function  that  is
included to demonstrate the sort of things that  are  possible  with  the
<var>p</var>-group generation machinery.
<p>
</ol>
<p>
Ignoring  the  extra  functionality  provided  in  an  <font face="Gill Sans,Helvetica,Arial">XGAP</font>   session,
<code>PqDescendantsTreeCoclassOne</code>, with one argument that is the index of  an
interactive <font face="Gill Sans,Helvetica,Arial">ANUPQ</font> process, is approximately equivalent to:
<p>
<pre>
PqDescendantsTreeCoclassOne := function( procId )
    local   des,  i;

    des := PqDescendants( procId : StepSize := 1 );
    RecurseDescendants( procId, 2, Length(des) );
end;
</pre>
<p>
where <code>RecurseDescendants</code> is (approximately) defined as follows:
<p>
<pre>
RecurseDescendants := function( procId, class, n )
    local   i,  nr;

    if class &gt; ValueOption("TreeDepth") then return; fi;

    for i in [1..n] do
        PqPGSetDescendantToPcp( procId, class, i );
        PqPGExtendAutomorphisms( procId );
        nr := PqPGConstructDescendants( procId : StepSize := 1 );
        Print( "Number of descendants of group ", i,
               " at class ", class, ": ", nr, "\n" );
        RecurseDescendants( procId, class+1, nr );
    od;
    return;
end;
</pre>
<p>
The  following  examples  (executed  via  <code>PqExample</code>;  see&nbsp;<a href="CHAP003.htm#SSEC004.4">PqExample</a>),
demonstrate the use of <code>PqDescendantsTreeCoclassOne</code>:
<p>
<p>
<dl compact>
<p>
<dt><code>"PqDescendantsTreeCoclassOne-9-i"</code><dd>
approximately does example <code>"PqDescendants-treetraverse-i"</code> again  using
<code>PqDescendantsTreeCoclassOne</code>;
<p>
<dt><code>"PqDescendantsTreeCoclassOne-16-i"</code><dd>
uses the option <code>CapableDescendants</code>; and
<p>
<dt><code>"PqDescendantsTreeCoclassOne-25-i"</code><dd>
calculates all descendants by omitting the <code>CapableDescendants</code> option.
<p>
</dl>
<p>
The numbers <code>9</code>, <code>16</code> and <code>25</code> respectively, indicate the  order  of  the
elementary  abelian  group  to  which  <code>PqDescendantsTreeCoclassOne</code>   is
applied for these examples.
<p>
<p>
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP007.htm">Previous</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>ANUPQ manual<br>November 2013
</address></body></html>