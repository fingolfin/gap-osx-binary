  
  [1X2 Cones and semigroups[0X
  
  
  [1X2.1 Cones[0X
  
  This section introduces the [5Xtoric[0m commands which deal with cones and related
  combinatorial-geometric  objects.  Recall,  a  [12Xcone[0m  is  a  strongly  convex
  polyhedral cone ([Ful93], page 4).
  
  [1X2.1-1 InsideCone[0m
  
  [2X> InsideCone( [0X[3Xv, L[0X[2X ) _______________________________________________[0Xfunction
  
  This  command  returns `true` if the vector [3Xv[0m belongs to the interior of the
  (strongly convex polyhedral) cone generated by the vectors in [3XL[0m.
  
  This  procedure  does  not check if [3XL[0m generates a strongly convex polyhedral
  cone.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> L:=[[1,0,0],[1,1,0],[1,1,1],[1,0,1]];; v:=[0,0,1];;[0X
    [4Xgap> InsideCone(v,L);[0X
    [4Xfalse[0X
    [4Xgap> L:=[[1,0],[3,4]];;[0X
    [4Xgap> v:=[1,-7]; InsideCone(v,L);[0X
    [4X[ 1, -7 ][0X
    [4Xfalse[0X
    [4Xgap> v:=[4,-3]; InsideCone(v,L);[0X
    [4X[ 4, -3 ][0X
    [4Xfalse[0X
    [4Xgap> v:=[4,-4]; InsideCone(v,L);[0X
    [4X[ 4, -4 ][0X
    [4Xfalse[0X
    [4Xgap> v:=[4,1]; InsideCone(v,L);[0X
    [4X[ 4, 1 ][0X
    [4Xtrue[0X
  [4X------------------------------------------------------------------[0X
  
  [1X2.1-2 InDualCone[0m
  
  [2X> InDualCone( [0X[3Xv, L[0X[2X ) _______________________________________________[0Xfunction
  
  This  command  returns `true` if [3Xv[0m belongs to the dual of the cone generated
  by the vectors in [3XL[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> L:=[[1,0,0],[1,1,0],[1,1,1],[1,0,1]];; v:=[0,0,1];;[0X
    [4Xgap> InDualCone(v,L);[0X
    [4Xtrue[0X
    [4Xgap> L:=[[1,0],[3,4]];[0X
    [4X[ [ 1, 0 ], [ 3, 4 ] ][0X
    [4Xgap> v:=[1,-7]; InDualCone(v,L);[0X
    [4X[ 1, -7 ][0X
    [4Xfalse[0X
    [4Xgap> v:=[4,-3]; InDualCone(v,L);[0X
    [4X[ 4, -3 ][0X
    [4Xtrue[0X
    [4Xgap> v:=[4,-4]; InDualCone(v,L);[0X
    [4X[ 4, -4 ][0X
    [4Xfalse[0X
    [4Xgap> v:=[4,1]; InDualCone(v,L);[0X
    [4X[ 4, 1 ][0X
    [4Xtrue[0X
  [4X------------------------------------------------------------------[0X
  
  [1X2.1-3 PolytopeLatticePoints[0m
  
  [2X> PolytopeLatticePoints( [0X[3XA, Perps[0X[2X ) ________________________________[0Xfunction
  
  [13XInput[0m:   [3XPerps[0m=[v_1,...,v_k]   is  the  list  of  ``inward  normal"  vectors
  perpendicular  to  the walls of a polytope P in the vector space L_0^*otimes
  Q,
  [3XA[0m=[a_1,...,a_k]  is  a k-tuple of integers, where a_i denotes the amount the
  i-th  ``wall"  (defined  by the normal v_i) is shifted from the origin (each
  a_i is assumed non-negative).
  For   example,   the  polytope  P  with  faces  [10X[x=0,  x=a,  y=0,  y=b][0m  has
  [3XPerps[0m=[[1,0],[-1,0],[0,1],[0,-1]] and [3XA[0m=[0,a,0,b].
  [13XOutput[0m: the list of points in P cap L_0^*.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> Perps:=[[1,0],[-1,0],[0,1],[0,-1]];[0X
    [4X[ [ 1, 0 ], [ -1, 0 ], [ 0, 1 ], [ 0, -1 ] ][0X
    [4Xgap> A:=[0,4,0,3];[0X
    [4X[ 0, 4, 0, 3 ][0X
    [4Xgap> PolytopeLatticePoints(A,Perps);[0X
    [4X[ [ 0, 0 ], [ 0, 1 ], [ 0, 2 ], [ 0, 3 ], [ 1, 0 ], [ 1, 1 ], [ 1, 2 ],[0X
    [4X  [ 1, 3 ], [ 2, 0 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], [ 3, 0 ], [ 3, 1 ],[0X
    [4X  [ 3, 2 ], [ 3, 3 ], [ 4, 0 ], [ 4, 1 ], [ 4, 2 ], [ 4, 3 ] ][0X
    [4Xgap> Length(last);[0X
    [4X20[0X
  [4X------------------------------------------------------------------[0X
  
  [1X2.1-4 Faces[0m
  
  [2X> Faces( [0X[3XRays[0X[2X ) ____________________________________________________[0Xfunction
  
  [13XInput[0m: [3XRays[0m is a list of rays for the fan Delta
  [13XOutput[0m: All the normals to the faces (hyperplanes of the cone).
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> Cones1:=[[[2,-1],[-1,2]],[[-1,2],[-1,-1]],[[-1,-1],[2,-1]]];;[0X
    [4Xgap> Faces(Cones1[1]);[0X
    [4X[ [ 1/2, 1 ], [ 2, 1 ] ][0X
    [4Xgap> Faces(Cones1[2]);[0X
    [4X[ [ -2, -1 ], [ -1, 1 ] ][0X
    [4Xgap> Cones2:=[[[ 2,0,0],[0,2,0],[0,0,2]], [[2,0,0], [0,2,0], [2,-2,1],[1,2,-2]]];;[0X
    [4Xgap> Faces(Cones2[1]);[0X
    [4X[ [ 0, 0, 1 ], [ 0, 1, 0 ], [ 1, 0, 0 ] ][0X
    [4Xgap> Faces(Cones2[2]);[0X
    [4X[ [ 1/3, 5/6, 1 ], [ 1/2, 0, -1 ], [ 2, 0, 1 ] ][0X
    [4Xgap>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X2.1-5 ConesOfFan[0m
  
  [2X> ConesOfFan( [0X[3XDelta, k[0X[2X ) ___________________________________________[0Xfunction
  
  [13XInput[0m: [3XDelta[0m is the fan of cones,
  [3Xk[0m is the dimension of the cones desired.
  [13XOutput[0m: The [3Xk[0m-dimensional cones in the fan.
  
  [1X2.1-6 NumberOfConesOfFan[0m
  
  [2X> NumberOfConesOfFan( [0X[3XDelta, k[0X[2X ) ___________________________________[0Xfunction
  
  [13XInput[0m: [3XDelta[0m is the fan of cones in V=Q^n,
  [3Xk[0m is the dimension of the cones counted.
  [13XOutput[0m: The number of [3Xk[0m-dimensional cones in the fan.
  
  Idea:  The  fan  [3XDelta[0m  is  represented  as a set of maximal cones. For each
  maximal  cone, look at the [3Xk[0m-dimensional faces obtained by taking n choose [3Xk[0m
  subsets  of  the  rays describing the cone. Certain of these [3Xk[0m-subsets yield
  the desired cones.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> Delta0:=[ [ [2,0,0],[0,2,0],[0,0,2] ], [ [2,0,0],[0,2,0],[2,-2,1],[1,2,-2] ] ];;[0X
    [4Xgap>[0X
    [4Xgap> NumberOfConesOfFan(Delta0,2);[0X
    [4X6[0X
    [4Xgap> ConesOfFan(Delta0,2);[0X
    [4X[ [ [ 0, 0, 2 ], [ 0, 2, 0 ] ], [ [ 0, 0, 2 ], [ 2, 0, 0 ] ], [0X
    [4X  [ [ 0, 2, 0 ], [ 1, 2, -2 ] ], [ [ 0, 2, 0 ], [ 2, -2, 1 ] ],[0X
    [4X  [ [ 0, 2, 0 ], [ 2, 0, 0 ] ], [ [ 1, 2, -2 ], [ 2, -2, 1 ] ] ][0X
    [4Xgap> ConesOfFan(Delta0,1);[0X
    [4X[ [ [ 0, 0, 2 ] ], [ [ 0, 2, 0 ] ], [ [ 1, 2, -2 ] ], [0X
    [4X  [ [ 2, -2, 1 ] ], [ [ 2, 0, 0 ] ] ][0X
    [4Xgap> NumberOfConesOfFan(Delta0,1);[0X
    [4X5[0X
    [4X[0X
  [4X------------------------------------------------------------------[0X
  
  [1X2.1-7 ToricStar[0m
  
  [2X> ToricStar( [0X[3Xsigma, Delta[0X[2X ) ________________________________________[0Xfunction
  
  [13XInput[0m:  [3Xsigma[0m is a cone in the fan, represented by its set of maximal (i.e.,
  highest dimensional) cones.
  [3XDelta[0m is the fan of cones in V=Q^n.
  [13XOutput[0m:  The star of the cone [3Xsigma[0m in [3XDelta[0m, i.e., the cones tau which have
  [3Xsigma[0m as a face.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> MaxCones:=[ [ [2,0,0],[0,2,0],[0,0,2] ], [0X
    [4X                 [ [2,0,0],[0,2,0],[2,-2,1],[1,2,-2] ] ];;[0X
    [4Xgap> #this is the set of maximal cones in the fan Delta[0X
    [4Xgap> ToricStar([[1,0]],MaxCones);[0X
    [4X[  ][0X
    [4Xgap> ToricStar([[2,0,0],[0,2,0]],MaxCones);[0X
    [4X[ [ [ 0, 2, 0 ], [ 2, 0, 0 ] ], [ [ 2, 0, 0 ], [ 0, 2, 0 ], [ 0, 0, 2 ] ],[0X
    [4X  [ [ 2, 0, 0 ], [ 0, 2, 0 ], [ 2, -2, 1 ], [ 1, 2, -2 ] ] ][0X
    [4Xgap>[0X
    [4Xgap> MaxCones:=[ [ [2,0,0],[0,2,0],[0,0,2] ], [ [2,0,0],[0,2,0],[1,1,-2] ] ];;[0X
    [4Xgap> ToricStar([[2,0,0],[0,2,0]],MaxCones);[0X
    [4X[ [ [ 0, 2, 0 ], [ 2, 0, 0 ] ], [ [ 2, 0, 0 ], [ 0, 2, 0 ], [ 0, 0, 2 ] ],[0X
    [4X  [ [ 2, 0, 0 ], [ 0, 2, 0 ], [ 1, 1, -2 ] ] ][0X
    [4Xgap> ToricStar([[1,0]],MaxCones);[0X
    [4X[  ][0X
    [4X[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X2.2 Semigroups[0X
  
  [1X2.2-1 DualSemigroupGenerators[0m
  
  [2X> DualSemigroupGenerators( [0X[3XL[0X[2X ) _____________________________________[0Xfunction
  
  [13XInput[0m: [3XL[0m is a list of integral n-vectors generating a cone sigma.
  [13XOutput[0m: the generators of S_sigma,
  
  Idea:  let M be the maximum of the absolute values of the coordinates of the
  [3XL[0m[i]'s,  for  each  vector  v  in  [1..M]^n,  test  if v is in the dual cone
  sigma^*.  If so, add v to list of possible generators. Once this for loop is
  finished,  one can check this list for redundant generators. The trick is to
  simply  omit those elements which are of the form d_1+d_2, where d_1 and d_2
  are ``small" elements in the integral dual cone.
  
  This  program  is  not  very  efficient  and  should  not be used in ``large
  examples''  involving  semigroups  with ``many'' generators. For example, if
  you       take       [3XL:=[[1,2,3,4],[0,1,0,7],[3,1,0,2],[0,0,1,0]];[0m      then
  [10XDualSemigroupGenerators(L);[0m can exhaust GAP's memory allocation.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> L:=[[1,0],[3,4]];; DualSemigroupGenerators([[1,0],[3,4]]);[0X
    [4X[ [ 0, 0 ], [ 0, 1 ], [ 1, 0 ], [ 2, -1 ], [ 3, -2 ], [ 4, -3 ] ][0X
    [4Xgap> L:=[[1,0,0],[1,1,0],[1,1,1],[1,0,1]];;[0X
    [4Xgap> DualSemigroupGenerators(L);[0X
    [4X[ [ 0, 0, 0 ], [ 0, 0, 1 ], [ 0, 1, 0 ], [ 1, -1, 0 ], [ 1, 0, -1 ] ][0X
    [4Xgap>[0X
  [4X------------------------------------------------------------------[0X
  
