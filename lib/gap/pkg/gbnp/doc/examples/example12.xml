gap> ######################### BEGIN COPYRIGHT MESSAGE #########################
GBNP - computing Gröbner bases of noncommutative polynomials
Copyright 2001-2010 by Arjeh M. Cohen, Dié A.H. Gijsbers, Jan Willem
Knopper, Chris Krook. Address: Discrete Algebra and Geometry (DAM) group
at the Department of Mathematics and Computer Science of Eindhoven
University of Technology.

For acknowledgements see the manual. The manual can be found in several
formats in the doc subdirectory of the GBNP distribution. The
acknowledgements formatted as text can be found in the file chap0.txt.

GBNP is free software; you can redistribute it and/or modify it under
the terms of the Lesser GNU General Public License as published by the
Free Software Foundation (FSF); either version 2.1 of the License, or
(at your option) any later version. For details, see the file 'LGPL' in
the doc subdirectory of the GBNP distribution or see the FSF's own site:
http://www.gnu.org/licenses/lgpl.html
gap> ########################## END COPYRIGHT MESSAGE ##########################

gap> ### file created by jwk - wo 30 mei 2007 11:35:01 CEST

<#GAPDoc Label="Example12">
<Section Label="Example12"><Heading>The universal enveloping
algebra of a Lie algebra</Heading>
Consider the Lie algebra with generators <M>e</M>, <M>f</M> and
<M>h</M>, and relations <M>[e,f]=h</M>, <M>[e,h]=-2e</M>, <M>[f,h]=2f</M>.
This is the well-known Lie algebra of type A<M>_1</M>.
We construct the corresponding universal enveloping algebra of this
Lie algebra
and show how one can prove that <M>f^2</M> belongs to the ideal
generated by <M>e^2</M> in that associative algebra.
The example is from Knopper's report <Cite Key="Knopper2004"/>.
<P/>
First load the package and set the standard infolevel <Ref
InfoClass="InfoGBNP" Style="Text"/> to 0 and the time infolevel <Ref
Func="InfoGBNPTime" Style="Text"/> to 0 (for more information about the info
level, see Chapter <Ref Chap="Info"/>).

<Listing><![CDATA[
gap> LoadPackage("GBNP");
-----------------------------------------------------------------------------
Loading  GBNP 1.0.1 (Non-commutative Gröbner bases)
by A.M. Cohen (http://www.win.tue.nl/~amc) and
   J.W. Knopper (J.W.Knopper@tue.nl).
-----------------------------------------------------------------------------
true

gap> SetInfoLevel(InfoGBNP,0);
gap> SetInfoLevel(InfoGBNPTime,0);
]]></Listing>

Then define the algebra and enter the relations as polynomials in GAP. 

<Listing><![CDATA[
gap> A:=FreeAssociativeAlgebraWithOne(Rationals, "e", "f", "h");
<algebra-with-one over Rationals, with 3 generators>
gap> e:=A.e;; f:=A.f;; h:=A.h;; o:=One(A);;
gap> uerels:=[f*e-e*f+h,h*e-e*h-2*e,h*f-f*h+2*f];
[ (1)*h+(-1)*e*f+(1)*f*e, (-2)*e+(-1)*e*h+(1)*h*e, (2)*f+(-1)*f*h+(1)*h*f ]
]]></Listing>

The relations can be converted to NP format (see <Ref Sect="NP"/>) with the
function <Ref Func="GP2NPList" Style="Text"/> and can be subsequently
displayed with <Ref Func="PrintNPList" Style="Text"/>.

<Listing><![CDATA[
gap> uerelsNP:=GP2NPList(uerels);;
gap> PrintNPList(uerelsNP);
 ba - ab + c 
 ca - ac - 2a 
 cb - bc + 2b 
]]></Listing>

Now configure printing in such a way that this algebra is used with the
function <Ref Func="GBNP.ConfigPrint" Style="Text"/>.

<Listing><![CDATA[
gap> GBNP.ConfigPrint(A);
]]></Listing>

The set is actually a Gröbner basis, as can be verified by calculating the
Gröbner basis with <Ref Func="SGrobner"
Style="Text"/>.

<Listing><![CDATA[
gap> GB:=SGrobner(uerelsNP);;
gap> PrintNPList(GB);
 fe - ef + h 
 he - eh - 2e 
 hf - fh + 2f 
]]></Listing>

Determine whether the quotient algebra is finite dimensional by means of <Ref
Func="FinCheckQA" Style="Text"/>, with arguments the leading monomials of
<C>GB</C> and 3, the number of variables involved. The leading monomials of
<C>GB</C> are found by invoking <Ref Func="LMonsNP" Style="Text"/>.

<Listing><![CDATA[
gap> F:=LMonsNP(GB);
[ [ 2, 1 ], [ 3, 1 ], [ 3, 2 ] ]
gap> FinCheckQA(F,3);
false
]]></Listing>



Adding the relation <M>e^2=0</M> results in a finite quotient algebra.

<Listing><![CDATA[
gap> extendedrels:=[f*e-e*f+h,h*e-e*h-2*e,h*f-f*h+2*f,e^2];
[ (1)*h+(-1)*e*f+(1)*f*e, (-2)*e+(-1)*e*h+(1)*h*e, (2)*f+(-1)*f*h+(1)*h*f, 
  (1)*e^2 ]
gap> extendedrelsNP:=GP2NPList(extendedrels);;
]]></Listing>

With the function <Ref Func="SGrobnerTrace" Style="Text"/> it is possible to
calculate a Gröbner basis with trace information.

<Listing><![CDATA[
gap> GB:=SGrobnerTrace(extendedrelsNP);;
]]></Listing>

The Gröbner basis can now be displayed with <Ref Func="PrintNPListTrace"
Style="Text"/>.

<Listing><![CDATA[
gap> PrintNPListTrace(GB);
 e^2 
 eh + e 
 fe - ef + h 
 f^2 
 fh - f 
 he - e 
 hf + f 
 h^2 - 2ef + h 
]]></Listing>

Note the fourth relation: <M>f^2=0</M>. To view a trace one can use the
function <Ref Func="PrintTracePol" Style="Text"/>.

<Listing><![CDATA[
gap> PrintTracePol(GB[4]);
- 1/12G(1)f^2 + 1/12f^2G(1) + 1/12f^2G(1)h - 1/6fG(1)hf + 1/12G(1)hf^2 + 1/
24G(1)ef^3 + 1/24eG(1)f^3 - 1/8fG(1)ef^2 - 1/8feG(1)f^2 + 1/8f^2G(1)ef + 1/
8f^2eG(1)f - 1/24f^3G(1)e - 1/24f^3eG(1) - 1/24G(2)f^3 + 1/8fG(2)f^2 - 1/
8f^2G(2)f + 1/24f^3G(2) + 1/4G(3)f + 1/4fG(3) + 1/12fG(3)h + 1/12fhG(3) - 1/
12G(3)hf - 1/12hG(3)f - 1/12eG(3)f^2 + 1/6feG(3)f - 1/12f^2eG(3) + 1/24G(
4)f^4 - 1/6fG(4)f^3 + 1/4f^2G(4)f^2 - 1/6f^3G(4)f + 1/24f^4G(4) 
]]></Listing>

This proves that <M>f^2=0</M> is a consequence of <M>e^2=0</M> in the
universal enveloping algebra of the simple Lie algebra of type A<M>_1</M>.
<P/>

The function <Ref Func="StrongNormalFormTraceDiff" Style="Text"/> can be used
to trace the difference between an element and its strong normal form in the
terms of <C>extendedrels</C>. Apparently, in the first example the strong
normal form of <C>r</C> is <C>r - s.pol=0</C>.

<Listing><![CDATA[
gap> r := [[[2,2,2,2,1,1,1,1]],[1]];;
gap> s := StrongNormalFormTraceDiff(r, GB);;

gap> PrintNP(s.pol);
 f^4e^4 
gap> PrintTracePol(s);
 f^4G(4)e^2 
gap> PrintNP(AddNP(r,s.pol,1,-1));
 0
]]></Listing>

One more example where the strong normal form is not zero.

<Listing><![CDATA[
gap> r := [[[3,3,3]],[1]];;
gap> s := StrongNormalFormTraceDiff(r, GB);;

gap> PrintNP(s.pol);
 h^3 - h 
gap> PrintTracePol(s);
- G(1) - 1/2G(1)ef - 1/6eG(1)f + 1/3efG(1) + 1/2fG(1)e + 1/2feG(1) + G(
1)h^2 + 1/2G(1)efh + 1/2eG(1)fh + 1/3efG(1)h - 1/3eG(1)hf - 1/2fG(1)eh - 1/
2feG(1)h - 1/6eG(1)ef^2 - 1/6e^2G(1)f^2 + 1/3efG(1)ef + 1/3efeG(1)f - 1/
6ef^2G(1)e - 1/6ef^2eG(1) + 1/2G(2)f - 1/2fG(2) - 1/2G(2)fh + 1/2fG(2)h + 1/
6eG(2)f^2 - 1/3efG(2)f + 1/6ef^2G(2) - 2/3eG(3)h + 1/3ehG(3) + 1/3e^2G(3)f - 
1/3efeG(3) - 1/2G(4)f^2 + fG(4)f - 1/2f^2G(4) + 1/2G(4)f^2h - fG(4)fh + 1/
2f^2G(4)h - 1/6eG(4)f^3 + 1/2efG(4)f^2 - 1/2ef^2G(4)f + 1/6ef^3G(4) 
gap> PrintNP(AddNP(r,s.pol,1,-1));
 h 
]]></Listing>

</Section>
<#/GAPDoc>
