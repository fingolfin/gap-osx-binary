% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}
\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}
\definecolor{FuncColor}{rgb}{1.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,1.0}

\usepackage{fancyvrb}

\usepackage{pslatex}

\usepackage[pdftex=true,
        a4paper=true,bookmarks=false,pdftitle={Written with GAPDoc},
        pdfcreator={LaTeX with hyperref package / GAPDoc},
        colorlinks=true,backref=page,breaklinks=true,linkcolor=RoyalBlue,
        citecolor=RoyalGreen,filecolor=RoyalRed,
        urlcolor=RoyalRed,pagecolor=RoyalBlue]{hyperref}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages


\newcommand{\GAP}{\textsf{GAP}}

\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\begin{center}{\Huge \textbf{Documentation on the \textsf{NMO} package\mbox{}}}\\[1cm]
\hypersetup{pdftitle=Documentation on the \textsf{NMO} package}
\markright{\scriptsize \mbox{}\hfill Documentation on the \textsf{NMO} package \hfill\mbox{}}
{Version 1.0\mbox{}}\\[1cm]
{7 January 2010\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\large \textbf{Randall E. Cone \mbox{}}}\\
\hypersetup{pdfauthor=Randall E. Cone }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{Randall E. Cone } --- Email: \href{mailto://rcone@math.vt.edu} {\texttt{rcone@math.vt.edu}}}\\

\noindent \textbf{Address: }\begin{minipage}[t]{8cm}\noindent
Virginia Tech\\
 Blacksburg, VA, 24060, USA \end{minipage}
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 1 ]}
 
\begin{itemize}
\item Our immense gratitude to the authors of GBNP for allowing us to make a small
contribution.
\item Equal gratitude to Dr. Ed Green for his help as mentor and advisor, in both
this project and many others.
\end{itemize}
 \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 2 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{NMO}}\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7D8A0B897AE65E23}{}
{
 
\section{\textcolor{Chapter }{Introduction}}\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
 What follows is a description of the largely experimental project of providing
arbitrary monomial orderings to the \textsf{GBNP} package. The addition of the orderings comes in the form of a library, and a
patch to \textsf{GBNP}; the patching process being called at the \textsf{GBNP} user's discretion. 

 More precisely, after a user creates a monomial ordering via the \textsf{NMO} library functions, a routine is called which overwrites the two \textsf{GBNP} functions "LtNP" and "GtNP". In \textsf{GBNP}, these latter two functions are explicitly length-lexicographic monomial
comparison functions, and are used in GBNP's Gr{\"o}bner Basis routines.
Therefore \textsf{NMO} allows for the creation of arbitrary monomial ordering comparison functions,
which, after the patching process, will be used by GBNP in place of its native
comparison functions. 

 \textsf{NMO} is an acronym for Noncommutative Monomial Orderings. Such orderings play a key
role in research surrounding noncommutative Gr{\"o}bner basis theory; see \cite{Green1997}, \cite{TCS::Mora1994:131}. This package is geared primarily toward the use and study of noncommutative
(associative) free algebras with identity, over computational fields. We have
done our best to write code that treats a more general class of algebras, but
the routines have not been as extensively tested in those cases. Users of the
package are encouraged to provide constructive feedback about this issue or
any others; we have open ears to ways to better these research tools. 

 Flexibility in the creation and use of noncommutative monomial orderings has
been our guiding principle in writing \textsf{NMO}. For example, two (or more) orderings can be chained together to form new
orderings. It should be noted, however, that efficiency has also been
considered in the design of \textsf{NMO} for commonly used monomial orderings for noncommutative rings (e.g. length
left-lexicographic). That is to say, some monomial orderings that occur
regularly in the study of noncommutative algebras have already been included
in \textsf{NMO}. 

 Throughout this chapter, methods and functions are generally classed as \emph{External} and \emph{Internal} routines. \emph{External} routines are methods and functions that will be most useful to the average
user, and generally work directly with native \textsf{GAP} algebraic objects. \emph{Internal} routines usually concern backend operations and mechanisms, and are often
related to operations involving \emph{NP representations} of \textsf{GAP} algebraic elements, or they are related to attributes of monomial orderings.
Many examples of basic code use are provided; with some examples following the
reference material for the functions or methods involved. }

 
\section{\textcolor{Chapter }{NMO Files within GBNP}}\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X8282EFF97FA1752A}{}
{
 Per the \textsf{GAP} package standard, \textsf{NMO} library code is read in via the file \texttt{gbnp/read.g}. The following gives brief descriptions of each of the files loaded by \texttt{gbnp/read.g}, all of which reside in the \texttt{gbnp/lib/nmo/} subdirectory: 
\begin{itemize}
\item  \texttt{ncalgebra.gd}

 Sets up some nice categories and filters in \textsf{GAP}.
\item \texttt{ncordmachine.g*}

 Code for creating the new \textsf{GAP} family of noncommutative monomial orderings, as well as its attending
(internal) machinery.
\item \texttt{ncorderings.g*}

 Sets up actual noncommutative monomial orderings. This is where some specific
example routines for monomial orderings are included. The less-than functions
determining monomial orderings should be collected here, e.g. the length
left-lexicographic ordering is here.
\item \texttt{ncinterface.g*}

 These files provide the interface to comparison routines for determining
equivalence, less-than, and greater-than comparison between two algebraic
elements under a given \textsf{NMO} ordering.
\item \texttt{ncutils.g*}

 Helpful utility routines, such as: patching \textsf{GBNP} for use with an \textsf{NMO} ordering, unpatching \textsf{GBNP}, as well as a `String' routine for elements of an associative algebra not
already covered in \textsf{GAP}.
\end{itemize}
 There is a documentation directory in \texttt{gbnp/doc/nmo} wherein the \textsf{GAPDoc} source for this chapter may be found. 

 Finally, there is an examples directory in \texttt{gbnp/doc/examples/nmo} where the plain \textsf{GAP} source can be found for the examples in the Quickstart section of this
chapter. }

 
\section{\textcolor{Chapter }{Quickstart}}\logpage{[ 1, 3, 0 ]}
\hyperdef{L}{X7F83DF528480AEA3}{}
{
 This Quickstart assumes you've already installed the \textsf{GBNP} package in its proper home. If that's yet to be done, please see the \textsf{GBNP} package manual for installation instructions. 

 If the user wishes, cutting and pasting the commands which directly follow the \textsf{GAP} prompt \texttt{gap{\textgreater}} is a good way to become familiar with \textsf{NMO} via the examples below. Alternatively, code for the following examples may be
found in \texttt{gbnp/doc/examples/nmo/example0*.g}. 

 This Quickstart covers specific use of the \textsf{NMO} package's functionality as pertaining to computing noncommutative Gr{\"o}bner
bases for various examples. There are \textsf{NMO} user-level routines beyond these Gr{\"o}bner basis applications that may be of
interest, all of which are documented in later sections. 
\subsection{\textcolor{Chapter }{NMO Example 1}}\logpage{[ 1, 3, 1 ]}
\hyperdef{L}{X7B44E73581910347}{}
{
 Example 1 is taken from Dr. Edward Green's paper ``Noncommutative Gr{\"o}bner Bases, and Projective Resolutions'', and is referenced as ``Example 2.7'' there; please see \cite{Green1997} for more information. 

 Load the \textsf{GBNP} package with: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> LoadPackage("gbnp");
  true
\end{Verbatim}
 Create a noncommutative free algebra on 4 generators over the Rationals in \textsf{GAP}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> A := FreeAssociativeAlgebraWithOne(Rationals,"a","b","c","d");
  <algebra-with-one over Rationals, with 4 generators> 
\end{Verbatim}
 Label the generators of the algebra: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> a := A.a; b := A.b; c := A.c; d := A.d;
  (1)*a
  (1)*b
  (1)*c
  (1)*d
\end{Verbatim}
 Set up our polynomials, and convert them to \textsf{GBNP} NP format: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> polys := [c*d*a*b-c*b,b*c-d*a];
  [ (-1)*c*b+(1)*c*d*a*b, (1)*b*c+(-1)*d*a ]
  gap> reps := GP2NPList(polys);
  [ [ [ [ 3, 4, 1, 2 ], [ 3, 2 ] ], [ 1, -1 ] ],
             [ [ [ 4, 1 ], [ 2, 3 ] ], [ -1, 1 ] ] ]
\end{Verbatim}
 Compute the Gr{\"o}bner basis via \textsf{GBNP} using its default (length left-lexicographic) ordering; that is, without
patching \textsf{GBNP} with an \textsf{NMO} ordering: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> gbreps := Grobner(reps);;
  gap> gb := NP2GPList(gbreps,A);
  [ (1)*d*a+(-1)*b*c, (1)*c*b*c*b+(-1)*c*b ]
\end{Verbatim}
 Create length left-lexicographic ordering, with generators ordered: a
{\textless} b {\textless} c {\textless} d. Note: this is the default ordering
of generators by \textsf{NMO}, if none is provided: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> ml := NCMonomialLeftLengthLexOrdering(A);
  NCMonomialLeftLengthLexicographicOrdering([ (1)*a, (1)*b, (1)*c, (1)*d ])
\end{Verbatim}
 Patch \textsf{GBNP} with the ordering \texttt{ml}, and then run the same example. We should get the same answer as above: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> PatchGBNP(ml);
  LtNP patched.
  GtNP patched.
  gap> gbreps := Grobner(reps);;
  gap> gb := NP2GPList(gbreps,A);
  [ (1)*d*a+(-1)*b*c, (1)*c*b*c*b+(-1)*c*b ]
\end{Verbatim}
 Create a Length-Lexicographic ordering on the generators such that d
{\textless} c {\textless} b {\textless} a: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> ml2 := NCMonomialLeftLengthLexOrdering(A,[4,3,2,1]);
  NCMonomialLeftLengthLexicographicOrdering([ (1)*d, (1)*c, (1)*b, (1)*a ])
\end{Verbatim}
 Compute the Gr{\"o}bner basis with respect to this new ordering on the same
algebra: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> PatchGBNP(ml2);
  LtNP patched.
  GtNP patched.
  gap> gbreps2 := SGrobner(reps);;
  gap> gb2 := NP2GPList(gbreps2,A);
  [ (1)*b*c+(-1)*d*a, (1)*c*d*a*b+(-1)*c*b, (1)*d*a*d*a*b+(-1)*d*a*b,
    (1)*c*d*a*d*a+(-1)*c*d*a, (1)*d*a*d*a*d*a+(-1)*d*a*d*a ]
\end{Verbatim}
 }

 
\subsection{\textcolor{Chapter }{NMO Example 2}}\logpage{[ 1, 3, 2 ]}
\hyperdef{L}{X82D4722E7A4DA58B}{}
{
 This example is the same as Example 1 above, except that the length and
left-lexicographic orderings are created independently and then chained to
form the usual length left-lexicographic ordering. Hence, all results should
be the same. Note: we assume from this point forward in all further examples
that GBNP is loaded. 

 Create a noncommutative free algebra on 4 generators over the Rationals,
label, and set up the example: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> A := FreeAssociativeAlgebraWithOne(Rationals,"a","b","c","d");;
  gap> a := A.a;; b := A.b;; c := A.c;; d := A.d;;
  gap> polys := [c*d*a*b-c*b,b*c-d*a];;
  gap> reps := GP2NPList(polys);;
\end{Verbatim}
 Create left-lexicographic ordering with a {\textless} b {\textless} c
{\textless} d: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> lexord := NCMonomialLeftLexicographicOrdering(A);
  NCMonomialLeftLexicographicOrdering([ (1)*a, (1)*b, (1)*c, (1)*d ])
\end{Verbatim}
 Create a length ordering on monomials in $A$, with ties broken by the lexicographic order \texttt{lexord}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> lenlex := NCMonomialLengthOrdering(A,lexord);
  NCMonomialLengthOrdering([ (1)*a, (1)*b, (1)*c, (1)*d ])
\end{Verbatim}
 Patch \textsf{GBNP} and proceed with our example: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> PatchGBNP(lenlex);;
  LtNP patched.
  GtNP patched.
  gap> gbreps := Grobner(reps);;
  gap> gb := NP2GPList(gbreps,A);
  [ (1)*d*a+(-1)*b*c, (1)*c*b*c*b+(-1)*c*b ]
\end{Verbatim}
 Now, proceed similarly, with the lexicographic order such that d {\textless} c
{\textless} b {\textless} a: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> lexord2 := NCMonomialLeftLexicographicOrdering(A,[4,3,2,1]);
  NCMonomialLeftLexicographicOrdering([ (1)*d, (1)*c, (1)*b, (1)*a ])
  gap> lenlex2 := NCMonomialLengthOrdering(A,lexord2);
  NCMonomialLengthOrdering([ (1)*a, (1)*b, (1)*c, (1)*d ])
  gap> PatchGBNP(lenlex2);;
  LtNP patched.
  GtNP patched.
  gap> gbreps2 := Grobner(reps);;
  gap> gb2 := NP2GPList(gbreps2,A);
  [ (1)*b*c+(-1)*d*a, (1)*c*d*a*b+(-1)*c*b, (1)*d*a*d*a*b+(-1)*d*a*b,
    (1)*c*d*a*d*a+(-1)*c*d*a, (1)*d*a*d*a*d*a+(-1)*d*a*d*a ]
\end{Verbatim}
 An important point can be made here. Notice that when the \texttt{lenlex2} length ordering is created, a lexicographic (generator) ordering table is
assigned internally to the ordering since one was not provided to it. This is
merely a convenience for lexicographically-dependent orderings, and in the
case of the length order, it is not used. Only the lex table for \texttt{lexord2} is ever used. Some clarification may be provided in examining: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> HasNextOrdering(lenlex2);
  true
  gap> NextOrdering(lenlex2);
  NCMonomialLeftLexicographicOrdering([ (1)*d, (1)*c, (1)*b, (1)*a ])
  gap> LexicographicTable(NextOrdering(lenlex2));
  [ (1)*d, (1)*c, (1)*b, (1)*a ]
\end{Verbatim}
 }

 
\subsection{\textcolor{Chapter }{NMO Example 3}}\logpage{[ 1, 3, 3 ]}
\hyperdef{L}{X85A401278794C813}{}
{
 Example 3 is taken from the book ``Ideals, Varieties, and Algorithms'', (\cite{CLO97}, Example 2, p. 93-94); it is a commutative example. 

 First, we set up the problem and find a Gr{\"o}bner basis with respect to the
length left-lexicographic ordering implicitly assumed in \textsf{GBNP}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> A := FreeAssociativeAlgebraWithOne(Rationals,"x","y","z");;
  gap> x := A.x;; y := A.y;; z := A.z;; id := One(A);;
  gap> polys := [ x^2 + y^2 + z^2 - id, x^2 + z^2 - y, x-z,
  >            x*y-y*x, x*z-z*x, y*z-z*y];;
  gap> reps := GP2NPList(polys);;
  gap> gb := Grobner(reps);;
  gap> NP2GPList(gb,A);
  [ (1)*z+(-1)*x, (1)*x^2+(-1/2)*y, (1)*y*x+(-1)*x*y,
    (1)*y^2+(2)*x^2+(-1)*<identity ...> ]
\end{Verbatim}
 The example, as presented in the book, uses a left-lexicographic ordering with
z {\textless} y {\textless} x. We create the ordering in \textsf{NMO}, patch \textsf{GBNP}, and get the result expected: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> ml := NCMonomialLeftLexicographicOrdering(A,[3,2,1]);
  NCMonomialLeftLexicographicOrdering([ (1)*z, (1)*y, (1)*x ])
  gap> PatchGBNP(ml);
  LtNP patched.
  GtNP patched.
  gap> gb := Grobner(reps);;
  gap> NP2GPList(gb,A);
  [ (1)*z^4+(1/2)*z^2+(-1/4)*<identity ...>, (1)*y+(-2)*z^2, (1)*x+(-1)*z ]
\end{Verbatim}
 }

 
\subsection{\textcolor{Chapter }{NMO Example 4}}\logpage{[ 1, 3, 4 ]}
\hyperdef{L}{X7C42487D8043F876}{}
{
 Example 4 was taken from page 339 of the book ``Some Tapas of Computer Algebra'' by A.M. Cohen, H. Cuypers, H. Sterk, \cite{CohenCuypersSterk1999}; it also appears as Example 6 in the \textsf{GBNP} example set. 

 A noncommutative free algebra on 6 generators over the Rationals is created in \textsf{GAP}, and the generators are labeled: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> A := FreeAssociativeAlgebraWithOne(Rationals,"a","b","c","d","e","f");;
  gap> a := A.a;; b := A.b;; c := A.c;; d := A.d;; e := A.e;; f := A.f;;
\end{Verbatim}
 Set up list of noncommutative polynomials: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> polys := [ e*a, a^3 + f*a, a^9 + c*a^3, a^81 + c*a^9 + d*a^3,
  >            a^27 + d*a^81 + e*a^9 + f*a^3, b + c*a^27 + e*a^81 + f*a^9,
  >            c*b + d*a^27 + f*a^81, a + d*b + e*a^27, c*a + e*b + f*a^27,
  >            d*a + f*b, b^3 - b, a*b - b*a, a*c - c*a, a*d - d*a,
  >            a*e - e*a, a*f - f*a, b*c - c*b, b*d - d*b, b*e - e*b,
  >            b*f - f*b, c*d - d*c, c*e - e*c, c*f - f*c, d*e - e*d,
  >            d*f - f*d, e*f - f*e
  > ];;
  gap> reps := GP2NPList(polys);;
\end{Verbatim}
 Create a length left-lex ordering with the following (default) ordering on the
generators a {\textless} b {\textless} c {\textless} d {\textless} e
{\textless} f: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> ml := NCMonomialLeftLengthLexOrdering(A);
  NCMonomialLeftLengthLexicographicOrdering([ (1)*a, (1)*b, (1)*c, (1)*d,
     (1)*e, (1)*f ])
\end{Verbatim}
 Patch \textsf{GBNP} and compute the Gr{\"o}bner basis with respect to the ordering \texttt{ml}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> PatchGBNP(ml);
  LtNP patched.
  GtNP patched.
  gap> gb := Grobner(reps);;
  gap> NP2GPList(gb,A);
  [ (1)*a, (1)*b, (1)*d*c+(-1)*c*d, (1)*e*c+(-1)*c*e,
    (1)*e*d+(-1)*d*e, (1)*f*c+(-1)*c*f,
    (1)*f*d+(-1)*d*f, (1)*f*e+(-1)*e*f ]
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Orderings}}\logpage{[ 1, 4, 0 ]}
\hyperdef{L}{X7E4AAA7382D42361}{}
{
 This section describes the current orderings built into the \textsf{GAP} package \textsf{NMO}, and describes some of the internals of the machinery involved. 

 
\subsection{\textcolor{Chapter }{Internals}}\logpage{[ 1, 4, 1 ]}
\hyperdef{L}{X7AE05C0578857310}{}
{
 The orderings portion of \textsf{NMO} is divided codewise into the files \texttt{ncordmachine.gd, ncordmachine.gi} and \texttt{ncorderings.gd, ncorderings.gi}. The former file pair contains code to set up the machinery to create new
monomial orderings on noncommutative algebras, whereas the latter sets up
actual orderings. We will first describe the creation and use of length
lexicographic ordering, afterward describing more of the details of the new \textsf{GAP} family `NoncommutativeMonomialOrdering'. 

 The \textsf{NMO} package was built with the mindset of allowing great flexibility in creating
new monomial orderings on noncommutative algebras. All that is required to
install a new ordering is to create two \textsf{GAP} functions that determine less-than comparisons (one non-indexed, and one
indexed) and then call \texttt{InstallNoncommutativeMonomialOrdering} with the comparison functions as arguments. The comparison functions should be
written to compare simple lists of integers, these lists representing
monomials as in \textsf{GBNP}'s `NP' format, or the letter representation format in \textsf{GAP} (see "The External Representation for Associative Words" in the \textsf{GAP} reference manual). An example follows the description of the function \texttt{InstallNoncommutativeMonomialOrdering}. 

 A bit of explanation is due here to address the added complexity introduced by
requiring that two functions \texttt{({\textless}function{\textgreater}, {\textless}function2{\textgreater})} need be supplied to \texttt{InstallNoncommutativeMonomialOrdering} to create an ordering. The first function \texttt{{\textless}function{\textgreater}} should be responsible for comparing two given monomial list representations in
their unadultered forms. The second, indexed, function \texttt{{\textless}function2{\textgreater}} should be capable of using a provided index list corresponding to an order on
generators, based on a different lexicographic ordering. This accomplishes
something worthwhile: two orderings with different lexicographic tables can be
applied to the same algebra in \textsf{GAP}. 

 One more caveat: \texttt{InstallNoncommutativeMonomialOrdering} will create a default lexicographic table for all orderings, despite whether
or not it will be used in the comparison function. It does this only out of
convenience and ease of use. 

 For example, in the creation of the following left-lex ordering, which is
installed via the \texttt{InstallNoncommutativeMonomialOrdering} function, a default ordering of a {\textless} b {\textless} c is created for \texttt{ml} even though an ordering on the generators is not provided: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> A := FreeAssociativeAlgebraWithOne(Rationals,"a","b","c");
  <algebra-with-one over Rationals, with 3 generators>
  gap> lexord := NCMonomialLeftLexicographicOrdering(A);
  NCMonomialLeftLexicographicOrdering([ (1)*a, (1)*b, (1)*c ])
\end{Verbatim}
 Notice next that when an ordering on the generators is provided, it is
utilized in the creation of the ordering: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> lexord2 := NCMonomialLeftLexicographicOrdering(A,[2,3,1]);
  NCMonomialLeftLexicographicOrdering([ (1)*b, (1)*c, (1)*a ])
\end{Verbatim}
 }

 
\subsection{\textcolor{Chapter }{Internal Routines}}\logpage{[ 1, 4, 2 ]}
\hyperdef{L}{X785C92247DF27D6C}{}
{
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{InstallNoncommutativeMonomialOrdering({\slshape {\textless}string{\textgreater}, {\textless}function{\textgreater}, {\textless}function2{\textgreater}})\index{InstallNoncommutativeMonomialOrdering@\texttt{InstallNoncommutativeMonomialOrdering}}
\label{InstallNoncommutativeMonomialOrdering}
}\hfill{\scriptsize (function)}}\\


 Given a name \texttt{{\textless}string{\textgreater}}, a direct comparison function \texttt{{\textless}function{\textgreater}}, and an indexed comparison function \texttt{{\textless}function2{\textgreater}}, \texttt{InstallNoncommutativeMonomialOrdering} will install a monomial ordering function to allow the creation of a monomial
ordering based on the provided functions. 

 For example, we create a length ordering by setting up the two comparison
functions, choosing a name for the ordering type and then calling \texttt{InstallNoncommutativeMonomialOrdering}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
    gap> f1 := function(a,b,aux)
    >   return Length(a) < Length(b);
    > end;
    function( a, b, aux ) ... end
    gap> f2 := function(a,b,aux,idx)
    >   return Length(a) < Length(b);
    > end;
    function( a, b, aux, idx ) ... end
    
    DeclareGlobalFunction("lenOrdering");
    InstallNoncommutativeMonomialOrdering("lenOrdering",f1,f2);
    
\end{Verbatim}
 Now we create an ordering based on this new function, and make some simple
comparisons. (Note: we are passing in an empty \texttt{aux} table since it is not being used. Also, the comparison function is the
non-indexed version since we determined no lex order on the generators): 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
    gap> A := FreeAssociativeAlgebraWithOne(Rationals,"a","b","c");
    <algebra-with-one over Rationals, with 3 generators>
    gap> ml := lenOrdering(A);
    lenOrdering([ (1)*a, (1)*b, (1)*c ])
    gap>
    gap> LtFunctionListRep(ml)([1,2],[1,1,1],[]);
    true
    gap> LtFunctionListRep(ml)([1,1],[],[]);
    false
    
\end{Verbatim}
 

 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsNoncommutativeMonomialOrdering({\slshape {\textless}obj{\textgreater}})\index{IsNoncommutativeMonomialOrdering@\texttt{IsNoncommutativeMonomialOrdering}}
\label{IsNoncommutativeMonomialOrdering}
}\hfill{\scriptsize (Category)}}\\


 A noncommutative monomial ordering is an object representing a monomial
ordering on a noncommutative (associative) algebra. All \textsf{NMO} orderings are of this category. 

 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LtFunctionListRep({\slshape {\textless}NoncommutativeMonomialOrdering{\textgreater}})\index{LtFunctionListRep@\texttt{LtFunctionListRep}}
\label{LtFunctionListRep}
}\hfill{\scriptsize (attribute)}}\\


 Returns the low-level comparison function used by the given ordering. The
function returned is a comparison function on the external representations
(lists) for monomials in the algebra. 

 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NextOrdering({\slshape {\textless}NoncommutativeMonomialOrdering{\textgreater}})\index{NextOrdering@\texttt{NextOrdering}}
\label{NextOrdering}
}\hfill{\scriptsize (attribute)}}\\


 Returns the next noncommutative monomial ordering chained to the given
ordering, if one exists. It is usually called after a \texttt{true} determination has been made with a \texttt{HasNextOrdering} call. 

 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ParentAlgebra({\slshape {\textless}NoncommutativeMonomialOrdering{\textgreater}})\index{ParentAlgebra@\texttt{ParentAlgebra}}
\label{ParentAlgebra}
}\hfill{\scriptsize (attribute)}}\\


 Returns the parent algebra used in the creation of the given ordering. 

 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LexicographicTable({\slshape {\textless}NoncommutativeMonomialOrdering{\textgreater}})\index{LexicographicTable@\texttt{LexicographicTable}}
\label{LexicographicTable}
}\hfill{\scriptsize (attribute)}}\\


 Returns the ordering of the generators of the \texttt{ParentAlgebra}, as specified in the creation of the given ordering. 

 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LexicographicIndexTable({\slshape {\textless}NoncommutativeMonomialOrdering{\textgreater}})\index{LexicographicIndexTable@\texttt{LexicographicIndexTable}}
\label{LexicographicIndexTable}
}\hfill{\scriptsize (attribute)}}\\


 Returns the ordering of the generators of the \texttt{ParentAlgebra}, as specified in the creation of the given ordering. 

 An example here would be useful. We create a length left-lexicographic
ordering on an algebra \texttt{A} with an order on the generators of $b < a < d < c$. Then in accessing the attributes via the atrributes above we see how the
list given by \texttt{LexicographicIndexTable} indexes the ordered generators: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> A := FreeAssociativeAlgebraWithOne(Rationals,"a","b","c","d");
  <algebra-with-one over Rationals, with 4 generators>
  gap> ml := NCMonomialLeftLengthLexOrdering(A,2,4,1,3);
  NCMonomialLeftLengthLexicographicOrdering([ (1)*b, (1)*d, (1)*a, (1)*c ])
  gap>  LexicographicTable(ml);
  [ (1)*b, (1)*d, (1)*a, (1)*c ]
  gap> LexicographicIndexTable(ml);
  [ 3, 1, 4, 2 ]
\end{Verbatim}
 The index table shows that the generator $a$ is the third in the generator ordering, $b$ is the least generator in the ordering, $c$ is the greatest and $d$ the second least in order. 

 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LexicographicPermutation({\slshape {\textless}NoncommutativeMonomialOrdering{\textgreater}})\index{LexicographicPermutation@\texttt{LexicographicPermutation}}
\label{LexicographicPermutation}
}\hfill{\scriptsize (attribute)}}\\


 Experimental permutation based on the information in \texttt{LexicographicTable}, could possibly be used to make indexed versions of comparison functions more
efficient. Currently only used by the \textsf{NMO} built-in ordering \texttt{NCMonomialLLLTestOrdering}. 

 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AuxilliaryTable({\slshape {\textless}NoncommutativeMonomialOrdering{\textgreater}})\index{AuxilliaryTable@\texttt{AuxilliaryTable}}
\label{AuxilliaryTable}
}\hfill{\scriptsize (attribute)}}\\


 An extra table carried by the given ordering which can be used for such things
as weight vectors, etc. 

 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OrderingLtFunctionListRep({\slshape {\textless}NoncommutativeMonomialOrdering{\textgreater}})\index{OrderingLtFunctionListRep@\texttt{OrderingLtFunctionListRep}}
\label{OrderingLtFunctionListRep}
}\hfill{\scriptsize (operation)}}\\


 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OrderingGtFunctionListRep({\slshape {\textless}NoncommutativeMonomialOrdering{\textgreater}})\index{OrderingGtFunctionListRep@\texttt{OrderingGtFunctionListRep}}
\label{OrderingGtFunctionListRep}
}\hfill{\scriptsize (operation)}}\\


 Given a noncommutative monomial ordering, \texttt{OrderingLtFunctionListRep} and \texttt{OrderingLtFunctionListRep} return functions which compare the `list' representations (NP representations)
of two monomials from the ordering's associated parent algebra. These
functions are not typically accessed by the user. 

 }

 
\subsection{\textcolor{Chapter }{Provided Orderings}}\logpage{[ 1, 4, 3 ]}
\hyperdef{L}{X7CDF05BD85AA0EE6}{}
{
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NCMonomialLeftLengthLexicographicOrdering({\slshape {\textless}algebra{\textgreater}, {\textless}list{\textgreater}})\index{NCMonomialLeftLengthLexicographicOrdering@\texttt{NCMonomial}\-\texttt{Left}\-\texttt{Length}\-\texttt{Lexicographic}\-\texttt{Ordering}}
\label{NCMonomialLeftLengthLexicographicOrdering}
}\hfill{\scriptsize (function)}}\\


 Given a free algebra $A$, and an optional ordered (possibly partial) ordered list of generators for
the algebra $A$, \texttt{NCMonomialLeftLengthLexicographicOrdering} returns a noncommutative length lexicographic ordering object. If an ordered
list of generators is provided, its order is used in creation of the ordering
object. If a list is not provided, then the ordering object is created based
on the order of the generators when the free algebra $A$ was created. 

 Note: the synonym \texttt{NCMonomialLeftLengthLexOrdering} may also be used. 

 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NCMonomialLengthOrdering({\slshape {\textless}algebra{\textgreater}})\index{NCMonomialLengthOrdering@\texttt{NCMonomialLengthOrdering}}
\label{NCMonomialLengthOrdering}
}\hfill{\scriptsize (function)}}\\


 Given a free algebra $A$, \texttt{NCMonomialLengthOrdering} returns a noncommutative length ordering object. Only the lengths of the words
of monomials in $A$ are compared using this ordering. 

 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NCMonomialLeftLexicographicOrdering({\slshape {\textless}algebra{\textgreater}, {\textless}list{\textgreater}})\index{NCMonomialLeftLexicographicOrdering@\texttt{NCMonomialLeftLexicographicOrdering}}
\label{NCMonomialLeftLexicographicOrdering}
}\hfill{\scriptsize (function)}}\\


 Given a free algebra $A$, and an optional ordered (possibly partial) ordered list of generators for
the algebra $A$, \texttt{NCMonomialLeftLexicographicOrdering} returns a simple noncommutative left-lexicographic ordering object. 

 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NCMonomialCommutativeLexicographicOrdering({\slshape {\textless}algebra{\textgreater}, {\textless}list{\textgreater}})\index{NCMonomialCommutativeLexicographicOrdering@\texttt{NCMonomial}\-\texttt{Commutative}\-\texttt{Lexicographic}\-\texttt{Ordering}}
\label{NCMonomialCommutativeLexicographicOrdering}
}\hfill{\scriptsize (function)}}\\


 Given a free algebra $A$, and an optional ordered (possibly partial) ordered list of generators for
the algebra $A$, \texttt{NCMonomialCommutativeLexicographicOrdering} returns a commutative left-lexicographic ordering object. Under this ordering,
monomials from $A$ are compared using their respective commutative analogues. 

 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NCMonomialWeightOrdering({\slshape {\textless}algebra{\textgreater}, {\textless}list{\textgreater}, {\textless}list2{\textgreater}})\index{NCMonomialWeightOrdering@\texttt{NCMonomialWeightOrdering}}
\label{NCMonomialWeightOrdering}
}\hfill{\scriptsize (function)}}\\


 Given a free algebra $A$, an ordered (possibly partial) ordered \texttt{{\textless}list{\textgreater}} of generators for the algebra $A$, and a \texttt{{\textless}list2{\textgreater}} of respective weights for the generators, \texttt{NCMonomialWeightOrdering} returns a noncommutative weight ordering object. 

 }

 
\subsection{\textcolor{Chapter }{Externals}}\logpage{[ 1, 4, 4 ]}
\hyperdef{L}{X7F2E50BE79D79C8F}{}
{
 All user-level interface routines in the descriptions following allow for the
comparison of not only monomials from a given algebra with respect to a given
ordering, but also compare general elements from an algebra by comparing their
leading terms (again, with respect to the given ordering). These routines are
located in the files \texttt{ncinterface.gd} and \texttt{ncinterface.gi}. }

 
\subsection{\textcolor{Chapter }{External Routines}}\logpage{[ 1, 4, 5 ]}
\hyperdef{L}{X7A5671D67CA092F3}{}
{
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NCLessThanByOrdering({\slshape {\textless}NoncommutativeMonomialOrdering{\textgreater}, {\textless}a{\textgreater}, {\textless}b{\textgreater}})\index{NCLessThanByOrdering@\texttt{NCLessThanByOrdering}}
\label{NCLessThanByOrdering}
}\hfill{\scriptsize (operation)}}\\


 Given a \texttt{{\textless}NoncommutativeMonomialOrdering{\textgreater}} on an algebra $A$ and $a,b \in A$, \texttt{NCLessThanByOrdering} returns the (boolean) result of $a < b$, where $<$ represents the comparison operator determined by \texttt{{\textless}NoncommutativeMonomialOrdering{\textgreater}}. 

 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NCGreaterThanByOrdering({\slshape {\textless}NoncommutativeMonomialOrdering{\textgreater}, {\textless}a{\textgreater}, {\textless}b{\textgreater}})\index{NCGreaterThanByOrdering@\texttt{NCGreaterThanByOrdering}}
\label{NCGreaterThanByOrdering}
}\hfill{\scriptsize (operation)}}\\


 Given a \texttt{{\textless}NoncommutativeMonomialOrdering{\textgreater}} on an algebra $A$ and $a,b \in A$, \texttt{NCLessThanByOrdering} returns the (boolean) result of $a > b$, where $>$ represents the comparison operator determined by \texttt{{\textless}NoncommutativeMonomialOrdering{\textgreater}}. 

 

 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NCEquivalentByOrdering({\slshape {\textless}NoncommutativeMonomialOrdering{\textgreater}, {\textless}a{\textgreater}, {\textless}b{\textgreater}})\index{NCEquivalentByOrdering@\texttt{NCEquivalentByOrdering}}
\label{NCEquivalentByOrdering}
}\hfill{\scriptsize (operation)}}\\


 Given a \texttt{{\textless}NoncommutativeMonomialOrdering{\textgreater}} on an algebra $A$ and $a,b \in A$, \texttt{NCLessThanByOrdering} returns the (boolean) result of $a = b$, where $=$ represents the comparison operator determined by \texttt{{\textless}NoncommutativeMonomialOrdering{\textgreater}}. 

 Some examples of these methods in use: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> A := FreeAssociativeAlgebraWithOne(Rationals,"x","y","z");
  <algebra-with-one over Rationals, with 3 generators>
  gap> x := A.x;; y := A.y;; z := A.z;; id := One(A);;
  gap> w1 := x*x*y;; w2 := x*y*x;; w3 := z*x;;
  
  gap> ml := NCMonomialLeftLengthLexOrdering(A);
  NCMonomialLeftLengthLexicographicOrdering([ (1)*x, (1)*y, (1)*z ])
  
  gap> ml2 := NCMonomialLengthOrdering(A);
  NCMonomialLengthOrdering([ (1)*x, (1)*y, (1)*z ])
  
  gap> ml7 := NCMonomialWeightOrdering(A,[1,2,3],[1,1,2]);
  NCMonomialWeightOrdering([ (1)*x, (1)*y, (1)*z ])
  
  gap> ml8 := NCMonomialWeightOrdering(A,[2,3,1],[1,1,2]);
  NCMonomialWeightOrdering([ (1)*y, (1)*z, (1)*x ])
  
  gap> #  Left length-lex ordering, x<y<z:
  gap> NCEquivalentByOrdering(ml,w1,w2);
  false
  gap> #  Length ordering:
  gap> NCEquivalentByOrdering(ml2,w1,w2);
  true
  gap> NCEquivalentByOrdering(ml2,w3,w2);
  false
  gap> # Weight ordering ( z=2, x=y=1 ):
  gap> NCEquivalentByOrdering(ml7,w1,w2);
  true
  gap> NCEquivalentByOrdering(ml7,w3,w2);
  true
  gap> # Weight ordering ( z=2, x=y=1 ), different lex:
  gap> NCEquivalentByOrdering(ml8,w1,w2);
  true
  gap> NCEquivalentByOrdering(ml8,w3,w2);
  true
\end{Verbatim}
 

 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NCSortNP({\slshape {\textless}NoncommutativeMonomialOrdering{\textgreater}, {\textless}list{\textgreater}, {\textless}function{\textgreater}})\index{NCSortNP@\texttt{NCSortNP}}
\label{NCSortNP}
}\hfill{\scriptsize (operation)}}\\


 Given a \texttt{{\textless}list{\textgreater}} of NP `list' representations for monomials from a noncommutative algebra, and
an NP comparison (ordering) function \texttt{{\textless}function{\textgreater}}, \texttt{NCSortNP} returns a sorted version of \texttt{{\textless}list{\textgreater}} (with respect to the NP comparison function \texttt{{\textless}function{\textgreater}}). The sort used here is an insertion sort, per the recommendation from \cite{gN02}. 

 }

 
\subsection{\textcolor{Chapter }{Flexibility vs. Efficiency}}\logpage{[ 1, 4, 6 ]}
\hyperdef{L}{X8528D2528613E9A2}{}
{
 We recall that \texttt{InstallNoncommutativeMonomialOrdering} completes a list of generators if only a partial one is provided. An example
will provide clarity here. It is given in terms of length-lex, but the
generator list completion functionality is identical for any \textsf{NMO} ordering. Note: If at all possible, users are encouraged to use the default
ordering on generators as it is more efficient than the indirection inherent
in sorting via the indexed list \texttt{LexicographicIndexTable}. Here is the example showing the flexibility in requiring only a partial list
of the ordering on generators: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> A := FreeAssociativeAlgebraWithOne(Rationals,"a","b","c","d");
  <algebra-with-one over Rationals, with 4 generators>
  gap> ml2 := NCMonomialLeftLengthLexOrdering(A,[3,1]);
  NCMonomialLeftLengthLexicographicOrdering([ (1)*c, (1)*a, (1)*b, (1)*d ])
  gap> LexicographicTable(ml2);
  [ (1)*c, (1)*a, (1)*b, (1)*d ]
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Utility Routines}}\logpage{[ 1, 5, 0 ]}
\hyperdef{L}{X79B90CCE7A05DEEB}{}
{
 
\subsection{\textcolor{Chapter }{GBNP Patching Routines}}\logpage{[ 1, 5, 1 ]}
\hyperdef{L}{X7B758C747AD2344B}{}
{
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PatchGBNP({\slshape {\textless}NoncommutativeMonomialOrdering{\textgreater}})\index{PatchGBNP@\texttt{PatchGBNP}}
\label{PatchGBNP}
}\hfill{\scriptsize (operation)}}\\


 \noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UnpatchGBNP({\slshape })\index{UnpatchGBNP@\texttt{UnpatchGBNP}}
\label{UnpatchGBNP}
}\hfill{\scriptsize (function)}}\\


 Let \texttt{{\textless}NoncommutativeMonomialOrdering{\textgreater}} be a monomial ordering (on an algebra $A$). \texttt{PatchGBNP} overwrites the \textsf{GBNP} Global functions \texttt{LtNP} and \texttt{GtNP} with the less-than and greater-than functions defined for \texttt{{\textless}NoncommutativeMonomialOrdering{\textgreater}}. The purpose of such a patching is to force \textsf{GBNP} to use \texttt{{\textless}NoncommutativeMonomialOrdering{\textgreater}} in its computation of a Gr{\"o}bner basis. \texttt{UnpatchGBNP()} simply restores the \texttt{LtNP} and \texttt{GtNP} functions to their original state. The examples in Quickstart section are more
illustrative, but here is an example of the use of the patching routines
above: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> A := FreeAssociativeAlgebraWithOne(Rationals,"x","y","z");
  <algebra-with-one over Rationals, with 3 generators>
  gap> ml := NCMonomialLeftLexicographicOrdering(A,3,2,1);
  NCMonomialLeftLexicographicOrdering([ (1)*z, (1)*y, (1)*x ])
  gap> PatchGBNP(ml);
  LtNP patched.
  GtNP patched.
  gap> UnpatchGBNP();
  LtNP restored.
  GtNP restored.
\end{Verbatim}
 

 }

 
\subsection{\textcolor{Chapter }{Printing Routine}}\logpage{[ 1, 5, 2 ]}
\hyperdef{L}{X8150015682ED1709}{}
{
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{String({\slshape {\textless}obj{\textgreater}})\index{String@\texttt{String}}
\label{String}
}\hfill{\scriptsize (operation)}}\\


 \textsf{GAP} seems to be currently lacking a method to convert an object from a free
associative ring to a string version of the same object. This routine fills
that gap. 

 Example (after loading \textsf{NMO} via the \textsf{GBNP} package): 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> A := FreeAssociativeAlgebraWithOne(ZmodpZ(19),"x","y");
  <algebra-with-one over GF(19), with 2 generators>
  gap> x := A.x; y := A.y;
  (Z(19)^0)*x
  (Z(19)^0)*y
  gap> IsString(String(x^2+x*y*x));
  true
  gap> String(x^2+x*y*x);
  "(Z(19)^0)*x^2+(Z(19)^0)*x*y*x"
\end{Verbatim}
 Example (before loading \textsf{NMO} via the \textsf{GBNP} package): 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>  A := FreeAssociativeAlgebraWithOne(ZmodpZ(19),"x","y");
  <lgebra-with-one over GF(19), with 2 generators>
  gap> x := A.x; y := A.y;
  (Z(19)^0)*x
  (Z(19)^0)*y
  gap>  String(x^2+x*y*x);
  Error, no method found! For debugging hints type ?Recovery from NoMethodFound
  Error, no 1st choice method found for `String' on 1 arguments called from
  <function>( <arguments> ) called from read-eval-loop
  Entering break read-eval-print loop ...
  you can 'quit;' to quit to outer loop, or
  you can 'return;' to continue
  brk>
\end{Verbatim}
 }

 }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{../plainurl}
\bibliography{../gbnp_doc,nmo_doc}

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
