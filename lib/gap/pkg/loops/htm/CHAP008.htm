<html><head><title>[loops] 8 Specific methods</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP007.htm">Previous</a>] [<a href ="CHAP009.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>8 Specific methods</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP008.htm#SECT001">Core methods for Bol loops</a>
<li> <A HREF="CHAP008.htm#SECT002">Moufang modifications</a>
<li> <A HREF="CHAP008.htm#SECT003">Triality for Moufang loops</a>
<li> <A HREF="CHAP008.htm#SECT004">Realizing groups as multiplication groups of loops</a>
</ol><p>
<p>
This chapter describes methods of <font face="Gill Sans,Helvetica,Arial">LOOPS</font> that apply to some special loops,
mostly Bol and Moufang loops.
<p>
<p>
<h2><a name="SECT001">8.1 Core methods for Bol loops</a></h2>
<p><p>
Let <i>L</i> be a left Bol loop such that the mapping <i>x</i>&#8594; <i>x</i><sup>2</sup> is a permutation of <i>L</i>. Define a new operation * on <i>L</i> by <i>x</i>*<i>y</i> = (<i>x</i>(<i>y</i><sup>2</sup><i>x</i>))<sup>1/2</sup>. Then Bruck showed that (<i>L</i>,*) is a left Bruck loop, called
the <var>assoicated left Bruck loop</var>. (In fact,
Bruck used the isomorphic operation <i>x</i>*<i>y</i> = <i>x</i><sup>1/2</sup>(<i>yx</i><sup>1/2</sup>) instead. Our
approach is more natural, since the associated left Bruck loop to a left Bruck
loop <i>L</i> is identical to <i>L</i> then.) The associated left Bruck loop of <i>L</i> is
returned via
<p>
<a name = "SSEC001.1"></a>
<li><code>AssociatedLeftBruckLoop( </code><var>L</var><code> ) A</code>
<p>
<p>
<h2><a name="SECT002">8.2 Moufang modifications</a></h2>
<p><p>
Ale\vs Dr&aacute;pal discovered two prominent families of extensions of Moufang
loops. It turns out that these extensions can be used to obtain all
nonassociative Moufang loops of order at most 64. We call these two
constructions <var>Moufang modifications</var>. The library
of Moufang loops included with <font face="Gill Sans,Helvetica,Arial">LOOPS</font> is based on Moufang modifications. We
describe the two modifications briefly here. See <a href="biblio.htm#DrVo"><cite>DrVo</cite></a> for details.
<p>
Assume that <i>L</i> is a Moufang loop with normal subloop <i>S</i> such that <i>L</i>/<i>S</i> is a
cyclic group of order 2<i>m</i>. Let <i>h</i> &#8712; <i>S</i>&#8745;<i>Z</i>(<i>L</i>). Let &#945; be a generator
of <i>L</i>/<i>S</i> and write <i>L</i> = &#8746;<sub><i>i</i> &#8712; <i>M</i></sub> &#945;<sup><i>i</i></sup>, where <i>M</i>={&#8722;<i>m</i>+1, ...,
<i>m</i>}. Let &#963;:<b>Z</b>&#8594; <i>M</i> be defined by &#963;(<i>i</i>)=0 if <i>i</i> &#8712; <i>M</i>,
&#963;(<i>i</i>)=1 if <i>i</i> &gt; <i>m</i>, and &#963;(<i>i</i>)=&#8722;1 if <i>i</i> &lt; &#8722;<i>m</i>+1. Introduce a new
multiplication &#8727; on <i>L</i> defined by
<br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"> <i>x</i>&#8727;<i>y</i> = <i>xyh</i><sup>&#963;(<i>i</i>+<i>j</i>)</sup>, </td></tr></table></td></tr></table>
where <i>x</i> &#8712; &#945;<sup><i>i</i></sup>, <i>y</i> &#8712; &#945;<sup><i>j</i></sup>, <i>i</i> &#8712; <i>M</i>, <i>j</i> &#8712; <i>M</i>. Then (<i>L</i>,&#8727;) is a
Moufang loop, a <var>cyclic modification</var> of <i>L</i>.
<p>
When <i>L</i>, <i>S</i>, &#945;, <i>h</i> are as above and when <i>a</i> is any element of
&#945;, the corresponding cyclic modification is obtained via
<p>
<a name = "SSEC002.1"></a>
<li><code>LoopByCyclicModification( </code><var>L</var><code>, </code><var>S</var><code>, </code><var>a</var><code>, </code><var>h</var><code> ) F</code>
<p>
Now assume that <i>L</i> is a Moufang loop with normal subloop <i>S</i> such that <i>L</i>/<i>S</i>
is a dihedral group of order 4<i>m</i>, with <i>m</i> &#8805; 1. Let <i>M</i> and &#963; be
defined as in the cyclic case. Let &#946;, &#947; &#8712; <i>L</i>/<i>S</i> be two involutions
of <i>L</i>/<i>S</i> such that &#945; = &#946;&#947; generates a cyclic subgroup of <i>L</i>/<i>S</i> of
order 2<i>m</i>. Let <i>e</i> &#8712; &#946; and <i>f</i> &#8712; &#947; be arbitrary. Then <i>L</i> can be
written as a disjoint union <i>L</i>=&#8746;<sub><i>i</i> &#8712; <i>M</i></sub>(&#945;<sup><i>i</i></sup>&#8746;<i>e</i>&#945;<sup><i>i</i></sup>), and
also <i>L</i>=&#8746;<sub><i>i</i> &#8712; <i>M</i></sub>(&#945;<sup><i>i</i></sup>&#8746;&#945;<sup><i>i</i></sup><i>f</i>. Let <i>G</i><sub>0</sub>=&#8746;<sub><i>i</i> &#8712;  <i>M</i></sub>&#945;<sup><i>i</i></sup>, and <i>G</i><sub>1</sub>=<i>L</i>\<i>G</i><sub>0</sub>. Let <i>h</i> &#8712; <i>S</i>&#8745;<i>N</i>(<i>L</i>)&#8745;<i>Z</i>(<i>G</i><sub>0</sub>).
Introduce a new multiplication &#8727; on <i>L</i> defined by
<br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"> <i>x</i>&#8727;<i>y</i> = <i>xyh</i><sup>(&#8722;1)<sup><i>r</i></sup>&#963;(<i>i</i>+<i>j</i>)</sup>, </td></tr></table></td></tr></table>
where <i>x</i> &#8712; &#945;<sup><i>i</i></sup>&#8746;<i>e</i>&#945;<sup><i>i</i></sup>, <i>y</i> &#8712; &#945;<sup><i>j</i></sup>&#8746;&#945;<sup><i>j</i></sup><i>f</i>, <i>i</i> &#8712; <i>M</i>,
<i>j</i> &#8712; <i>M</i>, <i>y</i> &#8712; <i>G</i><sub><i>r</i></sub>, <i>r</i> &#8712; {0,1}. Then (<i>L</i>,&#8727;) is a Moufang loop, a
<var>dihedral modification</var> of <i>L</i>.
<p>
When <i>L</i>, <i>S</i>, <i>e</i>, <i>f</i> and <i>h</i> are as above, the corresponding dihedral
modification is obtained via
<p>
<a name = "SSEC002.2"></a>
<li><code>LoopByDihedralModification( </code><var>L</var><code>, </code><var>S</var><code>, </code><var>e</var><code>, </code><var>f</var><code>, </code><var>h</var><code> ) F</code>
<p>
In order to apply the cyclic and dihedral modifications, it is beneficial to
have access to a class of nonassociative Moufang loops. The following
construction is due to Chein:
<p>
Let <i>G</i> be a group. Let [&#x02C9;(<i>G</i>)]={[&#x02C9;(<i>g</i>)];&nbsp;&nbsp;<i>g</i> &#8712; <i>G</i>} be a set of
new elements. Define multiplication &#8727; on <i>L</i>=<i>G</i>&#8746;[&#x02C9;(<i>G</i>)] by
<br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"> <i>g</i>&#8727;<i>h</i> = <i>gh</i>,&nbsp;<i>g</i>&#8727;</td><td nowrap="nowrap" align="center"><div class="hrcomp"><hr noshade="noshade" size="1"/></div><div class="norm"><i>h</i><br /></div><div class="comb">&nbsp;</div></td><td nowrap="nowrap" align="center">=</td><td nowrap="nowrap" align="center"><div class="hrcomp"><hr noshade="noshade" size="1"/></div><div class="norm"><i>hg</i><br /></div><div class="comb">&nbsp;</div></td><td nowrap="nowrap" align="center">,\</td><td nowrap="nowrap" align="center"><div class="hrcomp"><hr noshade="noshade" size="1"/></div><div class="norm"><i>g</i><br /></div><div class="comb">&nbsp;</div></td><td nowrap="nowrap" align="center">&#8727;<i>h</i> = </td><td nowrap="nowrap" align="center"><div class="hrcomp"><hr noshade="noshade" size="1"/></div><div class="norm"><i>gh</i><sup>&#8722;1</sup><br /></div><div class="comb">&nbsp;</div></td><td nowrap="nowrap" align="center">,\</td><td nowrap="nowrap" align="center"><div class="hrcomp"><hr noshade="noshade" size="1"/></div><div class="norm"><i>g</i><br /></div><div class="comb">&nbsp;</div></td><td nowrap="nowrap" align="center">&#8727;</td><td nowrap="nowrap" align="center"><div class="hrcomp"><hr noshade="noshade" size="1"/></div><div class="norm"><i>h</i><br /></div><div class="comb">&nbsp;</div></td><td nowrap="nowrap" align="center">=<i>h</i><sup>&#8722;1</sup><i>g</i>, </td></tr></table></td></tr></table>
where <i>g</i>, <i>h</i> &#8712; <i>G</i>. Then <i>L</i>=<i>M</i>(<i>G</i>,2) is a Moufang loop that is nonassociative
if and only if <i>G</i> is nonabelian.
<p>
The loop <i>M</i>(<i>G</i>,2) can be obtained from a finite group <i>G</i> with
<p>
<a name = "SSEC002.3"></a>
<li><code>LoopMG2( </code><var>G</var><code> ) F</code>
<p>
<p>
<h2><a name="SECT003">8.3 Triality for Moufang loops</a></h2>
<p><p>
Let <i>G</i> be a group and &#963;, &#961; be automorphisms of <i>G</i>, satisfying
&#963;<sup>2</sup> = &#961;<sup>3</sup> = (&#963;&#961;)<sup>2</sup> = 1. We write the automorphisms of a
group as exponents and [<i>g</i>,&#963;] for <i>g</i><sup>&#8722;1</sup><i>g</i><sup>&#963;</sup>. We say that the
triple (<i>G</i>,&#961;,&#963;) is a <var>group with triality</var> if [<i>g</i>, &#963;] [<i>g</i>,&#963;]<sup>&#961;</sup> [<i>g</i>,&#963;]<sup>&#961;<sup>2</sup></sup> = 1 holds for all <i>g</i>  &#8712;  <i>G</i>. It is known that one can associate a group with triality (<i>G</i>,&#961;,&#963;)
in a canonical way with a Moufang loop <i>L</i>. See <a href="biblio.htm#NaVo2003"><cite>NaVo2003</cite></a> for more
details.
<p>
For any Moufang loop <i>L</i>, we can calculate the triality group as a permutation
group acting on 3&#124;<i>L</i>&#124; points. If the multiplication group of <i>L</i> is
polycyclic, then we can also represent the triality group as a pc group. In
both cases, the automorphisms &#963; and &#961; are in the same family as the
elements of <i>G</i>.
<p>
Given a Moufang loop <i>L</i>, the function
<p>
<a name = "SSEC003.1"></a>
<li><code>TrialityPermGroup( </code><var>L</var><code> ) F</code>
<p>
returns a record [<i>G</i>, &#961;, &#963;], where <i>G</i> is the group with triality
associated with <i>L</i>, and &#961;, &#963; are the corresponding triality
automorphisms.
<p>
The function
<p>
<a name = "SSEC003.2"></a>
<li><code>TrialityPcGroup( </code><var>L</var><code> ) F</code>
<p>
differs from <code>TrialityPermGroup</code> only in that <i>G</i> is returned as a pc group.
<p>
<p>
<h2><a name="SECT004">8.4 Realizing groups as multiplication groups of loops</a></h2>
<p><p>
The following commands look for loops such that the multiplication group is
contained in a given transitive permutation group <var>G</var>.
<p>
The resulting loops are given by their right sections.
<p>
<a name = "SSEC004.1"></a>
<li><code>AllLoopTablesInGroup( </code><var>G</var><code>[, </code><var>depth</var><code>[, </code><var>infolevel</var><code>]] ) O</code>
<a name = "SSEC004.1"></a>
<li><code>AllProperLoopTablesInGroup( </code><var>G</var><code>[, </code><var>depth</var><code>[, </code><var>infolevel</var><code>]] ) O</code>
<a name = "SSEC004.1"></a>
<li><code>OneLoopTableInGroup( </code><var>G</var><code>[, </code><var>depth</var><code>[, </code><var>infolevel</var><code>]] ) O</code>
<a name = "SSEC004.1"></a>
<li><code>OneProperLoopTableInGroup( </code><var>G</var><code>[, </code><var>depth</var><code>[, </code><var>infolevel</var><code>]] ) O</code>
<a name = "SSEC004.1"></a>
<li><code>AllLoopsWithMltGroup( </code><var>G</var><code>[, </code><var>depth</var><code>[, </code><var>infolevel</var><code>]] ) O</code>
<a name = "SSEC004.1"></a>
<li><code>OneLoopWithMltGroup( </code><var>G</var><code>[, </code><var>depth</var><code>[, </code><var>infolevel</var><code>]] ) O</code>
<p>
One can speed up the search by setting the argument <var>depth</var> higher, the price
is much higher memory consumption. <var>depth</var> is optimally chosen if in the permutation group <var>G</var>, there are not
many permutations fixing <var>depth</var> elements. You can omit the argument <var>depth</var> or set it equal to
2 with little harm.
<p>
The parameter <var>infolevel</var> determines the amount of information you get during
the search. With <var>infolevel</var>=0, no information is provided.
With <var>infolevel</var>=1, you get the information on timing and hits.
With <var>infolevel</var>=2, the results are printed, as well.
<p>
<pre>
gap&gt; g:=PGL(3,3);
Group([ (6,7)(8,11)(9,13)(10,12), (1,2,5,7,13,3,8,6,10,9,12,4,11) ])
gap&gt; a:=AllLoopTablesInGroup(g,3,0);; Size(a);
56
gap&gt; a:=AllLoopsWithMltGroup(g,3,0);; Size(a);
52
</pre>
<p>
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP007.htm">Previous</a>] [<a href ="CHAP009.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>loops manual<br>July 2012
</address></body></html>