% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{\textsf{Circle}\mbox{}}}\\
\vfill

\hypersetup{pdftitle=\textsf{Circle}}
\markright{\scriptsize \mbox{}\hfill \textsf{Circle} \hfill\mbox{}}
{\Huge \textbf{Adjoint groups of finite rings\mbox{}}}\\
\vfill

{\Huge Version 1.5.3\mbox{}}\\[1cm]
{13 February 2015\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{Alexander Konovalov    \mbox{}}}\\
{\Large \textbf{Panagiotis Soules   \mbox{}}}\\
\hypersetup{pdfauthor=Alexander Konovalov    ; Panagiotis Soules   }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{Alexander Konovalov    }  Email: \href{mailto://alexk@mcs.st-andrews.ac.uk} {\texttt{alexk@mcs.st-andrews.ac.uk}}\\
  Homepage: \href{http://www.cs.st-andrews.ac.uk/~alexk/} {\texttt{http://www.cs.st-andrews.ac.uk/\texttt{\symbol{126}}alexk/}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 School of Computer Science\\
 University of St Andrews\\
 Jack Cole Building, North Haugh,\\
 St Andrews, Fife, KY16 9SX, Scotland \end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{Panagiotis Soules   }  Email: \href{mailto://psoules@math.uoa.gr} {\texttt{psoules@math.uoa.gr}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Department of Mathematics\\
 National and Capodistrian University of Athens\\
 Panepistimioupolis, GR-15784, Athens, Greece \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Abstract}
\logpage{[ 0, 0, 1 ]}
 \index{Circle package@\textsf{Circle} package} The \textsf{GAP}4 package \textsf{Circle} extends the \textsf{GAP} functionality for computations in adjoint groups of associative rings. It
provides functionality to construct circle objects that will respect the
circle multiplication $ r \cdot s = r + s + rs $, and to compute adjoint semigroups and adjoint groups of finite rings. Also
it may serve as an example of extending the \textsf{GAP} system with new multiplicative objects. 

 \mbox{}}\\[1cm]
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 2 ]}
 {\copyright} 2006-2015 by Alexander Konovalov and Panagiotis Soules 

 \textsf{Circle} is free software; you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation;
either version 2 of the License, or (at your option) any later version. For
details, see the FSF's own site \href{http://www.gnu.org/licenses/gpl.html} {\texttt{http://www.gnu.org/licenses/gpl.html}}. 

 If you obtained \textsf{Circle}, we would be grateful for a short notification sent to one of the authors. 

 If you publish a result which was partially obtained with the usage of \textsf{Circle}, please cite it in the following form: 

 A. Konovalov, P. Soules. \emph{Circle --- Adjoint groups of finite rings, Version 1.5.3;} 2015 (\href{http://www.cs.st-andrews.ac.uk/~alexk/circle/} {\texttt{http://www.cs.st-andrews.ac.uk/\texttt{\symbol{126}}alexk/circle/}}). \mbox{}}\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 3 ]}
 We acknowledge very much Alexander Hulpke and James Mitchell for their helpful
comments and advices, and the referee for testing the package and useful
suggestions. 

 \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 4 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Introduction}}\label{Intro}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  
\section{\textcolor{Chapter }{General aims}}\label{IntroAbstract}
\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X8557083378F2A3B2}{}
{
  Let $R$ be an associative ring, not necessarily with one. The set of all elements of $R$ forms a monoid with the neutral element $0$ from $R$ under the operation $ r \cdot s = r + s + rs $ defined for all $r$ and $s$ of $R$. This operation is called the \emph{circle multiplication}, and it is also known as the \emph{star multiplication}. The monoid of elements of $R$ under the circle multiplication is called the adjoint semigroup of $R$ and is denoted by $R^{ad}$. The group of all invertible elements of this monoid is called the adjoint
group of $R$ and is denoted by $R^{*}$. 

 These notions naturally lead to a number of questions about the connection
between a ring and its adjoint group, for example, how the ring properties
will determine properties of the adjoint group; which groups can appear as
adjoint groups of rings; which rings can have adjoint groups with prescribed
properties, etc. 

 For example, V. O. Gorlov in \cite{Gorlov-1995} gives a full list of finite nilpotent algebras $R$, such that $R^2 \ne 0$ and the adjoint group of $R$ is metacyclic (but not cyclic). 

 S. V. Popovich and Ya. P. Sysak in \cite{Popovich-Sysak-1997} characterize all quasiregular algebras such that all subgroups of their
adjoint group are their subalgebras. In particular, they show that all
algebras of such type are nilpotent with nilpotency index at most three. 

 Various connections between properties of a ring and its adjoint group were
considered by O. D. Artemovych and Yu. B. Ishchuk in \cite{Artemovych-Ishchuk-1997}. 

 B. Amberg and L. S. Kazarin in \cite{Amberg-Kazarin-2000} give the description of all nonisomorphic finite $p$-groups that can occur as the adjoint group of some nilpotent $p$-algebra of the dimension at most 5. 

 In \cite{Amberg-Sysak-2001} B. Amberg and Ya. P. Sysak give a survey of results on adjoint groups of
radical rings, including such topics as subgroups of the adjoint group;
nilpotent groups which are isomorphic to the adjoint group of some radical
ring; adjoint groups of finite nilpotent \$p\$-algebras. The authors continued
their investigations in further papers \cite{Amberg-Sysak-2002} and \cite{Amberg-Sysak-2004}. 

 In \cite{Kazarin-Soules-2004} L. S. Kazarin and P. Soules study associative nilpotent algebras over a field
of positive characteristic whose adjoint group has a small number of
generators. 

 The main objective of the proposed \textsf{GAP}4 package \textsf{Circle} is to extend the \textsf{GAP} functionality for computations in adjoint groups of associative rings to make
it possible to use the \textsf{GAP} system for the investigation of the above described questions. 

 \textsf{Circle} provides functionality to construct circle objects that will respect the
circle multiplication $ r \cdot s = r + s + rs $, create multiplicative structures, generated by such objects, and compute
adjoint semigroups and adjoint groups of finite rings. 

 Also we hope that the package will be useful as an example of extending the \textsf{GAP} system with new multiplicative objects. Relevant details are explained in the
next chapter of the manual. }

  
\section{\textcolor{Chapter }{Installation and system requirements}}\label{IntroInstall}
\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X7DB566D5785B7DBC}{}
{
  \textsf{Circle} does not use external binaries and, therefore, works without restrictions on
the type of the operating system. This version of the package is designed for \textsf{GAP}4.5 and no compatibility with previous releases of \textsf{GAP}4 is guaranteed. 

 To use the \textsf{Circle} online help it is necessary to install the \textsf{GAP}4 package \textsf{GAPDoc} by Frank L{\"u}beck and Max Neunh{\"o}ffer, which is available from the \textsf{GAP} site or from \href{http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc/} {\texttt{http://www.math.rwth-aachen.de/\texttt{\symbol{126}}Frank.Luebeck/GAPDoc/}}. 

 \textsf{Circle} is distributed in standard formats (\texttt{tar.gz}, \texttt{tar.bz2}, \texttt{zip} and \texttt{-win.zip}) and can be obtained from \href{http://www.cs.st-andrews.ac.uk/~alexk/circle/} {\texttt{http://www.cs.st-andrews.ac.uk/\texttt{\symbol{126}}alexk/circle/}} or from the \textsf{GAP} homepage. To install the package, unpack its archive in the \texttt{pkg} subdirectory of your \textsf{GAP} installation. }

 }

 
\chapter{\textcolor{Chapter }{Implementing circle objects}}\label{Objects}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X8404D6997A466953}{}
{
  In this chapter we explain how the \textsf{GAP} system may be extended with new objects using the circle multiplication as an
example. We follow the guidelines given in the \textsf{GAP} Reference Manual (see  (\textbf{Reference: Creating New Objects}) and subsequent chapters), to which we refer for more details. 
\section{\textcolor{Chapter }{First attempts}}\label{ObjectsFirst}
\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X86492955868108EC}{}
{
  Of course, having two ring elements, you can straightforwardly compute their
circle product defined as $ r \cdot s = r + s + rs $. You can do this in a command line, and it is a trivial task to write a
simplest function of two arguments that will do this: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@CircleMultiplication := function(a,b)|
  !gapprompt@>| !gapinput@     return a+b+a*b;|
  !gapprompt@>| !gapinput@   end;|
  function( a, b ) ... end
  !gapprompt@gap>| !gapinput@CircleMultiplication(2,3); |
  11
  !gapprompt@gap>| !gapinput@CircleMultiplication( ZmodnZObj(2,8), ZmodnZObj(5,8) );      |
  ZmodnZObj( 1, 8 )
  
\end{Verbatim}
 However, there is no check whether both arguments belong to the same ring and
whether they are ring elements at all, so it is easy to obtain some
meaningless results: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@CircleMultiplication( 3, ZmodnZObj(3,8) );|
  ZmodnZObj( 7, 8 )
  !gapprompt@gap>| !gapinput@CircleMultiplication( [1], [2,3] );|
  [ 5, 5 ]
  
\end{Verbatim}
 You can include some tests for arguments, and maybe the best way of doing this
would be declaring a new operation for two ring elements, and installing the
previous function as a method for this operation. This will check
automatically if the arguments are ring elements from the common ring: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@DeclareOperation( "BetterCircleMultiplication",                             |
  !gapprompt@>| !gapinput@     [IsRingElement,IsRingElement] );|
  !gapprompt@gap>| !gapinput@InstallMethod( BetterCircleMultiplication,|
  !gapprompt@>| !gapinput@     IsIdenticalObj,|
  !gapprompt@>| !gapinput@     [IsRingElement,IsRingElement],  |
  !gapprompt@>| !gapinput@     CircleMultiplication );|
  !gapprompt@gap>| !gapinput@BetterCircleMultiplication(2,3);|
  11
  !gapprompt@gap>| !gapinput@BetterCircleMultiplication( ZmodnZObj(2,8), ZmodnZObj(5,8) );|
  ZmodnZObj( 1, 8 )
  
\end{Verbatim}
 Nevertheless, the functionality gained from such operation would be rather
limited. You will not be able to compute circle product via the infix operator \texttt{*}, and, moreover, you will not be able to create higher level objects such as
semigroups and groups with respect to the circle multiplication.

 In order to "integrate" the circle multiplication into the \textsf{GAP} library properly, instead of defining \emph{new} operations for existing objects, we should define \emph{new} objects for which the infix operator \texttt{*} will perform the circle multiplication. This approach is explained in the next
two sections. }

 
\section{\textcolor{Chapter }{Defining circle objects}}\label{ObjectsDefining}
\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X852C1F3281137DD6}{}
{
  Thus, we are going to implement \emph{circle objects}, for which we can envisage the following functionality: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@CircleObject( 2 ) * CircleObject( 3 );                       |
  CircleObject( 11 )
  
\end{Verbatim}
 First we need to distinguish these new objects from other \textsf{GAP} objects. This is done via the \emph{type} of the objects, that is mainly determined by their \emph{category}, \emph{representation} and \emph{family}. 

 We start with declaring the category \texttt{IsCircleObject} as a subcategory of \texttt{IsAssociativeElement{\textgreater}} and \texttt{IsMultiplicativeElementWithInverse}. Thus, each circle object will "know" that it is \texttt{IsAssociativeElement} and \texttt{IsMultiplicativeElementWithInverse}, and this will make it possible to apply to circle objects such operations as \texttt{One} and \texttt{Inverse} (the latter is allowed to return \texttt{fail} for a given circle object), and construct semigroups generated by circle
objects. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@DeclareCategory( "IsMyCircleObject", |
  !gapprompt@>| !gapinput@IsAssociativeElement and IsMultiplicativeElementWithInverse );|
  
\end{Verbatim}
 Further we would like to create semigroups and groups generated by circle
objects. Such structures will be \emph{collections} of circle objects, so they will be in the category \texttt{CategoryCollections( IsCircleObject )}. This is why immediately after we declare the underlying category of circle
objects, we need also to declare the category of their collections: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@DeclareCategoryCollections( "IsMyCircleObject" );|
  
\end{Verbatim}
 On the next step we should think about the internal representation of circle
objects. A natural way would be to store the underlying ring element in a
list-like structure at its first position. We do not foresee any other data
that we need to store internally in the circle object. This is quite common
situation, so we may define first \texttt{IsPositionalObjectOneSlotRep} that is the list-like representation with only one position in the list, and
then declare a synonym \texttt{IsDefaultCircleObject} that means that we are dealing with a circle object in one-slot
representation: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@DeclareRepresentation( "IsMyPositionalObjectOneSlotRep",|
  !gapprompt@>| !gapinput@    IsPositionalObjectRep, [ 1 ] );|
  !gapprompt@gap>| !gapinput@DeclareSynonym( "IsMyDefaultCircleObject",|
  !gapprompt@>| !gapinput@    IsMyCircleObject and IsMyPositionalObjectOneSlotRep );|
  
\end{Verbatim}
 Until now we are still unable to create circle objects, because we did not
specify to which family they will belong. Naturally, having a ring, we want to
have all circle objects for elements of this ring in the same family to be
able to multiply them, and we expect circle objects for elements of different
rings to be placed in different families. Thus, it would be nice to establish
one-to-one correspondence between the family of ring elements and a family of
circle elements for this ring. We can store the corresponding circle family as
an attribute of the ring elements family. To do this first we declare an
attribute \texttt{CircleFamily} for families: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@DeclareAttribute( "MyCircleFamily", IsFamily );|
  
\end{Verbatim}
 Now we install the method that stores the corresponding circle family in this
attribute: 
\begin{Verbatim}[commandchars=@|A,fontsize=\small,frame=single,label=Example]
  
  @gapprompt|gap>A @gapinput|InstallMethod( MyCircleFamily,A
  @gapprompt|>A @gapinput|    "for a family",A
  @gapprompt|>A @gapinput|    [ IsFamily ],A
  @gapprompt|>A @gapinput|    function( Fam )A
  @gapprompt|>A @gapinput|    local F;A
  @gapprompt|>A @gapinput|  # create the family of circle elementsA
  @gapprompt|>A @gapinput|  F:= NewFamily( "MyCircleFamily(...)", IsMyCircleObject );A
  @gapprompt|>A @gapinput|  if HasCharacteristic( Fam ) thenA
  @gapprompt|>A @gapinput|    SetCharacteristic( F, Characteristic( Fam ) );A
  @gapprompt|>A @gapinput|  fi;A
  @gapprompt|>A @gapinput|  # store the type of objects in the outputA
  @gapprompt|>A @gapinput|  F!.MyCircleType:= NewType( F, IsMyDefaultCircleObject );A
  @gapprompt|>A @gapinput|  # Return the circle familyA
  @gapprompt|>A @gapinput|  return F;A
  @gapprompt|>A @gapinput|end );A
  
\end{Verbatim}
 Similarly, we want one-to-one correspondence between circle elements and
underlying ring elements. We declare an attribute \texttt{CircleObject} for a ring element, and then install the method to create new circle object
from the ring element. This method takes the family of the ring element, finds
corresponding circle family, extracts from it the type of circle objects and
finally creates the new circle object of that type: 
\begin{Verbatim}[commandchars=@|B,fontsize=\small,frame=single,label=Example]
  
  @gapprompt|gap>B @gapinput|DeclareAttribute( "MyCircleObject", IsRingElement );B
  @gapprompt|gap>B @gapinput|InstallMethod( MyCircleObject,B
  @gapprompt|>B @gapinput|    "for a ring element",B
  @gapprompt|>B @gapinput|    [ IsRingElement ],B
  @gapprompt|>B @gapinput|    obj -> Objectify( MyCircleFamily( FamilyObj( obj ) )!.MyCircleType,B
  @gapprompt|>B @gapinput|                      [ Immutable( obj ) ] ) );B
  
\end{Verbatim}
 Only after entering all code above we are able to create some circle object.
However, it is displayed just as \texttt{{\textless}object{\textgreater}}, though we can get the underlying ring element using the "!" operator: 
\begin{Verbatim}[commandchars=@|A,fontsize=\small,frame=single,label=Example]
  
  @gapprompt|gap>A @gapinput|a:=MyCircleObject(2);A
  <object>
  @gapprompt|gap>A @gapinput|a![1];A
  2
  
\end{Verbatim}
 We can check that the intended relation between families holds: 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@FamilyObj( MyCircleObject ( 2 ) ) = MyCircleFamily( FamilyObj( 2 ) );|
  true
  
\end{Verbatim}
 We can not multiply circle objects yet. But before implementing this, first
let us improve the output by installing the method for \texttt{PrintObj}: 
\begin{Verbatim}[commandchars=@|A,fontsize=\small,frame=single,label=Example]
  
  @gapprompt|gap>A @gapinput|InstallMethod( PrintObj,A
  @gapprompt|>A @gapinput|    "for object in `IsMyCircleObject'",A
  @gapprompt|>A @gapinput|    [ IsMyDefaultCircleObject ],A
  @gapprompt|>A @gapinput|    function( obj )A
  @gapprompt|>A @gapinput|    Print( "MyCircleObject( ", obj![1], " )" );A
  @gapprompt|>A @gapinput|    end );A
  
\end{Verbatim}
 This method will be used by \texttt{Print} function, and also by \texttt{View}, since we did not install special method for \texttt{ViewObj} for circle objects. As a result of this installation, the output became more
meaningful: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@a;|
  MyCircleObject( 2 )
  
\end{Verbatim}
 We need to avoid the usage of "!" operator, which, in general, is not
recommended to the user (for example, if \textsf{GAP} developers will change the internal representation of some object, all \textsf{GAP} functions that deal with it must be adjusted appropriately, while if the
user's code had direct access to that representation via "!", an error may
occur). To do this, we wrap getting the first component of a circle object in
the following operation: 
\begin{Verbatim}[commandchars=@|B,fontsize=\small,frame=single,label=Example]
  
  @gapprompt|gap>B @gapinput|DeclareAttribute("UnderlyingRingElement", IsMyCircleObject );B
  @gapprompt|gap>B @gapinput|InstallMethod( UnderlyingRingElement,B
  @gapprompt|>B @gapinput|    "for a circle object", B
  @gapprompt|>B @gapinput|    [ IsMyCircleObject],B
  @gapprompt|>B @gapinput|    obj -> obj![1] );B
  @gapprompt|gap>B @gapinput|UnderlyingRingElement(a);B
  2
  
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Installing operations for circle objects}}\label{ObjectsOperations}
\logpage{[ 2, 3, 0 ]}
\hyperdef{L}{X85B1413E7FBC8ACB}{}
{
  Now we are finally able to install circle multiplication as a default method
for the multiplication of circle objects, and perform the computation that we
envisaged in the beginning: 
\begin{Verbatim}[commandchars=@|A,fontsize=\small,frame=single,label=Example]
  
  @gapprompt|gap>A @gapinput|InstallMethod( \*,A
  @gapprompt|>A @gapinput|    "for two objects in `IsMyCircleObject'",A
  @gapprompt|>A @gapinput|    IsIdenticalObj,A
  @gapprompt|>A @gapinput|    [ IsMyDefaultCircleObject, IsMyDefaultCircleObject ],A
  @gapprompt|>A @gapinput|    function( a, b )A
  @gapprompt|>A @gapinput|    return MyCircleObject( a![1] + b![1] + a![1]*b![1] );A
  @gapprompt|>A @gapinput|    end );A
  @gapprompt|gap>A @gapinput|MyCircleObject(2)*MyCircleObject(3);A
  MyCircleObject( 11 )
  
\end{Verbatim}
 However, this functionality is not enough to form semigroups or groups
generated by circle elements. We need to be able to check whether two circle
objects are equal, and we need to define ordering for them (for example, to be
able to form sets of circle elements). Since we already have both operations
for underlying ring elements, this can be implemented in a straightforward
way: 
\begin{Verbatim}[commandchars=@|A,fontsize=\small,frame=single,label=Example]
  
  @gapprompt|gap>A @gapinput|InstallMethod( \=,A
  @gapprompt|>A @gapinput|    "for two objects in `IsMyCircleObject'",A
  @gapprompt|>A @gapinput|    IsIdenticalObj,A
  @gapprompt|>A @gapinput|    [ IsMyDefaultCircleObject, IsMyDefaultCircleObject ],A
  @gapprompt|>A @gapinput|    function( a, b )A
  @gapprompt|>A @gapinput|    return a![1] = b![1];A
  @gapprompt|>A @gapinput|    end );A
  @gapprompt|gap>A @gapinput|InstallMethod( \<,A
  @gapprompt|>A @gapinput|    "for two objects in `IsMyCircleObject'",A
  @gapprompt|>A @gapinput|    IsIdenticalObj,A
  @gapprompt|>A @gapinput|    [ IsMyDefaultCircleObject, IsMyDefaultCircleObject ],A
  @gapprompt|>A @gapinput|    function( a, b )A
  @gapprompt|>A @gapinput|    return a![1] < b![1];A
  @gapprompt|>A @gapinput|    end );A
  
\end{Verbatim}
 Further, zero element of the ring plays a role of the neutral element for the
circle multiplication, and we add this knowledge to our code in a form of a
method for \texttt{OneOp} that returns circle object for the corresponding zero object: 
\begin{Verbatim}[commandchars=@|A,fontsize=\small,frame=single,label=Example]
  
  @gapprompt|gap>A @gapinput|InstallMethod( OneOp,A
  @gapprompt|>A @gapinput|    "for an object in `IsMyCircleObject'",A
  @gapprompt|>A @gapinput|    [ IsMyDefaultCircleObject ],A
  @gapprompt|>A @gapinput|    a -> MyCircleObject( Zero( a![1] ) ) );A
  @gapprompt|gap>A @gapinput|One(a);A
  MyCircleObject( 0 )
  
\end{Verbatim}
 Now we are already able to create monoids generated by circle objects: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@S:=Monoid(a);|
  <monoid with 1 generator>
  !gapprompt@gap>| !gapinput@One(S);|
  MyCircleObject( 0 )
  !gapprompt@gap>| !gapinput@S:=Monoid( MyCircleObject( ZmodnZObj( 2,8) ) );|
  <monoid with 1 generator>
  !gapprompt@gap>| !gapinput@Size(S);|
  2
  !gapprompt@gap>| !gapinput@AsList(S);|
  [ MyCircleObject( ZmodnZObj( 0, 8 ) ), MyCircleObject( ZmodnZObj( 2, 8 ) ) ]
  
\end{Verbatim}
 Finally, to generate groups using circle objects, we need to add a method for
the \texttt{InverseOp}. In our implementation we will assume that the underlying ring is a subring
of the ring with one, thus, if the circle inverse for an element $x$ exists, than it can be computed as $-x(1+x)^{-1}$: 
\begin{Verbatim}[commandchars=@|A,fontsize=\small,frame=single,label=Example]
  
  @gapprompt|gap>A @gapinput|InstallMethod( InverseOp,A
  @gapprompt|>A @gapinput|    "for an object in `IsMyCircleObject'",A
  @gapprompt|>A @gapinput|    [ IsMyDefaultCircleObject ],A
  @gapprompt|>A @gapinput|    function( a )A
  @gapprompt|>A @gapinput|    local x;A
  @gapprompt|>A @gapinput|    x := Inverse( One( a![1] ) + a![1] );A
  @gapprompt|>A @gapinput|    if x = fail thenA
  @gapprompt|>A @gapinput|      return fail;A
  @gapprompt|>A @gapinput|    elseA
  @gapprompt|>A @gapinput|      return MyCircleObject( -a![1] * x );A
  @gapprompt|>A @gapinput|    fi;A
  @gapprompt|>A @gapinput|    end );A
  @gapprompt|gap>A @gapinput|MyCircleObject(-2)^-1;                A
  MyCircleObject( -2 )
  @gapprompt|gap>A @gapinput|MyCircleObject(2)^-1; A
  MyCircleObject( -2/3 )
  
\end{Verbatim}
 The last method already makes it possible to create groups generated by circle
objects (the warning may be ignored): 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@Group( MyCircleObject(2) );  |
  #I  default `IsGeneratorsOfMagmaWithInverses' method returns `true' for
  [ MyCircleObject( 2 ) ]
  <group with 1 generators>
  !gapprompt@gap>| !gapinput@G:=Group( [MyCircleObject( ZmodnZObj( 2,8 ) )  ]);|
  #I  default `IsGeneratorsOfMagmaWithInverses' method returns `true' for
  [ MyCircleObject( ZmodnZObj( 2, 8 ) ) ]
  <group with 1 generators>
  !gapprompt@gap>| !gapinput@Size(G);|
  2
  !gapprompt@gap>| !gapinput@AsList(G);|
  [ MyCircleObject( ZmodnZObj( 0, 8 ) ), MyCircleObject( ZmodnZObj( 2, 8 ) ) ]
  
\end{Verbatim}
 The \textsf{GAP} code used in this Chapter, is contained in the files \texttt{circle/lib/circle.gd} and \texttt{circle/lib/circle.gi} (without \texttt{My} in identifiers). For more examples of implementing new \textsf{GAP} objects and further details see  (\textbf{Reference: Creating New Objects}) and subsequent chapters in the \textsf{GAP} Reference Manual. }

 }

 
\chapter{\textcolor{Chapter }{\textsf{Circle} functions}}\label{Funct}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X84E0DB177F665AF0}{}
{
  To use the \textsf{Circle} package first you need to load it as follows: 
\begin{Verbatim}[commandchars=!|B,fontsize=\small,frame=single,label=Example]
  
  !gapprompt|gap>B !gapinput|LoadPackage("circle");B
  -----------------------------------------------------------------------------
  Loading  Circle 1.4.0 (Adjoint groups of finite rings)
  by Alexander Konovalov (http://www.cs.st-andrews.ac.uk/~alexk/) and
     Panagiotis Soules (psoules@math.uoa.gr).
  -----------------------------------------------------------------------------
  true
  gap>
  
\end{Verbatim}
 Note that if you entered examples from the previous chapter, you need to
restart \textsf{GAP} before loading the \textsf{Circle} package. 
\section{\textcolor{Chapter }{Circle objects}}\label{CircleObjects}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X7E25EF1786B5F87C}{}
{
  Because for elements of the ring $R$ the ordinary multiplication is already denoted by \texttt{*}, for the implementation of the circle multiplication in the adjoint semigroup
we need to wrap up ring elements as CircleObjects, for which \texttt{*} is defined to be the circle multiplication. 

\subsection{\textcolor{Chapter }{CircleObject}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X7F5C18AA7B433BDD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CircleObject({\mdseries\slshape x})\index{CircleObject@\texttt{CircleObject}}
\label{CircleObject}
}\hfill{\scriptsize (attribute)}}\\


 Let \mbox{\texttt{\mdseries\slshape x}} be a ring element. Then \texttt{CircleObject(x)} returns the corresponding circle object. If \mbox{\texttt{\mdseries\slshape x}} lies in the family \texttt{fam}, then \texttt{CircleObject(x)} lies in the family \texttt{CircleFamily} (\ref{CircleFamily}), corresponding to the family \texttt{fam}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@a := CircleObject( 2 );|
  CircleObject( 2 )
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{UnderlyingRingElement}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X874B2B2A7F5A9A78}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UnderlyingRingElement({\mdseries\slshape x})\index{UnderlyingRingElement@\texttt{UnderlyingRingElement}}
\label{UnderlyingRingElement}
}\hfill{\scriptsize (attribute)}}\\


 Returns the corresponding ring element for the circle object \mbox{\texttt{\mdseries\slshape x}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@a := CircleObject( 2 );|
  CircleObject( 2 )
  !gapprompt@gap>| !gapinput@UnderlyingRingElement( a );    |
  2
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsCircleObject}}
\logpage{[ 3, 1, 3 ]}\nobreak
\hyperdef{L}{X810FB77F860F888D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsCircleObject({\mdseries\slshape x})\index{IsCircleObject@\texttt{IsCircleObject}}
\label{IsCircleObject}
}\hfill{\scriptsize (Category)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsCircleObjectCollection({\mdseries\slshape x})\index{IsCircleObjectCollection@\texttt{IsCircleObjectCollection}}
\label{IsCircleObjectCollection}
}\hfill{\scriptsize (Category)}}\\


 An object \mbox{\texttt{\mdseries\slshape x}} lies in the category \texttt{IsCircleObject} if and only if it lies in a family constructed by \texttt{CircleFamily} (\ref{CircleFamily}). Since circle objects can be multiplied via \texttt{*} with elements in their family, and we need operations \texttt{One} and \texttt{Inverse} to deal with groups they generate, circle objects are implemented in the
category \texttt{IsMultiplicativeElementWithInverse}. A collection of circle objects (e.g. adjoint semigroup or adjoint group)
will lie in the category \texttt{IsCircleObjectCollection}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@IsCircleObject( 2 ); IsCircleObject( CircleObject( 2 ) );            |
  false
  true
  !gapprompt@gap>| !gapinput@IsMultiplicativeElementWithInverse( CircleObject( 2 ) );|
  true
  !gapprompt@gap>| !gapinput@IsCircleObjectCollection( [ CircleObject(0), CircleObject(2) ] );|
  true
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsPositionalObjectOneSlotRep}}
\logpage{[ 3, 1, 4 ]}\nobreak
\hyperdef{L}{X8469C7F67A8864B3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPositionalObjectOneSlotRep({\mdseries\slshape x})\index{IsPositionalObjectOneSlotRep@\texttt{IsPositionalObjectOneSlotRep}}
\label{IsPositionalObjectOneSlotRep}
}\hfill{\scriptsize (Representation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsDefaultCircleObject({\mdseries\slshape x})\index{IsDefaultCircleObject@\texttt{IsDefaultCircleObject}}
\label{IsDefaultCircleObject}
}\hfill{\scriptsize (Representation)}}\\


 To store the corresponding circle object, we need only to store the underlying
ring element. Since this is quite common situation, we defined the
representation \texttt{IsPositionalObjectOneSlotRep} for a more general case. Then we defined \texttt{IsDefaultCircleObject} as a synonym of \texttt{IsPositionalObjectOneSlotRep} for objects in \texttt{IsCircleObject} (\ref{IsCircleObject}). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@IsPositionalObjectOneSlotRep( CircleObject( 2 ) );|
  true
  !gapprompt@gap>| !gapinput@IsDefaultCircleObject( CircleObject( 2 ) );                          |
  true
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{CircleFamily}}
\logpage{[ 3, 1, 5 ]}\nobreak
\hyperdef{L}{X7F88A0017DC2E878}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CircleFamily({\mdseries\slshape fam})\index{CircleFamily@\texttt{CircleFamily}}
\label{CircleFamily}
}\hfill{\scriptsize (attribute)}}\\


 \texttt{CircleFamily(fam)} is a family, elements of which are in one-to-one correspondence with elements
of the family \mbox{\texttt{\mdseries\slshape fam}}, but with the circle multiplication as an infix multiplication. That is, for $x$, $y$ in \mbox{\texttt{\mdseries\slshape fam}}, the product of their images in the \texttt{CircleFamily(fam)} will be the image of $ x + y + x y $. The relation between these families is demonstrated by the following
equality: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@FamilyObj( CircleObject ( 2 ) ) = CircleFamily( FamilyObj( 2 ) );|
  true
  
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Operations with circle objects}}\label{CircleOperations}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X85ECB0B482AB3170}{}
{
  

\subsection{\textcolor{Chapter }{One}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X8129A6877FFD804B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{One({\mdseries\slshape x})\index{One@\texttt{One}}
\label{One}
}\hfill{\scriptsize (operation)}}\\


 This operation returns the multiplicative neutral element for the circle
object \mbox{\texttt{\mdseries\slshape x}}. The result is the circle object corresponding to the additive neutral
element of the appropriate ring. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@One( CircleObject( 5 ) );|
  CircleObject( 0 )
  !gapprompt@gap>| !gapinput@One( CircleObject( 5 ) ) = CircleObject( Zero( 5 ) );|
  true
  !gapprompt@gap>| !gapinput@One( CircleObject( [ [ 1, 1 ],[ 0, 1 ] ] ) );|
  CircleObject( [ [ 0, 0 ], [ 0, 0 ] ] )
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{InverseOp}}
\logpage{[ 3, 2, 2 ]}\nobreak
\hyperdef{L}{X82EC4F49877D6EB1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{InverseOp({\mdseries\slshape x})\index{InverseOp@\texttt{InverseOp}}
\label{InverseOp}
}\hfill{\scriptsize (operation)}}\\


 For a circle object \mbox{\texttt{\mdseries\slshape x}}, returns the multiplicative inverse of \mbox{\texttt{\mdseries\slshape x}} with respect to the circle multiplication; if such one does not exist then \texttt{fail} is returned.

 In our implementation we assume that the underlying ring is a subring of the
ring with one, thus, if the circle inverse for an element $x$ exists, than it can be computed as $-x(1+x)^{-1}$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@CircleObject( -2 )^-1;                        |
  CircleObject( -2 )
  !gapprompt@gap>| !gapinput@CircleObject( 2 )^-1; |
  CircleObject( -2/3 )
  !gapprompt@gap>| !gapinput@CircleObject( -2 )*CircleObject( -2 )^-1;|
  CircleObject( 0 )
  
\end{Verbatim}
 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@m := CircleObject( [ [ 1, 1 ], [ 0, 1 ] ] );   |
  CircleObject( [ [ 1, 1 ], [ 0, 1 ] ] )
  !gapprompt@gap>| !gapinput@m^-1;    |
  CircleObject( [ [ -1/2, -1/4 ], [ 0, -1/2 ] ] )
  !gapprompt@gap>| !gapinput@m * m^-1;|
  CircleObject( [ [ 0, 0 ], [ 0, 0 ] ] )
  !gapprompt@gap>| !gapinput@CircleObject( [ [ 0, 1 ], [ 1, 0 ] ] )^-1; |
  fail
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsUnit}}
\logpage{[ 3, 2, 3 ]}\nobreak
\hyperdef{L}{X85CBFBAE78DE72E8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsUnit({\mdseries\slshape [R, ]x})\index{IsUnit@\texttt{IsUnit}}
\label{IsUnit}
}\hfill{\scriptsize (operation)}}\\


 Let \mbox{\texttt{\mdseries\slshape x}} be a circle object corresponding to an element of the ring \mbox{\texttt{\mdseries\slshape R}}. Then the operation \texttt{IsUnit} returns \texttt{true}, if \mbox{\texttt{\mdseries\slshape x}} is invertible in \mbox{\texttt{\mdseries\slshape R}} with respect to the circle multiplication, and \texttt{false} otherwise. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@IsUnit( Integers, CircleObject( -2 ) );|
  true
  !gapprompt@gap>| !gapinput@IsUnit( Integers, CircleObject( 2 ) ); |
  false
  !gapprompt@gap>| !gapinput@IsUnit( Rationals, CircleObject( 2 ) );        |
  true
  !gapprompt@gap>| !gapinput@IsUnit( ZmodnZ(8), CircleObject( ZmodnZObj(2,8) ) );|
  true
  !gapprompt@gap>| !gapinput@m := CircleObject( [ [ 1, 1 ],[ 0, 1 ] ] );;|
  !gapprompt@gap>| !gapinput@IsUnit( FullMatrixAlgebra( Rationals, 2 ), m );|
  true
  
\end{Verbatim}
 If the first argument is omitted, the result will be returned with respect to
the default ring of the circle object \mbox{\texttt{\mdseries\slshape x}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@IsUnit( CircleObject( -2 ) );|
  true
  !gapprompt@gap>| !gapinput@IsUnit( CircleObject( 2 ) ); |
  false
  !gapprompt@gap>| !gapinput@IsUnit( CircleObject( ZmodnZObj(2,8) ) );|
  true
  !gapprompt@gap>| !gapinput@IsUnit( CircleObject( [ [ 1, 1 ],[ 0, 1 ] ] ) );                                    |
  false
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsCircleUnit}}
\logpage{[ 3, 2, 4 ]}\nobreak
\hyperdef{L}{X7CE7866F7CD00709}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsCircleUnit({\mdseries\slshape [R, ]x})\index{IsCircleUnit@\texttt{IsCircleUnit}}
\label{IsCircleUnit}
}\hfill{\scriptsize (operation)}}\\


 Let \mbox{\texttt{\mdseries\slshape x}} be an element of the ring \mbox{\texttt{\mdseries\slshape R}}. Then \texttt{IsCircleUnit( R, x )} determines whether \mbox{\texttt{\mdseries\slshape x}} is invertible in \mbox{\texttt{\mdseries\slshape R}} with respect to the circle multilpication. This is equivalent to the condition
that 1+\mbox{\texttt{\mdseries\slshape x}} is a unit in \mbox{\texttt{\mdseries\slshape R}} with respect to the ordinary multiplication. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@IsCircleUnit( Integers, -2 );|
  true
  !gapprompt@gap>| !gapinput@IsCircleUnit( Integers, 2 ); |
  false
  !gapprompt@gap>| !gapinput@IsCircleUnit( Rationals, 2 );          |
  true
  !gapprompt@gap>| !gapinput@IsCircleUnit( ZmodnZ(8), ZmodnZObj(2,8) ); |
  true
  !gapprompt@gap>| !gapinput@m := [ [ 1, 1 ],[ 0, 1 ] ];                |
  [ [ 1, 1 ], [ 0, 1 ] ]
  !gapprompt@gap>| !gapinput@IsCircleUnit( FullMatrixAlgebra(Rationals,2), m );|
  true
  
\end{Verbatim}
 If the first argument is omitted, the result will be returned with respect to
the default ring of \mbox{\texttt{\mdseries\slshape x}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@IsCircleUnit( -2 );                               |
  true
  !gapprompt@gap>| !gapinput@IsCircleUnit( 2 ); |
  false
  !gapprompt@gap>| !gapinput@IsCircleUnit( ZmodnZObj(2,8) );           |
  true
  !gapprompt@gap>| !gapinput@IsCircleUnit( [ [ 1, 1 ],[ 0, 1 ] ] ); |
  false
  
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Construction of the adjoint semigroup and adjoint group}}\label{CircleAdjointGroups}
\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X86F80DD8823966F7}{}
{
  

\subsection{\textcolor{Chapter }{AdjointSemigroup}}
\logpage{[ 3, 3, 1 ]}\nobreak
\hyperdef{L}{X83993FD0848D0C80}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AdjointSemigroup({\mdseries\slshape R})\index{AdjointSemigroup@\texttt{AdjointSemigroup}}
\label{AdjointSemigroup}
}\hfill{\scriptsize (attribute)}}\\


 If \mbox{\texttt{\mdseries\slshape R}} is a finite ring then \texttt{AdjointSemigroup(\mbox{\texttt{\mdseries\slshape R}})} will return the monoid which is formed by all elements of \mbox{\texttt{\mdseries\slshape R}} with respect to the circle multiplication. 

 The implementation is rather straightforward and was added to provide a link
to the \textsf{GAP} functionality for semigroups. It assumes that the enumaration of all elements
of the ring \mbox{\texttt{\mdseries\slshape R}} is feasible. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@R:=Ring( [ ZmodnZObj(2,8) ] );|
  <ring with 1 generators>
  !gapprompt@gap>| !gapinput@S:=AdjointSemigroup(R);|
  <monoid with 4 generators>
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{AdjointGroup}}
\logpage{[ 3, 3, 2 ]}\nobreak
\hyperdef{L}{X868FAC7E87D11137}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AdjointGroup({\mdseries\slshape R})\index{AdjointGroup@\texttt{AdjointGroup}}
\label{AdjointGroup}
}\hfill{\scriptsize (attribute)}}\\


 If \mbox{\texttt{\mdseries\slshape R}} is a finite radical algebra then \texttt{AdjointGroup(\mbox{\texttt{\mdseries\slshape R}})} will return the adjoint group of \mbox{\texttt{\mdseries\slshape R}}, given as a group generated by a set of circle objects. 

 To compute the adjoint group of a finite radical algebra, \textsf{Circle} uses the fact that all elements of a radical algebra form a group with respect
to the circle multiplication. Thus, the adjoint group of \mbox{\texttt{\mdseries\slshape R}} coincides with \mbox{\texttt{\mdseries\slshape R}} elementwise, and we can randomly select an appropriate set of generators for
the adjoint group. 

 The warning is displayed by \texttt{IsGeneratorsOfMagmaWithInverses} method defined in \texttt{gap4r4/lib/grp.gi} and may be ignored. 

 \textsc{WARNINGS:} 

 1. The set of generators of the returned group is not required to be a
generating set of minimal possible order. 

 2. \texttt{AdjointGroup} is stored as an attribute of \mbox{\texttt{\mdseries\slshape R}}, so for the same copy of \mbox{\texttt{\mdseries\slshape R}} calling it again you will get the same result. But if you will create another
copy of \mbox{\texttt{\mdseries\slshape R}} in the future, the output may differ because of the random selection of
generators. If you want to have the same generating set, next time you should
construct a group immediately specifying circle objects that generate it. 

 3. In most cases, to investigate some properties of the adjoint group, it is
necessary first to convert it to an isomorphic permutation group or to a
PcGroup. 

 For example, we can create the following commutative 2-dimensional radical
algebra of order 4 over the field of two elements, and show that its adjoint
group is a cyclic group of order 4: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@x:=[ [ 0, 1, 0 ],|
  !gapprompt@>| !gapinput@        [ 0, 0, 1 ],|
  !gapprompt@>| !gapinput@        [ 0, 0, 0 ] ];;|
  !gapprompt@gap>| !gapinput@R := Algebra( GF(2), [ One(GF(2))*x ] );  |
  <algebra over GF(2), with 1 generators>
  !gapprompt@gap>| !gapinput@RadicalOfAlgebra( R ) = R;|
  true
  !gapprompt@gap>| !gapinput@Dimension(R);|
  2
  !gapprompt@gap>| !gapinput@G := AdjointGroup( R );;|
  !gapprompt@gap>| !gapinput@Size( R ) = Size( G );|
  true
  !gapprompt@gap>| !gapinput@StructureDescription( G );|
  "C4"
  
\end{Verbatim}
 In the following example we construct a non-commutative 3-dimensional radical
algebra of order 8 over the field of two elements, and demonstrate that its
adjoint group is the dihedral group of order 8: \pagebreak 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@x:=[ [ 0, 1, 0 ],|
  !gapprompt@>| !gapinput@        [ 0, 0, 0 ],     |
  !gapprompt@>| !gapinput@        [ 0, 0, 0 ] ];;|
  !gapprompt@gap>| !gapinput@y:=[ [ 0, 0, 0 ],     |
  !gapprompt@>| !gapinput@        [ 0, 0, 1 ],  |
  !gapprompt@>| !gapinput@        [ 0, 0, 0 ] ];;|
  !gapprompt@gap>| !gapinput@R := Algebra( GF(2), One(GF(2))*[x,y] );  |
  <algebra over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@RadicalOfAlgebra(R) = R;                |
  true
  !gapprompt@gap>| !gapinput@Dimension(R);|
  3
  !gapprompt@gap>| !gapinput@G := AdjointGroup( R );|
  <group of size 8 with 2 generators>
  !gapprompt@gap>| !gapinput@StructureDescription( G );|
  "D8"
  
\end{Verbatim}
 If the ring \mbox{\texttt{\mdseries\slshape R}} is not a radical algebra, then \textsf{Circle} will use another approach. We will enumerate all elements of the ring \mbox{\texttt{\mdseries\slshape R}} and select those that are units with respect to the circle multiplication.
Then we will use a random approach similar to the case of the radical algebra,
to find some generating set of the adjoint group. Again, all warnings 1-3
above refer also to this case. 

 Of course, enumeration of all elements of \mbox{\texttt{\mdseries\slshape R}} should be feasible for this computation. In the following example we
demonstrate how it works for rings, generated by residue classes: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@R := Ring( [ ZmodnZObj(2,8) ] );|
  <ring with 1 generators>
  !gapprompt@gap>| !gapinput@G := AdjointGroup( R );|
  <group of size 4 with 2 generators>
  !gapprompt@gap>| !gapinput@StructureDescription( G );|
  "C2 x C2"
  !gapprompt@gap>| !gapinput@R := Ring( [ ZmodnZObj(2,256) ] );   |
  <ring with 1 generators>
  !gapprompt@gap>| !gapinput@G := AdjointGroup( R );;|
  !gapprompt@gap>| !gapinput@StructureDescription( G );|
  "C64 x C2"
  
\end{Verbatim}
 Due to the \texttt{AdjointSemigroup} (\ref{AdjointSemigroup}), there is also another way to compute the adjoint group of a ring $R$ by means of the computation of its adjoint semigroup $S(R)$ and taking the Green's $H$-class of the multiplicative neutral element of $S(R)$. Let us repeat the last example in this way: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@R := Ring( [ ZmodnZObj(2,256) ] );  |
  <ring with 1 generators>
  !gapprompt@gap>| !gapinput@S := AdjointSemigroup( R );|
  <monoid with 128 generators>
  !gapprompt@gap>| !gapinput@H := GreensHClassOfElement(S,One(S));|
  {CircleObject( ZmodnZObj( 0, 256 ) )}
  !gapprompt@gap>| !gapinput@G:=AsGroup(H);|
  <group of size 128 with 2 generators>
  !gapprompt@gap>| !gapinput@StructureDescription(G);|
  "C64 x C2"
  
\end{Verbatim}
 However, the conversion of the Green's $H$-class to the group may take some time which may vary dependently on the
particular ring in question, and will also display a lot of warnings about the
default \texttt{IsGeneratorsOfMagmaWithInverses} method, so we did not implemented this as as standard method. In the following
example the method based on Green's $H$-class is much slower than an application of earlier described random approach
(20s vs 10ms): 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@R := Ring( [ ZmodnZObj(2,256) ] );   |
  <ring with 1 generators>
  !gapprompt@gap>| !gapinput@AdjointGroup(R);;|
  !gapprompt@gap>| !gapinput@R := Ring( [ ZmodnZObj(2,256) ] );|
  <ring with 1 generators>
  !gapprompt@gap>| !gapinput@S:=AdjointSemigroup(R); |
  <monoid with 128 generators>
  !gapprompt@gap>| !gapinput@AsGroup(GreensHClassOfElement(S,One(S))); |
  <group of size 128 with 2 generators>
  
\end{Verbatim}
 Finally, note that if \mbox{\texttt{\mdseries\slshape R}} has a unity $1$, then the set $1+R^{ad}$, where $R^{ad}$ is the adjoint semigroup of \mbox{\texttt{\mdseries\slshape R}}, coincides with the multiplicative semigroup $R^{mult}$ of $R$, and the map $ r \mapsto (1+r) $ for $r$ in $R$ is an isomorphism from $R^{ad}$ onto $R^{mult}$. 

 Similarly, the set $1+R^*$, where $R^{*}$ is the adjoint group of \mbox{\texttt{\mdseries\slshape R}}, coincides with the unit group of $R$, which we denote $U(R)$, and the map $r \mapsto (1+r)$ for $r$ in $R$ is an isomorphism from $R^*$ onto $U(R)$. 

 We demonstrate this isomorphism using the following example. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@LoadPackage( "laguna", false );|
  true
  !gapprompt@gap>| !gapinput@FG := GroupRing( GF(2), DihedralGroup(8) );|
  <algebra-with-one over GF(2), with 3 generators>
  !gapprompt@gap>| !gapinput@R := AugmentationIdeal( FG );;|
  !gapprompt@gap>| !gapinput@G := AdjointGroup( R );;|
  !gapprompt@gap>| !gapinput@IdGroup( G );|
  [ 128, 170 ]
  !gapprompt@gap>| !gapinput@IdGroup( Units( FG ) );|
  #I  LAGUNA package: Computing the unit group ...
  [ 128, 170 ]
  
\end{Verbatim}
 Thus, dependently on the ring \texttt{R} in question, it might be possible that you can compute much faster its unit
group using \texttt{Units(R)} than its adjoint group using \texttt{AdjointGroup(R)}. This is why in an attempt of computation of the adjoint group of the ring
with one a warning message will be displayed: 

 
\begin{Verbatim}[commandchars=@|B,fontsize=\small,frame=single,label=Example]
  
  @gapprompt|gap>B @gapinput|Size( AdjointGroup( GroupRing( GF(2), DihedralGroup(8) ) ) );B
  
  WARNING: usage of AdjointGroup for associative ring <R> with one!!! 
  In this case the adjoint group is isomorphic to the unit group 
  Units(<R>), which possibly may be computed faster!!! 
  
  128
  @gapprompt|gap>B @gapinput|Size( AdjointGroup( Integers mod 11 ) );                  B
  
  WARNING: usage of AdjointGroup for associative ring <R> with one!!! 
  In this case the adjoint group is isomorphic to the unit group 
  Units(<R>), which possibly may be computed faster!!! 
  
  10
  
\end{Verbatim}
 If \mbox{\texttt{\mdseries\slshape R}} is infinite, an error message will appear, telling that \textsf{Circle} does not provide methods to deal with infinite rings. }

 }

  
\section{\textcolor{Chapter }{Service functions}}\label{Service}
\logpage{[ 3, 4, 0 ]}
\hyperdef{L}{X80DFB24F8289C323}{}
{
  

\subsection{\textcolor{Chapter }{InfoCircle}}
\logpage{[ 3, 4, 1 ]}\nobreak
\hyperdef{L}{X7A24C0997AC7C6A3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{InfoCircle\index{InfoCircle@\texttt{InfoCircle}}
\label{InfoCircle}
}\hfill{\scriptsize (info class)}}\\


 \texttt{InfoCircle} is a special Info class for \textsf{Circle} algorithms. It has 2 levels: 0 (default) and 1. To change info level to \texttt{k}, use command \texttt{SetInfoLevel(InfoCircle, k)}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@SetInfoLevel( InfoCircle, 1 );|
  !gapprompt@gap>| !gapinput@SetInfoLevel(InfoCircle,1);|
  !gapprompt@gap>| !gapinput@R := Ring( [ ZmodnZObj(2,8) ]);|
  <ring with 1 generators>
  !gapprompt@gap>| !gapinput@G := AdjointGroup( R );|
  #I  Circle : <R> is not a radical algebra, computing circle units ...
  #I  Circle : searching generators for adjoint group ...
  <group of size 4 with 2 generators>
  !gapprompt@gap>| !gapinput@SetInfoLevel( InfoCircle, 0 );|
  
\end{Verbatim}
 }

 }

 }

 
\chapter{\textcolor{Chapter }{A sample computation with \textsf{Circle}}}\label{Example}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X8064F0F97809ED19}{}
{
  Here we give an example to give the reader an idea what \textsf{Circle} is able to compute. 

 It was proved in \cite{Kazarin-Soules-2004} that if $R$ is a finite nilpotent two-generated algebra over a field of characteristic $p>3$ whose adjoint group has at most three generators, then the dimension of $R$ is not greater than 9. Also, an example of the 6-dimensional such algebra with
the 3-generated adjoint group was given there. We will construct the algebra
from this example and investigate it using \textsf{Circle}. First we create two matrices that determine its generators: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@x:=[ [ 0, 1, 0, 0, 0, 0, 0 ],|
  !gapprompt@>| !gapinput@        [ 0, 0, 0, 1, 0, 0, 0 ],|
  !gapprompt@>| !gapinput@        [ 0, 0, 0, 0, 1, 0, 0 ],|
  !gapprompt@>| !gapinput@        [ 0, 0, 0, 0, 0, 0, 1 ],|
  !gapprompt@>| !gapinput@        [ 0, 0, 0, 0, 0, 1, 0 ],|
  !gapprompt@>| !gapinput@        [ 0, 0, 0, 0, 0, 0, 0 ],|
  !gapprompt@>| !gapinput@        [ 0, 0, 0, 0, 0, 0, 0 ] ];;|
  !gapprompt@gap>| !gapinput@y:=[ [ 0, 0, 1, 0, 0, 0, 0 ],|
  !gapprompt@>| !gapinput@        [ 0, 0, 0, 0,-1, 0, 0 ],|
  !gapprompt@>| !gapinput@        [ 0, 0, 0, 1, 0, 1, 0 ],|
  !gapprompt@>| !gapinput@        [ 0, 0, 0, 0, 0, 1, 0 ],|
  !gapprompt@>| !gapinput@        [ 0, 0, 0, 0, 0, 0,-1 ],|
  !gapprompt@>| !gapinput@        [ 0, 0, 0, 0, 0, 0, 0 ],|
  !gapprompt@>| !gapinput@        [ 0, 0, 0, 0, 0, 0, 0 ] ];;|
  
\end{Verbatim}
 Now we construct this algebra in characteristic five and check its basic
properties: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@R := Algebra( GF(5), One(GF(5))*[x,y] );|
  <algebra over GF(5), with 2 generators>
  !gapprompt@gap>| !gapinput@Dimension( R );|
  6
  !gapprompt@gap>| !gapinput@Size( R );|
  15625
  !gapprompt@gap>| !gapinput@RadicalOfAlgebra( R ) = R;|
  true
  
\end{Verbatim}
 Then we compute the adjoint group of \texttt{R}: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@G := AdjointGroup( R );;|
  !gapprompt@gap>| !gapinput@Size(G);|
  15625
  
\end{Verbatim}
 Now we can find the generating set of minimal possible order for the group \texttt{G}, and check that \texttt{G} it is 3-generated. To do this, first we need to convert it to the isomorphic
PcGroup: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@f := IsomorphismPcGroup( G );;|
  !gapprompt@gap>| !gapinput@H := Image( f );|
  Group([ f1, f2, f3, f4, f5, f6 ])
  !gapprompt@gap>| !gapinput@gens := MinimalGeneratingSet( H );;|
  !gapprompt@gap>| !gapinput@Length( gens );|
  3
  
\end{Verbatim}
 One can also use \texttt{UnderlyingRingElement(PreImage(f,x))} to find the preimage of \texttt{x} in \texttt{G}. 

 It appears that the adjoint group of the algebra from example will be
3-generated in characteristic 3 as well: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@R := Algebra( GF(3), One(GF(3))*[x,y] );|
  <algebra over GF(3), with 2 generators>
  !gapprompt@gap>| !gapinput@G := AdjointGroup( R );|
  <group of size 729 with 3 generators>
  !gapprompt@gap>| !gapinput@H := Image( IsomorphismPcGroup( G ) );|
  Group([ f1, f2, f3, f4, f5, f6 ])
  !gapprompt@gap>| !gapinput@Length( MinimalGeneratingSet( H ) );|
  3
  
\end{Verbatim}
 But this is not the case in characteristic 2, where the adjoint group is
4-generated: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@R := Algebra( GF(2), One(GF(2))*[x,y] );|
  <algebra over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@G := AdjointGroup( R );;|
  !gapprompt@gap>| !gapinput@Size(G);|
  64
  !gapprompt@gap>| !gapinput@H := Image( IsomorphismPcGroup( G ) );|
  Group([ f1, f2, f3, f4, f5, f6 ])
  !gapprompt@gap>| !gapinput@Length( MinimalGeneratingSet( H ) );|
  4
  
\end{Verbatim}
 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{manual}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
