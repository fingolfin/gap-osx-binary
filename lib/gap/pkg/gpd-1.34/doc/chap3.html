<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (Gpd) - Chapter 3: Groupoids</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>

<p><a id="X82F6A1AB798648F4" name="X82F6A1AB798648F4"></a></p>
<div class="ChapSects"><a href="chap3.html#X82F6A1AB798648F4">3 <span class="Heading">Groupoids</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7AC321DC7E3C6167">3.1 <span class="Heading">Groupoids: their properties and attributes</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8406913B7ED86CFE">3.1-1 SinglePieceGroupoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8511D3EE845CC930">3.1-2 IsPermGroupoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79877FAA8556A726">3.1-3 UnionOfPieces</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X855F318181808814">3.1-4 HomogeneousGroupoid</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7F23BE3F85C9BA06">3.2 <span class="Heading">Groupoid elements; stars; costars; homsets</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X86247DFC8242CEBE">3.2-1 Arrow</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X78C3228682279032">3.2-2 IdentityArrow</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X84F59A2687C62763">3.2-3 Order</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B561BAE7D471C60">3.2-4 ObjectStar</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7BDBA72C852C4625">3.3 <span class="Heading">Subgroupoids</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80780D287EDDB7BB">3.3-1 Subgroupoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X873E0914871858E8">3.3-2 SubgroupoidWithRays</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X831AA9E8780235F2">3.4 <span class="Heading">Left, right and double cosets</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8412ABD57986B9FC">3.4-1 RightCoset</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X8653FC9786E3209A">3.5 <span class="Heading">Conjugation</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X851E390F87037421">3.5-1 ConjugateArrow</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C2727D285BA2EBE">3.5-2 SinglePieceGroupoidByGenerators</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X78218F357BFEDE82">3.5-3 ConjugateGroupoid</a></span>
</div></div>
</div>

<h3>3 <span class="Heading">Groupoids</span></h3>

<p>A <em>groupoid</em> is a (mathematical) category in which every element is invertible. It consists of a set of <em>pieces</em>, each of which is a connected groupoid. (The usual terminology is `connected component', but in <strong class="pkg">GAP</strong> `component' is used for `record component'.)</p>

<p>A <em>single piece groupoid</em> is determined by a set of <em>objects</em> <code class="code">obs</code> and an <em>object group</em> <code class="code">grp</code>. The objects of a single piece groupoid are generally chosen to be consecutive negative integers, but any suitable ordered set is acceptable, and `consecutive' is not a requirement. The object groups will usually be taken to be permutation groups, but pc-groups and fp-groups are also supported.</p>

<p>A <em>group</em> is a single piece groupoid with one object.</p>

<p>A <em>groupoid</em> is a set of one or more single piece groupoids, its <em>pieces</em>, and is represented as <code class="code">IsGroupoidRep</code>, with attribute <code class="code">PiecesOfGroupoid</code>.</p>

<p>A groupoid is <em>homogeneous</em> if it has two of more isomorphic pieces, with identical groups. The special case of <em>homogeneous, discrete</em> groupoids, where each piece has a single object, is given its own representation. Such a groupoid is used in the <strong class="pkg">XMod</strong> package as the source of a crossed modules of groupoids.</p>

<p>For the definitions of the standard properties of groupoids we refer to R. Brown's book ``Topology'' <a href="chapBib.html#biBBrTop">[Bro88]</a>, recently revised and reissued as ``Topology and Groupoids'' <a href="chapBib.html#biBBrTopGpd">[Bro06]</a>.</p>

<p><a id="X7AC321DC7E3C6167" name="X7AC321DC7E3C6167"></a></p>

<h4>3.1 <span class="Heading">Groupoids: their properties and attributes</span></h4>

<p><a id="X8406913B7ED86CFE" name="X8406913B7ED86CFE"></a></p>

<h5>3.1-1 SinglePieceGroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SinglePieceGroupoid</code>( <var class="Arg">grp</var>, <var class="Arg">obs</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Groupoid</code>( <var class="Arg">args</var> )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RootObject</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>As for magmas with objects, the simplest construction of a groupoid is as the direct product of a group and a complete graph. Many subgroupoids of such a groupoid do not have this simple form, and will be considered in section <a href="chap3.html#X7BDBA72C852C4625"><span class="RefLink">3.3</span></a>. As usual, the <code class="code">RootObject</code> is the object with least label. The global function <code class="code">Groupoid</code> will normally find the appropriate constructor to call, the options being:</p>


<ul>
<li><p>the object group, a list of objects;</p>

</li>
<li><p>a group being converted to a groupoid, a single object;</p>

</li>
<li><p>a list of groupoids which have already been constructed.</p>

</li>
</ul>
<p>Methods for <code class="code">ViewObj</code>, <code class="code">PrintObj</code> and <code class="code">Display</code> are provided for groupoids and the other types of object in this package. Users are advised to supply names for all the groups and groupoids they construct.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s4 := Group( (1,2,3,4), (3,4) );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d8 := Subgroup( s4, [ (1,2,3,4), (1,3) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( s4, "s4" );  SetName( d8, "d8" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gs4 := SinglePieceGroupoid( s4, [-15 .. -11] ); </span>
single piece groupoid: &lt; s4, [ -15 .. -11 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RootObject( Gs4 );</span>
-15
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gd8 := Groupoid( d8, [-9,-8,-7] );</span>
single piece groupoid: &lt; d8, [ -9, -8, -7 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c6 := Group( (5,6,7)(8,9) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( c6, "c6" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gc6 := DomainWithSingleObject( c6, -6 );</span>
single piece groupoid: &lt; c6, [ -6 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( Gs4, "Gs4" );  SetName( Gd8, "Gd8" );  SetName( Gc6, "Gc6" );  </span>

</pre></div>

<p><a id="X8511D3EE845CC930" name="X8511D3EE845CC930"></a></p>

<h5>3.1-2 IsPermGroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPermGroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( property )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPcGroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( property )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFpGroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( property )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMatrixGroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>A groupoid is a permutation groupoid if all its pieces have permutation groups. Most of the examples in this chapter are permutation groupoids, but in principle any type of group known to <strong class="pkg">GAP</strong> may be used. In the following example <code class="code">Gf2</code> is an fp-groupoid, <code class="code">Gq8</code> is a pc-groupoid, and <code class="code">Gsl43</code> is a matrix groupoid.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f2 := FreeGroup( 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gf2 := Groupoid( f2, -22 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( f2, "f2" );  SetName( Gf2, "Gf2" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q8 := SmallGroup( 8, 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gq8 := Groupoid( q8, [ -28, -27 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( q8, "q8" );  SetName( Gq8, "Gq8" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sl43 := SpecialLinearGroup( 4, 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gsl43 := SinglePieceGroupoid( sl43, [ -35..-31 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( sl43, "sl43" );  SetName( Gsl43, "Gsl43" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ IsMatrixGroupoid( Gsl43 ), IsFpGroupoid( Gf2 ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     IsPcGroupoid( Gq8 ), IsPermGroupoid( Gs4 ) ]; </span>
[ true, true, true, true ]

</pre></div>

<p><a id="X79877FAA8556A726" name="X79877FAA8556A726"></a></p>

<h5>3.1-3 UnionOfPieces</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnionOfPieces</code>( <var class="Arg">pieces</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Pieces</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Size</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ReplaceOnePieceInUnion</code>( <var class="Arg">gpd</var>, <var class="Arg">old_piece</var>, <var class="Arg">new_piece</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>When a groupoid consists of two or more pieces, we require their object lists to be disjoint. The operation <code class="code">UnionOfPieces</code> and the attribute <code class="code">Pieces</code>, introduced in section <a href="chap1.html#X87B3A56F8231D0F3"><span class="RefLink">1.4</span></a>, are also used for groupoids. The pieces are sorted by the least object in their object lists. The <code class="code">ObjectList</code> is the sorted concatenation of the objects in the pieces.</p>

<p>The <code class="code">Size</code> of a groupoid is the number of its arrows which, for a single piece groupoid, is the product of the size of the group with the square of the number of objects.</p>

<p>One of the pieces in a groupoid may be replaced by an alternative piece using the operation <code class="code">ReplaceOnePieceInUnion</code>. The objects in the new piece may or may not overlap the objects in the piece removed -- we just require that the object lists in the new union are disjoint.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U3 := UnionOfPieces( [ Gs4, Gd8, Gc6 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( U3 );</span>
groupoid with 3 pieces:
&lt; objects: [ -15 .. -11 ]
    group: s4 = &lt;[ (1,2,3,4), (3,4) ]&gt; &gt;
&lt; objects: [ -9, -8, -7 ]
    group: d8 = &lt;[ (1,2,3,4), (1,3) ]&gt; &gt;
&lt; objects: [ -6 ]
    group: c6 = &lt;[ (5,6,7)(8,9) ]&gt; &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Pieces( U3 );</span>
[ Gs4, Gd8, Gc6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectList( U3 );</span>
[ -15, -14, -13, -12, -11, -9, -8, -7, -6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U2 := Groupoid( [ Gf2, Gq8 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ Size(Gs4), Size(Gd8), Size(Gc6), Size(U3) ];</span>
[ 600, 72, 6, 678 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ Size(Gf2), Size(Gq8), Size(U2) ];           </span>
[ infinity, 32, infinity ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U5 := UnionOfPieces( [ U3, Gf2, Gq8 ] );</span>
groupoid with 5 pieces:
[ Gq8, Gf2, Gs4, Gd8, Gc6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V5 := ReplaceOnePieceInUnion( U5, 3, Gsl43 ); </span>
groupoid with 5 pieces:
[ Gsl43, Gq8, Gf2, Gd8, Gc6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectList(V5);             </span>
[ -35, -34, -33, -32, -31, -28, -27, -22, -9, -8, -7, -6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U5 = V5; </span>
false

</pre></div>

<p><a id="X855F318181808814" name="X855F318181808814"></a></p>

<h5>3.1-4 HomogeneousGroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HomogeneousGroupoid</code>( <var class="Arg">gpd</var>, <var class="Arg">oblist</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HomogeneousDiscreteGroupoid</code>( <var class="Arg">gp</var>, <var class="Arg">obs</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Special functions are provided for the case where a groupoid has more than one connected component, and these components are identical except for their object sets. Such groupoids are said to be <em>homogeneous</em>.</p>

<p>The operation <code class="code">HomogeneousGroupoid</code> is used when the components each contain more than one object. The arguments consist of a single piece groupoid <code class="code">gpd</code> and a list of lists of objects <code class="code">oblist</code>, each of whose lists has the same length as the object list <code class="code">obs</code> of <code class="code">gpd</code>. Note that <code class="code">gpd</code> is <em>not</em> included as one of the pieces in the output unless <code class="code">obs</code> is included as one of the lists in <code class="code">oblist</code>.</p>

<p>The operation <code class="code">HomogeneousDiscreteGroupoid</code> is used when the components each have a single object. In this case the first argument is just a group -- the root group for each component. These groupoids are used in the <strong class="pkg">XMod</strong> package as the source of many crossed modules of groupoids.</p>

<p>Both types of groupoid have the property <code class="code">IsHomogeneousDomainWithObjects</code>. In the latter case a separate representation <code class="code">IsHomogeneousDiscreteGroupoidRep</code> is used.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hd8 := HomogeneousGroupoid( Gd8, [ [-12,-11,-10], [-16,-15,-14] ] ); </span>
homogeneous groupoid with 2 pieces:
1:  single piece groupoid: &lt; d8, [ -16, -15, -14 ] &gt;
2:  single piece groupoid: &lt; d8, [ -12, -11, -10 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsHomogeneousDomainWithObjects(Hd8);               </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hc6 := HomogeneousDiscreteGroupoid( c6, [-7..-4] );</span>
homogeneous, discrete groupoid: &lt; c6, [ -7 .. -4 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentationsOfObject(Gd8);</span>
[ "IsComponentObjectRep", "IsAttributeStoringRep", "IsMWOSinglePieceRep" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentationsOfObject(Hd8);</span>
[ "IsComponentObjectRep", "IsAttributeStoringRep", "IsPiecesRep" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentationsOfObject(Hc6);</span>
[ "IsComponentObjectRep", "IsAttributeStoringRep", 
  "IsHomogeneousDiscreteGroupoidRep" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KnownTruePropertiesOfObject(Hc6); </span>
[ "CanEasilyCompareElements", "CanEasilySortElements", "IsDuplicateFree", 
  "IsAssociative", "IsCommutative", "IsDiscreteDomainWithObjects", 
  "IsHomogeneousDomainWithObjects" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Kd8 := UnionOfPieces( [ Gd8, Hd8 ] );</span>
groupoid with 3 pieces:
1:  single piece groupoid: &lt; d8, [ -16, -15, -14 ] &gt;
2:  single piece groupoid: &lt; d8, [ -12, -11, -10 ] &gt;
3:  Gd8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectList(Kd8);</span>
[ -16, -15, -14, -12, -11, -10, -9, -8, -7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsHomogeneousDomainWithObjects( Kd8 );</span>
true

</pre></div>

<p><a id="X7F23BE3F85C9BA06" name="X7F23BE3F85C9BA06"></a></p>

<h4>3.2 <span class="Heading">Groupoid elements; stars; costars; homsets</span></h4>

<p><a id="X86247DFC8242CEBE" name="X86247DFC8242CEBE"></a></p>

<h5>3.2-1 Arrow</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Arrow</code>( <var class="Arg">gpd</var>, <var class="Arg">elt</var>, <var class="Arg">tail</var>, <var class="Arg">head</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ElementOfArrow</code>( <var class="Arg">elt</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TailOfArrow</code>( <var class="Arg">elt</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeadOfArrow</code>( <var class="Arg">elt</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsArrowIn</code>( <var class="Arg">arr</var>, <var class="Arg">gpd</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>A <em>groupoid element</em> is an arrow in a magma with objects, as described in subsection <a href="chap1.html#X86247DFC8242CEBE"><span class="RefLink">1.1-2</span></a>. To recapitulate, an arrow <code class="code">e</code> consists of a group element, <code class="code">ElementOfArrow(e)</code> or <code class="code">e![1]</code>; the tail (source) object, <code class="code">TailOfArrow(e)</code> or <code class="code">e![2]</code>; and the head (target) object, <code class="code">HeadOfArrow(e)</code> or <code class="code">e![3]</code>. Arrows have a <em>partial composition</em>: two arrows may be multiplied when the head of the first coincides with the tail of the second. When an attempt is made to multiply arrows where this condition does not hold, then the value <code class="code">fail</code> is returned. (In earlier versions of the package there were functions <code class="code">GroupoidElement</code> and <code class="code">MultiplicativeElementWithObjects</code>, but these have now been replaced by <code class="code">Arrow</code>.)</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e1 := Arrow( Gd8, (1,2,3,4), -9, -8 );</span>
[(1,2,3,4) : -9 -&gt; -8]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e2 := Arrow( Gd8, (1,3), -8, -7 );</span>
[(1,3) : -8 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print( [ ElementOfArrow(e2), TailOfArrow(e2), HeadOfArrow(e2) ], "\n" );</span>
[ (1,3), -8, -7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prod := e1*e2;</span>
[(1,2)(3,4) : -9 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e2*e1;</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e3 := Arrow( Gd8, (2,4), -7, -9 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cycle := prod*e3;</span>
[(1,4,3,2) : -9 -&gt; -9]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cycle^2;</span>
[(1,3)(2,4) : -9 -&gt; -9]

</pre></div>

<p><a id="X78C3228682279032" name="X78C3228682279032"></a></p>

<h5>3.2-2 IdentityArrow</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IdentityArrow</code>( <var class="Arg">gpd</var>, <var class="Arg">obj</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The identity arrow <span class="SimpleMath">1_o</span> of <span class="SimpleMath">G</span> at object <span class="SimpleMath">o</span> is <span class="SimpleMath">(e:o -&gt; o)</span> where <span class="SimpleMath">e</span> is the identity element in the object group. The inverse <span class="SimpleMath">e^-1</span> of <span class="SimpleMath">e = (c : p -&gt; q)</span> is <span class="SimpleMath">(c^-1 : q -&gt; p)</span>, so that <span class="SimpleMath">e*e^-1=1_p</span> and <span class="SimpleMath">e^-1*e = 1_q</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i8 := IdentityArrow( Gd8, -8 );</span>
[() : -8 -&gt; -8]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ e1*i8, i8*e1, e1^-1]; </span>
[ [(1,2,3,4) : -9 -&gt; -8], fail, [(1,4,3,2) : -8 -&gt; -9] ]

</pre></div>

<p><a id="X84F59A2687C62763" name="X84F59A2687C62763"></a></p>

<h5>3.2-3 Order</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Order</code>( <var class="Arg">arr</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>A groupoid element is a <em>loop</em> when the tail and head coincide. In this case the order of the element is defined to be the order of its group element.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i8; Order(i8);</span>
[() : -8 -&gt; -8]
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cycle; Order(cycle);</span>
[(1,4,3,2) : -9 -&gt; -9]
4

</pre></div>

<p><a id="X7B561BAE7D471C60" name="X7B561BAE7D471C60"></a></p>

<h5>3.2-4 ObjectStar</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ObjectStar</code>( <var class="Arg">gpd</var>, <var class="Arg">obj</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ObjectCostar</code>( <var class="Arg">gpd</var>, <var class="Arg">obj</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Homset</code>( <var class="Arg">gpd</var>, <var class="Arg">tail</var>, <var class="Arg">head</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The <em>star</em> at <code class="code">obj</code> is the set of arrows which have <code class="code">obj</code> as tail, while the <em>costar</em> is the set of arrows which have <code class="code">obj</code> as head. The <em>homset</em> from <code class="code">obj1</code> to <code class="code">obj2</code> is the set of arrows with the specified tail and head, and so is bijective with the elements of the object groups. Thus every star and every costar is a union of homsets. The identity arrow at an object is a left identity for the star and a right identity for the costar at that object.</p>

<p>In order not to create unneccessarily long lists, these operations return objects of type <code class="code">IsHomsetCosetsRep</code> for which an <code class="code">Iterator</code> is provided. (An <code class="code">Enumerator</code> is not yet implemented.)</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">star9 := ObjectStar( Gd8, -9 );</span>
&lt;star at [ -9 ] with group d8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( star9 ); </span>
24
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for e in star9 do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if ( Order( ElementOfArrow(e) ) = 4 ) then Print( e, "\n" ); fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
[(1,4,3,2) : -9 -&gt; -9]
[(1,4,3,2) : -9 -&gt; -8]
[(1,4,3,2) : -9 -&gt; -7]
[(1,2,3,4) : -9 -&gt; -9]
[(1,2,3,4) : -9 -&gt; -8]
[(1,2,3,4) : -9 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">costar6 := ObjectCostar( Gc6, -6 );</span>
&lt;costar at [ -6 ] with group c6&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( costar6 ); </span>
6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hsetq8 := Homset( Gq8, -28, -27 );</span>
&lt;homset -28 -&gt; -27 with group q8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for e in hsetq8 do Print(e,"\n"); od;</span>
[&lt;identity&gt; of ... : -28 -&gt; -27]
[f3 : -28 -&gt; -27]
[f2 : -28 -&gt; -27]
[f2*f3 : -28 -&gt; -27]
[f1 : -28 -&gt; -27]
[f1*f3 : -28 -&gt; -27]
[f1*f2 : -28 -&gt; -27]
[f1*f2*f3 : -28 -&gt; -27]

</pre></div>

<p><a id="X7BDBA72C852C4625" name="X7BDBA72C852C4625"></a></p>

<h4>3.3 <span class="Heading">Subgroupoids</span></h4>

<p><a id="X80780D287EDDB7BB" name="X80780D287EDDB7BB"></a></p>

<h5>3.3-1 Subgroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Subgroupoid</code>( <var class="Arg">args</var> )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubgroupoidByPieces</code>( <var class="Arg">gpd</var>, <var class="Arg">obhoms</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSubgroupoid</code>( <var class="Arg">gpd</var>, <var class="Arg">sgpd</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FullSubgroupoid</code>( <var class="Arg">gpd</var>, <var class="Arg">obs</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MaximalDiscreteSubgroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DiscreteSubgroupoid</code>( <var class="Arg">gpd</var>, <var class="Arg">sgps</var>, <var class="Arg">obs</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FullTrivialSubgroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DiscreteTrivialSubgroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsWide</code>( <var class="Arg">gpd</var>, <var class="Arg">sgpd</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>A <em>subgroupoid</em> <code class="code">sgpd</code> of a groupoid <code class="code">gpd</code> has as objects some subset of the objects of <code class="code">gpd</code>. It is <em>wide</em> if all the objects are included. It is <em>full</em> if, for any two objects in <code class="code">sgpd</code>, the <code class="code">Homset</code> is the same as that in <code class="code">gpd</code>. The arrows of <code class="code">sgpd</code> are a subset of those of <code class="code">gpd</code>, closed under multiplication and with tail and head in the chosen object set.</p>

<p>There are a variety of constructors for a subgroupoid of a groupoid, and the most general is the operation <code class="code">SubgroupoidByPieces</code>. Its two parameters are a groupoid and a list of pieces, each piece being specified as a list <code class="code">[sgp,obs]</code>, where <code class="code">sgp</code> is a subgroup of the root group in that piece, and <code class="code">obs</code> is a subset of the objects in that piece. The <code class="code">FullSubgroupoid</code> of a groupoid <code class="code">gpd</code> on a subset <code class="code">obs</code> of its objects contains all the arrows of <code class="code">gpd</code> with tail and head in <code class="code">obs</code>. A subgroupoid is <em>discrete</em> if it is a union of groups. The <code class="code">MaximalDiscreteSubgroupoid</code> of <code class="code">gpd</code> is the union of all the single-object full subgroupoids of <code class="code">gpd</code>. A <em>trivial subgroupoid</em> has trivial object groups, but need not be discrete. A single piece trivial groupoid is sometimes called a <em>tree groupoid</em>. (The term <em>identity subgroupoid</em> was used in versions up to 1.14.) The global function <code class="code">Subgroupoid</code> should call the appropriate operation.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c4 := Subgroup( d8, [ (1,2,3,4) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k4 := Subgroup( d8, [ (1,2)(3,4), (1,3)(2,4) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( c4, "c4" );  SetName( k4, "k4" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ud8 := Subgroupoid( Gd8, [ [ k4, [-9] ], [ c4, [-8,-7] ] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( Ud8, "Ud8" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Ud8 );</span>
groupoid with 2 pieces:
&lt; objects: [ -9 ]
    group: k4 = &lt;[ (1,2)(3,4), (1,3)(2,4) ]&gt; &gt;
&lt; objects: [ -8, -7 ]
    group: c4 = &lt;[ (1,2,3,4) ]&gt; &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ Parent( Ud8 ), IsWide( Gd8, Ud8 ) ]; </span>
[ Gd8, true ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">genf2b := List( GeneratorsOfGroup(f2), g -&gt; g^2 );</span>
[ f1^2, f2^2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f2b := Subgroup( f2, genf2b );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubgroupoidByPieces( U2, [ [q8,[-27]], [f2b,[-22]] ] );</span>
groupoid with 2 pieces:
1:  single piece groupoid: &lt; q8, [ -27 ] &gt;
2:  single piece groupoid: &lt; Group( [ f1^2, f2^2 ] ), [ -22 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubgroupoid( Gf2, Groupoid( f2b, [-22] ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FullSubgroupoid( U3, [-7,-6] );</span>
groupoid with 2 pieces:
1:  single piece groupoid: &lt; d8, [ -7 ] &gt;
2:  single piece groupoid: &lt; c6, [ -6 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DiscreteSubgroupoid( U3, [ c4, k4 ], [-9,-7] );</span>
groupoid with 2 pieces:
1:  single piece groupoid: &lt; c4, [ -9 ] &gt;
2:  single piece groupoid: &lt; k4, [ -7 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FullTrivialSubgroupoid( Ud8 );</span>
groupoid with 2 pieces:
1:  single piece groupoid: &lt; id(k4), [ -9 ] &gt;
2:  single piece groupoid: &lt; id(c4), [ -8, -7 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MaximalDiscreteSubgroupoid(U2);</span>
groupoid with 3 pieces:
1:  single piece groupoid: &lt; q8, [ -28 ] &gt;
2:  single piece groupoid: &lt; q8, [ -27 ] &gt;
3:  single piece groupoid: &lt; f2, [ -22 ] &gt;

</pre></div>

<p><a id="X873E0914871858E8" name="X873E0914871858E8"></a></p>

<h5>3.3-2 SubgroupoidWithRays</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubgroupoidWithRays</code>( <var class="Arg">gpd</var>, <var class="Arg">sgp</var>, <var class="Arg">rays</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RaysOfGroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RayElementsOfGroupoid</code>( <var class="Arg">gpd</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>If groupoid <span class="SimpleMath">G</span> is of type <code class="code">IsDirectProductWithCompleteGraph</code> with group <span class="SimpleMath">g</span> and <span class="SimpleMath">n</span> objects, then a typical wide subgroupoid <span class="SimpleMath">H</span> of <span class="SimpleMath">G</span> is formed by choosing a subgroup <span class="SimpleMath">h</span> of <span class="SimpleMath">g</span> to be the object group at the root object <span class="SimpleMath">q</span>, and an arrow <span class="SimpleMath">r : q -&gt; p</span> for each of the objects <span class="SimpleMath">p</span>. The chosen loop arrow at <span class="SimpleMath">q</span> must be the identity arrow. These <span class="SimpleMath">n</span> arrows are called the <em>rays</em> of the subgroupoid. The arrows in the homset from <span class="SimpleMath">p</span> to <span class="SimpleMath">p'</span> have the form <span class="SimpleMath">r^-1xr'</span> for all rays <span class="SimpleMath">r,r'</span> and all <span class="SimpleMath">x</span> in <span class="SimpleMath">h</span>.</p>

<p>The operation <code class="code">RaysOfGroupoid</code> returns a list of arrows, one for each object, while the operation <code class="code">RayElementsOfGroupoid</code> returns the list of group elements in these arrows.</p>

<p>In the following example we construct a subgroupoid with rays on four of the five objects. It is therefore necessary to construct the full subgroupoid on these four objects first.</p>

<p>Note that it is also possible to construct a subgroupoid with rays of a subgroupoid with rays.</p>

<p>Note also that the function <code class="code">Ancestor</code> provides an iteration of <code class="code">Parent</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hs4 := FullSubgroupoid( Gs4, [-14,-13,-12] );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( Hs4, "Hs4" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hd8a := SubgroupoidWithRays( Hs4, d8, [(),(2,3),(3,4)] );</span>
single piece groupoid with rays: &lt; d8, [ -14, -13, -12 ], [ (), (2,3), (3,4)
 ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hs1413 := Homset( Hd8a, -14, -13 );</span>
&lt;homset -14 -&gt; -13 with group d8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for e in hs1413 do  Print(e,", "); od;  Print( "\n");</span>
[(2,3) : -14 -&gt; -13], [(1,2,4,3) : -14 -&gt; -13], [(1,4,2) : -14 -&gt; -13], [
(1,3,4) : -14 -&gt; -13], [(2,4,3) : -14 -&gt; -13], [(1,2,3) : -14 -&gt; -13], [
(1,4) : -14 -&gt; -13], [(1,3,4,2) : -14 -&gt; -13], 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hd8b := SubgroupoidWithRays( Hs4, d8, [(),(1,2,3),(1,2,4)] );</span>
single piece groupoid with rays: &lt; d8, [ -14, -13, -12 ],
[ (), (1,2,3), (1,2,4) ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hd8a = Hd8b; </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RaysOfGroupoid( Hd8b );</span>
[ [() : -14 -&gt; -14], [(1,2,3) : -14 -&gt; -13], [(1,2,4) : -14 -&gt; -12] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RayElementsOfGroupoid( Hd8b ); </span>
[ (), (1,2,3), (1,2,4) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Parent( Hd8a );</span>
Hs4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ancestor( Hd8a ); </span>
Gs4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fd8a := FullSubgroupoid( Hd8a, [-14,-13]);</span>
single piece groupoid with rays: &lt; d8, [ -14, -13 ], [ (), (2,3) ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fd8b := FullSubgroupoid( Hd8a, [-13,-12]);</span>
single piece groupoid with rays: &lt; Group( [ (1,3,2,4), (1,2) ] ), 
[ -13, -12 ], [ (), (2,4,3) ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Fd8a := FullSubgroupoid( Hd8a, [-13,-12] );            </span>
single piece groupoid with rays: &lt; Group( [ (1,3,2,4), (1,2) ] ), 
[ -13, -12 ], [ (), (2,4,3) ] &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Kd8a := SubgroupoidWithRays( Fd8a, k4, [ (), (1,3) ] ); </span>
single piece groupoid with rays: &lt; k4, [ -13, -12 ], [ (), (1,3) ] &gt;

</pre></div>

<p><a id="X831AA9E8780235F2" name="X831AA9E8780235F2"></a></p>

<h4>3.4 <span class="Heading">Left, right and double cosets</span></h4>

<p><a id="X8412ABD57986B9FC" name="X8412ABD57986B9FC"></a></p>

<h5>3.4-1 RightCoset</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightCoset</code>( <var class="Arg">G</var>, <var class="Arg">U</var>, <var class="Arg">elt</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightCosetRepresentatives</code>( <var class="Arg">G</var>, <var class="Arg">U</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftCoset</code>( <var class="Arg">G</var>, <var class="Arg">U</var>, <var class="Arg">elt</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftCosetRepresentatives</code>( <var class="Arg">G</var>, <var class="Arg">U</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftCosetRepresentativesFromObject</code>( <var class="Arg">G</var>, <var class="Arg">U</var>, <var class="Arg">obj</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DoubleCoset</code>( <var class="Arg">G</var>, <var class="Arg">U</var>, <var class="Arg">elt</var>, <var class="Arg">V</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DoubleCosetRepresentatives</code>( <var class="Arg">G</var>, <var class="Arg">U</var>, <var class="Arg">V</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>If <code class="code">U</code> is a wide subgroupoid of <span class="SimpleMath">G</span>, the <em>right cosets</em> <span class="SimpleMath">Ug</span> of <span class="SimpleMath">U</span> in <span class="SimpleMath">G</span> are the equivalence classes for the relation on the arrows of <span class="SimpleMath">G</span> where <span class="SimpleMath">g1</span> is related to <span class="SimpleMath">g2</span> if and only if <span class="SimpleMath">g2 = u*g1</span> for some arrow <span class="SimpleMath">u</span> of <span class="SimpleMath">U</span>. The right coset containing <span class="SimpleMath">g</span> is written <span class="SimpleMath">Ug</span>. These right cosets partition the costars of <span class="SimpleMath">G</span> and, in particular, the costar <span class="SimpleMath">U1_o</span> of <span class="SimpleMath">U</span> at object <span class="SimpleMath">o</span>, so that (unlike groups) <span class="SimpleMath">U</span> is itself a coset only when <span class="SimpleMath">G</span> has a single object.</p>

<p>The <em>right coset representatives</em> for <span class="SimpleMath">U</span> in <span class="SimpleMath">G</span> form a list containing one arrow for each coset where, in a particular piece of <span class="SimpleMath">U</span>, the group element chosen is the right coset representative of the group of <span class="SimpleMath">U</span> in the group of <span class="SimpleMath">G</span>.</p>

<p>Similarly, the <em>left cosets</em> <span class="SimpleMath">gU</span> refine the stars of <span class="SimpleMath">G</span>, while <em>double cosets</em> are unions of left cosets and right cosets. The operation <code class="code">LeftCosetRepresentativesFromObject( G, U, obj )</code> is used in Chapter 4, and returns only those representatives which have tail at <code class="code">obj</code>.</p>

<p>As with stars and homsets, these cosets are implemented with representation <code class="code">IsHomsetCosetsRep</code> and provided with an iterator. Note that, when <span class="SimpleMath">U</span> has more than one piece, cosets may have differing lengths.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">re2 := RightCoset( Gd8, Ud8, e2 );</span>
RightCoset(single piece groupoid: &lt; c4, [ -8, -7 ] &gt;,[(1,3) : -8 -&gt; -7])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for x in re2 do Print( x, "\n" ); od;</span>
[(1,3) : -8 -&gt; -7]
[(1,3) : -7 -&gt; -7]
[(2,4) : -8 -&gt; -7]
[(2,4) : -7 -&gt; -7]
[(1,4)(2,3) : -8 -&gt; -7]
[(1,4)(2,3) : -7 -&gt; -7]
[(1,2)(3,4) : -8 -&gt; -7]
[(1,2)(3,4) : -7 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rcrd8 := RightCosetRepresentatives( Gd8, Ud8 );</span>
[ [() : -9 -&gt; -9], [() : -9 -&gt; -8], [() : -9 -&gt; -7], [(2,4) : -9 -&gt; -9],
  [(2,4) : -9 -&gt; -8], [(2,4) : -9 -&gt; -7], [() : -8 -&gt; -9], [() : -8 -&gt; -8],
  [() : -8 -&gt; -7], [(2,4) : -8 -&gt; -9], [(2,4) : -8 -&gt; -8], [(2,4) : -8 -&gt; -7]
 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lcr7 := LeftCosetRepresentativesFromObject( Gd8, Ud8, -7 );</span>
[ [() : -7 -&gt; -9], [(2,4) : -7 -&gt; -9], [() : -7 -&gt; -8], [(2,4) : -7 -&gt; -8] ]

</pre></div>

<p><a id="X8653FC9786E3209A" name="X8653FC9786E3209A"></a></p>

<h4>3.5 <span class="Heading">Conjugation</span></h4>

<p><a id="X851E390F87037421" name="X851E390F87037421"></a></p>

<h5>3.5-1 ConjugateArrow</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConjugateArrow</code>( <var class="Arg">e1</var>, <var class="Arg">e</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>When <span class="SimpleMath">e = (c : p -&gt; q)</span> conjugation by <span class="SimpleMath">e</span> is the groupoid automorphism defined as follows. There are two cases.</p>

<p>In the case <span class="SimpleMath">p ≠ q</span>,</p>


<ul>
<li><p>objects <span class="SimpleMath">p,q</span> are interchanged, and the remaining objects are fixed;</p>

</li>
<li><p>loops at <span class="SimpleMath">p,q</span>: <span class="SimpleMath">(b: p -&gt; p) ↦ (b^c : q -&gt; q)</span> and <span class="SimpleMath">(b: q -&gt; q) ↦ (b^c^-1} : p -&gt; p)</span>;</p>

</li>
<li><p>arrows between <span class="SimpleMath">p</span> and <span class="SimpleMath">q</span>: <span class="SimpleMath">(b : p -&gt; q) ↦ (c^-1bc^-1 : q -&gt; p)</span> and <span class="SimpleMath">(b : q -&gt; p) ↦ (cbc : p -&gt; q)</span>;</p>

</li>
<li><p>costar at <span class="SimpleMath">p,q</span>: <span class="SimpleMath">(b : r -&gt; p) ↦ (bc : r -&gt; q)</span> and <span class="SimpleMath">(b : r -&gt; q) ↦ (bc^-1 : r -&gt; p)</span>;</p>

</li>
<li><p>star at <span class="SimpleMath">p,q</span>: <span class="SimpleMath">(b : p -&gt; r) ↦ (c^-1b : -&gt; q)</span> and <span class="SimpleMath">(b : q -&gt; r) ↦ (cb : p -&gt; r)</span>;</p>

</li>
<li><p>the remaining arrows are unchanged.</p>

</li>
</ul>
<p>In the case <span class="SimpleMath">p=q</span>,</p>


<ul>
<li><p>all the objects are fixed;</p>

</li>
<li><p>loops at <span class="SimpleMath">p</span> are conjugated by <span class="SimpleMath">c</span>, <span class="SimpleMath">(b : p -&gt; p) ↦ (b^c : p -&gt; p)</span>;</p>

</li>
<li><p>the rest of the costar and star at <span class="SimpleMath">p</span> are permuted, <span class="SimpleMath">(b : r -&gt; p) ↦ (bc : r -&gt; p)</span> and <span class="SimpleMath">(b : p -&gt; r) ↦ (c^-1b : p -&gt; r)</span>;</p>

</li>
<li><p>the remaining arrows are unchanged.</p>

</li>
</ul>
<p>The details of this construction may be found in <a href="chapBib.html#biBAlWe">[AW10]</a>.</p>

<p>(Note that it is more desirable to use the command <code class="code">e1^e2</code>, but it has not yet been possible to get this to work!)</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Arrow( Gd8, (1,3), -9, -9 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y := Arrow( Gd8, (1,2,3,4), -8, -9 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := Arrow( Gd8, (1,2)(3,4), -9, -7 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := Arrow( Gd8, (1,2,3,4), -7, -8 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##  conjugation with arrows x, y, z and w in Gd8: </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateArrow(x,y);</span>
[(2,4) : -8 -&gt; -8]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateArrow(x,z);</span>
[(2,4) : -7 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateArrow(x,w);</span>
[(1,3) : -9 -&gt; -9]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateArrow(y,x);</span>
[() : -8 -&gt; -9]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateArrow(y,z);</span>
[(2,4) : -8 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateArrow(y,w);    </span>
[(1,3)(2,4) : -7 -&gt; -9]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateArrow(z,x);</span>
[(1,4,3,2) : -9 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateArrow(z,y);</span>
[(2,4) : -8 -&gt; -7]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateArrow(z,w);</span>
[(1,3) : -9 -&gt; -8]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateArrow(w,x); </span>
[(1,2,3,4) : -7 -&gt; -8]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateArrow(w,y);</span>
[(1,3)(2,4) : -7 -&gt; -9]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateArrow(w,z);</span>
[(1,3) : -9 -&gt; -8]

</pre></div>

<p><a id="X7C2727D285BA2EBE" name="X7C2727D285BA2EBE"></a></p>

<h5>3.5-2 SinglePieceGroupoidByGenerators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SinglePieceGroupoidByGenerators</code>( <var class="Arg">parent</var>, <var class="Arg">gens</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>A set of arrows generates a groupoid by taking all possible products and inverses. So far, the only implementation is for the case of loops generating a group at an object <span class="SimpleMath">o</span> andf a set of rays from <span class="SimpleMath">o</span>, where <span class="SimpleMath">o</span> is <em>not</em> the least object. A suitably large supergroupoid, which must be a direct product with a complete graph, should be provided. This is the case needed for <code class="code">ConjugateGroupoid</code> in the following section. Other cases will be added as time permits.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := Arrow( Gs4, (1,2,3), -15, -13 ); </span>
[(1,2,3) : -15 -&gt; -13]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gensa := GeneratorsOfGroupoid( Hd8a );</span>
[ [(1,2,3,4) : -14 -&gt; -14], [(1,3) : -14 -&gt; -14], [(2,3) : -14 -&gt; -13], 
  [(3,4) : -14 -&gt; -12] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">imsa := List( gensa, g -&gt; ConjugateArrow( g, u ) ); </span>
[ [(1,2,3,4) : -14 -&gt; -14], [(1,3) : -14 -&gt; -14], [(1,3) : -14 -&gt; -15], 
  [(3,4) : -14 -&gt; -12] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := SinglePieceGroupoidByGenerators( Gs4, imsa ); </span>
single piece groupoid with rays: &lt; Group( [ (1,4,3,2), (1,3) ] ), 
[ -15, -14, -12 ], [ (), (1,3), (1,4,3) ] &gt;

</pre></div>

<p><a id="X78218F357BFEDE82" name="X78218F357BFEDE82"></a></p>

<h5>3.5-3 ConjugateGroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConjugateGroupoid</code>( <var class="Arg">gpd</var>, <var class="Arg">e</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>When <span class="SimpleMath">H</span> is a subgroupoid of a groupoid <span class="SimpleMath">G</span> and <span class="SimpleMath">a</span> is an arrow of <span class="SimpleMath">G</span>, then the conjugate of <span class="SimpleMath">H</span> by <span class="SimpleMath">a</span> is the subgroupoid generated by the conjugates of the generators of <span class="SimpleMath">H</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugateGroupoid( Hd8a, u^-1 ); </span>
single piece groupoid with rays: &lt; Group( [ (1,4,3,2), (1,3) ] ), 
[ -15, -14, -12 ], [ (), (1,3), (1,4,3) ] &gt;

</pre></div>

<p>More examples of all these operations may be found in the example file <code class="file">gpd/examples/gpd.g</code>.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
