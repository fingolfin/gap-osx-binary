<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (recog) - Chapter 3: Methods for recognition</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>

<p><a id="X78C5295B86AD0C66" name="X78C5295B86AD0C66"></a></p>
<div class="ChapSects"><a href="chap3.html#X78C5295B86AD0C66">3 <span class="Heading">Methods for recognition</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X829A2F96860513F2">3.1 <span class="Heading">Methods for permutation groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8553B50D83FF8D09">3.1-1 <span class="Heading"><code class="code">TrivialPermGroup</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D0F93CC7F6FD5FA">3.1-2 <span class="Heading"><code class="code">ThrowAwayFixedPoints</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7936FB597D61D4F1">3.1-3 <span class="Heading"><code class="code">Pcgs</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X789EC18884A6169E">3.1-4 <span class="Heading"><code class="code">VeryFewPoints</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8251084C84624B79">3.1-5 <span class="Heading"><code class="code">Nontransitive</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X86008C717EE1C27A">3.1-6 <span class="Heading"><code class="code">Giant</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79CD5A5D8743F365">3.1-7 <span class="Heading"><code class="code">Imprimitive</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7FE7B1407E9C60B8">3.1-8 <span class="Heading"><code class="code">SnkSetswrSr</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X784801B47E9838D5">3.1-9 <span class="Heading"><code class="code">StabChain</code></span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X829BA50B82FEC109">3.2 <span class="Heading">Methods for matrix groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X796A682C78FFB9DC">3.2-1 <span class="Heading"><code class="code">TrivialMatrixGroup</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79C0EC2987BCA334">3.2-2 <span class="Heading"><code class="code">DiagonalMatrices</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8499282F7825D28C">3.2-3 <span class="Heading"><code class="code">ReducibleIso</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X85655B8082FCB0AD">3.2-4 <span class="Heading"><code class="code">BlockLowerTriangular</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X799EEBE27AF157B6">3.2-5 <span class="Heading"><code class="code">BlockDiagonal</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79A0674B7ECAFB62">3.2-6 <span class="Heading"><code class="code">GoProjective</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B9301E97DE36543">3.2-7 <span class="Heading"><code class="code">BlockScalar</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X78A525FD797F429B">3.2-8 <span class="Heading"><code class="code">LowerLeftPGroup</code></span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X867550F684F795AE">3.3 <span class="Heading">Methods for projective groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X814A92C48174540D">3.3-1 <span class="Heading"><code class="code">TrivialProjectiveGroup</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B8A3F4781278CEF">3.3-2 <span class="Heading"><code class="code">ProjDeterminant</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8499282F7825D28C">3.3-3 <span class="Heading"><code class="code">ReducibleIso</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X803E531C83954EC5">3.3-4 <span class="Heading"><code class="code">BlocksModScalars</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X83737D087B53188A">3.3-5 <span class="Heading"><code class="code">NotAbsolutelyIrred</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80EA5C7580235817">3.3-6 <span class="Heading"><code class="code">Subfield</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B46C2848668373B">3.3-7 <span class="Heading"><code class="code">Derived</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X86BAC96E7BA6E699">3.3-8 <span class="Heading"><code class="code">LowIndex</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8010C98580729238">3.3-9 <span class="Heading"><code class="code">C6</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8750385D847D5C24">3.3-10 <span class="Heading"><code class="code">Tensor</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X856A17D787B6435D">3.3-11 <span class="Heading"><code class="code">TwoLargeElOrders</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79CB567683B3A36F">3.3-12 <span class="Heading"><code class="code">StabilizerChain</code></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7BFA205981277BD5">3.3-13 <span class="Heading"><code class="code">BlockScalarProj</code></span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X81DB42647E8FA7B6">3.4 <span class="Heading">Methods for black box groups</span></a>
</span>
</div>
</div>

<h3>3 <span class="Heading">Methods for recognition</span></h3>

<p><a id="X829A2F96860513F2" name="X829A2F96860513F2"></a></p>

<h4>3.1 <span class="Heading">Methods for permutation groups</span></h4>

<p>The following table gives an overview over the installed methods and their rank (higher rank means higher priority, the method is tried earlier, see Chapter <a href="/Users/mhorn/Projekte/GAP/repos/pkg/neunhoef/recogbase/doc/chap3.html#X8058CC8187162644"><span class="RefLink">recogbase: Method Selection</span></a>).</p>

<div class="pcenter"><table class="GAPDocTable">
<caption class="GAPDocTable"><b>Table: </b>Permutation group find homomorphism methods</caption>
<tr>
<td class="tdleft">300</td>
<td class="tdleft"><code class="code">TrivialPermGroup</code></td>
<td class="tdleft"><a href="chap3.html#X8553B50D83FF8D09"><span class="RefLink">3.1-1</span></a></td>
</tr>
<tr>
<td class="tdleft">100</td>
<td class="tdleft"><code class="code">ThrowAwayFixedPoints</code></td>
<td class="tdleft"><a href="chap3.html#X7D0F93CC7F6FD5FA"><span class="RefLink">3.1-2</span></a></td>
</tr>
<tr>
<td class="tdleft">97</td>
<td class="tdleft"><code class="code">Pcgs</code></td>
<td class="tdleft"><a href="chap3.html#X7936FB597D61D4F1"><span class="RefLink">3.1-3</span></a></td>
</tr>
<tr>
<td class="tdleft">95</td>
<td class="tdleft"><code class="code">VeryFewPoints</code></td>
<td class="tdleft"><a href="chap3.html#X789EC18884A6169E"><span class="RefLink">3.1-4</span></a></td>
</tr>
<tr>
<td class="tdleft">90</td>
<td class="tdleft"><code class="code">NonTransitive</code></td>
<td class="tdleft"><a href="chap3.html#X8251084C84624B79"><span class="RefLink">3.1-5</span></a></td>
</tr>
<tr>
<td class="tdleft">80</td>
<td class="tdleft"><code class="code">Giant</code></td>
<td class="tdleft"><a href="chap3.html#X86008C717EE1C27A"><span class="RefLink">3.1-6</span></a></td>
</tr>
<tr>
<td class="tdleft">70</td>
<td class="tdleft"><code class="code">Imprimitive</code></td>
<td class="tdleft"><a href="chap3.html#X79CD5A5D8743F365"><span class="RefLink">3.1-7</span></a></td>
</tr>
<tr>
<td class="tdleft">60</td>
<td class="tdleft"><code class="code">SnkSetswrSr</code></td>
<td class="tdleft"><a href="chap3.html#X7FE7B1407E9C60B8"><span class="RefLink">3.1-8</span></a></td>
</tr>
<tr>
<td class="tdleft">50</td>
<td class="tdleft"><code class="code">StabChain</code></td>
<td class="tdleft"><a href="chap3.html#X784801B47E9838D5"><span class="RefLink">3.1-9</span></a></td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p><a id="X8553B50D83FF8D09" name="X8553B50D83FF8D09"></a></p>

<h5>3.1-1 <span class="Heading"><code class="code">TrivialPermGroup</code></span></h5>

<p>This method is successful if and only if all generators of the permutation group <var class="Arg">G</var> are equal to the identity. Otherwise it returns <code class="keyw">false</code> indicating that it will never succeed. This method is only installed to handle the trivial case such that we do not have to take this case into account in the other methods.</p>

<p><a id="X7D0F93CC7F6FD5FA" name="X7D0F93CC7F6FD5FA"></a></p>

<h5>3.1-2 <span class="Heading"><code class="code">ThrowAwayFixedPoints</code></span></h5>

<p>This method defines a homomorphism of a permutation group <var class="Arg">G</var> to the action on the moved points of <var class="Arg">G</var> if <var class="Arg">G</var> does not have too many moved points. In the current setup, the homomorphism is defined if the number <span class="SimpleMath">k</span> of moved points is at most <span class="SimpleMath">1/3</span> of the largest moved point of <var class="Arg">G</var>, or <span class="SimpleMath">k</span> is at most half of the number of points on which <var class="Arg">G</var> is stored internally by <strong class="pkg">GAP</strong>. The method returns <code class="keyw">false</code> if it does not define a homomorphism indicating that it will never succeed.</p>

<p><a id="X7936FB597D61D4F1" name="X7936FB597D61D4F1"></a></p>

<h5>3.1-3 <span class="Heading"><code class="code">Pcgs</code></span></h5>

<p>This is the <strong class="pkg">GAP</strong> library function to compute a stabiliser chain for a solvable permutation group. If the method is successful then the calling node becomes a leaf node in the recursive scheme. If the input group is not solvable then the method returns <code class="keyw">false</code>.</p>

<p><a id="X789EC18884A6169E" name="X789EC18884A6169E"></a></p>

<h5>3.1-4 <span class="Heading"><code class="code">VeryFewPoints</code></span></h5>

<p>If a permutation group acts only on a few points (the current limit is at most 10 points) then a stabiliser chain is computed by the randomized <strong class="pkg">GAP</strong> library function for that purpose. If the method is successful then the calling node becomes a leaf node in the recursive scheme. If the input group acts on more than 10 points then the method returns <code class="keyw">false</code>.</p>

<p><a id="X8251084C84624B79" name="X8251084C84624B79"></a></p>

<h5>3.1-5 <span class="Heading"><code class="code">Nontransitive</code></span></h5>

<p>If a permutation group <var class="Arg">G</var> acts nontransitively then this method computes a homomorphism to the action of <var class="Arg">G</var> on the orbit of the largest moved point. If <var class="Arg">G</var> is transitive then the method returns <code class="keyw">false</code>.</p>

<p><a id="X86008C717EE1C27A" name="X86008C717EE1C27A"></a></p>

<h5>3.1-6 <span class="Heading"><code class="code">Giant</code></span></h5>

<p>The method tries to determine whether the input group <var class="Arg">G</var> is a giant (that is, <span class="SimpleMath">A_n</span> or <span class="SimpleMath">S_n</span> in its natural action on <span class="SimpleMath">n</span> points). The output is either a data structure <span class="SimpleMath">D</span> containing nice generators for <var class="Arg">G</var> and a procedure to write an SLP for arbitrary elements of <var class="Arg">G</var> from the nice generators; or <code class="keyw">false</code> if <var class="Arg">G</var> is not transitive; or <code class="keyw">fail</code>, in the case that no evidence was found that <var class="Arg">G</var> is a giant, or evidence was found, but the construction of <span class="SimpleMath">D</span> was unsuccessful. If the method constructs <span class="SimpleMath">D</span> then the calling node becomes a leaf.</p>

<p><a id="X79CD5A5D8743F365" name="X79CD5A5D8743F365"></a></p>

<h5>3.1-7 <span class="Heading"><code class="code">Imprimitive</code></span></h5>

<p>If the input group is not known to be transitive then this method returns <code class="keyw">NotApplicable</code>. If the input group is known to be transitive and primitive then the method returns <code class="keyw">false</code>; otherwise, the method tries to compute a nontrivial block system. If successful then a homomorphism to the action on the blocks is defined; otherwise, the method returns <code class="keyw">false</code>. If the method is successful then it also gives a hint for the children of the node by determining whether the kernel of the action on the block system is solvable. If the answer is yes then the default value 20 for the number of random generators in the kernel construction is increased by the number of blocks.</p>

<p><a id="X7FE7B1407E9C60B8" name="X7FE7B1407E9C60B8"></a></p>

<h5>3.1-8 <span class="Heading"><code class="code">SnkSetswrSr</code></span></h5>

<p>This method tries to determine whether the input group <var class="Arg">G</var> is acting primitively on <span class="SimpleMath">N</span> points, and is isomorphic to a large subgroup of <span class="SimpleMath">H ≀ S_r</span> where <span class="SimpleMath">H</span> is <span class="SimpleMath">S_n</span> acting on <span class="SimpleMath">k</span>-sets and <span class="SimpleMath">N = {n choose k}^r</span> and <span class="SimpleMath">kr &gt; 1</span>. "Large" means that <var class="Arg">G</var> contains a subgroup isomorphic to <span class="SimpleMath">A_n^r</span>. If <var class="Arg">G</var> is imprimitive then the output is <code class="keyw">false</code>. If <var class="Arg">G</var> is primitive then the output is either a homomorphism into the natural imprimitive action of <var class="Arg">G</var> on <span class="SimpleMath">nr</span> points with <span class="SimpleMath">r</span> blocks of size <span class="SimpleMath">n</span>, or <code class="keyw">fail</code>.</p>

<p><a id="X784801B47E9838D5" name="X784801B47E9838D5"></a></p>

<h5>3.1-9 <span class="Heading"><code class="code">StabChain</code></span></h5>

<p>This is the randomized <strong class="pkg">GAP</strong> library function for computing a stabiliser chain. The method selection process ensures that this function is called only with small-base inputs, where the method works efficiently.</p>

<p><a id="X829BA50B82FEC109" name="X829BA50B82FEC109"></a></p>

<h4>3.2 <span class="Heading">Methods for matrix groups</span></h4>

<p>THIS CHAPTER IS CURRENTLY A BIT OUT OF DATE!</p>

<p>The following table gives an overview over the installed methods and their rank (higher rank means higher priority, the method is tried earlier, see Chapter <a href="/Users/mhorn/Projekte/GAP/repos/pkg/neunhoef/recogbase/doc/chap3.html#X8058CC8187162644"><span class="RefLink">recogbase: Method Selection</span></a>). Note that there are not that many methods for matrix groups since the system can switch to projective groups by dividing out the subgroup of scalar matrices. The bulk of the recognition methods are then installed es methods for projective groups.</p>

<div class="pcenter"><table class="GAPDocTable">
<caption class="GAPDocTable"><b>Table: </b>Matrix group find homomorphism methods</caption>
<tr>
<td class="tdleft">3100</td>
<td class="tdleft"><code class="code">TrivialMatrixGroup</code></td>
<td class="tdleft"><a href="chap3.html#X796A682C78FFB9DC"><span class="RefLink">3.2-1</span></a></td>
</tr>
<tr>
<td class="tdleft">1100</td>
<td class="tdleft"><code class="code">DiagonalMatrices</code></td>
<td class="tdleft"><a href="chap3.html#X79C0EC2987BCA334"><span class="RefLink">3.2-2</span></a></td>
</tr>
<tr>
<td class="tdleft">1000</td>
<td class="tdleft"><code class="code">ReducibleIso</code></td>
<td class="tdleft"><a href="chap3.html#X8499282F7825D28C"><span class="RefLink">3.2-3</span></a></td>
</tr>
<tr>
<td class="tdleft">900</td>
<td class="tdleft"><code class="code">GoProjective</code></td>
<td class="tdleft"><a href="chap3.html#X79A0674B7ECAFB62"><span class="RefLink">3.2-6</span></a></td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p><a id="X796A682C78FFB9DC" name="X796A682C78FFB9DC"></a></p>

<h5>3.2-1 <span class="Heading"><code class="code">TrivialMatrixGroup</code></span></h5>

<p>This method is successful if and only if all generators of a matrix group <var class="Arg">G</var> are equal to the identity. Otherwise, it returns <code class="keyw">false</code>.</p>

<p><a id="X79C0EC2987BCA334" name="X79C0EC2987BCA334"></a></p>

<h5>3.2-2 <span class="Heading"><code class="code">DiagonalMatrices</code></span></h5>

<p>This method is successful if and only if all generators of a matrix group <var class="Arg">G</var> are diagonal matrices. Otherwise, it returns <code class="keyw">false</code>.</p>

<p><a id="X8499282F7825D28C" name="X8499282F7825D28C"></a></p>

<h5>3.2-3 <span class="Heading"><code class="code">ReducibleIso</code></span></h5>

<p>This method determines whether a matrix group <var class="Arg">G</var> acts irreducibly. If yes, then it returns <code class="keyw">false</code>. If <var class="Arg">G</var> acts reducibly then a composition series of the underlying module is computed and a base change is performed to write <var class="Arg">G</var> in a block lower triangular form. Also, the method passes a hint to the image group that it is in block lower triangular form, so the image immediately can make recursive calls for the actions on the diagonal blocks, and then to the lower <span class="SimpleMath">p</span>-part. For the image the method <code class="code">BlockLowerTriangular</code> (see <a href="chap3.html#X85655B8082FCB0AD"><span class="RefLink">3.2-4</span></a>) is used.</p>

<p>Note that this method is implemented in a way such that it can also be used as a method for a projective group <var class="Arg">G</var>. In that case the recognition info record has the <code class="code">!.projective</code> component bound to <code class="keyw">true</code> and this information is passed down to image and kernel.</p>

<p><a id="X85655B8082FCB0AD" name="X85655B8082FCB0AD"></a></p>

<h5>3.2-4 <span class="Heading"><code class="code">BlockLowerTriangular</code></span></h5>

<p>This method is only called when a hint was passed down from the method <code class="code">ReducibleIso</code> (see <a href="chap3.html#X8499282F7825D28C"><span class="RefLink">3.2-3</span></a>). In that case, it knows that a base change to block lower triangular form has been performed. The method can then immediately find a homomorphism by mapping to the diagonal blocks. It sets up this homomorphism and gives hints to image and kernel. For the image, the method <code class="code">BlockDiagonal</code> (see <a href="chap3.html#X799EEBE27AF157B6"><span class="RefLink">3.2-5</span></a>) is used and for the kernel, the method <code class="code">LowerLeftPGroup</code> (see <a href="chap3.html#X78A525FD797F429B"><span class="RefLink">3.2-8</span></a>) is used.</p>

<p>Note that this method is implemented in a way such that it can also be used as a method for a projective group <var class="Arg">G</var>. In that case the recognition info record has the <code class="code">!.projective</code> component bound to <code class="keyw">true</code> and this information is passed down to image and kernel.</p>

<p><a id="X799EEBE27AF157B6" name="X799EEBE27AF157B6"></a></p>

<h5>3.2-5 <span class="Heading"><code class="code">BlockDiagonal</code></span></h5>

<p>This method is only called when a hint was passed down from the method <code class="code">BlockLowerTriangular</code> (see <a href="chap3.html#X85655B8082FCB0AD"><span class="RefLink">3.2-4</span></a>). In that case, it knows that the group is in block diagonal form. The method is used both in the matrix- and the projective case.</p>

<p>The method immediately delegates to projective methods handling all the diagonal blocks projectively. This is done by giving a hint to the factor to use the method <code class="code">BlocksModScalars</code> (see <a href="chap3.html#X803E531C83954EC5"><span class="RefLink">3.3-4</span></a>) is given. The method for the kernel then has to deal with only scalar blocks, either projectively or with scalars, which is again done by giving a hint to either use <code class="code">BlockScalar</code> (see <a href="chap3.html#X7B9301E97DE36543"><span class="RefLink">3.2-7</span></a>) or <code class="code">BlockScalarProj</code> (see <a href="chap3.html#X7BFA205981277BD5"><span class="RefLink">3.3-13</span></a>) respectively.</p>

<p>Note that this method is implemented in a way such that it can also be used as a method for a projective group <var class="Arg">G</var>. In that case the recognition info record has the <code class="code">!.projective</code> component bound to <code class="keyw">true</code> and this information is passed down to image and kernel.</p>

<p><a id="X79A0674B7ECAFB62" name="X79A0674B7ECAFB62"></a></p>

<h5>3.2-6 <span class="Heading"><code class="code">GoProjective</code></span></h5>

<p>This method defines a homomorphism from a matrix group <var class="Arg">G</var> into the projective group <var class="Arg">G</var> modulo scalar matrices. In fact, since projective groups in <strong class="pkg">GAP</strong> are represented as matrix groups, the homomorphism is the identity mapping and the only difference is that in the image the projective group methods can be applied. The bulk of the work in matrix recognition is done in the projective group setting.</p>

<p><a id="X7B9301E97DE36543" name="X7B9301E97DE36543"></a></p>

<h5>3.2-7 <span class="Heading"><code class="code">BlockScalar</code></span></h5>

<p>This method is only called by a hint. Alongside with the hint it gets a block decomposition respected by the matrix group <var class="Arg">G</var> to be recognised and the promise, that all diagonal blocks of all group elements will only be scalar matrices. This method recursively builds a balanced tree and does scalar recognition in each leaf.</p>

<p><a id="X78A525FD797F429B" name="X78A525FD797F429B"></a></p>

<h5>3.2-8 <span class="Heading"><code class="code">LowerLeftPGroup</code></span></h5>

<p>This method is only called by a hint from <code class="code">BlockLowerTriangular</code> as the kernel of the homomorphism mapping to the diagonal blocks. The method uses the fact the this kernel is a <span class="SimpleMath">p</span>-group where <span class="SimpleMath">p</span> is the characteristic of the underlying field. It exploits this fact and uses this special structure to find nice generators and a method to express group elements in terms of these.</p>

<p><a id="X867550F684F795AE" name="X867550F684F795AE"></a></p>

<h4>3.3 <span class="Heading">Methods for projective groups</span></h4>

<p>THIS CHAPTER IS CURRENTLY A BIT OUT OF DATE!</p>

<p>The following table gives an overview over the installed methods and their rank (higher rank means higher priority, the method is tried earlier, see Chapter <a href="/Users/mhorn/Projekte/GAP/repos/pkg/neunhoef/recogbase/doc/chap3.html#X8058CC8187162644"><span class="RefLink">recogbase: Method Selection</span></a>). Note that the recognition for matrix group switches to projective recognition rather soon in the recognition process such that most recognition methods in fact are installed as methods for projective groups.</p>

<div class="pcenter"><table class="GAPDocTable">
<caption class="GAPDocTable"><b>Table: </b>Projective group find homomorphism methods</caption>
<tr>
<td class="tdleft">3000</td>
<td class="tdleft"><code class="code">TrivialProjectiveGroup</code></td>
<td class="tdleft"><a href="chap3.html#X814A92C48174540D"><span class="RefLink">3.3-1</span></a></td>
</tr>
<tr>
<td class="tdleft">1300</td>
<td class="tdleft"><code class="code">ProjDeterminant</code></td>
<td class="tdleft"><a href="chap3.html#X7B8A3F4781278CEF"><span class="RefLink">3.3-2</span></a></td>
</tr>
<tr>
<td class="tdleft">1200</td>
<td class="tdleft"><code class="code">ReducibleIso</code></td>
<td class="tdleft"><a href="chap3.html#X8499282F7825D28C"><span class="RefLink">3.3-3</span></a></td>
</tr>
<tr>
<td class="tdleft">1100</td>
<td class="tdleft"><code class="code">NotAbsolutelyIrred</code></td>
<td class="tdleft"><a href="chap3.html#X83737D087B53188A"><span class="RefLink">3.3-5</span></a></td>
</tr>
<tr>
<td class="tdleft">1000</td>
<td class="tdleft"><code class="code">Subfield</code></td>
<td class="tdleft"><a href="chap3.html#X80EA5C7580235817"><span class="RefLink">3.3-6</span></a></td>
</tr>
<tr>
<td class="tdleft">900</td>
<td class="tdleft"><code class="code">Derived</code></td>
<td class="tdleft"><a href="chap3.html#X7B46C2848668373B"><span class="RefLink">3.3-7</span></a></td>
</tr>
<tr>
<td class="tdleft">800</td>
<td class="tdleft"><code class="code">LowIndex</code></td>
<td class="tdleft"><a href="chap3.html#X86BAC96E7BA6E699"><span class="RefLink">3.3-8</span></a></td>
</tr>
<tr>
<td class="tdleft">700</td>
<td class="tdleft"><code class="code">C6</code></td>
<td class="tdleft"><a href="chap3.html#X8010C98580729238"><span class="RefLink">3.3-9</span></a></td>
</tr>
<tr>
<td class="tdleft">600</td>
<td class="tdleft"><code class="code">Tensor</code></td>
<td class="tdleft"><a href="chap3.html#X8750385D847D5C24"><span class="RefLink">3.3-10</span></a></td>
</tr>
<tr>
<td class="tdleft">500</td>
<td class="tdleft"><code class="code">TwoLargeElOrders</code></td>
<td class="tdleft"><a href="chap3.html#X856A17D787B6435D"><span class="RefLink">3.3-11</span></a></td>
</tr>
<tr>
<td class="tdleft">100</td>
<td class="tdleft"><code class="code">StabilizerChain</code></td>
<td class="tdleft"><a href="chap3.html#X79CB567683B3A36F"><span class="RefLink">3.3-12</span></a></td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p><a id="X814A92C48174540D" name="X814A92C48174540D"></a></p>

<h5>3.3-1 <span class="Heading"><code class="code">TrivialProjectiveGroup</code></span></h5>

<p>This method is successful if and only if all generators of a projective group <var class="Arg">G</var> are equal to the identity (that is, in the matrix representation of <var class="Arg">G</var>, all matrices are scalars). Otherwise, it returns <code class="keyw">false</code>.</p>

<p><a id="X7B8A3F4781278CEF" name="X7B8A3F4781278CEF"></a></p>

<h5>3.3-2 <span class="Heading"><code class="code">ProjDeterminant</code></span></h5>

<p>The method defines a homomorphism from a projective group <var class="Arg">G</var><span class="SimpleMath">le PGL(d,q)</span> to the cyclic group <span class="SimpleMath">GF(q)^*/D</span>, where <span class="SimpleMath">D</span> is the set of <span class="SimpleMath">d</span>th powers in <span class="SimpleMath">GF(q)^*</span>. The image of a group element <span class="SimpleMath">g ∈ <var class="Arg">G</var></span> is the determinant of a matrix representative of <span class="SimpleMath">g</span>, modulo <span class="SimpleMath">D</span>.</p>

<p><a id="X8499282F7825D28C" name="X8499282F7825D28C"></a></p>

<h5>3.3-3 <span class="Heading"><code class="code">ReducibleIso</code></span></h5>

<p>This method is the same as the matrix group method with the same name (see <a href="chap3.html#X8499282F7825D28C"><span class="RefLink">3.2-3</span></a>), which is able to take into account the projective mode.</p>

<p><a id="X803E531C83954EC5" name="X803E531C83954EC5"></a></p>

<h5>3.3-4 <span class="Heading"><code class="code">BlocksModScalars</code></span></h5>

<p>This method is only called when hinted from above. In this method it is understood that G should <em>neither</em> be recognised as a matrix group <em>nor</em> as a projective group. Rather, it treats all diagonal blocks modulo scalars which means that two matrices are considered to be equal, if they differ only by a scalar factor in <em>corresponding</em> diagonal blocks, and this scalar can be different for each diagonal block. This means that the kernel of the homomorphism mapping to a node which is recognised using this method will have only scalar matrices in all diagonal blocks.</p>

<p>This method does the balanced tree approach mapping to subsets of the diagonal blocks and finally using projective recognition to recognise single diagonal block groups.</p>

<p><a id="X83737D087B53188A" name="X83737D087B53188A"></a></p>

<h5>3.3-5 <span class="Heading"><code class="code">NotAbsolutelyIrred</code></span></h5>

<p>If an irreducible projective group <var class="Arg">G</var> acts absolutely irreducibly then this method returns <code class="keyw">false</code>. If <var class="Arg">G</var> is not absolutely irreducible then a homomorphism into a smaller dimensional representation over an extension field is defined. A hint is handed down to the image that no test for absolute irreducibility has to be done any more. Another hint is handed down to the kernel indicating that the only possible kernel elements can be elements in the centraliser of <var class="Arg">G</var> in <span class="SimpleMath">PGL(d,q)</span> that come from scalar matrices in the extension field.</p>

<p><a id="X80EA5C7580235817" name="X80EA5C7580235817"></a></p>

<h5>3.3-6 <span class="Heading"><code class="code">Subfield</code></span></h5>

<p>When this method runs it knows that the projective group <var class="Arg">G</var> acts absolutely irreducibly. It then tries to realise this group over a smaller field. The algorithm used is the one using the "standard basis approach" known from isomorphism testing of absolutely irreducible modules. It finds a base change to write the projective group over the smallest field possible. Since the group is projective, it may choose to multiply generators with arbitrary scalars to write them over a smaller field.</p>

<p>However, sometimes the correct scalar can not be guessed. Therefore, if the first approach does not work, the method computes the derived subgroup. If the group can be written over a smaller field, then taking commutators loses the scalars preventing a direct base change to work. Therefore, if the derived subgroup still acts irreducibly, the standard basis approach can find the right base change that could also do the job for the whole group. If it acts reducibly, the method <code class="code">Derived</code> (see <a href="chap3.html#X7B46C2848668373B"><span class="RefLink">3.3-7</span></a>) which is run next already has the computed derived subgroup and can try different things to find a reduction.</p>

<p><a id="X7B46C2848668373B" name="X7B46C2848668373B"></a></p>

<h5>3.3-7 <span class="Heading"><code class="code">Derived</code></span></h5>

<p>This method computes the derived subgroup, if this has not yet been done by other methods. It then uses the MeatAxe to decide whether the derived subgroup acts irreducibly or not. If it acts reducibly, then we can apply Clifford theory to the natural module. The natural module restricted to the derived subgroup is a direct sum of simple modules. If all the summands are isomorphic, we immediately get either an action of <var class="Arg">G</var> on blocks or a tensor decomposition. Otherwise, we get an action of <var class="Arg">G</var> on the isotypic components. Either way, we find a reduction.</p>

<p>If the derived group acts irreducibly, we return <code class="keyw">false</code> in the current implementation.</p>

<p><a id="X86BAC96E7BA6E699" name="X86BAC96E7BA6E699"></a></p>

<h5>3.3-8 <span class="Heading"><code class="code">LowIndex</code></span></h5>

<p>This method is designed for the handling of the Aschbacher class C2 (stabiliser of a decomposition of the underlying vector space), but may succeed on other types of input as well. Given <var class="Arg">G</var> <span class="SimpleMath">le PGL(d,q)</span>, the output is either the permutation action of <var class="Arg">G</var> on a short orbit of subspaces or <code class="keyw">fail</code>. In the current setup, "short orbit" is defined to have length at most <span class="SimpleMath">4d</span>.</p>

<p><a id="X8010C98580729238" name="X8010C98580729238"></a></p>

<h5>3.3-9 <span class="Heading"><code class="code">C6</code></span></h5>

<p>This method is designed for the handling of the Aschbacher class C6 (normaliser of an extraspecial group). If the input <var class="Arg">G</var><span class="SimpleMath">le PGL(d,q)</span> does not satisfy <span class="SimpleMath">d=r^n</span> and <span class="SimpleMath">r|q-1</span> for some prime <span class="SimpleMath">r</span> and integer <span class="SimpleMath">n</span> then the method returns <code class="keyw">false</code>. Otherwise, it returns either a homomorphism of <var class="Arg">G</var> into <span class="SimpleMath">Sp(2n,r)</span>, or a homomorphism into the C2 permutation action of <var class="Arg">G</var> on a decomposition of <span class="SimpleMath">GF(q)^d</span>, or <code class="keyw">fail</code>.</p>

<p><a id="X8750385D847D5C24" name="X8750385D847D5C24"></a></p>

<h5>3.3-10 <span class="Heading"><code class="code">Tensor</code></span></h5>

<p>This method currently tries to find one tensor factor by powering up commutators of random elements to elements of prime order. This seems to work quite well provided that the two tensor factors are not "linked" too much such that there exist enough elements that act with different orders on both tensor factors.</p>

<p>This method and its description needs some improvement.</p>

<p><a id="X856A17D787B6435D" name="X856A17D787B6435D"></a></p>

<h5>3.3-11 <span class="Heading"><code class="code">TwoLargeElOrders</code></span></h5>

<p>In the case when the input group <var class="Arg">G</var><span class="SimpleMath">le PGL(d,p^e)</span> is suspected to be simple but not alternating, this method takes the two largest element orders from a sample of pseudorandom elements of <var class="Arg">G</var>. From these element orders, it tries to determine whether <var class="Arg">G</var> is of Lie type or sporadic, and the characteristic of <var class="Arg">G</var> if it is of Lie type. In the case when <var class="Arg">G</var> is of Lie type of characteristic different from <span class="SimpleMath">p</span> or <var class="Arg">G</var> is sporadic, the method also provides a short list of the possible isomorphism types of <var class="Arg">G</var>.</p>

<p><a id="X79CB567683B3A36F" name="X79CB567683B3A36F"></a></p>

<h5>3.3-12 <span class="Heading"><code class="code">StabilizerChain</code></span></h5>

<p>This method computes a stabiliser chain and a base and strong generating set using projective actions. This is a last resort method since for bigger examples no short orbits can be found in the natural action. The strong generators are the nice generator in this case and expressing group elements in terms of the nice generators ist just sifting along the stabiliser chain.</p>

<p><a id="X7BFA205981277BD5" name="X7BFA205981277BD5"></a></p>

<h5>3.3-13 <span class="Heading"><code class="code">BlockScalarProj</code></span></h5>

<p>This method is only called by a hint. Alongside with the hint it gets a block decomposition respected by the matrix group <var class="Arg">G</var> to be recognised and the promise, that all diagonal blocks of all group elements will only be scalar matrices. This method simply norms the last diagonal block in all generators by multiplying with a scalar and then delegates to <code class="code">BlockScalar</code> (see <a href="chap3.html#X7B9301E97DE36543"><span class="RefLink">3.2-7</span></a>) and matrix group mode to do the recognition.</p>

<p><a id="X81DB42647E8FA7B6" name="X81DB42647E8FA7B6"></a></p>

<h4>3.4 <span class="Heading">Methods for black box groups</span></h4>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
