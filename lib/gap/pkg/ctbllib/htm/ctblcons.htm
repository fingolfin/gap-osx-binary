<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.59">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 

              
<title> Using Table Automorphisms for Constructing Character Tables in GAP</title>
 
<h1 align="center">Using Table Automorphisms for Constructing Character Tables in GAP </h1>
  <body bgcolor="FFFFFF"> 

<div class="p"><!----></div>

<h3 align="center"> T<font size="-2">HOMAS</font> B<font size="-2">REUER</font> <br />
<i>Lehrstuhl D f&#252;r Mathematik</i> <br />
<i>RWTH, 52056 Aachen, Germany</i> </h3>

<div class="p"><!----></div>

<h3 align="center">June 27th, 2004 </h3>

<div class="p"><!----></div>


<div class="p"><!----></div>
This note has three aims.
First it shows how character table automorphisms can be utilized to
construct certain character tables from others
using the <font face="helvetica">GAP</font> system&nbsp;[<a href="#GAP4" name="CITEGAP4">GAP04</a>];
the <font face="helvetica">GAP</font> functions used for that are part of the <font face="helvetica">GAP</font> Character Table
Library&nbsp;[<a href="#CTblLib1.2" name="CITECTblLib1.2">Bre12</a>].
Second it documents several constructions of character tables which are
contained in the <font face="helvetica">GAP</font> Character Table Library.
Third it serves as a testfile for the involved <font face="helvetica">GAP</font> functions.

<div class="p"><!----></div>



<div class="p"><!----></div>

<h1>Contents </h1><a href="#tth_sEc1"
>1&nbsp; Overview</a><br />
<a href="#tth_sEc2"
>2&nbsp; Theoretical Background</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.1"
>2.1&nbsp; Character Table Automorphisms</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.2"
>2.2&nbsp; Permutation Equivalence of Character Tables</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.3"
>2.3&nbsp; Class Fusions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4"
>2.4&nbsp; Constructing Character Tables of Certain Isoclinic Groups</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.5"
>2.5&nbsp; Isoclinic Double Covers of Almost Simple Groups</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6"
>2.6&nbsp; Characters of Normal Subgroups</a><br />
<a href="#tth_sEc3"
>3&nbsp; The Constructions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.1"
>3.1&nbsp; Character Tables of Groups of the Structure M.G.A</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2"
>3.2&nbsp; Character Tables of Groups of the Structure G.S<sub>3</sub></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.3"
>3.3&nbsp; Character Tables of Groups of the Structure G.2<sup>2</sup></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4"
>3.4&nbsp; Character Tables of Groups of the Structure 2<sup>2</sup>.G (August 2005)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.5"
>3.5&nbsp; p-Modular Tables of Extensions by p-singular Automorphisms</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.6"
>3.6&nbsp; Character Tables of Subdirect Products of Index Two (July 2007)</a><br />
<a href="#tth_sEc4"
>4&nbsp; Examples for the Type M.G.A</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1"
>4.1&nbsp; Character Tables of Dihedral Groups</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2"
>4.2&nbsp; An M.G.A Type Example with M noncentral in M.G (May 2004)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3"
>4.3&nbsp;  A<font size="-2">TLAS</font> Tables of the Type M.G.A</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.4"
>4.4&nbsp; More  A<font size="-2">TLAS</font> Tables of the Type M.G.A</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.5"
>4.5&nbsp; The Character Tables of 4<sub>2</sub>.L<sub>3</sub>(4).2<sub>3</sub> and 12<sub>2</sub>.L<sub>3</sub>(4).2<sub>3</sub></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.6"
>4.6&nbsp; The Character Table of (2<sup>2</sup> &times;F<sub>4</sub>(2)):2  &lt;  B (March&nbsp;2003)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.7"
>4.7&nbsp; The Character Table of 2.(S<sub>3</sub> &times;Fi<sub>22</sub>.2)  &#8804; 2.B (March&nbsp;2003)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.8"
>4.8&nbsp; The Character Table of (2 &times;2.Fi<sub>22</sub>):2  &lt;  Fi<sub>24</sub> (November&nbsp;2008)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.9"
>4.9&nbsp; The Character Table of S<sub>3</sub> &times;2.U<sub>4</sub>(3).2<sub>2</sub>  &#8804; 2.Fi<sub>22</sub> (September 2002)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.10"
>4.10&nbsp; The Character Table of 4.HS.2  &#8804; HN.2 (May 2002)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.11"
>4.11&nbsp; The Character Tables of 4.A<sub>6</sub>.2<sub>3</sub>, 12.A<sub>6</sub>.2<sub>3</sub>, and 4.L<sub>2</sub>(25).2<sub>3</sub></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.12"
>4.12&nbsp; Pseudo Character Tables of the Type M.G.A (May 2004)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.13"
>4.13&nbsp; Some Extra-ordinary p-Modular Tables of the Type M.G.A (September 2005)</a><br />
<a href="#tth_sEc5"
>5&nbsp; Examples for the Type G.S<sub>3</sub></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1"
>5.1&nbsp; Small Examples</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2"
>5.2&nbsp;  A<font size="-2">TLAS</font> Tables of the Type G.S<sub>3</sub></a><br />
<a href="#tth_sEc6"
>6&nbsp; Examples for the Type G.2<sup>2</sup></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1"
>6.1&nbsp; The Character Table of A<sub>6</sub>.2<sup>2</sup></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2"
>6.2&nbsp;  A<font size="-2">TLAS</font> Tables of the Type G.2<sup>2</sup> - Easy Cases</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.3"
>6.3&nbsp; The Character Table of S<sub>4</sub>(9).2<sup>2</sup> (September 2011)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.4"
>6.4&nbsp; The Character Tables of Groups of the Type 2.L<sub>3</sub>(4).2<sup>2</sup> (June 2010)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.5"
>6.5&nbsp; The Character Tables of Groups of the Type 6.L<sub>3</sub>(4).2<sup>2</sup> (October 2011)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.6"
>6.6&nbsp; The Character Tables of Groups of the Type 2.U<sub>4</sub>(3).2<sup>2</sup> (February 2012)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.7"
>6.7&nbsp; The Character Tables of Groups of the Type 4<sub>1</sub>.L<sub>3</sub>(4).2<sup>2</sup> (October 2011)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.8"
>6.8&nbsp; The Character Tables of Groups of the Type 4<sub>2</sub>.L<sub>3</sub>(4).2<sup>2</sup> (October 2011)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.9"
>6.9&nbsp; The Character Table of <span class="roman">Aut</span>(L<sub>2</sub>(81))</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.10"
>6.10&nbsp; The Character Table of O<sub>8</sub><sup>+</sup>(3).2<sup>2</sup><sub>111</sub></a><br />
<a href="#tth_sEc7"
>7&nbsp; Examples for the Type 2<sup>2</sup>.G</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.1"
>7.1&nbsp; The Character Table of 2<sup>2</sup>.Sz(8)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.2"
>7.2&nbsp;  A<font size="-2">TLAS</font> Tables of the Type 2<sup>2</sup>.G (September 2005)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.3"
>7.3&nbsp; The Character Table of 2<sup>2</sup>.O<sub>8</sub><sup>+</sup>(3) (March 2009)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.4"
>7.4&nbsp; The Character Table of the Schur Cover of L<sub>3</sub>(4) (September 2005)</a><br />
<a href="#tth_sEc8"
>8&nbsp; Examples of Extensions by p-singular Automorphisms</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.1"
>8.1&nbsp; Some p-Modular Tables of Groups of the Type M.G.A</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2"
>8.2&nbsp; Some p-Modular Tables of Groups of the Type G.S<sub>3</sub></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3"
>8.3&nbsp; 2-Modular Tables of Groups of the Type G.2<sup>2</sup></a><br />
<a href="#tth_sEc9"
>9&nbsp; Examples of Subdirect Products of Index Two</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.1"
>9.1&nbsp; Certain Dihedral Groups as Subdirect Products of Index Two</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.2"
>9.2&nbsp; The Character Table of (D<sub>10</sub> &times;HN).2  &lt;  M (June 2008)</a><br />



<div class="p"><!----></div>

<div class="p"><!----></div>

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Overview</h2>

<div class="p"><!----></div>
Several types of constructions of character tables of finite groups
from known tables of smaller groups are described in Section&nbsp;<a href="#constr">3</a>.
Selecting suitable character table automorphisms is an important
ingredient of these constructions.

<div class="p"><!----></div>
Section&nbsp;<a href="#theory">2</a> collects the few representation theoretical facts
on which these constructions are based.

<div class="p"><!----></div>
The remaining sections show examples of the constructions in <font face="helvetica">GAP</font>.
These examples use the <font face="helvetica">GAP</font> Character Table Library,
therefore we load this package first.

<div class="p"><!----></div>

<pre>
    gap&#62; LoadPackage( "ctbllib", "1.1.4" );
    true

</pre>

<div class="p"><!----></div>

 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Theoretical Background</h2><a name="theory">
</a>

<div class="p"><!----></div>

     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Character Table Automorphisms</h3>

<div class="p"><!----></div>
Let G be a finite group,
<span class="roman">Irr</span>(G) be the matrix of ordinary irreducible characters of G,
Cl(G) be the set of conjugacy classes of elements in G,
g<sup>G</sup> the G-conjugacy class of g  &#8712; G,
and

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 pow<sub>p</sub> :</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
Cl(G) </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#8594; </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
Cl(G) </td></tr></table></td></tr>
<tr><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
g<sup>G</sup> </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#8594; </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
(g<sup>p</sup>)<sup>G</sup> </td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>


the p-th power map, for each prime integer p.

<div class="p"><!----></div>
A <b>table automorphism</b> of G is a permutation
&#963;:Cl(G) &#8594; Cl(G) with the properties that
&#967;&#176;&#963; &#8712; <span class="roman">Irr</span>(G) holds for all &#967; &#8712; <span class="roman">Irr</span>(G)
and that &#963; commutes with pow<sub>p</sub>, for all prime integers p that
divide the order of G.
Note that for prime integers p that are coprime to the order of G,
pow<sub>p</sub> commutes with each &#963; that permutes <span class="roman">Irr</span>(G),
since pow<sub>p</sub> acts as a field automorphism on the character values.

<div class="p"><!----></div>
In <font face="helvetica">GAP</font>, a character table covers the irreducible characters
-a matrix M of character values- as well as the power maps of the
underlying group -each power map pow<sub>p</sub> being represented as a list
pow<sub>p</sub><sup>&#8242;</sup> of positive integers denoting the positions of the image
classes.
The group of table automorphisms of a character table is represented
as a permutation group on the column positions of the table;
it can be computed with the function <tt>AutomorphismsOfTable</tt>.

<div class="p"><!----></div>
In the following, we will mainly use that each <b>group automorphism</b> &#963;
of G induces a table automorphism that maps the class of each element
in G to the class of its image under &#963;.

<div class="p"><!----></div>

     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;Permutation Equivalence of Character Tables</h3>

<div class="p"><!----></div>
Two character tables with matrices M<sub>1</sub>, M<sub>2</sub> of irreducibles and p-th
power maps pow<sub>1,p</sub>, pow<sub>2,p</sub> are <em>permutation equivalent</em>
if permutations &#968; and &#960; of row and column positions of the M<sub>i</sub>
exist such that [ M<sub>1</sub> ]<sub>i,j</sub> = [ M<sub>2</sub> ]<sub>i &#968;, j &#960;</sub> holds for all
indices i, j,
and such that &#960;&#183;pow<sub>2,p</sub><sup>&#8242;</sup> = pow<sub>1,p</sub><sup>&#8242;</sup> &#183;&#960;
holds for all primes p that divide the (common) group order.
The first condition is equivalent to the existence of a permutation &#960;
such that permuting the columns of M<sub>1</sub> with &#960; maps the set of rows of
M<sub>1</sub> to the set of rows of M<sub>2</sub>.

<div class="p"><!----></div>
&#960; is of course determined only up to table automorphisms of the two
character tables, that is, two transforming permutations &#960;<sub>1</sub>, &#960;<sub>2</sub>
satisfy that &#960;<sub>1</sub> &#183;&#960;<sub>2</sub><sup>&#8722;1</sup> is a table automorphism of the first
table, and &#960;<sub>1</sub><sup>&#8722;1</sup> &#183;&#960;<sub>2</sub> is a table automorphism of the second.

<div class="p"><!----></div>
Clearly two isomorphic groups have permutation equivalent character tables.

<div class="p"><!----></div>

<div class="p"><!----></div>
The <font face="helvetica">GAP</font> library function <tt>TransformingPermutationsCharacterTables</tt> returns
a record that contains transforming permutations of rows and columns if the
two argument tables are permutation equivalent, and <tt>fail</tt> otherwise.

<div class="p"><!----></div>
In the example sections, the following function for computing representatives
from a list of character tables w.r.t.&nbsp;permutation equivalence will be used.
More precisely, the input is either a list of character tables
or a list of records which have a component <tt>table</tt> whose value
is a character table, and the output is a sublist of the input.

<div class="p"><!----></div>

<pre>
    gap&#62; RepresentativesCharacterTables:= function( list )
    &#62;    local reps, i, found, r;
    &#62; 
    &#62;    reps:= [];
    &#62;    for i in [ 1 .. Length( list ) ] do
    &#62;      if ForAll( reps, r -&#62; ( IsCharacterTable( r ) and
    &#62;             TransformingPermutationsCharacterTables( list[i], r ) = fail )
    &#62;           or ( IsRecord( r ) and TransformingPermutationsCharacterTables(
    &#62;                                    list[i].table, r.table ) = fail ) ) then
    &#62;        Add( reps, list[i] );
    &#62;      fi;
    &#62;    od;
    &#62;    return reps;
    &#62;    end;;

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc2.3">
2.3</a>&nbsp;&nbsp;Class Fusions</h3><a name="class_fusions">
</a>

<div class="p"><!----></div>
For two groups H, G such that H is isomorphic with a subgroup of G,
any embedding &#953;:H &#8594; G induces a class function

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 fus<sub>&#953;</sub> :</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
Cl(H) </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#8594; </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
Cl(G) </td></tr></table></td></tr>
<tr><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
h<sup>G</sup> </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#8594; </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
(&#953;(h))<sup>G</sup> </td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>


the <b>class fusion</b> of H in G via &#953;.
Analogously, for a normal subgroup N of G,
any epimorphism &#960;:G &#8594; G/N induces a class function

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 fus<sub>&#960;</sub> :</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
Cl(G) </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#8594; </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
Cl(G/N) </td></tr></table></td></tr>
<tr><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
g<sup>G</sup> </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#8594; </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
(&#960;(g))<sup>G</sup> </td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>


the <b>class fusion</b> of G onto G/N via &#960;.

<div class="p"><!----></div>
When one works only with character tables and not with groups,
these class fusions are the objects that describe subgroup and factor group
relations between character tables.
Technically, class fusions are necessary for restricting, inducing, and
inflating characters from one character table to another.
If one is faced with the problem to compute the class fusion between the
character tables of two groups H and G for which it is known that H
can be embedded into G
then one can use character-theoretic necessary conditions,
concerning that the restriction of all irreducible characters of G to H
(via the class fusion) must decompose into the irreducible characters of H,
and that the class fusion must commute with the power maps of H and G.

<div class="p"><!----></div>
With this character-theoretic approach, one can clearly determine
possible class fusions only up to character table automorphisms.
Note that one can interpret each character table automorphism of G
as a class fusion from the table of G to itself.

<div class="p"><!----></div>
If N is a normal subgroup in G then the class fusion of N in G
determines the orbits of the conjugation action of G on the classes of N.
Often the knowledge of these orbits suffices to identify the subgroup of
table automorphisms of N that corresponds to this action of G;
for example, this is always the case if N has index 2 in G.

<div class="p"><!----></div>
<font face="helvetica">GAP</font> library functions for dealing with class fusions, power maps,
and character table automorphisms are described in the chapter
"Maps Concerning Character Tables" in the <font face="helvetica">GAP</font> Reference Manual.

<div class="p"><!----></div>

     <h3><a name="tth_sEc2.4">
2.4</a>&nbsp;&nbsp;Constructing Character Tables of Certain Isoclinic Groups</h3><a name="isoclinism">
</a>

<div class="p"><!----></div>
As is stated in&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;xxiii],
two groups G, H are called <b>isoclinic</b> if they can be embedded
into a group K such that K is generated by Z(K) and G,
and also by Z(K) and H.
In the following, two special cases of isoclinism will be used,
where the character tables of the isoclinic groups are closely related.

<div class="p"><!----></div>

<ul>
<br />(1)
    G  &#8773; 2 &times;U for a group U that has a central subgroup N
    of order 2,
    and H is the central product of U and a cyclic group of order four.
    Here we can set K = 2 &times;H.
<br />(2)
    G  &#8773; 2 &times;U for a group U that has a normal subgroup N
    of index 2,
    and H is the subdirect product of U and a cyclic
    group of order four,
    Here we can set K = 4 &times;U.</ul>

<div class="p"><!----></div>

<center> <img src="ctblcons01.png" alt="ctblcons01.png" />

</center>

<div class="p"><!----></div>
Starting from the group K containing both G and H,
we first note that each irreducible representation of G or H extends
to K.
More specifically, if &#961;<sub>G</sub> is an irreducible representation of G then
we can define an extension &#961; of K by defining it suitably on Z(K)
and then form &#961;<sub>H</sub>, the restriction of &#961; to H.

<div class="p"><!----></div>
In our two cases, we set S = G &#8745;H,
so K = S &#8746;G \S &#8746;H \S &#8746;z S holds for some
element z  &#8712; Z(K) \( G &#8746;H ) of order four,
and G = S &#8746;g S for some g  &#8712; G \S,
and H = S &#8746;h S where h = z &#183;g  &#8712; H \S.
For defining &#961;<sub>H</sub>, it suffices to consider &#961;(h) = &#961;(z) &#961;(g),
where &#961;(z) = &#949;<sub>&#961;</sub>(z) &#183;I is a scalar matrix.

<div class="p"><!----></div>
As for the character table heads of G and H,
we have s<sup>G</sup> = s<sup>H</sup> and z (g &#183;s)<sup>G</sup> = (h &#183;s)<sup>H</sup> for each s  &#8712; S,
so this defines a bijection of the conjugacy classes of G and H.
For a prime integer p,
(h &#183;s)<sup>p</sup> = (z &#183;g &#183;s)<sup>p</sup> = z<sup>p</sup> &#183;(g &#183;s)<sup>p</sup> holds
for all s  &#8712; S,
so the p-th power maps of G and H are related as follows:
Inside S they coincide for any p.
If p  &#8801; 1  mod 4 they coincide also outside S,
if p  &#8801; &#8722;1  mod 4 the images differ by exchanging the classes
of (h &#183;s)<sup>p</sup> and z<sup>2</sup> &#183;(h &#183;s)<sup>p</sup> (if these elements lie
in different classes),
and for p = 2 the images (which lie inside S) differ by exchanging
the classes of (h &#183;s)<sup>2</sup> and z<sup>2</sup> &#183;(g &#183;s)<sup>2</sup>
(if these elements lie in different classes).

<div class="p"><!----></div>
Let &#961; be an irreducible representation of K.
Then &#961;<sub>G</sub> and &#961;<sub>H</sub> are related as follows:
&#961;<sub>G</sub>(s) = &#961;<sub>H</sub>(s)
and &#961;(z) &#183;&#961;<sub>G</sub>(g &#183;s) = &#961;<sub>H</sub>(h &#183;s)
for all s  &#8712; S.
If &#967;<sub>G</sub> and &#967;<sub>H</sub> are the characters afforded by &#961;<sub>G</sub>
and &#961;<sub>H</sub>, respectively,
then &#967;<sub>G</sub>(s) = &#967;<sub>H</sub>(s) and
&#949;<sub>&#961;</sub>(z) &#183;&#967;<sub>G</sub>(g &#183;s) = &#967;<sub>H</sub>(h &#183;s) hold
for all s  &#8712; S.
In the case &#967;<sub>G</sub>(z<sup>2</sup>) = &#967;(1) we have &#949;<sub>&#961;</sub>(z) = &#177;1,
and both cases actually occur if one considers all irreducible
representations of K.
In the case &#967;<sub>G</sub>(z<sup>2</sup>) = &#8722; &#967;(1) we have &#949;<sub>&#961;</sub>(z) = &#177;i,
and again both cases occur.
So we obtain the irreducible characters of H from those of G by
multiplying the values outside S in all those characters by i that
do not have z<sup>2</sup> in their kernels.

<div class="p"><!----></div>
In <font face="helvetica">GAP</font>, the function <tt>CharacterTableIsoclinic</tt> can be used for
computing the character table of H from that of G, and vice versa.
(Note that in the above two cases, also the groups U and H are
isoclinic by definition,
but <tt>CharacterTableIsoclinic</tt> does not transfer the character table of U
to that of H.)

<div class="p"><!----></div>

     <h3><a name="tth_sEc2.5">
2.5</a>&nbsp;&nbsp;Isoclinic Double Covers of Almost Simple Groups</h3><a name="isoclinicATLAS">
</a>

<div class="p"><!----></div>
<tt>CharacterTableIsoclinic</tt> can also be used to switch between the character
tables of double covers of groups of the type G.2,
where G is a perfect group, see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,Section&nbsp;6.7].
Typical examples are the double covers of symmetric groups.

<div class="p"><!----></div>
Note that these double covers may be isomorphic.
This happens for 2.S<sub>6</sub>.
More generally, this happens for all semilinear groups <span class="roman">&#931;L</span>(2,p<sup>2</sup>),
for odd primes p.
The smallest examples are <span class="roman">&#931;L</span>(2,9) = 2.A<sub>6</sub>.2<sub>1</sub> and
<span class="roman">&#931;L</span>(2,25) = 2.L<sub>2</sub>(25).2<sub>2</sub>.
This implies that the character table and its isoclinic variant are
permutation isomorphic.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "2.A6.2_1" );
    CharacterTable( "2.A6.2_1" )
    gap&#62; TransformingPermutationsCharacterTables( t,
    &#62;        CharacterTableIsoclinic( t ) );
    rec( columns := (4,6)(5,7)(11,12)(14,16)(15,17), 
      group := Group([ (16,17), (14,15) ]), rows := (3,5)(4,6)(10,11)(12,15,13,
        14) )
    gap&#62; t:= CharacterTable( "2.L2(25).2_2" );
    CharacterTable( "2.L2(25).2_2" )
    gap&#62; TransformingPermutationsCharacterTables( t,
    &#62;        CharacterTableIsoclinic( t ) );
    rec( columns := (7,9)(8,10)(20,21)(23,24)(25,27)(26,28), 
      group := &lt;permutation group with 4 generators&#62;, 
      rows := (3,5)(4,6)(14,15)(16,17)(19,22,20,21) )

</pre>

<div class="p"><!----></div>
For groups of the type 4.G.2, two different situations can occur.
Either the distinguished central cyclic subgroup of order four in 4.G
is inverted by the elements in 4.G.2 \4.G,
or this subgroup is central in 4.G.2.
In the first case,
calling <tt>CharacterTableIsoclinic</tt> with the character table of 4.G.2
yields a character table with the same set of irreducibles,
only the 2-power map will in general differ from that of the input table.
In the second case, the one argument version of
<tt>CharacterTableIsoclinic</tt> returns a permutation isomorphic table.
By supplying additional arguments, there is a chance to construct tables of
different groups.

<div class="p"><!----></div>
We demonstrate this phenomenon with the various groups of the structure
4.L<sub>3</sub>(4).2.

<div class="p"><!----></div>

<pre>
    gap&#62; tbls:= [];;
    gap&#62; for m in [ "4_1", "4_2" ] do
    &#62;      for a in [ "2_1", "2_2", "2_3" ] do
    &#62;        Add( tbls, CharacterTable( Concatenation( m, ".L3(4).", a ) ) );
    &#62;      od;
    &#62;    od;
    gap&#62; tbls;
    [ CharacterTable( "4_1.L3(4).2_1" ), CharacterTable( "4_1.L3(4).2_2" ), 
      CharacterTable( "4_1.L3(4).2_3" ), CharacterTable( "4_2.L3(4).2_1" ), 
      CharacterTable( "4_2.L3(4).2_2" ), CharacterTable( "4_2.L3(4).2_3" ) ]
    gap&#62; case1:= Filtered( tbls, t -&#62; Size( ClassPositionsOfCentre( t ) ) = 2 );
    [ CharacterTable( "4_1.L3(4).2_1" ), CharacterTable( "4_1.L3(4).2_2" ), 
      CharacterTable( "4_2.L3(4).2_1" ), CharacterTable( "4_2.L3(4).2_3" ) ]
    gap&#62; case2:= Filtered( tbls, t -&#62; Size( ClassPositionsOfCentre( t ) ) = 4 );
    [ CharacterTable( "4_1.L3(4).2_3" ), CharacterTable( "4_2.L3(4).2_2" ) ]

</pre>

<div class="p"><!----></div>
The centres of the groups 4<sub>1</sub>.L<sub>3</sub>(4).2<sub>1</sub>, 4<sub>1</sub>.L<sub>3</sub>(4).2<sub>2</sub>,
4<sub>2</sub>.L<sub>3</sub>(4).2<sub>1</sub>, and 4<sub>2</sub>.L<sub>3</sub>(4).2<sub>3</sub> have order two,
that is, these groups belong to the first case.
Each of these groups is not permutation equivalent to its isoclinic
variant but has the same irreducible characters.

<div class="p"><!----></div>

<pre>
    gap&#62; isos1:= List( case1, CharacterTableIsoclinic );;
    gap&#62; List( [ 1 .. 4 ], i -&#62; Irr( case1[i] ) = Irr( isos1[i] ) );
    [ true, true, true, true ]
    gap&#62; List( [ 1 .. 4 ],
    &#62;      i -&#62; TransformingPermutationsCharacterTables( case1[i], isos1[i] ) );
    [ fail, fail, fail, fail ]

</pre>

<div class="p"><!----></div>
The groups 4<sub>1</sub>.L<sub>3</sub>(4).2<sub>3</sub> and 4<sub>2</sub>.L<sub>3</sub>(4).2<sub>2</sub> belong to the second case
because their centres have order four.

<div class="p"><!----></div>

<pre>
    gap&#62; isos2:= List( case2, CharacterTableIsoclinic );;
    gap&#62; List( [ 1, 2 ],
    &#62;      i -&#62; TransformingPermutationsCharacterTables( case2[i], isos2[i] ) );
    [ rec( columns := (26,27,28,29)(30,31,32,33)(38,39,40,41)(42,43,44,45), 
          group := &lt;permutation group with 5 generators&#62;, 
          rows := (16,17)(18,19)(20,21)(22,23)(28,29)(32,33)(36,37)(40,41) ), 
      rec( columns := (28,29,30,31)(32,33)(34,35,36,37)(38,39,40,41)(42,43,44,
            45)(46,47,48,49), group := &lt;permutation group with 3 generators&#62;, 
          rows := (15,16)(17,18)(20,21)(22,23)(24,25)(26,27)(28,29)(34,35)(38,
            39)(42,43)(46,47) ) ]
    gap&#62; isos3:= List( case2, t -&#62; CharacterTableIsoclinic( t,
    &#62;                                ClassPositionsOfCentre( t ) ) );;
    gap&#62; List( [ 1, 2 ],
    &#62;      i -&#62; TransformingPermutationsCharacterTables( case2[i], isos3[i] ) );
    [ fail, fail ]

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc2.6">
2.6</a>&nbsp;&nbsp;Characters of Normal Subgroups</h3><a name="theorClifford">
</a>

<div class="p"><!----></div>
Let G be a group and N be a normal subgroup of G.
We will need the following well-known facts about the relation
between the irreducible characters of G and N.

<div class="p"><!----></div>
For an irreducible (Brauer) character &#967; of N and g  &#8712; G,
we define &#967;<sup>g</sup> by &#967;<sup>g</sup>(n) = &#967;(n<sup>g</sup>) for all n  &#8712; N,
and set I<sub>G</sub>(&#967;) = { g  &#8712; G; &#967;<sup>g</sup> = &#967;}
(see&nbsp;[<a href="#Feit82" name="CITEFeit82">Fei82</a>,p.&nbsp;86]).

<div class="p"><!----></div>
If I<sub>G</sub>(&#967;) = N then the induced character &#967;<sup>G</sup> is an
irreducible (Brauer) character of G
(see&nbsp;[<a href="#Feit82" name="CITEFeit82">Fei82</a>,Lemma&nbsp;III 2.11]).

<div class="p"><!----></div>
If G/N is cyclic and if I<sub>G</sub>(&#967;) = G then &#967; =  &#968;<sub>N</sub>
for an irreducible (Brauer) character &#968; of G,
and each irreducible (Brauer) character &#952; with the property
&#967; =  &#952;<sub>N</sub> is of the form &#952; =  &#968;&#183;&#949;,
where &#949; is an irreducible (Brauer) character of G/N
(see&nbsp;[<a href="#Feit82" name="CITEFeit82">Fei82</a>,Theorem&nbsp;III 2.14]).

<div class="p"><!----></div>
Clifford's theorem&nbsp;[<a href="#Feit82" name="CITEFeit82">Fei82</a>,Theorem&nbsp;III 2.12] states that the
restriction of an irreducible (Brauer) character of G to N
has the form e &#8721;<sub>i=1</sub><sup>t</sup> &#981;<sub>i</sub> for a positive integer e
and irreducible (Brauer) characters &#981;<sub>i</sub> of N,
where t is the index of I<sub>G</sub>(&#981;<sub>1</sub>) in G.

<div class="p"><!----></div>
Now assume that G is a normal subgroup in a larger group H,
that G/N is an abelian chief factor of H and that &#968; is an
ordinary irreducible character of G such that I<sub>H</sub>(&#968;) = H.
Then either t = 1 and e<sup>2</sup> is one of 1, &#124;G/N&#124;,
or t = &#124;G/N&#124; and e = 1
(see&nbsp;[<a href="#Isa76" name="CITEIsa76">Isa76</a>,Theorem&nbsp;6.18]).

<div class="p"><!----></div>

 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;The Constructions</h2><a name="constr">
</a>

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;Character Tables of Groups of the Structure M.G.A</h3><a name="theorMGA">
</a>

<div class="p"><!----></div>
Let N denote a downward extension of the finite group G
by a finite group M,
let H denote an automorphic (upward) extension of N by
a finite cyclic group A such that M is normal in H,
and set F = H / M.
We consider the situation that each irreducible character of N
that does not contain M in its kernel induces irreducibly to H.
Equivalently, the action of A = &#9001;a &#9002; on the characters of N,
via &#967;&#8594; &#967;<sup>a</sup>, has orbits of length exactly &#124;A&#124; on the set
{ &#967; &#8712; <span class="roman">Irr</span>(N); M  &#8836; eq ker(&#967;) }.

<div class="p"><!----></div>

<center> <img src="ctblcons02.png" alt="ctblcons02.png" />

</center>

<div class="p"><!----></div>
This occurs for example if M is central in N and A acts
fixed-point freely on M,
we have &#124;M&#124;  &#8801; 1  mod &#124;A&#124; in this case.
If M has prime order then it is sufficient that A does not
centralize M.

<div class="p"><!----></div>
The ordinary (or p-modular) irreducible characters of H are then given
by the ordinary (or p-modular) irreducible characters of F and N,
the class fusions from the table of N onto the table of G
and from the table of G into that of F,
and the permutation &#960; that is induced by the action of A on the
conjugacy classes of N.

<div class="p"><!----></div>
In general, the action of A on the classes of M is not the right
thing to look at, one really must consider the action on the relevant
characters of M.G.
For example, take H the quaternion group or the dihedral group of
order eight, N a cyclic subgroup of index two, and M the centre of H;
here A acts trivially on M, but the relevant fact is that the action
of A swaps those two irreducible characters of N that take the value
&#8722;1 on the involution in M -these are the faithful irreducible characters
of N.

<div class="p"><!----></div>
If the orders of M and A are coprime then also the power maps of H
can be computed from the above data.
For each prime p that divides the orders of both M and A,
the p-th power map is in general not uniquely determined by these
input data.
In this case, we can compute the (finitely many) candidates for the
character table of H that are described by these data.
One possible reason for ambiguities is the existence of several isoclinic
but nonisomorphic groups that can arise from the input tables
(cf. Section&nbsp;<a href="#isoclinism">2.4</a>, see Section&nbsp;<a href="#HN2">4.10</a> for an example).

<div class="p"><!----></div>
With the <font face="helvetica">GAP</font> function <tt>PossibleActionsForTypeMGA</tt>, one can compute
the possible orbit structures induced by G.A on the classes of M.G,
and <tt>PossibleCharacterTablesForTypeMGA</tt> computes the possible ordinary
character tables for a given orbit structure.
For constructing the p-modular Brauer table of a group H of the structure
M.G.A, the <font face="helvetica">GAP</font> function <tt>BrauerTableOfTypeMGA</tt> takes the ordinary
character table of H and the p-modular tables of the subgroup M.G
and the factor group G.A as its input.
The p-modular table of G is not explicitly needed in the construction,
it is implicitly given by the class fusions from M.G into M.G.A and
from M.G.A onto G.A;
these class fusions must of course be available.

<div class="p"><!----></div>
The <font face="helvetica">GAP</font> Character Table Library contains many tables of groups of the
structure M.G.A as described above, which are encoded by references to
the tables of the groups M.G and G.A, plus the fusion and action
information.
This reduces the space needed for storing these character tables.

<div class="p"><!----></div>
For examples, see Section&nbsp;<a href="#explMGA">4</a>.

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;Character Tables of Groups of the Structure G.S<sub>3</sub></h3>

<div class="p"><!----></div>
Let G be a finite group, and H be an upward extension of G
such that the factor group H / G is a Frobenius group F = K C with
abelian kernel K and cyclic complement C of prime order c.
(Typical cases for F are the symmetric group S<sub>3</sub> on three points
and the alternating group A<sub>4</sub> on four points.)
Let N and U denote the preimages of K and C under the natural
epimorphism from H onto F.

<div class="p"><!----></div>

<div class="p"><!----></div>

<center> <img src="ctblcons03.png" alt="ctblcons03.png" />

</center>

<div class="p"><!----></div>
For certain isomorphism types of F,
the ordinary (or p-modular) character table of H can be computed
from the ordinary (or p-modular) character tables of G, U, and N,
the class fusions from the table of G into those of U and N,
and the permutation &#960; induced by H on the conjugacy classes of N.
This holds for example for F = S<sub>3</sub> and in the ordinary case also
for F = A<sub>4</sub>.

<div class="p"><!----></div>
Each class of H is either a union of &#960;-orbits or an H-class of
U \G; the latter classes are in bijection with the
U-classes of U \G, they are just &#124;K&#124; times larger
since the &#124;K&#124; conjugates of U in H are fused.
The power maps of H are uniquely determined from the power maps of
U and N, because each element in F lies in K or in an
F-conjugate of C.

<div class="p"><!----></div>
Concerning the computation of the ordinary irreducible characters of H,
we could induce the irreducible characters of U and N to H,
and then take the union of the irreducible characters among those
and the irreducible differences of those.
(For the case F = S<sub>3</sub>, this approach has been described in the
Appendix of&nbsp;[<a href="#HL94" name="CITEHL94">HL94</a>].)

<div class="p"><!----></div>
The <font face="helvetica">GAP</font> function <tt>CharacterTableOfTypeGS3</tt> proceeds in a different way,
which is suitable also for the construction of p-modular character tables
of H.

<div class="p"><!----></div>
By the facts listed in Section&nbsp;<a href="#theorClifford">2.6</a>,
for an irreducible (Brauer) character &#967; of N,
we have I<sub>H</sub>(&#967;) equal to either N or H.
In the former case, &#967; induces irreducibly to H.
In the latter case, there are extensions &#968;<sup>(i)</sup>,
1  &#8804; i  &#8804; &#124;C&#124; (or &#124;C&#124;<sub>p&#8242;</sub>), to H,
and we have the following possibilities,
depending on the restriction &#967;<sub>G</sub>.

<div class="p"><!----></div>
If &#967;<sub>G</sub> = e &#981;, for an irreducible character &#981; of G,
then I<sub>U</sub>(&#981;) = U holds,
hence the &#968;<sup>(i)</sup><sub>U</sub> are &#124;C&#124; (or &#124;C&#124;<sub>p&#8242;</sub>) extensions
of &#967;<sub>G</sub> to U.
Moreover, we have either e = 1 or e<sup>2</sup> = &#124;K&#124;.
In the case e = 1, this determines the values of the &#968;<sup>(i)</sup>
on the classes of U outside G.
In the case e  &#8800; 1, we have the problem to combine e extensions
of &#981; to a character of U that extends to H.

<div class="p"><!----></div>
(One additional piece of information in the case of ordinary character tables
is that the norm of this linear combination equals 1 + (&#124;K&#124;&#8722;1)/&#124;C&#124;,
which determines the &#968;<sup>(i)</sup><sub>U</sub> if F = A<sub>4</sub>  &#8773; 2<sup>2</sup>:3 or F = 2<sup>3</sup>:7
holds;
in the former case, the sum of each two out of the three different extensions
of &#981; extends to U;
in the latter case, the sum of all different extensions plus one of the
extensions extends.
Note that for F = S<sub>3</sub>, the case e  &#8800; 1 does not occur.)

<div class="p"><!----></div>
The remaining case is that &#967;<sub>G</sub> is not a multiple of an irreducible
character of G.
Then &#967;<sub>G</sub> = &#981;<sub>1</sub> + &#981;<sub>2</sub> + &#8230;+ &#981;<sub>&#124;K&#124;</sub>,
for pairwise different irreducible characters &#981;<sub>i</sub>, 1  &#8804; i  &#8804; &#124;K&#124;,
of G with the property &#981;<sub>i</sub><sup>N</sup> = &#967;.
The action of U on G fixes at least one of the &#981;<sub>i</sub>,
since &#124;K&#124;  &#8801; 1  mod &#124;C&#124;.
Without loss of generality, let I<sub>U</sub>(&#981;<sub>1</sub>) = U,
and let [(&#981;<sub>1</sub>)\tilde]<sup>(i)</sup>, 1  &#8804; i  &#8804; &#124;C&#124;,
be the extensions of &#981;<sub>1</sub> to U.
(In fact exactly &#981;<sub>1</sub> is fixed by U since otherwise k  &#8712; K
would exist with &#981;<sub>1</sub><sup>k</sup>  &#8800; &#981;<sub>1</sub> and such that also
&#981;<sub>1</sub><sup>k</sup> would be invariant in U;
but then &#981;<sub>1</sub> would be invariant under both C and C<sup>k</sup>, which
generate F.
So each of the &#124;K&#124; constituents is invariant in exactly one of the
&#124;K&#124; subgroups of type U above G.)

<div class="p"><!----></div>
Then
(([(&#981;<sub>1</sub>)\tilde]<sup>(i)</sup>)<sup>H</sup>)<sub>N</sub> = &#981;<sub>1</sub><sup>N</sup> = &#967;,
hence the values of &#968;<sup>(i)</sup> on the classes of U \G
are given by those of ([(&#981;<sub>1</sub>)\tilde]<sup>(i)</sup>)<sup>H</sup>.
(These are exactly the values of [(&#981;<sub>1</sub>)\tilde]<sup>(i)</sup>.
So in both cases, we take the values of &#967; on N,
and on the classes of U \G the values of the extensions
of the unique extendible constituent of &#967;<sub>G</sub>.)

<div class="p"><!----></div>
For examples, see Section&nbsp;<a href="#GS3">5</a>.

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.3">
3.3</a>&nbsp;&nbsp;Character Tables of Groups of the Structure G.2<sup>2</sup></h3><a name="theorGV4">
</a>

<div class="p"><!----></div>
Let G be a finite group, and H be an upward extension of G
such that the factor group H / G is a Klein four group.
We assume that the ordinary character tables of G and of the three index
two subgroups U<sub>1</sub>, U<sub>2</sub>, and U<sub>3</sub> (of the structures G.2<sub>1</sub>, G.2<sub>2</sub>,
and G.2<sub>3</sub>, respectively) of H above G are known,
as well as the class fusions of G into these groups.
The idea behind the method that is described in this section is that
in this situation,
there are only few possibilities for the ordinary character table of H.

<div class="p"><!----></div>

<center> <img src="ctblcons04.png" alt="ctblcons04.png" />

</center>

<div class="p"><!----></div>
Namely, the action of H on the classes of G.2<sub>i</sub> is given by a table
automorphism &#960;<sub>i</sub> of G.2<sub>i</sub>, and H realizes compatible choices of such
automorphisms &#960;<sub>1</sub>, &#960;<sub>2</sub>, &#960;<sub>3</sub> in the sense that the orbits of all
three &#960;<sub>i</sub> on the classes of G inside the groups G.2<sub>i</sub> coincide.
Furthermore, if G.2<sub>i</sub> has n<sub>i</sub> conjugacy classes then an action &#960;<sub>i</sub>
that is a product of f<sub>i</sub> disjoint transpositions leads to a character table
candidate for G.2<sup>2</sup> that has 2 n<sub>i</sub> &#8722; 3 f<sub>i</sub> classes,
so also the f<sub>i</sub> must be compatible.

<div class="p"><!----></div>
Taking the "inner" classes, i.e., the orbit sums of the classes inside G
under the &#960;<sub>i</sub>, plus the union of the &#960;<sub>i</sub>-orbits of
the classes of G.2<sub>i</sub> \G gives a possibility for the classes
of H.
Furthermore, the power maps of the groups G.2<sub>i</sub> determine the power maps of
the candidate table constructed this way.

<div class="p"><!----></div>
Concerning the computation of the irreducible characters of H,
we consider also the case of p-modular characters tables,
where we assume that the ordinary character table of H is already known
and the only task is to compute the irreducible p-modular Brauer
characters.

<div class="p"><!----></div>
Let &#967; be an irreducible (p-modular Brauer) character of G.
By the facts that are listed in Section&nbsp;<a href="#theorClifford">2.6</a>,
there are three possibilities.

<ul>
<br />1.
   I<sub>H</sub>(&#967;) = G; then &#967;<sup>H</sup> is irreducible.
<br />2.
   I<sub>H</sub>(&#967;) = G.2<sub>i</sub> for i one of 1, 2, 3;
   then I<sub>G.2<sub>i</sub></sub>(&#967;) = G.2<sub>i</sub> for this i,
   so &#967; extends to G.2<sub>i</sub>;
   none of these extensions extends to H (because otherwise &#967;
   would be invariant in H),
   so they induce irreducible characters of H.
<br />3.
   I<sub>H</sub>(&#967;) = H;
   then &#967; extends to each of the three groups G.2<sub>i</sub>,
   and either all these extensions induce the same character of H
   (which vanishes on H \G) or they are invariant in H
   and thus extend to H.</ul>

<div class="p"><!----></div>
In the latter part of case&nbsp;3. (except if p = 2),
the problem is to combine the values of six irreducible characters
of the groups G.2<sub>i</sub> to four characters of H.
This yields essentially two choices, and we try to exclude one possibility
by forming scalar products with the 2-nd symmetrizations of the known
irreducibles.
If several possibilities remain then we get several possible tables.

<div class="p"><!----></div>
So we end up with a list of possible character tables of H.

<div class="p"><!----></div>
The first step is to specify a list of possible triples
(&#960;<sub>1</sub>, &#960;<sub>2</sub>, &#960;<sub>3</sub>), using the table automorphisms of the groups G.2<sub>i</sub>;
this can be done using the <font face="helvetica">GAP</font> function <tt>PossibleActionsForTypeGV4</tt>.
Then the <font face="helvetica">GAP</font> function <tt>PossibleCharacterTablesOfTypeGV4</tt> can be used
for computing the character table candidates for each given triple of
permutations; it may of course happen that some triples of automorphisms
are excluded in this second step.

<div class="p"><!----></div>
For examples, see Section&nbsp;<a href="#xplGV4">6</a>.

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.4">
3.4</a>&nbsp;&nbsp;Character Tables of Groups of the Structure 2<sup>2</sup>.G
(August 2005)</h3><a name="theorV4G">
</a>

<div class="p"><!----></div>
Let G be a finite group, and H be a central extension of G
by a Klein four group Z = &#9001;z<sub>1</sub>, z<sub>2</sub> &#9002;;
set z<sub>3</sub> = z<sub>1</sub> z<sub>2</sub> and Z<sub>i</sub> = &#9001;z<sub>i</sub> &#9002;, for 1  &#8804; i  &#8804; 3.
We assume that the ordinary character tables of the three factor groups
2<sub>i</sub>.G = H / Z<sub>i</sub> of H are known,
as well as the class fusions from these groups to G.
The idea behind the method described in this section is that
in this situation,
there are only few possibilities for the ordinary character table of H.

<div class="p"><!----></div>

<center> <img src="ctblcons05.png" alt="ctblcons05.png" />

</center>

<div class="p"><!----></div>
Namely, the irreducible (p-modular) characters of H are exactly the
inflations of the irreducible (p-modular) characters of the three
factor groups H / Z<sub>i</sub>.
(Note that for any noncyclic central subgroup C of H
and any &#967; &#8712; <span class="roman">Irr</span>(H), we have &#124;ker(&#967;) &#8745;C&#124;  &gt;  1.
To see this, let N = ker(&#967;).
Then clearly &#124;N&#124;  &gt;  1,
and &#967; can be regarded as a faithful irreducible character of H/N.
If N &#8745;C would be trivial then N C / N  &#8773; C would be
a noncyclic central subgroup of H/N.
This cannot happen by&nbsp;[<a href="#Isa76" name="CITEIsa76">Isa76</a>,Thm.&nbsp;2.32&nbsp;(a)],
so the statement can be regarded as an obvious refinement of this theorem.)
So all we have to construct is the character table head of H
-classes and power maps- and the factor fusions from H to these groups.

<div class="p"><!----></div>
For fixed h  &#8712; H, we consider the question in which H-classes the
elements h, h z<sub>1</sub>, h z<sub>2</sub>, and h z<sub>3</sub> lie.
There are three possibilities.

<div class="p"><!----></div>

<ul>
<br />1.
   The four elements are all conjugate in H.
   Then in each of the three groups H/Z<sub>i</sub>,
   the two preimages of h Z  &#8712; H/Z are conjugate.
<br />2. 
   We are not in case 1. but two of the four elements are conjugate in H,
   i.&nbsp;e., g<sup>&#8722;1</sup> h g = h z<sub>i</sub> for some g  &#8712; H and some i;
   then g<sup>&#8722;1</sup> h z<sub>j</sub> g = h z<sub>i</sub> z<sub>j</sub> for each j,
   so the four elements lie in exactly two H-classes.
   This implies that for i  &#8800; j, the elements h and h z<sub>j</sub> are not
   H-conjugate,
   so h Z<sub>i</sub> is not conjugate to h z<sub>j</sub> Z<sub>i</sub> in H/Z<sub>i</sub>
   and h Z<sub>j</sub> is conjugate to h z<sub>i</sub> Z<sub>j</sub> in H/Z<sub>j</sub>.
<br />3.
   The four elements are pairwise nonconjugate in H.
   Then in each of the three groups H/Z<sub>i</sub>,
   the two preimages of h Z  &#8712; H/Z are nonconjugate.</ul>

<div class="p"><!----></div>
We observe that the question which case actually applies for h  &#8712; H
can be decided from the three factor fusions from H/Z<sub>i</sub> to G.
So we attempt to construct the table head of H and the three factor fusions
from H to the groups H/Z<sub>i</sub>, as follows.
Each class g<sup>G</sup> of G yields either one or two or four preimage classes
in H.

<div class="p"><!----></div>
In case 1., we get one preimage class in H,
and have no choice for the factor fusions.

<div class="p"><!----></div>
In case 2., we get two preimage classes,
there is exactly one group H/Z<sub>i</sub> in which g<sup>G</sup> has two preimage classes
-which are in bijection with the two preimage classes of H-
and for the other two groups H/Z<sub>j</sub>, the factor fusions from H
map the two classes of H to the unique preimage class of g<sup>G</sup>.
(In the following picture, this is shown for i = 1.)

<div class="p"><!----></div>

<center> <img src="ctblcons06.png" alt="ctblcons06.png" />

</center>

<div class="p"><!----></div>
In case 3., the three factor fusions are in general not uniquely determined:
We get four classes, which are defined as two pairs of preimages of the two
preimages of g<sup>G</sup> in H/Z<sub>1</sub> and in H/Z<sub>2</sub>
- so we choose the relevant images in the two factor fusions to H/Z<sub>1</sub>
and H/Z<sub>2</sub>, respectively.
Note that the class of h in H is the unique class
that maps to the class of h Z<sub>1</sub> in H/Z<sub>1</sub> and to the class of h Z<sub>2</sub> in
H/Z<sub>2</sub>, and so on,
and we define four classes of H via the four possible combinations of
image classes in H/Z<sub>1</sub> and H/Z<sub>2</sub> (see the picture below).

<div class="p"><!----></div>

<center> <img src="ctblcons07.png" alt="ctblcons07.png" />

</center>

<div class="p"><!----></div>
Due to the fact that in general we do not know which of the two
preimage classes of g<sup>G</sup> in H/Z<sub>3</sub> is the class of h Z<sub>3</sub>,
there are in general the following <b>two</b> possibilities
for the fusion from H to H/Z<sub>3</sub>.

<div class="p"><!----></div>

<center> <img src="ctblcons08.png" alt="ctblcons08.png" />

</center>

<div class="p"><!----></div>
This means that we can inflate the irreducible characters of H/Z<sub>1</sub> and
of H/Z<sub>2</sub> to H but that for the inflations of those irreducible characters
of H/Z<sub>3</sub> to H that are not characters of G, the values on classes
where case 3.&nbsp;applies are determined only up to sign.

<div class="p"><!----></div>
The <font face="helvetica">GAP</font> function <tt>PossibleCharacterTablesOfTypeV4G</tt> computes the
candidates for the table of H from the tables of the groups H/Z<sub>i</sub>
by setting up the character table head of H using the class fusions
from H/Z<sub>1</sub> and H/Z<sub>2</sub> to G,
and then forming the possible class fusions from H to H/Z<sub>3</sub>.

<div class="p"><!----></div>
If case 3.&nbsp;applies for a class g<sup>G</sup> with g of <b>odd</b> element order
then exactly one preimage class in H has odd element order,
and we can identify this class in the groups H/Z<sub>i</sub>,
which resolves the ambiguity in this situation.
More generally, if g = k<sup>2</sup> holds for some k  &#8712; G then all preimages of
k<sup>G</sup> in H square to the same class of H,
so again this class can be identified.
In fact <tt>PossibleCharacterTablesOfTypeV4G</tt> checks whether the p-th power
maps of the candidate table for H and the p-th power map of H/Z<sub>3</sub>
together with the fusion candidate form a commutative diagram.

<div class="p"><!----></div>
An additional criterion used by <tt>PossibleCharacterTablesOfTypeV4G</tt> is given
by the property that the product of two characters inflated from
H/Z<sub>1</sub> and H/Z<sub>2</sub>, respectively, that are not characters of G
is a character of H that contains Z<sub>3</sub> in its kernel,
so it is checked whether the scalar products of these characters
with all characters that are inflated from H/Z<sub>3</sub> via the candidate fusion
are nonnegative integers.

<div class="p"><!----></div>
Once the fusions from H to the groups H/Z<sub>i</sub> are known,
the computation of the irreducible p-modular characters of H
from those of the groups H/Z<sub>i</sub> is straightforward.

<div class="p"><!----></div>
The only open question is why this construction is described in this note.
That is, how is it related to table automorphisms?

<div class="p"><!----></div>
The answer is that in several interesting cases, the three subgroups Z<sub>1</sub>,
Z<sub>2</sub>, Z<sub>3</sub> are conjugate under an order three automorphism &#963;, say,
of H.
In this situation, the three factor groups 2<sub>i</sub>.G = H/Z<sub>i</sub> are isomorphic,
and we can describe the input tables and fusions by the character table of
2<sub>1</sub>.G, the factor fusion from this group to G,
and the automorphism [&#63717;&#963;] of G that is induced by &#963;.
Assume that &#963;(Z<sub>1</sub>) = Z<sub>2</sub> holds, and choose h  &#8712; H.
Then &#963;(h Z<sub>1</sub>) = &#963;(h) Z<sub>2</sub> is mapped to
&#963;(h) Z = [&#63717;&#963;](h Z) under the factor fusion from 2<sub>2</sub>.G
to G.
Let us start with the character table of 2<sub>1</sub>.G,
and fix the class fusion to the character table of G.
We may choose the identity map as isomorphism from the table of 2<sub>1</sub>.G to
the tables of 2<sub>2</sub>.G and 2<sub>3</sub>.G,
which implies that the class of h Z<sub>1</sub> is identified with the class
of h Z<sub>2</sub> and in turn the class fusion from the table of 2<sub>2</sub>.G to that of
G can be chosen as the class fusion from the table of 2<sub>1</sub>.G followed by
the permutation of classes of G induced by [&#63717;&#963;];
analogously, the fusion from the table of 2<sub>3</sub>.G is obtained by applying
this permutation twice to the class fusion from the table of 2<sub>1</sub>.G.

<div class="p"><!----></div>
For examples, see Section&nbsp;<a href="#xplV4G">7</a>.

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.5">
3.5</a>&nbsp;&nbsp;p-Modular Tables of Extensions by p-singular Automorphisms</h3><a name="theorpsing">
</a>

<div class="p"><!----></div>
Let G be a finite group, and H be an upward extension of G
by an automorphism of prime order p, say.
H induces a table automorphism of the p-modular character table of G;
let &#960; denote the corresponding permutation of classes of G.
The columns of the p-modular character table of H are given by the
orbits of &#960;,
and the irreducible Brauer characters of H are exactly the orbit sums
of &#960; on the irreducible Brauer characters of G.

<div class="p"><!----></div>
Note that for computing the p-modular character table of H from that
of G, it is sufficient to know the orbits of &#960; and not &#960; itself.
Also the ordinary character table of H is not needed,
but since <font face="helvetica">GAP</font> stores Brauer character tables relative to their ordinary
tables, we are interested mainly in cases where the ordinary character
tables of G and H and the p-modular character table of G are known.
Assuming that the class fusion between the ordinary tables of G and H
is stored on the table of G, the orbits of the action of H on the
p-regular classes of G can be read off from it.

<div class="p"><!----></div>
The <font face="helvetica">GAP</font> function <tt>IBrOfExtensionBySingularAutomorphism</tt> can be used
to compute the p-modular irreducibles of H.

<div class="p"><!----></div>
For examples, see Section&nbsp;<a href="#xplpsing">8</a>.

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.6">
3.6</a>&nbsp;&nbsp;Character Tables of Subdirect Products of Index Two (July 2007)</h3><a name="theorsubdir">
</a>

<div class="p"><!----></div>
Let C<sub>2</sub> denote the cyclic group of order two,
let G<sub>1</sub>, G<sub>2</sub> be two finite groups,
and for i  &#8712; { 1, 2 }, let &#981;<sub>i</sub>:G<sub>i</sub> &#8594; C<sub>2</sub>
be an epimorphism with kernel H<sub>i</sub>.
Let G be the subdirect product (pullback) of G<sub>1</sub> and G<sub>2</sub> w.r.t. the
epimorphisms &#981;<sub>i</sub>, i.e.,

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 G = { (g<sub>1</sub>, g<sub>2</sub>)  &#8712; G<sub>1</sub> &times;G<sub>2</sub>; &#981;<sub>1</sub>(g<sub>1</sub>) = &#981;<sub>2</sub>(g<sub>2</sub>) } .</td></tr></table>
</td></tr></table>


The group G has index two in the direct product G<sub>1</sub> &times;G<sub>2</sub>,
and G contains H<sub>1</sub> &times;H<sub>2</sub> as a subgroup of index two.

<div class="p"><!----></div>
In the following,
we describe how the ordinary (or p-modular) character table of G
can be computed from the ordinary (or p-modular) character tables of
the groups G<sub>i</sub> and H<sub>i</sub>, and the class fusions from H<sub>i</sub> to G<sub>i</sub>.

<div class="p"><!----></div>
(For the case that one of the groups G<sub>i</sub> is a cyclic group of order four,
an alternative way to construct the character table of G is described
in Section&nbsp;<a href="#isoclinism">2.4</a>.
For the case that one of the groups G<sub>i</sub> acts fixed point freely on the
nontrivial irreducible characters of H<sub>i</sub>, an alternative construction
is described in Section&nbsp;<a href="#theorMGA">3.1</a>.)

<div class="p"><!----></div>

<center> <img src="ctblcons09.png" alt="ctblcons09.png" />

</center>

<div class="p"><!----></div>
Each conjugacy class of G is either contained in H<sub>1</sub> &times;H<sub>2</sub> or not.
In the former case, let h<sub>i</sub>  &#8712; H<sub>i</sub> and g<sub>i</sub>  &#8712; G<sub>i</sub> \H<sub>i</sub>;
in particular, (g<sub>1</sub>, g<sub>2</sub>)  &#8712; G because both &#981;<sub>1</sub>(g<sub>1</sub>) and
&#981;<sub>2</sub>(g<sub>2</sub>) are not the identity.
There are four possibilities.

<ul>
<br />1.
   If h<sub>1</sub><sup>H<sub>1</sub></sup> = h<sub>1</sub><sup>G<sub>1</sub></sup> and h<sub>2</sub><sup>H<sub>2</sub></sup> = h<sub>2</sub><sup>G<sub>2</sub></sup> then
   (h<sub>1</sub>, h<sub>2</sub>)<sup>H<sub>1</sub> &times;H<sub>2</sub></sup> = (h<sub>1</sub>, h<sub>2</sub>)<sup>G<sub>1</sub> &times;G<sub>2</sub></sup> holds,
   hence this class is equal to (h<sub>1</sub>, h<sub>2</sub>)<sup>G</sup>.
<br />2.
   If h<sub>1</sub><sup>H<sub>1</sub></sup>  &#8800; h<sub>1</sub><sup>G<sub>1</sub></sup> and h<sub>2</sub><sup>H<sub>2</sub></sup>  &#8800; h<sub>2</sub><sup>G<sub>2</sub></sup> then
   the four H<sub>1</sub> &times;H<sub>2</sub>-classes with the representatives (h<sub>1</sub>, h<sub>2</sub>),
   (h<sub>1</sub><sup>g<sub>1</sub></sup>, h<sub>2</sub>), (h<sub>1</sub>, h<sub>2</sub><sup>g<sub>2</sub></sup>), and (h<sub>1</sub><sup>g<sub>1</sub></sup>, h<sub>2</sub><sup>g<sub>2</sub></sup>)
   fall into two G-classes,
   where (h<sub>1</sub>, h<sub>2</sub>) is G-conjugate with (h<sub>1</sub><sup>g<sub>1</sub></sup>, h<sub>2</sub><sup>g<sub>2</sub></sup>),
   and (h<sub>1</sub><sup>g<sub>1</sub></sup>, h<sub>2</sub>) is G-conjugate with (h<sub>1</sub>, h<sub>2</sub><sup>g<sub>2</sub></sup>).
<br />3.
   If h<sub>1</sub><sup>H<sub>1</sub></sup> = h<sub>1</sub><sup>G<sub>1</sub></sup> and h<sub>2</sub><sup>H<sub>2</sub></sup>  &#8800; h<sub>2</sub><sup>G<sub>2</sub></sup> then
   the two H<sub>1</sub> &times;H<sub>2</sub>-classes with the representatives (h<sub>1</sub>, h<sub>2</sub>)
   and (h<sub>1</sub>, h<sub>2</sub><sup>g<sub>2</sub></sup>) fuse in G;
   note that there is [g\tilde]<sub>1</sub>  &#8712; C<sub>G<sub>1</sub></sub>(h<sub>1</sub>) \H<sub>1</sub>,
   so ([g\tilde]<sub>1</sub>, g<sub>2</sub>)  &#8712; G holds.
<br />4.
   The case of h<sub>1</sub><sup>H<sub>1</sub></sup>  &#8800; h<sub>1</sub><sup>G<sub>1</sub></sup> and h<sub>2</sub><sup>H<sub>2</sub></sup> = h<sub>2</sub><sup>G<sub>2</sub></sup>
   is analogous to case 3.</ul>

<div class="p"><!----></div>
It remains to deal with the G-classes that are not contained in
H<sub>1</sub> &times;H<sub>2</sub>.
Each such class is in fact a conjugacy class of G<sub>1</sub> &times;G<sub>2</sub>.
Note that two elements g<sub>1</sub>, g<sub>2</sub>  &#8712; G<sub>1</sub> \H<sub>1</sub> are G<sub>1</sub>-conjugate
if and only if they are H<sub>1</sub>-conjugate.
(If g<sub>1</sub><sup>x</sup> = g<sub>2</sub> for x  &#8712; G<sub>1</sub> \H<sub>1</sub> then g<sub>1</sub><sup>g<sub>1</sub> x</sup> = g<sub>2</sub>
holds, and g<sub>1</sub> x  &#8712; H<sub>1</sub>.)
This implies (g<sub>1</sub>, g<sub>2</sub>)<sup>G<sub>1</sub> &times;G<sub>2</sub></sup> = (g<sub>1</sub>, g<sub>2</sub>)<sup>H<sub>1</sub> &times;H<sub>2</sub></sup>,
and thus this class is equal to (g<sub>1</sub>, g<sub>2</sub>)<sup>G</sup>.

<div class="p"><!----></div>
The (ordinary or p-modular) irreducible characters of G are given
by the restrictions &#967;<sub>G</sub> of all those irreducible characters &#967;
of G<sub>1</sub> &times;G<sub>2</sub> whose restriction to H<sub>1</sub> &times;H<sub>2</sub> is irreducible,
plus the induced characters &#981;<sup>G</sup>, where &#981; runs over all
those irreducible characters of H<sub>1</sub> &times;H<sub>2</sub> that do not occur as
restrictions of characters of G<sub>1</sub> &times;G<sub>2</sub>.

<div class="p"><!----></div>
In other words, no irreducible character of H<sub>1</sub> &times;H<sub>2</sub>
has inertia subgroup G inside G<sub>1</sub> &times;G<sub>2</sub>.
This can be seen as follows.
Let &#981; be an irreducible character of H<sub>1</sub> &times;H<sub>2</sub>.
Then &#981; =  &#981;<sub>1</sub> &#183;&#981;<sub>2</sub>,
where &#981;<sub>1</sub>, &#981;<sub>2</sub> are irreducible characters of H<sub>1</sub> &times;H<sub>2</sub>
with the properties that H<sub>2</sub>  &#8838; ker(&#981;<sub>1</sub>) and
H<sub>1</sub>  &#8838; ker(&#981;<sub>2</sub>).
Sloppy speaking, &#981;<sub>i</sub> is an irreducible character of H<sub>i</sub>.

<div class="p"><!----></div>
There are four possibilities.

<ul>
<br />1.
   If &#981;<sub>1</sub> extends to G<sub>1</sub> and &#981;<sub>2</sub> extends to G<sub>2</sub>
   then &#981; extends to G,
   so &#981; has inertia subgroup G<sub>1</sub> &times;G<sub>2</sub>.
<br />2.
   If &#981;<sub>1</sub> does not extend to G<sub>1</sub> and &#981;<sub>2</sub> does not extend
   to G<sub>2</sub> then &#981;<sup>G<sub>1</sub> &times;G<sub>2</sub></sup> is irreducible,
   so &#981; has inertia subgroup H<sub>1</sub> &times;H<sub>2</sub>.
<br />3.
   If &#981;<sub>1</sub> extends to G<sub>1</sub> and &#981;<sub>2</sub> does not extend to G<sub>2</sub>
   then &#981; extends to G<sub>1</sub> &times;H<sub>2</sub> but not to G<sub>1</sub> &times;G<sub>2</sub>,
   so &#981; has inertia subgroup G<sub>1</sub> &times;H<sub>2</sub>.
<br />4.
   The case that &#981;<sub>1</sub> does not extend to G<sub>1</sub> and &#981;<sub>2</sub>
   extends to G<sub>2</sub> is analogous to case 3,
   &#981; has inertia subgroup H<sub>1</sub> &times;G<sub>2</sub>.</ul>

<div class="p"><!----></div>
For examples, see Section&nbsp;<a href="#Gsubdir">9</a>.

<div class="p"><!----></div>

 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Examples for the Type M.G.A</h2><a name="explMGA">
</a>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Character Tables of Dihedral Groups</h3><a name="dihedralMGA">
</a>

<div class="p"><!----></div>
Let n = 2<sup>k</sup> &#183;m where k is a nonnegative integer and m is an odd
integer, and consider the dihedral group D<sub>2n</sub> of order 2n.
Let N denote the derived subgroup of D<sub>2n</sub>.

<div class="p"><!----></div>
If k = 0 then D<sub>2n</sub> has the structure M.G.A, with M = N and
G the trivial group, and A a cyclic group of order two
that inverts each element of N and hence acts fixed-point freely on N.
The smallest nontrivial example is of course that of D<sub>6</sub>  &#8773; S<sub>3</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; tblMG:= CharacterTable( "Cyclic", 3 );;
    gap&#62; tblG:= CharacterTable( "Cyclic", 1 );;
    gap&#62; tblGA:= CharacterTable( "Cyclic", 2 );;
    gap&#62; StoreFusion( tblMG, [ 1, 1, 1 ], tblG );
    gap&#62; StoreFusion( tblG, [ 1 ], tblGA );
    gap&#62; elms:= Elements( AutomorphismsOfTable( tblMG ) );
    [ (), (2,3) ]
    gap&#62; orbs:= [ [ 1 ], [ 2, 3 ] ];;
    gap&#62; new:= PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, orbs,
    &#62;              "S3" );
    [ rec( MGfusMGA := [ 1, 2, 2 ], table := CharacterTable( "S3" ) ) ]
    gap&#62; Display( new[1].table );
    S3
    
         2  1  .  1
         3  1  1  .
    
           1a 3a 2a
        2P 1a 3a 1a
        3P 1a 1a 2a
    
    X.1     1  1  1
    X.2     1  1 -1
    X.3     2 -1  .

</pre>

<div class="p"><!----></div>
If k  &gt;  0 then D<sub>2n</sub> has the structure M.G.A, with M = N and
G a cyclic group of order two such that M.G is cyclic,
and A is a cyclic group of order two that inverts each element of M.G
and hence acts fixed-point freely on M.G.
The smallest nontrivial example is of course that of D<sub>8</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; tblMG:= CharacterTable( "Cyclic", 4 );;
    gap&#62; tblG:= CharacterTable( "Cyclic", 2 );;
    gap&#62; tblGA:= CharacterTable( "2^2" );;           
    gap&#62; OrdersClassRepresentatives( tblMG );
    [ 1, 4, 2, 4 ]
    gap&#62; StoreFusion( tblMG, [ 1, 2, 1, 2 ], tblG ); 
    gap&#62; StoreFusion( tblG, [ 1, 2 ], tblGA );      
    gap&#62; elms:= Elements( AutomorphismsOfTable( tblMG ) );
    [ (), (2,4) ]
    gap&#62; orbs:= Orbits( Group( elms[2] ), [ 1 ..4 ] );;
    gap&#62; new:= PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, orbs,
    &#62;              "order8" );
    [ rec( MGfusMGA := [ 1, 2, 3, 2 ], table := CharacterTable( "order8" ) ),
      rec( MGfusMGA := [ 1, 2, 3, 2 ], table := CharacterTable( "order8" ) ) ]

</pre>

<div class="p"><!----></div>
Here we get two possible tables, which are the character tables of the
dihedral and the quaternion group of order eight, respectively.

<div class="p"><!----></div>

<pre>
    gap&#62; List( new, x -&#62; OrdersClassRepresentatives( x.table ) );
    [ [ 1, 4, 2, 2, 2 ], [ 1, 4, 2, 4, 4 ] ]
    gap&#62; Display( new[1].table );
    order8
    
         2  3  2  3  2  2
    
           1a 4a 2a 2b 2c
        2P 1a 2a 1a 1a 1a
    
    X.1     1  1  1  1  1
    X.2     1  1  1 -1 -1
    X.3     1 -1  1  1 -1
    X.4     1 -1  1 -1  1
    X.5     2  . -2  .  .

</pre>

<div class="p"><!----></div>
For each k  &gt;  1 and m = 1, we get two possible tables this way,
that of the dihedral group of order 2<sup>k+1</sup> and that of the generalized
quaternion group of order 2<sup>k+1</sup>.

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;An M.G.A Type Example with M noncentral in M.G (May 2004)</h3><a name="A12N7">
</a>

<div class="p"><!----></div>
  <table><tr><td width="65%"> 
The Sylow 7 normalizer in the symmetric group S<sub>12</sub> has the structure
7:6 &times;S<sub>5</sub>, its intersection N with the alternating group A<sub>12</sub>
is of index two, it has the structure (7:3 &times;A<sub>5</sub>):2.

<div class="p"><!----></div>
Let M denote the normal subgroup of order 7 in N,
let G denote the normal subgroup of the type 3 &times;A<sub>5</sub>
in F = N/M  &#8773; 3 &times;S<sub>5</sub>,
and A = F/G, the cyclic group of order two.
Then N has the structure M.G.A, where A acts fixed-point freely
on the irreducible characters of M.G = 7:3 &times;A<sub>5</sub>
that do not contain M in their kernels,
hence the character table of N is determined by the character tables of
M.G and F, and the action of A on M.G.

<div class="p"><!----></div>
Note that in this example, the group M is not central in M.G,
unlike in most of our examples.

<div class="p"><!----></div>
  </td><td width="35%"> 

<center>
 <img src="ctblcons10.png" alt="ctblcons10.png" />

</center>

  </td></tr></table> 

<div class="p"><!----></div>

<pre>
    gap&#62; tblMG:= CharacterTable( "7:3" ) * CharacterTable( "A5" );;
    gap&#62; nsg:= ClassPositionsOfNormalSubgroups( tblMG );
    [ [ 1 ], [ 1, 6 .. 11 ], [ 1 .. 5 ], [ 1, 6 .. 21 ], [ 1 .. 15 ], [ 1 .. 25 ]
     ]
    gap&#62; List( nsg, x -&#62; Sum( SizesConjugacyClasses( tblMG ){ x } ) );
    [ 1, 7, 60, 21, 420, 1260 ]
    gap&#62; tblG:= tblMG / nsg[2];;
    gap&#62; tblGA:= CharacterTable( "Cyclic", 3 ) * CharacterTable( "A5.2" );;
    gap&#62; GfusGA:= PossibleClassFusions( tblG, tblGA );
    [ [ 1, 2, 3, 4, 4, 8, 9, 10, 11, 11, 15, 16, 17, 18, 18 ],
      [ 1, 2, 3, 4, 4, 15, 16, 17, 18, 18, 8, 9, 10, 11, 11 ] ]
    gap&#62; reps:= RepresentativesFusions( Group(()), GfusGA, tblGA );
    [ [ 1, 2, 3, 4, 4, 8, 9, 10, 11, 11, 15, 16, 17, 18, 18 ] ]
    gap&#62; StoreFusion( tblG, reps[1], tblGA );
    gap&#62; acts:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );
    [ [ [ 1 ], [ 2 ], [ 3 ], [ 4, 5 ], [ 6, 11 ], [ 7, 12 ], [ 8, 13 ],
          [ 9, 15 ], [ 10, 14 ], [ 16 ], [ 17 ], [ 18 ], [ 19, 20 ], [ 21 ],
          [ 22 ], [ 23 ], [ 24, 25 ] ] ]
    gap&#62; poss:= PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA,
    &#62;               acts[1], "A12N7" );
    [ rec( MGfusMGA := [ 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 5, 6, 7, 9, 8, 10, 11, 12, 
              13, 13, 14, 15, 16, 17, 17 ], table := CharacterTable( "A12N7" ) ) ]

</pre>

<div class="p"><!----></div>
Let us compare the result table with the table of the Sylow 7 normalizer
in A<sub>12</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; g:= AlternatingGroup( 12 );;
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( poss[1].table,
    &#62;                CharacterTable( Normalizer( g, SylowSubgroup( g, 7 ) ) ) ) );
    true

</pre>

<div class="p"><!----></div>
Since July 2007,
an alternative way to construct the character table of N from other
character tables is to exploit its structure as a subdirect product
of index two in the group 7:6 &times;S<sub>5</sub>, see Section&nbsp;<a href="#theorsubdir">3.6</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; tblh1:= CharacterTable( "7:3" );;
    gap&#62; tblg1:= CharacterTable( "7:6" );;
    gap&#62; tblh2:= CharacterTable( "A5" );;
    gap&#62; tblg2:= CharacterTable( "A5.2" );;
    gap&#62; subdir:= CharacterTableOfIndexTwoSubdirectProduct( tblh1, tblg1,
    &#62;                 tblh2, tblg2, "(7:3xA5).2" );;
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( poss[1].table,
    &#62;                subdir.table ) );
    true

</pre>

<div class="p"><!----></div>
For storing the table of N in the <font face="helvetica">GAP</font> Character Table Library,
the construction as a subdirect product is more suitable,
since the "auxiliary table" of the direct product 7:3 &times;A<sub>5</sub>
need not be stored in the library.

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.3">
4.3</a>&nbsp;&nbsp; A<font size="-2">TLAS</font> Tables of the Type M.G.A</h3><a name="ATLASMGA">
</a>

<div class="p"><!----></div>
We show the construction of some character tables of groups of the type
M.G.A that are contained in the <font face="helvetica">GAP</font> Character Table Library.
Each entry in the following input list contains the names of the library
character tables of M.G, G, G.A, and M.G.A.

<div class="p"><!----></div>
First we consider the situation where G is a simple group or a central
extension of a simple group whose character table is shown in the  A<font size="-2">TLAS</font>,
and M and A are cyclic groups such that M is central in M.G.

<div class="p"><!----></div>
In the following cases,
the character tables are uniquely determined by the input tables.
Note that in each of these cases, &#124;A&#124; and &#124;M&#124; are coprime.

<div class="p"><!----></div>

<pre>
    gap&#62; listMGA:= [
    &#62; [ "3.A6",        "A6",        "A6.2_1",        "3.A6.2_1"       ],
    &#62; [ "3.A6",        "A6",        "A6.2_2",        "3.A6.2_2"       ],
    &#62; [ "6.A6",        "2.A6",      "2.A6.2_1",      "6.A6.2_1"       ],
    &#62; [ "6.A6",        "2.A6",      "2.A6.2_2",      "6.A6.2_2"       ],
    &#62; [ "3.A7",        "A7",        "A7.2",          "3.A7.2"         ],
    &#62; [ "6.A7",        "2.A7",      "2.A7.2",        "6.A7.2"         ],
    &#62; [ "3.L3(4)",     "L3(4)",     "L3(4).2_2",     "3.L3(4).2_2"    ],
    &#62; [ "3.L3(4)",     "L3(4)",     "L3(4).2_3",     "3.L3(4).2_3"    ],
    &#62; [ "6.L3(4)",     "2.L3(4)",   "2.L3(4).2_2",   "6.L3(4).2_2"    ],
    &#62; [ "6.L3(4)",     "2.L3(4)",   "2.L3(4).2_3",   "6.L3(4).2_3"    ],
    &#62; [ "12_1.L3(4)",  "4_1.L3(4)", "4_1.L3(4).2_2", "12_1.L3(4).2_2" ],
    &#62; [ "12_1.L3(4)",  "4_1.L3(4)", "4_1.L3(4).2_3", "12_1.L3(4).2_3" ],
    &#62; [ "12_2.L3(4)",  "4_2.L3(4)", "4_2.L3(4).2_2", "12_2.L3(4).2_2" ],
    &#62; [ "12_2.L3(4)",  "4_2.L3(4)", "4_2.L3(4).2_3", "12_2.L3(4).2_3" ],
    &#62; [ "3.U3(5)",     "U3(5)",     "U3(5).2",       "3.U3(5).2"      ],
    &#62; [ "3.M22",       "M22",       "M22.2",         "3.M22.2"        ],
    &#62; [ "6.M22",       "2.M22",     "2.M22.2",       "6.M22.2"        ],
    &#62; [ "12.M22",      "4.M22",     "4.M22.2",       "12.M22.2"       ],
    &#62; [ "3.L3(7)",     "L3(7)",     "L3(7).2",       "3.L3(7).2"      ],
    &#62; [ "3_1.U4(3)",   "U4(3)",     "U4(3).2_1",     "3_1.U4(3).2_1"  ],
    &#62; [ "3_1.U4(3)",   "U4(3)",     "U4(3).2_2'",    "3_1.U4(3).2_2'" ],
    &#62; [ "3_2.U4(3)",   "U4(3)",     "U4(3).2_1",     "3_2.U4(3).2_1"  ],
    &#62; [ "3_2.U4(3)",   "U4(3)",     "U4(3).2_3'",    "3_2.U4(3).2_3'" ],
    &#62; [ "6_1.U4(3)",   "2.U4(3)",   "2.U4(3).2_1",   "6_1.U4(3).2_1"  ],
    &#62; [ "6_1.U4(3)",   "2.U4(3)",   "2.U4(3).2_2'",  "6_1.U4(3).2_2'" ],
    &#62; [ "6_2.U4(3)",   "2.U4(3)",   "2.U4(3).2_1",   "6_2.U4(3).2_1"  ],
    &#62; [ "6_2.U4(3)",   "2.U4(3)",   "2.U4(3).2_3'",  "6_2.U4(3).2_3'" ],
    &#62; [ "12_1.U4(3)",  "4.U4(3)",   "4.U4(3).2_1",   "12_1.U4(3).2_1" ],
    &#62; [ "12_2.U4(3)",  "4.U4(3)",   "4.U4(3).2_1",   "12_2.U4(3).2_1" ],
    &#62; [ "3.G2(3)",     "G2(3)",     "G2(3).2",       "3.G2(3).2"      ],
    &#62; [ "3.U3(8)",     "U3(8)",     "U3(8).2",       "3.U3(8).2"      ],
    &#62; [ "3.U3(8).3_1", "U3(8).3_1", "U3(8).6",       "3.U3(8).6"      ],
    &#62; [ "3.J3",        "J3",        "J3.2",          "3.J3.2"         ],
    &#62; [ "3.U3(11)",    "U3(11)",    "U3(11).2",      "3.U3(11).2"     ],
    &#62; [ "3.McL",       "McL",       "McL.2",         "3.McL.2"        ],
    &#62; [ "3.O7(3)",     "O7(3)",     "O7(3).2",       "3.O7(3).2"      ],
    &#62; [ "6.O7(3)",     "2.O7(3)",   "2.O7(3).2",     "6.O7(3).2"      ],
    &#62; [ "3.U6(2)",     "U6(2)",     "U6(2).2",       "3.U6(2).2"      ],
    &#62; [ "6.U6(2)",     "2.U6(2)",   "2.U6(2).2",     "6.U6(2).2"      ],
    &#62; [ "3.Suz",       "Suz",       "Suz.2",         "3.Suz.2"        ],
    &#62; [ "6.Suz",       "2.Suz",     "2.Suz.2",       "6.Suz.2"        ],
    &#62; [ "3.ON",        "ON",        "ON.2",          "3.ON.2"         ],
    &#62; [ "3.Fi22",      "Fi22",      "Fi22.2",        "3.Fi22.2"       ],
    &#62; [ "6.Fi22",      "2.Fi22",    "2.Fi22.2",      "6.Fi22.2"       ],
    &#62; [ "3.2E6(2)",    "2E6(2)",    "2E6(2).2",      "3.2E6(2).2"     ],
    &#62; [ "6.2E6(2)",    "2.2E6(2)",  "2.2E6(2).2",    "6.2E6(2).2"     ],
    &#62; [ "3.F3+",       "F3+",       "F3+.2",         "3.F3+.2"        ],
    &#62; ];;

</pre>

<div class="p"><!----></div>
Note that the groups of the types 12<sub>1</sub>.L<sub>3</sub>(4).2<sub>1</sub> and 12<sub>2</sub>.L<sub>3</sub>(4).2<sub>1</sub>
have central subgroups of order six, so we cannot choose G equal to
4<sub>1</sub>.L<sub>3</sub>(4) and 4<sub>2</sub>.L<sub>3</sub>(4), respectively, in these cases.
See Section&nbsp;<a href="#MoreATLASMGA">4.4</a> for the construction of these tables.

<div class="p"><!----></div>
Also in the following cases, &#124;A&#124; and &#124;M&#124; are coprime,
we have &#124;M&#124; = 3 and &#124;A&#124; = 2.
The group M.G has a central subgroup of the type 2<sup>2</sup> &times;3,
and A acts on this group by inverting the elements in the subgroup
of order 3 and by swapping two involutions in the Klein four group.

<div class="p"><!----></div>

<pre>
    gap&#62; Append( listMGA, [
    &#62; [ "(2^2x3).L3(4)",  "2^2.L3(4)",   "2^2.L3(4).2_2", "(2^2x3).L3(4).2_2" ],
    &#62; [ "(2^2x3).L3(4)",  "2^2.L3(4)",   "2^2.L3(4).2_3", "(2^2x3).L3(4).2_3" ],
    &#62; [ "(2^2x3).U6(2)",  "2^2.U6(2)",   "2^2.U6(2).2",   "(2^2x3).U6(2).2"   ],
    &#62; [ "(2^2x3).2E6(2)", "2^2.2E6(2)",  "2^2.2E6(2).2",  "(2^2x3).2E6(2).2"  ],
    &#62; ] );

</pre>

<div class="p"><!----></div>
Additionally, there are a few cases where A has order two,
and G.A has a factor group of the type 2<sup>2</sup>,<a name="3.A_6.2^2etc">
</a>
and a few cases where M has the type 2<sup>2</sup> and A is of order three
and acts transitively on the involutions in M.

<div class="p"><!----></div>

<pre>
    gap&#62; Append( listMGA, [
    &#62; [ "3.A6.2_3",       "A6.2_3",    "A6.2^2",      "3.A6.2^2"          ],
    &#62; [ "3.L3(4).2_1",    "L3(4).2_1", "L3(4).2^2",   "3.L3(4).2^2"       ],
    &#62; [ "3_1.U4(3).2_2",  "U4(3).2_2", "U4(3).(2^2)_{122}",
    &#62;                                             "3_1.U4(3).(2^2)_{122}" ],
    &#62; [ "3_2.U4(3).2_3",  "U4(3).2_3", "U4(3).(2^2)_{133}",
    &#62;                                             "3_2.U4(3).(2^2)_{133}" ],
    &#62; [ "3^2.U4(3).2_3'", "3_2.U4(3).2_3'", "3_2.U4(3).(2^2)_{133}",
    &#62;                                             "3^2.U4(3).(2^2)_{133}" ],
    &#62; [ "2^2.L3(4)",      "L3(4)",     "L3(4).3",     "2^2.L3(4).3"       ],
    &#62; [ "(2^2x3).L3(4)",  "3.L3(4)",   "3.L3(4).3",   "(2^2x3).L3(4).3"   ],
    &#62; [ "2^2.L3(4).2_1",  "L3(4).2_1", "L3(4).6",     "2^2.L3(4).6"       ],
    &#62; [ "2^2.Sz(8)",      "Sz(8)",     "Sz(8).3",     "2^2.Sz(8).3"       ],
    &#62; [ "2^2.U6(2)",      "U6(2)",     "U6(2).3",     "2^2.U6(2).3"       ],
    &#62; [ "(2^2x3).U6(2)",  "3.U6(2)",   "3.U6(2).3",   "(2^2x3).U6(2).3"   ],
    &#62; [ "2^2.O8+(2)",     "O8+(2)",    "O8+(2).3",    "2^2.O8+(2).3"      ],
    &#62; [ "2^2.O8+(3)",     "O8+(3)",    "O8+(3).3",    "2^2.O8+(3).3"      ],
    &#62; [ "2^2.2E6(2)",     "2E6(2)",    "2E6(2).3",    "2^2.2E6(2).3"      ],
    &#62; ] );

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
The constructions of the character tables of groups of the types
4<sub>2</sub>.L<sub>3</sub>(4).2<sub>3</sub> and 12<sub>2</sub>.L<sub>3</sub>(4).2<sub>3</sub>
is described in Section&nbsp;<a href="#4_2.L_3(4).2_3">4.5</a>,
in these cases the <font face="helvetica">GAP</font> functions return several possible tables.

<div class="p"><!----></div>
The construction of the various character table of groups of the types
4<sub>1</sub>.L<sub>3</sub>(4).2<sup>2</sup> and 4<sub>2</sub>.L<sub>3</sub>(4).2<sup>2</sup> are described in Section&nbsp;<a href="#41L34V4">6.7</a>.

<div class="p"><!----></div>
The following function takes the ordinary character tables of the groups
M.G, G, and G.A, a string to be used as the <tt>Identifier</tt> value of the
character table of M.G.A, and the character table of M.G.A that is
contained in the <font face="helvetica">GAP</font> Character Table Library;
the function first computes the possible actions of G.A on the classes of
M.G, using the function <tt>PossibleActionsForTypeMGA</tt>,
then computes the union of possible character tables for these actions,
and then representatives up to permutation equivalence;
if there is only one solution then the result table is compared with the
library table.

<div class="p"><!----></div>

<pre>
    gap&#62; ConstructOrdinaryMGATable:= function( tblMG, tblG, tblGA, name, lib )
    &#62;      local acts, poss, trans;
    &#62; 
    &#62;      acts:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );
    &#62;      poss:= Concatenation( List( acts, pi -&#62;
    &#62;                 PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, pi,
    &#62;                     name ) ) );
    &#62;      poss:= RepresentativesCharacterTables( poss );
    &#62;      if Length( poss ) = 1 then
    &#62;        # Compare the computed table with the library table.
    &#62;        if not IsCharacterTable( lib ) then
    &#62;          List( poss, x -&#62; AutomorphismsOfTable( x.table ) );
    &#62;          Print( "#I  no library table for ", name, "\n" );
    &#62;        else
    &#62;          trans:= TransformingPermutationsCharacterTables( poss[1].table,
    &#62;                      lib );
    &#62;          if not IsRecord( trans ) then
    &#62;            Print( "#E  computed table and library table for ", name,
    &#62;                   " differ\n" );
    &#62;          fi;
    &#62;          # Compare the computed fusion with the stored one.
    &#62;          if OnTuples( poss[1].MGfusMGA, trans.columns )
    &#62;                 &lt;&#62; GetFusionMap( tblMG, lib ) then
    &#62;            Print( "#E  computed and stored fusion for ", name,
    &#62;                   " differ\n" );
    &#62;          fi;
    &#62;        fi;
    &#62;      elif Length( poss ) = 0 then
    &#62;        Print( "#E  no solution for ", name, "\n" );
    &#62;      else
    &#62;        Print( "#E  ", Length( poss ), " possibilities for ", name, "\n" );
    &#62;      fi;
    &#62;      return poss;
    &#62;    end;;

</pre>

<div class="p"><!----></div>
The following function takes the ordinary character tables of the groups
M.G, G.A, and M.G.A,
and tries to construct the p-modular character tables of M.G.A from the
p-modular character tables of the first two of these tables,
for all prime divisors p of the order of M.G.A.
Note that the tables of G are not needed in the construction,
only the class fusions from M.G to M.G.A and from M.G.A to G.A
must be stored.

<div class="p"><!----></div>

<pre>
    gap&#62; ConstructModularMGATables:= function( tblMG, tblGA, ordtblMGA )
    &#62;    local name, poss, p, modtblMG, modtblGA, modtblMGA, modlib, trans;
    &#62; 
    &#62;    name:= Identifier( ordtblMGA );
    &#62;    poss:= [];
    &#62;    for p in Set( Factors( Size( ordtblMGA ) ) ) do
    &#62;      modtblMG := tblMG mod p;
    &#62;      modtblGA := tblGA mod p;
    &#62;      if ForAll( [ modtblMG, modtblGA ], IsCharacterTable ) then
    &#62;        modtblMGA:= BrauerTableOfTypeMGA( modtblMG, modtblGA, ordtblMGA );
    &#62;        Add( poss, modtblMGA );
    &#62;        modlib:= ordtblMGA mod p;
    &#62;        if IsCharacterTable( modlib ) then
    &#62;          trans:= TransformingPermutationsCharacterTables( modtblMGA.table,
    &#62;                      modlib );
    &#62;          if not IsRecord( trans ) then
    &#62;            Print( "#E  computed table and library table for ", name,
    &#62;                   " mod ", p, " differ\n" );
    &#62;          fi;
    &#62;        else
    &#62;          AutomorphismsOfTable( modtblMGA.table );
    &#62;          Print( "#I  no library table for ", name, " mod ", p, "\n" );
    &#62;        fi;
    &#62;      else
    &#62;        Print( "#I  not all input tables for ", name, " mod ", p,
    &#62;               " available\n" );
    &#62;      fi;
    &#62;    od;
    &#62; 
    &#62;    return poss;
    &#62;    end;;

</pre>

<div class="p"><!----></div>
Now we run the constructions for the cases in the list.
Note that in order to avoid conflicts of the class fusions that arise in
the construction with the class fusions that are already stored on the
library tables, we choose identifiers for the result tables that are
different from the identifiers of the library tables.

<div class="p"><!----></div>

<pre>
    gap&#62; for  input in listMGA do
    &#62;      tblMG := CharacterTable( input[1] );
    &#62;      tblG  := CharacterTable( input[2] );
    &#62;      tblGA := CharacterTable( input[3] );
    &#62;      name  := Concatenation( "new", input[4] );
    &#62;      lib   := CharacterTable( input[4] );
    &#62;      poss:= ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );
    &#62;      if 1 &lt;&#62; Length( poss ) then
    &#62;        Print( "#I  ", Length( poss ), " possibilities for ", name, "\n" );
    &#62;      elif lib = fail then
    &#62;        Print( "#I  no library table for ", input[4], "\n" );
    &#62;      else
    &#62;        ConstructModularMGATables( tblMG, tblGA, lib );
    &#62;      fi;
    &#62;    od;
    #I  not all input tables for 6.Suz.2 mod 13 available
    #I  not all input tables for 3.ON.2 mod 3 available
    #I  not all input tables for 3.2E6(2).2 mod 2 available
    #I  not all input tables for 3.2E6(2).2 mod 3 available
    #I  not all input tables for 3.2E6(2).2 mod 5 available
    #I  not all input tables for 3.2E6(2).2 mod 7 available
    #I  not all input tables for 3.2E6(2).2 mod 11 available
    #I  not all input tables for 3.2E6(2).2 mod 13 available
    #I  not all input tables for 3.2E6(2).2 mod 17 available
    #I  not all input tables for 3.2E6(2).2 mod 19 available
    #I  not all input tables for 6.2E6(2).2 mod 2 available
    #I  not all input tables for 6.2E6(2).2 mod 3 available
    #I  not all input tables for 6.2E6(2).2 mod 5 available
    #I  not all input tables for 6.2E6(2).2 mod 7 available
    #I  not all input tables for 6.2E6(2).2 mod 11 available
    #I  not all input tables for 6.2E6(2).2 mod 13 available
    #I  not all input tables for 6.2E6(2).2 mod 17 available
    #I  not all input tables for 6.2E6(2).2 mod 19 available
    #I  not all input tables for 3.F3+.2 mod 2 available
    #I  not all input tables for 3.F3+.2 mod 3 available
    #I  not all input tables for 3.F3+.2 mod 5 available
    #I  not all input tables for 3.F3+.2 mod 7 available
    #I  not all input tables for 3.F3+.2 mod 13 available
    #I  not all input tables for 3.F3+.2 mod 17 available
    #I  not all input tables for 3.F3+.2 mod 29 available
    #I  not all input tables for (2^2x3).2E6(2).2 mod 2 available
    #I  not all input tables for (2^2x3).2E6(2).2 mod 3 available
    #I  not all input tables for (2^2x3).2E6(2).2 mod 5 available
    #I  not all input tables for (2^2x3).2E6(2).2 mod 7 available
    #I  not all input tables for (2^2x3).2E6(2).2 mod 11 available
    #I  not all input tables for (2^2x3).2E6(2).2 mod 13 available
    #I  not all input tables for (2^2x3).2E6(2).2 mod 17 available
    #I  not all input tables for (2^2x3).2E6(2).2 mod 19 available
    #I  not all input tables for 3^2.U4(3).(2^2)_{133} mod 2 available
    #I  not all input tables for 3^2.U4(3).(2^2)_{133} mod 5 available
    #I  not all input tables for 3^2.U4(3).(2^2)_{133} mod 7 available
    #I  not all input tables for 2^2.O8+(3).3 mod 3 available
    #I  not all input tables for 2^2.O8+(3).3 mod 5 available
    #I  not all input tables for 2^2.O8+(3).3 mod 7 available
    #I  not all input tables for 2^2.O8+(3).3 mod 13 available
    #I  not all input tables for 2^2.2E6(2).3 mod 2 available
    #I  not all input tables for 2^2.2E6(2).3 mod 3 available
    #I  not all input tables for 2^2.2E6(2).3 mod 5 available
    #I  not all input tables for 2^2.2E6(2).3 mod 7 available
    #I  not all input tables for 2^2.2E6(2).3 mod 11 available
    #I  not all input tables for 2^2.2E6(2).3 mod 13 available
    #I  not all input tables for 2^2.2E6(2).3 mod 17 available
    #I  not all input tables for 2^2.2E6(2).3 mod 19 available

</pre>

<div class="p"><!----></div>
We do not get any unexpected output, so the character tables in question are
determined by the inputs.

<div class="p"><!----></div>
Alternative constructions of the character tables of 3.A<sub>6</sub>.2<sup>2</sup>,
3.L<sub>3</sub>(4).2<sup>2</sup>, and 3<sub>2</sub>.U<sub>4</sub>(3).(2<sup>2</sup>)<sub>133</sub> can be found
in Section&nbsp;<a href="#xplGV43.A6.V4">6.2</a>.

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.4">
4.4</a>&nbsp;&nbsp;More  A<font size="-2">TLAS</font> Tables of the Type M.G.A</h3><a name="MoreATLASMGA">
</a>

<div class="p"><!----></div>
In the following situations, we have &#124;A&#124; = 2,
and &#124;M&#124; is a multiple of 2.
The result turns out to be unique up to isoclinism,
see Section&nbsp;<a href="#theorMGA">3.1</a>.

<div class="p"><!----></div>
First, there are some cases where the centre of M.G is a cyclic group of
order four, and &#124;M&#124; = 2 holds.

<div class="p"><!----></div>

<pre>
    gap&#62; listMGA2:= [
    &#62; [ "4_1.L3(4)",  "2.L3(4)",   "2.L3(4).2_1",   "4_1.L3(4).2_1"  ],
    &#62; [ "4_1.L3(4)",  "2.L3(4)",   "2.L3(4).2_2",   "4_1.L3(4).2_2"  ],
    &#62; [ "4_2.L3(4)",  "2.L3(4)",   "2.L3(4).2_1",   "4_2.L3(4).2_1"  ],
    &#62; [ "4.M22",      "2.M22",     "2.M22.2",       "4.M22.2"        ],
    &#62; [ "4.U4(3)",    "2.U4(3)",   "2.U4(3).2_2",   "4.U4(3).2_2"    ],
    &#62; [ "4.U4(3)",    "2.U4(3)",   "2.U4(3).2_3",   "4.U4(3).2_3"    ],
    &#62; ];;

</pre>

<div class="p"><!----></div>
Note that the groups 4<sub>1</sub>.L3(4).2<sub>3</sub> and 4<sub>2</sub>.L3(4).2<sub>2</sub> and their
isoclinic variants have centres of order four, so they do not appear here.
The construction of the character table of 4<sub>2</sub>.L<sub>3</sub>(4).2<sub>3</sub> is more
involved, it is described in Section&nbsp;<a href="#4_2.L_3(4).2_3">4.5</a>.

<div class="p"><!----></div>
Also in the following cases, we have &#124;M&#124; = 2,
but the situation is different because M.G has a central subgroup of
the type 2<sup>2</sup> containing a unique subgroup of order 2 that is central
in M.G.A.

<div class="p"><!----></div>

<pre>
    gap&#62; Append( listMGA2, [
    &#62; [ "2^2.L3(4)",     "2.L3(4)",     "2.L3(4).2_2",         "2^2.L3(4).2_2" ],
    &#62; [ "2^2.L3(4)",     "2.L3(4)",     "2.L3(4).2_3",         "2^2.L3(4).2_3" ],
    &#62; [ "2^2.L3(4).2_1", "2.L3(4).2_1", "2.L3(4).(2^2)_{123}", "2^2.L3(4).2^2" ],
    &#62; [ "2^2.O8+(2)",    "2.O8+(2)",    "2.O8+(2).2",          "2^2.O8+(2).2"  ],
    &#62; [ "2^2.U6(2)",     "2.U6(2)",     "2.U6(2).2",           "2^2.U6(2).2"   ],
    &#62; [ "2^2.2E6(2)",    "2.2E6(2)",    "2.2E6(2).2",          "2^2.2E6(2).2"  ],
    &#62; ] );

</pre>

<div class="p"><!----></div>
Next there are two constructions for G = 6.L<sub>3</sub>(4),
with &#124;M&#124; = 12 and &#124;A&#124; = 2.
Note that the groups 12<sub>1</sub>.L3(4).2<sub>1</sub> and 12<sub>2</sub>.L3(4).2<sub>1</sub> have central
subgroups of the order six, so we cannot use the factor groups
4<sub>1</sub>.L3(4).2<sub>1</sub> and 4<sub>2</sub>.L3(4).2<sub>1</sub>, respectively, for the constructions.

<div class="p"><!----></div>

<pre>
    gap&#62; Append( listMGA2, [
    &#62; [ "12_1.L3(4)", "6.L3(4)", "6.L3(4).2_1", "12_1.L3(4).2_1" ],
    &#62; [ "12_2.L3(4)", "6.L3(4)", "6.L3(4).2_1", "12_2.L3(4).2_1" ],
    &#62; ] );

</pre>

<div class="p"><!----></div>
Next there are alternative constructions for tables which have been
constructed in Section&nbsp;<a href="#ATLASMGA">4.3</a>.
There we had viewed the groups of the structure 12.S.2,
for a simple group S, as 3.G.2 with G = 4.S.
Here we view these groups as 2.G.2 with G = 6.S,
which means that we do not prescribe the 4.S.2 type factor group.
So it is not surprising that we get more than one solution,
and that the computation of the 2-power map of 12.S.2 is more
involved.
Note that the construction of the character table of 12<sub>2</sub>.L<sub>3</sub>(4).2<sub>3</sub>
is more involved, it is described in Section&nbsp;<a href="#4_2.L_3(4).2_3">4.5</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; Append( listMGA2, [
    &#62; [ "12.M22",     "6.M22",     "6.M22.2",       "12.M22.2"       ],
    &#62; [ "12_1.L3(4)", "6.L3(4)",   "6.L3(4).2_2",   "12_1.L3(4).2_2" ],
    &#62; [ "12_1.U4(3)", "6_1.U4(3)", "6_1.U4(3).2_2", "12_1.U4(3).2_2" ],
    &#62; [ "12_2.U4(3)", "6_2.U4(3)", "6_2.U4(3).2_3", "12_2.U4(3).2_3" ],
    &#62; ] );

</pre>

<div class="p"><!----></div>
Finally, there are alternative constructions for the cases where
the group M.G has a central subgroup of the type 2<sup>2</sup> &times;3,
and A acts on this group by inverting the elements in the subgroup
of order 3 and by swapping two involutions in the Klein four group.

<div class="p"><!----></div>

<pre>
    gap&#62; Append( listMGA2, [
    &#62; [ "(2^2x3).L3(4)",  "6.L3(4)",   "6.L3(4).2_2", "(2^2x3).L3(4).2_2" ],
    &#62; [ "(2^2x3).L3(4)",  "6.L3(4)",   "6.L3(4).2_3", "(2^2x3).L3(4).2_3" ],
    &#62; [ "(2^2x3).U6(2)",  "6.U6(2)",   "6.U6(2).2",   "(2^2x3).U6(2).2"   ],
    &#62; [ "(2^2x3).2E6(2)", "6.2E6(2)",  "6.2E6(2).2",  "(2^2x3).2E6(2).2"  ],
    &#62; ] );

</pre>

<div class="p"><!----></div>
Now we run the constructions for the cases in the list.

<div class="p"><!----></div>

<pre>
    gap&#62; for  input in listMGA2 do
    &#62;      tblMG := CharacterTable( input[1] );
    &#62;      tblG  := CharacterTable( input[2] );
    &#62;      tblGA := CharacterTable( input[3] );
    &#62;      name  := Concatenation( "new", input[4] );
    &#62;      lib   := CharacterTable( input[4] );
    &#62;      poss:= ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );
    &#62;      if Length( poss ) = 2 then
    &#62;        iso:= CharacterTableIsoclinic( poss[1].table );
    &#62;        if IsRecord( TransformingPermutationsCharacterTables( poss[2].table,
    &#62;                         iso ) ) then
    &#62;          Unbind( poss[2] );
    &#62;        fi;
    &#62;      elif Length( poss ) = 1 then
    &#62;        Print( "#I  unique up to permutation equivalence: ", name, "\n" );
    &#62;      fi;
    &#62;      if 1 &lt;&#62; Length( poss ) then
    &#62;        Print( "#I  ", Length( poss ), " possibilities for ", name, "\n" );
    &#62;      elif lib = fail then
    &#62;        Print( "#I  no library table for ", input[4], "\n" );
    &#62;      else
    &#62;        ConstructModularMGATables( tblMG, tblGA, lib );
    &#62;      fi;
    &#62;    od;
    #E  2 possibilities for new4_1.L3(4).2_1
    #E  2 possibilities for new4_1.L3(4).2_2
    #E  2 possibilities for new4_2.L3(4).2_1
    #E  2 possibilities for new4.M22.2
    #E  2 possibilities for new4.U4(3).2_2
    #E  2 possibilities for new4.U4(3).2_3
    #I  unique up to permutation equivalence: new2^2.L3(4).2_2
    #I  unique up to permutation equivalence: new2^2.L3(4).2_3
    #I  unique up to permutation equivalence: new2^2.L3(4).2^2
    #I  unique up to permutation equivalence: new2^2.O8+(2).2
    #I  unique up to permutation equivalence: new2^2.U6(2).2
    #I  unique up to permutation equivalence: new2^2.2E6(2).2
    #I  not all input tables for 2^2.2E6(2).2 mod 2 available
    #I  not all input tables for 2^2.2E6(2).2 mod 3 available
    #I  not all input tables for 2^2.2E6(2).2 mod 5 available
    #I  not all input tables for 2^2.2E6(2).2 mod 7 available
    #E  2 possibilities for new12_1.L3(4).2_1
    #E  2 possibilities for new12_2.L3(4).2_1
    #E  2 possibilities for new12.M22.2
    #E  2 possibilities for new12_1.L3(4).2_2
    #E  2 possibilities for new12_1.U4(3).2_2
    #E  2 possibilities for new12_2.U4(3).2_3
    #I  unique up to permutation equivalence: new(2^2x3).L3(4).2_2
    #I  unique up to permutation equivalence: new(2^2x3).L3(4).2_3
    #I  unique up to permutation equivalence: new(2^2x3).U6(2).2
    #I  unique up to permutation equivalence: new(2^2x3).2E6(2).2
    #I  not all input tables for (2^2x3).2E6(2).2 mod 2 available
    #I  not all input tables for (2^2x3).2E6(2).2 mod 3 available
    #I  not all input tables for (2^2x3).2E6(2).2 mod 5 available
    #I  not all input tables for (2^2x3).2E6(2).2 mod 7 available
    #I  not all input tables for (2^2x3).2E6(2).2 mod 11 available
    #I  not all input tables for (2^2x3).2E6(2).2 mod 13 available
    #I  not all input tables for (2^2x3).2E6(2).2 mod 17 available
    #I  not all input tables for (2^2x3).2E6(2).2 mod 19 available

</pre>

<div class="p"><!----></div>
Again,
we do not get any unexpected output, so the character tables in question are
determined up to isoclinism by the inputs.

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.5">
4.5</a>&nbsp;&nbsp;The Character Tables of 4<sub>2</sub>.L<sub>3</sub>(4).2<sub>3</sub> and 12<sub>2</sub>.L<sub>3</sub>(4).2<sub>3</sub></h3><a name="4_2.L_3(4).2_3">
</a>

<div class="p"><!----></div>
In the construction of the character table of M.G.A = 4<sub>2</sub>.L<sub>3</sub>(4).2<sub>3</sub>
from the tables of M.G = 4<sub>2</sub>.L<sub>3</sub>(4) and G.A = 2.L<sub>3</sub>(4).2<sub>3</sub>,
the action of A on the classes of M.G is uniquely determined,
but we get four possible character tables.

<div class="p"><!----></div>

<pre>
    gap&#62; tblMG := CharacterTable( "4_2.L3(4)" );;
    gap&#62; tblG  := CharacterTable( "2.L3(4)" );;
    gap&#62; tblGA := CharacterTable( "2.L3(4).2_3" );;
    gap&#62; name  := "new4_2.L3(4).2_3";;
    gap&#62; lib   := CharacterTable( "4_2.L3(4).2_3" );;
    gap&#62; poss  := ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );
    #E  4 possibilities for new4_2.L3(4).2_3
    [ rec( MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 7, 9, 10, 11, 10, 12, 12, 13, 
              14, 15, 14, 16, 17, 18, 17, 19, 20, 21, 22, 19, 22, 21, 20 ], 
          table := CharacterTable( "new4_2.L3(4).2_3" ) ), 
      rec( MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 7, 9, 10, 11, 10, 12, 12, 13, 
              14, 15, 14, 16, 17, 18, 17, 19, 20, 21, 22, 19, 22, 21, 20 ], 
          table := CharacterTable( "new4_2.L3(4).2_3" ) ), 
      rec( MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 7, 9, 10, 11, 10, 12, 12, 13, 
              14, 15, 14, 16, 17, 18, 17, 19, 20, 21, 22, 19, 22, 21, 20 ], 
          table := CharacterTable( "new4_2.L3(4).2_3" ) ), 
      rec( MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 7, 9, 10, 11, 10, 12, 12, 13, 
              14, 15, 14, 16, 17, 18, 17, 19, 20, 21, 22, 19, 22, 21, 20 ], 
          table := CharacterTable( "new4_2.L3(4).2_3" ) ) ]

</pre>

<div class="p"><!----></div>
The centre of 4<sub>2</sub>.L<sub>3</sub>(4) is inverted by the action of the outer
automorphism, so the existence of <em>two</em> possible tables can be expected
because two isoclinic groups of the type 4<sub>2</sub>.L<sub>3</sub>(4).2<sub>3</sub> exist,
see Section&nbsp;<a href="#isoclinicATLAS">2.5</a>.

<div class="p"><!----></div>
Indeed the result consists of two pairs of isoclinic tables,
so we have to decide which pair of tables belongs to the groups of the
type 4<sub>2</sub>.L<sub>3</sub>(4).2<sub>3</sub>.

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( poss[1].table,
    &#62;                  CharacterTableIsoclinic( poss[4].table ) ) );
    true
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( poss[2].table,
    &#62;                  CharacterTableIsoclinic( poss[3].table ) ) );
    true

</pre>

<div class="p"><!----></div>
The possible tables differ only w.r.t.&nbsp;the 2-power map and perhaps the
element orders.
The  A<font size="-2">TLAS</font> prints the table of the split extension of M.G,
this table is one of the first two possibilities.

<div class="p"><!----></div>

<pre>
    gap&#62; List( poss, x -&#62; PowerMap( x.table, 2 ) );
    [ [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 21, 19, 
          21, 1, 1, 6, 6, 9, 9, 11, 11, 16, 16, 13, 13 ], 
      [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 21, 19, 
          21, 1, 1, 6, 6, 11, 11, 9, 9, 16, 16, 13, 13 ], 
      [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 21, 19, 
          21, 3, 3, 8, 8, 9, 9, 11, 11, 18, 18, 15, 15 ], 
      [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 21, 19, 
          21, 3, 3, 8, 8, 11, 11, 9, 9, 18, 18, 15, 15 ] ]

</pre>

<div class="p"><!----></div>
The 2-power map is not determined by the irreducible characters
(and by the 2-power map of the factor group 2.L<sub>3</sub>(4).2<sub>3</sub>).
We determine this map using the embedding of 4<sub>2</sub>.L<sub>3</sub>(4).2<sub>3</sub> into
4.U<sub>4</sub>(3).2<sub>3</sub>.
Note that L<sub>3</sub>(4).2<sub>3</sub> is a maximal subgroup of U<sub>4</sub>(3).2<sub>3</sub>
(see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;52]), and that the subgroup L<sub>3</sub>(4) of U<sub>4</sub>(3) lifts
to 4<sub>2</sub>.L<sub>3</sub>(4) in 4.U<sub>4</sub>(3) because no embedding of L<sub>3</sub>(4), 2.L<sub>3</sub>(4),
or 4<sub>1</sub>.L<sub>3</sub>(4) into 4.U<sub>4</sub>(3) is possible.

<div class="p"><!----></div>

<pre>
    gap&#62; PossiblePowerMaps( poss[1].table, 2 );
    [ [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 21, 19, 
          21, 1, 1, 6, 6, 11, 11, 9, 9, 16, 16, 13, 13 ], 
      [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 21, 19, 
          21, 1, 1, 6, 6, 9, 9, 11, 11, 16, 16, 13, 13 ] ]
    gap&#62; t:= CharacterTable( "4.U4(3)" );;
    gap&#62; List( [ "L3(4)", "2.L3(4)", "4_1.L3(4)", "4_2.L3(4)" ], name -&#62;
    &#62;          Length( PossibleClassFusions( CharacterTable( name ), t ) ) );
    [ 0, 0, 0, 4 ]

</pre>

<div class="p"><!----></div>
So the split extension 4<sub>2</sub>.L<sub>3</sub>(4).2<sub>3</sub> of 4<sub>2</sub>.L<sub>3</sub>(4) is a subgroup of
the split extension 4.U<sub>4</sub>(3).2<sub>3</sub> of 4.U<sub>4</sub>(3),
and only one of the two possible tables of 4<sub>2</sub>.L<sub>3</sub>(4).2<sub>3</sub> admits a
class fusion into the  A<font size="-2">TLAS</font> table of 4.U<sub>3</sub>(4).2<sub>3</sub>;
the construction of the latter table is shown in Section&nbsp;<a href="#ATLASMGA">4.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; t2:= CharacterTable( "4.U4(3).2_3" );;
    gap&#62; List( poss, x -&#62; Length( PossibleClassFusions( x.table, t2 ) ) );
    [ 0, 16, 0, 0 ]

</pre>

<div class="p"><!----></div>
I do not know a character theoretic argument that would disprove the
existence of a group whose character table is the other candidate (or its
isoclinic variant).
For example, the table passes the tests from Section&nbsp;<a href="#pseudo">4.12</a>.

<div class="p"><!----></div>
(It is straightforward to compute all extensions of 4<sub>2</sub>.L<sub>3</sub>(4) by an
automorphism of order two.  The extensions with 34 conjugacy classes
belong to the second candidate and its isoclinic variant.)

<div class="p"><!----></div>

<div class="p"><!----></div>
The correct table is the one that is contained in the <font face="helvetica">GAP</font> Character
Table Library.

<div class="p"><!----></div>

<pre>
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( poss[2].table,
    &#62;                  lib ) );
    true
    gap&#62; ConstructModularMGATables( tblMG, tblGA, lib );;

</pre>

<div class="p"><!----></div>
In the construction of the character table of 12<sub>2</sub>.L<sub>3</sub>(4).2<sub>3</sub>,
the same ambiguity arises.
We resolve it using the fact that 4<sub>2</sub>.L<sub>3</sub>(4).2<sub>3</sub> occurs as a factor
group, modulo the unique normal subgroup of order three.

<div class="p"><!----></div>

<pre>
    gap&#62; tblMG := CharacterTable( "12_2.L3(4)" );;
    gap&#62; tblG  := CharacterTable( "6.L3(4)" );;
    gap&#62; tblGA := CharacterTable( "6.L3(4).2_3" );;
    gap&#62; name  := "new12_2.L3(4).2_3";;
    gap&#62; lib   := CharacterTable( "12_2.L3(4).2_3" );;
    gap&#62; poss  := ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );;
    #E  4 possibilities for new12_2.L3(4).2_3
    gap&#62; Length( poss );
    4
    gap&#62; nsg:= ClassPositionsOfNormalSubgroups( poss[1].table );
    [ [ 1 ], [ 1, 5 ], [ 1, 7 ], [ 1, 4 .. 7 ], [ 1, 3 .. 7 ], [ 1 .. 7 ], 
      [ 1 .. 50 ], [ 1 .. 62 ] ]
    gap&#62; List( nsg, x -&#62; Sum( SizesConjugacyClasses( poss[1].table ){ x } ) );
    [ 1, 3, 2, 4, 6, 12, 241920, 483840 ]
    gap&#62; factlib:= CharacterTable( "4_2.L3(4).2_3" );;
    gap&#62; List( poss, x -&#62; IsRecord( TransformingPermutationsCharacterTables(
    &#62;                         x.table / [ 1, 5 ], factlib ) ) );
    [ false, true, false, false ]
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( poss[2].table,
    &#62;                  lib ) );
    true
    gap&#62; ConstructModularMGATables( tblMG, tblGA, lib );;

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.6">
4.6</a>&nbsp;&nbsp;The Character Table of (2<sup>2</sup> &times;F<sub>4</sub>(2)):2  &lt;  B
(March&nbsp;2003)</h3><a name="BM6">
</a>

<div class="p"><!----></div>
  <table><tr><td width="65%"> 
The sporadic simple group B contains a maximal subgroup [&#63717;N]
of type (2<sup>2</sup> &times;F<sub>4</sub>(2)):2, which is the normalizer of a <tt>2C</tt>
element [&#63717;x] in B (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;217]).

<div class="p"><!----></div>
We will see below that the normal Klein four group V in [&#63717;N]
contains two <tt>2A</tt> elements in B.
The <tt>2A</tt> centralizer in B, a group of the structure 2.<sup>2</sup>E<sub>6</sub>(2).2,
contains maximal subgroups of the type 2<sup>2</sup> &times;F<sub>4</sub>(2).
So the two <tt>2A</tt> type subgroups C<sub>1</sub>, C<sub>2</sub> in V are conjugate
in [&#63717;N],
and Z = &#9001;x &#9002; is the centre of [&#63717;N].

  </td><td width="35%"> 

<center>
 <img src="ctblcons11.png" alt="ctblcons11.png" />

</center>

  </td></tr></table> 

<div class="p"><!----></div>
We start with computing the class fusion of the 2<sup>2</sup> &times;F<sub>4</sub>(2) type
subgroup U of [&#63717;N] into B;
in order to speed this up, we first compute the class fusion of the F<sub>4</sub>(2)
subgroup of U into B (which is unique),
and use it and the stored embedding into U for prescribing an approximation
of the desired class fusion.
Additionally, we prescribe (without loss of generality) that the
<em>first</em> involution class in V is mapped to the class <tt>2C</tt> of B.

<div class="p"><!----></div>

<pre>
    gap&#62; f42:= CharacterTable( "F4(2)" );;
    gap&#62; v4:= CharacterTable( "2^2" );;
    gap&#62; dp:= v4 * f42;
    CharacterTable( "V4xF4(2)" )
    gap&#62; b:= CharacterTable( "B" );;
    gap&#62; f42fusb:= PossibleClassFusions( f42, b );;
    gap&#62; Length( f42fusb );
    1
    gap&#62; f42fusdp:= GetFusionMap( f42, dp );;
    gap&#62; comp:= CompositionMaps( f42fusb[1], InverseMap( f42fusdp ) );
    [ 1, 3, 3, 3, 5, 6, 6, 7, 9, 9, 9, 9, 14, 14, 13, 13, 10, 14, 14, 12, 14, 17,
      15, 18, 22, 22, 22, 22, 26, 26, 22, 22, 27, 27, 28, 31, 31, 39, 39, 36, 36,
      33, 33, 39, 39, 35, 41, 42, 47, 47, 49, 49, 49, 58, 58, 56, 56, 66, 66, 66,
      66, 58, 58, 66, 66, 69, 69, 60, 72, 72, 75, 79, 79, 81, 81, 85, 86, 83, 83,
      91, 91, 94, 94, 104, 104, 109, 109, 116, 116, 114, 114, 132, 132, 140, 140 ]
    gap&#62; v4fusdp:= GetFusionMap( v4, dp );
    [ 1, 96 .. 286 ]
    gap&#62; comp[ v4fusdp[2] ]:= 4;;
    gap&#62; dpfusb:= PossibleClassFusions( dp, b, rec( fusionmap:= comp ) );;
    gap&#62; Length( dpfusb );
    4
    gap&#62; Set( List( dpfusb, x -&#62; x{ v4fusdp } ) );
    [ [ 1, 4, 2, 2 ] ]

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
As announced above, we see that V contains two <tt>2A</tt> involutions.

<div class="p"><!----></div>
Set G = U / Z, M.G = U, and G.A = [&#63717;N] / Z.
The latter group is the direct product of F<sub>4</sub>(2).2 and a cyclic group
of order 2.
Next we compute the class fusion from G into G.A.

<div class="p"><!----></div>

<pre>
    gap&#62; tblG:= dp / v4fusdp{ [ 1, 2 ] };;
    gap&#62; tblMG:= dp;;
    gap&#62; c2:= CharacterTable( "Cyclic", 2 );;
    gap&#62; tblGA:= c2 * CharacterTable( "F4(2).2" );
    CharacterTable( "C2xF4(2).2" )
    gap&#62; GfusGA:= PossibleClassFusions( tblG, tblGA );;
    gap&#62; Length( GfusGA );
    4
    gap&#62; Length( RepresentativesFusions( tblG, GfusGA, tblGA ) );
    1

</pre>

<div class="p"><!----></div>
In principle, we have to be careful which of these equivalent maps
we choose, since the underlying symmetries may be broken in the central
extension M.G &#8594; G,
for which we choose the default factor fusion.

<div class="p"><!----></div>
However, in this situation the fusion G into G.A is unique already
up to table automorphisms of the table of G.A,
so we are free to choose one map.

<div class="p"><!----></div>

<pre>
    gap&#62; Length( RepresentativesFusions( Group( () ), GfusGA, tblGA ) );
    1
    gap&#62; StoreFusion( tblG, GfusGA[1], tblGA );

</pre>

<div class="p"><!----></div>
The tables involved determine the character table of
M.G.A  &#8773; [&#63717;N] uniquely.

<div class="p"><!----></div>

<pre>
    gap&#62; elms:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );;
    gap&#62; Length( elms );
    1
    gap&#62; poss:= PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, elms[1],
    &#62;               "(2^2xF4(2)):2" );;
    gap&#62; Length( poss );
    1
    gap&#62; tblMGA:= poss[1].table;;

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
Finally, we compare the table we constructed with the one that is contained
in the <font face="helvetica">GAP</font> Character Table Library.

<div class="p"><!----></div>

<pre>
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( tblMGA,
    &#62;                  CharacterTable( "(2^2xF4(2)):2" ) ) );
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.7">
4.7</a>&nbsp;&nbsp;The Character Table of 2.(S<sub>3</sub> &times;Fi<sub>22</sub>.2)  &#8804; 2.B
(March&nbsp;2003)</h3><a name="2.BM9">
</a>

<div class="p"><!----></div>
The sporadic simple group B contains a maximal subgroup [&#63717;M]
of type S<sub>3</sub> &times;Fi<sub>22</sub>.2.
In order to compute the character table of its preimage M
in the Schur cover 2.B,
we first analyse the structure of M and then describe
the construction of the character table from known character tables.

<div class="p"><!----></div>
Let Z denote the centre of 2.B.
We start with [&#63717;M] = M/Z.
Its class fusion into B is uniquely determined by the character tables.

<div class="p"><!----></div>

<pre>
    gap&#62; s3:= CharacterTable( "Dihedral", 6 );;
    gap&#62; fi222:= CharacterTable( "Fi22.2" );;
    gap&#62; tblMbar:= s3 * fi222;;
    gap&#62; b:= CharacterTable( "B" );;
    gap&#62; Mbarfusb:= PossibleClassFusions( tblMbar, b );;
    gap&#62; Length( Mbarfusb );
    1

</pre>

<div class="p"><!----></div>
The subgroup of type Fi<sub>22</sub> lifts to the double cover 2.Fi<sub>22</sub>
(that is, a group that is <em>not</em> a direct product 2 &times;Fi<sub>22</sub>)
in 2.B since 2.B admits no class fusion from Fi<sub>22</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; 2b:= CharacterTable( "2.B" );;
    gap&#62; PossibleClassFusions( CharacterTable( "Fi22" ), 2b );
    [  ]

</pre>

<div class="p"><!----></div>
So the preimage of Fi<sub>22</sub>.2 is one of the two nonisomorphic but isoclinic
groups of type 2.Fi<sub>22</sub>.2, and we have to decide which one really occurs.
For that, we consider the subgroup of type 3 &times;Fi<sub>22</sub>.2 in B,
which is a <tt>3A</tt> centralizer in B.
Its preimage has the structure 3 &times;2.Fi<sub>22</sub>.2 because the preimage
of the central group of order 3 is a cyclic group of order 6 and thus
contains a normal complement of the 2.Fi<sub>22</sub> type subgroup.
And a class fusion into 2.B is possible only from the direct product
containing the 2.Fi<sub>22</sub>.2 group that is printed in the  A<font size="-2">TLAS</font>.

<div class="p"><!----></div>

<pre>
    gap&#62; c3:= CharacterTable( "Cyclic", 3 );;
    gap&#62; 2fi222:= CharacterTable( "2.Fi22.2" );;
    gap&#62; PossibleClassFusions( c3 * CharacterTableIsoclinic( 2fi222 ), 2b );
    [  ]

</pre>

<div class="p"><!----></div>
Next we note that the involutions in the normal subgroup [&#63717;S]
of type S<sub>3</sub> in [&#63717;M] lift to involutions in 2.B.

<div class="p"><!----></div>

<pre>
    gap&#62; s3inMbar:= GetFusionMap( s3, tblMbar );
    [ 1, 113 .. 225 ]
    gap&#62; s3inb:= Mbarfusb[1]{ s3inMbar };
    [ 1, 6, 2 ]
    gap&#62; 2bfusb:= GetFusionMap( 2b, b );;
    gap&#62; 2s3in2B:= InverseMap( 2bfusb ){ s3inb };
    [ [ 1, 2 ], [ 8, 9 ], 3 ]
    gap&#62; CompositionMaps( OrdersClassRepresentatives( 2b ), 2s3in2B );
    [ [ 1, 2 ], [ 3, 6 ], 2 ]

</pre>

<div class="p"><!----></div>
Thus the preimage S of [&#63717;S] contains elements of order 6
but no elements of order 4,
which implies that S is a direct product 2 &times;S<sub>3</sub>.

<div class="p"><!----></div>
The two complements C<sub>1</sub>, C<sub>2</sub> of Z in S are normal in the preimage
N of [&#63717;N] = S<sub>3</sub> &times;Fi<sub>22</sub>,
which is thus of type S<sub>3</sub> &times;2.Fi<sub>22</sub>.
However, they are conjugate under the action of 2.Fi<sub>22</sub>.2,
as no class fusion from S<sub>3</sub> &times;2.Fi<sub>22</sub>.2 into 2.B is possible.

<div class="p"><!----></div>

<pre>
    gap&#62; PossibleClassFusions( s3 * 2fi222, 2b );
    [  ]

</pre>

<div class="p"><!----></div>
(More specifically, the classes of element order 36 in 2.Fi<sub>22</sub>.2
have centralizer orders 36 and 72, so their centralizer orders in
S<sub>3</sub> &times;2.Fi<sub>22</sub>.2 are 216 and 432;
but the centralizers of order 36 elements in 2.B have centralizer order
at most 216.)

<div class="p"><!----></div>
  <table><tr><td width="65%"> 
Now let us see how the character table of M can be constructed.

<div class="p"><!----></div>
Let Y denote the normal subgroup of order 3 in M,
and U its centralizer in M, which has index 2 in M.
Then the character table of M is determined by the tables of
M/Y, U, U/Y  &#8773; 2.Fi<sub>22</sub>.2, and the action of M on the
classes of U.

<div class="p"><!----></div>
As for M/Y, consider the normal subgroup N = N<sub>M</sub>(C<sub>1</sub>) of index 2 in M.
In particular, S/Y is central in N/Y but not in M/Y,
so the character table of M/Y is determined by the tables of
M/(YZ), N/Y  &#8773; 2 &times;2.Fi<sub>22</sub>, N/(YZ)  &#8773; 2 &times;Fi<sub>22</sub>,
and the action of M/Y on the classes of N/Y.

<div class="p"><!----></div>
Thus we proceed in two steps, starting with the computation of the
character table of M/Y, for which we choose the name according to the
structure 2<sup>2</sup>.Fi<sub>22</sub>.2.

  </td><td width="35%"> 

<center>
 <img src="ctblcons12.png" alt="ctblcons12.png" />

</center>

  </td></tr></table> 

<div class="p"><!----></div>

<pre>
    gap&#62; c2:= CharacterTable( "Cyclic", 2 );;
    gap&#62; 2fi22:= CharacterTable( "2.Fi22" );;
    gap&#62; tblNmodY:= c2 * 2fi22;;
    gap&#62; centre:= GetFusionMap( 2fi22, tblNmodY ){
    &#62;                 ClassPositionsOfCentre( 2fi22 ) };
    [ 1, 2 ]
    gap&#62; tblNmod6:= tblNmodY / centre;;
    gap&#62; tblMmod6:= c2 * fi222;;
    gap&#62; fus:= PossibleClassFusions( tblNmod6, tblMmod6 );;
    gap&#62; Length( fus );
    1
    gap&#62; StoreFusion( tblNmod6, fus[1], tblMmod6 );
    gap&#62; elms:= PossibleActionsForTypeMGA( tblNmodY, tblNmod6, tblMmod6 );;
    gap&#62; Length( elms );
    1
    gap&#62; poss:= PossibleCharacterTablesOfTypeMGA( tblNmodY, tblNmod6, tblMmod6,
    &#62;               elms[1], "2^2.Fi22.2" );;
    gap&#62; Length( poss );
    1
    gap&#62; tblMmodY:= poss[1].table;
    CharacterTable( "2^2.Fi22.2" )

</pre>

<div class="p"><!----></div>
So we found a unique solution for the character table of M/Y.
Now we compute the table of M.
For that, we have to specify the class fusion of U/Y into M/Y;
it is unique up to table automorphisms of M/Y.

<div class="p"><!----></div>

<pre>
    gap&#62; tblU:= c3 * 2fi222;;
    gap&#62; tblUmodY:= tblU / GetFusionMap( c3, tblU );;
    gap&#62; fus:= PossibleClassFusions( tblUmodY, tblMmodY );;
    gap&#62; Length( RepresentativesFusions( Group( () ), fus, tblMmodY ) );
    1
    gap&#62; StoreFusion( tblUmodY, fus[1], tblMmodY );
    gap&#62; elms:= PossibleActionsForTypeMGA( tblU, tblUmodY, tblMmodY );;
    gap&#62; Length( elms );
    1
    gap&#62; poss:= PossibleCharacterTablesOfTypeMGA( tblU, tblUmodY, tblMmodY,
    &#62;               elms[1], "(S3x2.Fi22).2" );;
    gap&#62; Length( poss );
    1
    gap&#62; tblM:= poss[1].table;
    CharacterTable( "(S3x2.Fi22).2" )
    gap&#62; mfus2b:= PossibleClassFusions( tblM, 2b );;
    gap&#62; Length( RepresentativesFusions( tblM, mfus2b, 2b ) );
    1

</pre>

<div class="p"><!----></div>
We did not construct M as a central extension of [&#63717;M],
so we verify that the tables fit together; note that this way we get also
the class fusion from M onto [&#63717;M].

<div class="p"><!----></div>

<pre>
    gap&#62; Irr( tblM / ClassPositionsOfCentre( tblM ) ) = Irr( tblMbar );
    true

</pre>

<div class="p"><!----></div>
Finally, we compare the table we constructed with the one that is contained
in the <font face="helvetica">GAP</font> Character Table Library.

<div class="p"><!----></div>

<pre>
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( tblM,
    &#62;                  CharacterTable( "(S3x2.Fi22).2" ) ) );
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.8">
4.8</a>&nbsp;&nbsp;The Character Table of (2 &times;2.Fi<sub>22</sub>):2  &lt;  Fi<sub>24</sub>
(November&nbsp;2008)</h3>

<div class="p"><!----></div>
  <table><tr><td width="65%"> 
The automorphism group Fi<sub>24</sub> of the sporadic simple group
Fi<sub>24</sub><sup>&#8242;</sup> contains a maximal subgroup
N of the type (2 &times;2.Fi<sub>22</sub>):2,
whose intersection with Fi<sub>24</sub><sup>&#8242;</sup> is 2.Fi<sub>22</sub>.2
(see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;207]).

<div class="p"><!----></div>
The normal Klein four group V in N
contains two <tt>2C</tt> elements in Fi<sub>24</sub>,
because the <tt>2C</tt> centralizer in Fi<sub>24</sub>, a group of the structure
2 &times;Fi<sub>23</sub>,
contains maximal subgroups of the type 2 &times;2.Fi<sub>22</sub>,
and so the two <tt>2C</tt> type subgroups C<sub>1</sub>, C<sub>2</sub> in V are conjugate
in N,
and Z = Z(N) is the centre of N &#8745;Fi<sub>24</sub><sup>&#8242;</sup>.

  </td><td width="35%"> 

<div class="p"><!----></div>

<center> <img src="ctblcons100.png" alt="ctblcons100.png" />

</center>

<div class="p"><!----></div>
  </td></tr></table> 

<div class="p"><!----></div>
With U = C<sub>N</sub>(C<sub>1</sub>), a group of the type 2 &times;2.Fi<sub>22</sub>,
we set G = U / Z, M.G = U, and G.A = N / Z.
The latter group is the direct product of Fi<sub>22</sub>.2 and a cyclic group
of order 2.

<div class="p"><!----></div>
This is exactly the situation of the construction of the character table of
the group that is called 2<sup>2</sup>.Fi<sub>22</sub>.2 in Section&nbsp;<a href="#2.BM9">4.7</a>,
where this group occurs as "M/Y".
Since the character table is uniquely determined by the input data,
it is the table we are interested in here.

<div class="p"><!----></div>
So all we have to do is to compute the class fusion from this table into
that of Fi<sub>24</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; fi24:= CharacterTable( "Fi24" );;
    gap&#62; t:= CharacterTable( "2^2.Fi22.2" );;
    gap&#62; fus:= PossibleClassFusions( t, fi24 );;
    gap&#62; Length( fus );
    4
    gap&#62; Length( RepresentativesFusions( t, fus, fi24 ) );
    1

</pre>

<div class="p"><!----></div>
(It should be noted that we did not need the character table of the
2.Fi<sub>22</sub>.2 type subgroup of N in the above construction,
only the tables of 2.Fi<sub>22</sub> and Fi<sub>22</sub>.2 were used.)

<div class="p"><!----></div>
The fact that the character table of a factor of a subgroup of 2.B
occurs as the character table of a subgroup of Fi<sub>24</sub>
is not a coincidence.
In fact, the groups 3.Fi<sub>24</sub> and 2.B are subgroups of the Monster group
M, and the subgroup U = 2.(S<sub>3</sub> &times;Fi<sub>22</sub>.2) of 2.B
normalizes an element of order three.
The full normalizer of this element in M is 3.Fi<sub>24</sub>,
which means that we have established U as a (maximal) subgroup of
3.Fi<sub>24</sub>.
Note that we have constructed the character table of U
in Section&nbsp;<a href="#2.BM9">4.7</a>.

<div class="p"><!----></div>
Let us compute the class fusion of U into 3.Fi<sub>24</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "(S3x2.Fi22).2" );;
    gap&#62; 3fi24:= CharacterTable( "3.Fi24" );;                        
    gap&#62; fus:= PossibleClassFusions( t, 3fi24 );;
    gap&#62; Length( fus );
    16
    gap&#62; Length( RepresentativesFusions( t, fus, 3fi24 ) );
    1
    gap&#62; GetFusionMap( t, 3fi24 ) in fus; 
    true

</pre>

<div class="p"><!----></div>
Moreover, U turns out to be the full normalizer of a <tt>6A</tt> element in M,

<div class="p"><!----></div>

<pre>
    gap&#62; m:= CharacterTable( "M" );;
    gap&#62; tfusm:= PossibleClassFusions( t, m );;
    gap&#62; Length( tfusm );
    4
    gap&#62; Length( RepresentativesFusions( t, tfusm, m ) );
    1
    gap&#62; nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
    &#62;        x -&#62; Sum( SizesConjugacyClasses( t ){ x } ) = 6 );
    [ [ 1, 2, 142, 143 ] ]
    gap&#62; Set( List( tfusm, x -&#62; x{ nsg[1] } ) );
    [ [ 1, 2, 4, 13 ] ]
    gap&#62; OrdersClassRepresentatives( t ){ nsg[1] };
    [ 1, 2, 3, 6 ]
    gap&#62; PowerMap( m, -1 )[13];
    13
    gap&#62; Size( t ) = 2 * SizesCentralizers( m )[13];
    true

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
(Thus U is also the full normalizer of an element of order six in 2.B and
in 3.Fi<sub>24</sub>.)

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.9">
4.9</a>&nbsp;&nbsp;The Character Table of S<sub>3</sub> &times;2.U<sub>4</sub>(3).2<sub>2</sub>  &#8804; 2.Fi<sub>22</sub>
 (September 2002)</h3>

<div class="p"><!----></div>
  <table><tr><td width="75%"> 
The sporadic simple Fischer group Fi<sub>22</sub> contains a maximal subgroup
[&#63717;M] of type S<sub>3</sub> &times;U<sub>4</sub>(3).2<sub>2</sub> (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;163]).
We claim that the preimage M of [&#63717;M] in the central extension
2.Fi<sub>22</sub> has the structure S<sub>3</sub> &times;2.U<sub>4</sub>(3).2<sub>2</sub>,
where the factor of type 2.U<sub>4</sub>(3).2<sub>2</sub> is the one printed in the  A<font size="-2">TLAS</font>.

<div class="p"><!----></div>
For that, we first note that the normal subgroup [&#63717;S] of type
S<sub>3</sub> in [&#63717;M] lifts to a group S which has the structure
2 &times;S<sub>3</sub>.
This follows from the fact that all involutions in Fi<sub>22</sub> lift to
involutions in 2.Fi<sub>22</sub> or, equivalently, the central involution in
2.Fi<sub>22</sub> is not a square.

  </td><td width="25%"> 

<center>
 <img src="ctblcons13.png" alt="ctblcons13.png" />

</center>

  </td></tr></table> 

<div class="p"><!----></div>

<pre>
    gap&#62; 2Fi22:= CharacterTable( "2.Fi22" );;
    gap&#62; ClassPositionsOfCentre( 2Fi22 );
    [ 1, 2 ]
    gap&#62; 2 in PowerMap( 2Fi22, 2 );
    false

</pre>

<div class="p"><!----></div>
Second, the normal subgroup [&#63717;U]  &#8773; U<sub>4</sub>(3).2<sub>2</sub> of Fi<sub>22</sub>
lifts to a nonsplit extension U in 2.Fi<sub>22</sub>,
since 2.Fi<sub>22</sub> contains no U<sub>4</sub>(3) type subgroup.
Furthermore, U is the 2.U<sub>4</sub>(3).2<sub>2</sub> type group printed in the  A<font size="-2">TLAS</font>
because the isoclinic variant does not admit a class fusion into 2.Fi<sub>22</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; PossibleClassFusions( CharacterTable( "U4(3)" ), 2Fi22 );
    [  ]
    gap&#62; tblU:= CharacterTable( "2.U4(3).2_2" );;
    gap&#62; iso:= CharacterTableIsoclinic( tblU );
    CharacterTable( "Isoclinic(2.U4(3).2_2)" )
    gap&#62; PossibleClassFusions( iso, 2Fi22 );                      
    [  ]

</pre>

<div class="p"><!----></div>
Now there are just two possibilities.
Either the two S<sub>3</sub> type subgroups in S are normal in M
(and thus M is the direct product of any such S<sub>3</sub> with the preimage
of the U<sub>4</sub>(3).2<sub>2</sub> type subgroup),
or they are conjugate in M.

<div class="p"><!----></div>
Suppose we are in the latter situation,
let z be a generator of the centre of 2.Fi<sub>22</sub>,
and let &#964;, &#963; be an involution and an order three element
respectively, in one of the S<sub>3</sub> type subgroups.

<div class="p"><!----></div>
Each element g  &#8712; U \U<sup>&#8242;</sup> conjugates &#964; to an
involution in the other S<sub>3</sub> type subgroup of S,
so g<sup>&#8722;1</sup> &#964;g = &#964;&#963;<sup>i</sup> z for some i  &#8712; { 0, 1, 2 }.
Furthermore, it is possible to choose g as an involution.

<div class="p"><!----></div>

<pre>
    gap&#62; derpos:= ClassPositionsOfDerivedSubgroup( tblU );;
    gap&#62; outer:= Difference( [ 1 .. NrConjugacyClasses( tblU ) ], derpos );;
    gap&#62; 2 in OrdersClassRepresentatives( tblU ){ outer };
    true

</pre>

<div class="p"><!----></div>
With this choice, (g &#964;)<sup>2</sup> = &#964;&#963;<sup>i</sup> z &#964; =  &#963;<sup>&#8722;i</sup> z
holds, which means that (g &#964;)<sup>3</sup> squares to z.
As we have seen above, this is impossible,
hence M is a direct product, as claimed.

<div class="p"><!----></div>
The class fusion of M into 2.Fi<sub>22</sub> is determined by the character
tables, up to table automorphisms.

<div class="p"><!----></div>

<pre>
    gap&#62; tblM:= CharacterTable( "Dihedral", 6 ) * tblU;;
    gap&#62; fus:= PossibleClassFusions( tblM, 2Fi22 );;
    gap&#62; Length( RepresentativesFusions( tblM, fus, 2Fi22 ) );
    1
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( tblM,
    &#62;                  CharacterTable( "2.Fi22M8" ) ) );
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.10">
4.10</a>&nbsp;&nbsp;The Character Table of 4.HS.2  &#8804; HN.2 (May 2002)</h3><a name="HN2">
</a>

<div class="p"><!----></div>

<div class="p"><!----></div>
  <table><tr><td width="75%"> 
The maximal subgroup U of type 2.HS.2 in the sporadic simple group HN
extends to a group N of structure 4.HS.2 in the automorphism group
HN.2 of HN (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;166]).

<div class="p"><!----></div>
N is the normalizer of a <tt>4D</tt> element g  &#8712; HN.2 \HN.
The centralizer C of g is of type 4.HS, which is the central product of
2.HS and the cyclic group &#9001;g &#9002; of order 4.
We have Z = Z(N) = &#9001;g<sup>2</sup> &#9002;.
Since U/Z  &#8773; HS.2 is a complement of &#9001;g &#9002;/ Z
in N/Z,
the factor group N/Z is a direct product of HS.2 and a cyclic
group of order 2.

  </td><td width="25%"> 

<center>
 <img src="ctblcons14.png" alt="ctblcons14.png" />

</center>

  </td></tr></table> 

<div class="p"><!----></div>
Thus N has the structure 2.G.2, the normal subgroup 2.G being C,
the factor group G.2 being 2 &times;HS.2,
and G being 2 &times;HS.
Each element in N \C inverts g, so N acts fixed point
freely on the faithful irreducible characters of C.
Hence we can use <tt>PossibleCharacterTablesOfTypeMGA</tt> for constructing the
character table of N from the tables of C and N/Z and the action of
N on the classes of C.

<div class="p"><!----></div>
We start with the table of the central product C.
It can be viewed as an isoclinic table of the direct product of
2.HS and a cyclic group of order 2, see&nbsp;<a href="#isoclinism">2.4</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; c2:= CharacterTable( "Cyclic", 2 );;
    gap&#62; tblC:= CharacterTableIsoclinic( CharacterTable( "2.HS" ) * c2 );;

</pre>

<div class="p"><!----></div>
The table of G is given as that of the factor group by the unique
normal subgroup of C that consists of two conjugacy classes.

<div class="p"><!----></div>

<pre>
    gap&#62; ord2:= Filtered( ClassPositionsOfNormalSubgroups( tblC ),
    &#62;               x -&#62; Length( x ) = 2 );
    [ [ 1, 3 ] ]
    gap&#62; tblCbar:= tblC / ord2[1];;

</pre>

<div class="p"><!----></div>
Finally, we construct the table of the extension G.2
and the class fusion of G into this table (which is uniquely determined
by the character tables).

<div class="p"><!----></div>

<pre>
    gap&#62; tblNbar:= CharacterTable( "HS.2" ) * c2;;
    gap&#62; fus:= PossibleClassFusions( tblCbar, tblNbar );
    [ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 
          21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 29, 30, 31, 32, 33, 34, 35, 36, 
          35, 36, 37, 38, 39, 40, 41, 42, 41, 42 ] ]
    gap&#62; StoreFusion( tblCbar, fus[1], tblNbar );

</pre>

<div class="p"><!----></div>
Now we compute the table automorphisms of the table of C that are
compatible with the extension N; we get two solutions.

<div class="p"><!----></div>

<pre>
    gap&#62; elms:= PossibleActionsForTypeMGA( tblC, tblCbar, tblNbar );
    [ [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6, 8 ], [ 7 ], [ 9 ], [ 10 ], [ 11 ],
          [ 12, 14 ], [ 13 ], [ 15 ], [ 16, 18 ], [ 17 ], [ 19 ], [ 20 ], [ 21 ],
          [ 22 ], [ 23 ], [ 24, 26 ], [ 25 ], [ 27 ], [ 28, 30 ], [ 29 ], [ 31 ],
          [ 32, 34 ], [ 33 ], [ 35 ], [ 36, 38 ], [ 37 ], [ 39 ], [ 40, 42 ],
          [ 41 ], [ 43 ], [ 44, 46 ], [ 45 ], [ 47 ], [ 48, 50 ], [ 49 ],
          [ 51, 53 ], [ 52, 54 ], [ 55 ], [ 56, 58 ], [ 57 ], [ 59 ], [ 60 ],
          [ 61, 65 ], [ 62, 68 ], [ 63, 67 ], [ 64, 66 ], [ 69 ], [ 70, 72 ],
          [ 71 ], [ 73 ], [ 74, 76 ], [ 75 ], [ 77, 81 ], [ 78, 84 ], [ 79, 83 ],
          [ 80, 82 ] ],
      [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6, 8 ], [ 7 ], [ 9 ], [ 10 ], [ 11 ],
          [ 12, 14 ], [ 13 ], [ 15, 17 ], [ 16 ], [ 18 ], [ 19 ], [ 20 ], [ 21 ],
          [ 22 ], [ 23 ], [ 24, 26 ], [ 25 ], [ 27 ], [ 28, 30 ], [ 29 ], [ 31 ],
          [ 32, 34 ], [ 33 ], [ 35, 37 ], [ 36 ], [ 38 ], [ 39 ], [ 40, 42 ],
          [ 41 ], [ 43 ], [ 44, 46 ], [ 45 ], [ 47, 49 ], [ 48 ], [ 50 ],
          [ 51, 53 ], [ 52, 54 ], [ 55 ], [ 56, 58 ], [ 57 ], [ 59 ], [ 60 ],
          [ 61, 65 ], [ 62, 68 ], [ 63, 67 ], [ 64, 66 ], [ 69, 71 ], [ 70 ],
          [ 72 ], [ 73 ], [ 74, 76 ], [ 75 ], [ 77, 83 ], [ 78, 82 ], [ 79, 81 ],
          [ 80, 84 ] ] ]

</pre>

<div class="p"><!----></div>
We compute the possible character tables arising from these two actions.

<div class="p"><!----></div>

<pre>
    gap&#62; poss:= List( elms, pi -&#62; PossibleCharacterTablesOfTypeMGA(
    &#62;                 tblC, tblCbar, tblNbar, pi, "4.HS.2" ) );;
    gap&#62; List( poss, Length );
    [ 0, 2 ]

</pre>

<div class="p"><!----></div>
So one of the two table automorphisms turned out to be impossible;
the reason is that the corresponding "character table" would not admit
a 2-power map.
(Alternatively, we could exclude this action on C by the fact
that it is not compatible with the action of 2.HS.2 on its subgroup
2.HS, which occurs here as the restriction of the action of N on C
to that of U on C &#8745;U.)

<div class="p"><!----></div>
The other table automorphism leads to two possible character tables.
This is not surprising since N contains a subgroup of type
2.HS.2, and the above setup does not determine which of the two isoclinism
types of this group occurs.
Let us look at the possible class fusions from these tables into that of
HN.2:

<div class="p"><!----></div>

<pre>
    gap&#62; result:= poss[2];;
    gap&#62; hn2:= CharacterTable( "HN.2" );;
    gap&#62; possfus:= List( result, r -&#62; PossibleClassFusions( r.table, hn2 ) );;
    gap&#62; List( possfus, Length );
    [ 32, 0 ]
    gap&#62; RepresentativesFusions( result[1].table, possfus[1], hn2 );
    [ [ 1, 46, 2, 2, 47, 3, 7, 45, 4, 58, 13, 6, 46, 47, 6, 47, 7, 48, 10, 62, 
          20, 9, 63, 21, 12, 64, 24, 27, 49, 50, 13, 59, 14, 16, 70, 30, 18, 53, 
          52, 17, 54, 20, 65, 22, 36, 56, 26, 76, 39, 77, 28, 59, 58, 31, 78, 41, 
          34, 62, 35, 65, 2, 45, 3, 45, 6, 48, 7, 47, 17, 54, 13, 49, 13, 50, 14, 
          50, 18, 53, 18, 52, 21, 56, 25, 57, 27, 59, 30, 60, 44, 72, 34, 66, 35, 
          66, 41, 71 ] ]

</pre>

<div class="p"><!----></div>
Only one of the candidates admits an embedding,
and the class fusion is unique up to table automorphisms.
So we are done.

<div class="p"><!----></div>
Finally, we compare the table we have constructed with the one that is
contained in the <font face="helvetica">GAP</font> Character Table Library.

<div class="p"><!----></div>

<pre>
    gap&#62; libtbl:= CharacterTable( "4.HS.2" );;
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( result[1].table,
    &#62;                  libtbl ) );
    true

</pre>

<div class="p"><!----></div>
(The following paragraphs have been added in May 2006.)

<div class="p"><!----></div>
The Brauer tables of N = 2.G.2 can be constructed as in
Section&nbsp;<a href="#ATLASMGA">4.3</a>.
Note that the Brauer tables of C = 2.G and of N / Z = G.2
are automatically available because the ordinary tables constructed above
arose as a direct product and as an isoclinic table of a direct product,
and the <font face="helvetica">GAP</font> Character Table Library contains the Brauer tables of the
direct factors involved.

<div class="p"><!----></div>

<pre>
    gap&#62; StoreFusion( tblC, result[1].MGfusMGA, result[1].table );
    gap&#62; ForAll( Set( Factors( Size( result[1].table ) ) ),
    &#62;            p -&#62; IsRecord( TransformingPermutationsCharacterTables(
    &#62;                     BrauerTableOfTypeMGA( tblC mod p, tblNbar mod p,
    &#62;                         result[1].table ).table, libtbl mod p ) ) );
    true

</pre>

<div class="p"><!----></div>
Here it is advantageous that the Brauer table of C / Z = G is not needed
in the construction,
since <font face="helvetica">GAP</font> does not know how to compute the p-modular table of the
ordinary table of G constructed above.
Of course we have G  &#8773; 2 &times;HS,
and the p-modular table of HS is known,
but in the construction of the table of G as a factor of the table of 2.G,
the information is missing that the nonsolvable simple direct factor of 2.G
corresponds to the library table of HS.

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.11">
4.11</a>&nbsp;&nbsp;The Character Tables of 4.A<sub>6</sub>.2<sub>3</sub>, 12.A<sub>6</sub>.2<sub>3</sub>,
and 4.L<sub>2</sub>(25).2<sub>3</sub></h3>

<div class="p"><!----></div>
  <table><tr><td width="75%"> 
For the "broken box" cases in the  A<font size="-2">TLAS</font> (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;xxiv]),
the character tables can be constructed with the M.G.A construction
method from Section&nbsp;<a href="#theorMGA">3.1</a>.

<div class="p"><!----></div>

<div class="p"><!----></div>
The group N = 4.A<sub>6</sub>.2<sub>3</sub> (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;5]) can be described as an
upward extension of the normal subgroup C  &#8773; 4.A<sub>6</sub>
-which is a central product of U = 2.A<sub>6</sub> and a cyclic group
&#9001;g &#9002; of order 4- by a cyclic group of order 2,
such that the factor group of N by the central subgroup
Z = &#9001;g<sup>2</sup> &#9002; of order 2
is isomorphic to a subdirect product [&#63717;N] of M<sub>10</sub> = A<sub>6</sub>.2<sub>3</sub>
and a cyclic group of order 4
and that N acts nontrivially on its normal subgroup &#9001;g &#9002;.

  </td><td width="25%"> 

<center>
 <img src="ctblcons15.png" alt="ctblcons15.png" />

</center>

  </td></tr></table> 

<div class="p"><!----></div>
Thus N has the structure 2.G.2, with 2.G = C and G.2 = [&#63717;N].
These two groups are isoclinic variants of 2 &times;2.A<sub>6</sub> and of
2 &times;M<sub>10</sub>, respectively.
Each element in N \C inverts g, so it acts fixed point
freely on the faithful irreducible characters of C.
Hence we can use <tt>PossibleCharacterTablesOfTypeMGA</tt> for constructing the
character table of N from the tables of C and N/Z and the action of
N on the classes of C.

<div class="p"><!----></div>

<pre>
    gap&#62; c2:= CharacterTable( "Cyclic", 2 );;
    gap&#62; 2a6:= CharacterTable( "2.A6" );;
    gap&#62; tblC:= CharacterTableIsoclinic( 2a6 * c2 );;
    gap&#62; ord2:= Filtered( ClassPositionsOfNormalSubgroups( tblC ),
    &#62;               x -&#62; Length( x ) = 2 );
    [ [ 1, 3 ] ]
    gap&#62; tblG:= tblC / ord2[1];;
    gap&#62; tblNbar:= CharacterTableIsoclinic( CharacterTable( "A6.2_3" ) * c2 );;
    gap&#62; fus:= PossibleClassFusions( tblG, tblNbar );
    [ [ 1, 2, 3, 4, 5, 6, 5, 6, 7, 8, 9, 10, 9, 10 ] ]
    gap&#62; StoreFusion( tblG, fus[1], tblNbar );
    gap&#62; elms:= PossibleActionsForTypeMGA( tblC, tblG, tblNbar );
    [ [ [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 12 ],
          [ 9, 13 ], [ 10, 14 ], [ 15, 17 ], [ 16, 18 ], [ 19, 23 ], [ 20, 24 ],
          [ 21, 25 ], [ 22, 26 ] ],
      [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 14 ], [ 9, 13 ],
          [ 10, 12 ], [ 15 ], [ 16, 18 ], [ 17 ], [ 19, 23 ], [ 20, 26 ],
          [ 21, 25 ], [ 22, 24 ] ],
      [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 14 ], [ 9, 13 ],
          [ 10, 12 ], [ 15, 17 ], [ 16 ], [ 18 ], [ 19, 23 ], [ 20, 26 ],
          [ 21, 25 ], [ 22, 24 ] ] ]
    gap&#62; poss:= List( elms, pi -&#62; PossibleCharacterTablesOfTypeMGA(
    &#62;                 tblC, tblG, tblNbar, pi, "4.A6.2_3" ) );
    [ [  ], [  ], 
      [
          rec( MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 9, 6, 9, 8, 7, 10, 11, 10,
                  12, 13, 14, 15, 16, 13, 16, 15, 14 ],
              table := CharacterTable( "4.A6.2_3" ) ) ] ]

</pre>

<div class="p"><!----></div>
So we get a unique solution.
It coincides with the character table of 4.A<sub>6</sub>.2<sub>3</sub> that is stored
in the <font face="helvetica">GAP</font> Character Table Library.

<div class="p"><!----></div>

<pre>
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( poss[3][1].table,
    &#62;                  CharacterTable( "4.A6.2_3" ) ) );
    true

</pre>

<div class="p"><!----></div>
Note that the first two candidates for the action lead to tables
that do not admit a 2-power map.
In fact the 2-power map of the character table of 4.A<sub>6</sub>.2<sub>3</sub> is not
uniquely determined by the matrix of character values.
However, the 2-power map is unique up to automorphisms of this matrix;
the function <tt>PossibleCharacterTablesOfTypeMGA</tt> takes this into account,
and returns only representatives, in this case one table.

<div class="p"><!----></div>

<div class="p"><!----></div>
  <table><tr><td width="75%"> 
The  A<font size="-2">TLAS</font> states in&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,Section&nbsp;6.7] that there is s group
of the structure 2<sup>2</sup>.A<sub>6</sub>.2<sub>3</sub> that is isoclinic with 4.A<sub>6</sub>.2<sub>3</sub>.
We construct also the character table of the 2<sup>2</sup>.A<sub>6</sub>.2<sub>3</sub> type group
with the M.G.A construction method from Section&nbsp;<a href="#theorMGA">3.1</a>.

<div class="p"><!----></div>
The group N = 2<sup>2</sup>.A<sub>6</sub>.2<sub>3</sub> can be described as an
upward extension of the normal subgroup C  &#8773; 2 &times;2.A<sub>6</sub>
by a cyclic group of order 2,
such that the factor group of N by the central subgroup
Z of order 2 that is contained in U = C&#8242; &#8773; 2.A<sub>6</sub>
is isomorphic to a subdirect product [&#63717;N] of M<sub>10</sub> = A<sub>6</sub>.2<sub>3</sub>
and a cyclic group of order 4
and that N acts nontrivially on the centre of C,
which is a Klein four group.

  </td><td width="25%"> 

<center>
 <img src="ctblcons15.png" alt="ctblcons15.png" />

</center>

  </td></tr></table> 

<div class="p"><!----></div>
Thus N has the structure 2.G.2, with 2.G = C and G.2 = [&#63717;N].
These latter group is an isoclinic variant of 2 &times;M<sub>10</sub>,
as in the construction of 4.A<sub>6</sub>.2<sub>3</sub>.
Each element in N \C swaps the two involutions in
Z(C) \Z, so it acts fixed point freely
on those irreducible characters of C whose kernels do not contain Z.
Hence we can use <tt>PossibleCharacterTablesOfTypeMGA</tt> for constructing the
character table of N from the tables of C and N/Z and the action of
N on the classes of C.

<div class="p"><!----></div>

<pre>
    gap&#62; tblC:= 2a6 * c2;;
    gap&#62; z:= GetFusionMap( 2a6, tblC ){ ClassPositionsOfCentre( 2a6 ) };
    [ 1, 3 ]
    gap&#62; tblG:= tblC / z;;
    gap&#62; tblNbar:= CharacterTableIsoclinic( CharacterTable( "A6.2_3" ) * c2 );;
    gap&#62; fus:= PossibleClassFusions( tblG, tblNbar );
    [ [ 1, 2, 3, 4, 5, 6, 5, 6, 7, 8, 9, 10, 9, 10 ] ]
    gap&#62; StoreFusion( tblG, fus[1], tblNbar );
    gap&#62; elms:= PossibleActionsForTypeMGA( tblC, tblG, tblNbar );
    [ [ [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 12 ], 
          [ 9, 13 ], [ 10, 14 ], [ 15, 17 ], [ 16, 18 ], [ 19, 23 ], [ 20, 24 ], 
          [ 21, 25 ], [ 22, 26 ] ], 
      [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 14 ], [ 9, 13 ], 
          [ 10, 12 ], [ 15 ], [ 16, 18 ], [ 17 ], [ 19, 23 ], [ 20, 26 ], 
          [ 21, 25 ], [ 22, 24 ] ], 
      [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 14 ], [ 9, 13 ], 
          [ 10, 12 ], [ 15, 17 ], [ 16 ], [ 18 ], [ 19, 23 ], [ 20, 26 ], 
          [ 21, 25 ], [ 22, 24 ] ] ]
    gap&#62; poss:= List( elms, pi -&#62; PossibleCharacterTablesOfTypeMGA(
    &#62;                 tblC, tblG, tblNbar, pi, "2^2.A6.2_3" ) );
    [ [  ], [  ], 
      [ 
          rec( MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 9, 6, 9, 8, 7, 10, 11, 10, 
                  12, 13, 14, 15, 16, 13, 16, 15, 14 ], 
              table := CharacterTable( "2^2.A6.2_3" ) ) ] ]

</pre>

<div class="p"><!----></div>
So we get a unique solution.

<div class="p"><!----></div>

<div class="p"><!----></div>
  <table><tr><td width="75%"> 
The group N = 12.A<sub>6</sub>.2<sub>3</sub> (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;5]) can be described as an
upward extension of the normal subgroup C  &#8773; 12.A<sub>6</sub>
-which is a central product of U = 6.A<sub>6</sub> and a cyclic group
&#9001;g &#9002; of order 4- by a cyclic group of order 2,
such that the factor group of N by the central subgroup
Z = &#9001;g<sup>2</sup> &#9002; of order 2
is isomorphic to a subdirect product [&#63717;N] of 3.M<sub>10</sub> = 3.A<sub>6</sub>.2<sub>3</sub>
and a cyclic group of order 4
and that N acts nontrivially on its normal subgroup &#9001;g &#9002;.

<div class="p"><!----></div>
Note that N has a central subgroup Y, say, of order 3,
so the situation here differs from that for groups of the type 12.G.2 with
G one of L<sub>3</sub>(4), U<sub>4</sub>(3), where the action on the normal subgroup
of order three is nontrivial.

<div class="p"><!----></div>
  </td><td width="25%"> 

<div class="p"><!----></div>

<center>  <img src="ctblcons16.png" alt="ctblcons16.png" /> 

</center>

<div class="p"><!----></div>
   </td></tr></table> 

<div class="p"><!----></div>
Thus N has the structure 2.G.2, with 2.G = C and G.2 = [&#63717;N].
These two groups are isoclinic variants of 2 &times;6.A<sub>6</sub> and of
2 &times;3.M<sub>10</sub>, respectively.
Each element in N \C inverts g, so it acts fixed point
freely on the faithful irreducible characters of C.
Hence we can use <tt>PossibleCharacterTablesOfTypeMGA</tt> for constructing the
character table of N from the tables of C and N/Z and the action of
N on the classes of C.

<div class="p"><!----></div>

<pre>
    gap&#62; c2:= CharacterTable( "Cyclic", 2 );;
    gap&#62; tblC:= CharacterTableIsoclinic( CharacterTable( "6.A6" ) * c2 );;
    gap&#62; ord2:= Filtered( ClassPositionsOfNormalSubgroups( tblC ),
    &#62;               x -&#62; Length( x ) = 2 );
    [ [ 1, 7 ] ]
    gap&#62; tblG:= tblC / ord2[1];;
    gap&#62; tblNbar:= CharacterTableIsoclinic( CharacterTable( "3.A6.2_3" ) * c2 );;
    gap&#62; fus:= PossibleClassFusions( tblG, tblNbar );
    [ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 13, 14, 15, 16, 17, 18, 
          19, 20, 21, 22, 23, 24, 25, 26, 21, 22, 23, 24, 25, 26 ], 
      [ 1, 2, 5, 6, 3, 4, 7, 8, 11, 12, 9, 10, 13, 14, 13, 14, 15, 16, 19, 20, 
          17, 18, 21, 22, 25, 26, 23, 24, 21, 22, 25, 26, 23, 24 ] ]
    gap&#62; rep:= RepresentativesFusions( Group( () ), fus, tblNbar );
    [ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 13, 14, 15, 16, 17, 18, 
          19, 20, 21, 22, 23, 24, 25, 26, 21, 22, 23, 24, 25, 26 ] ]
    gap&#62; StoreFusion( tblG, rep[1], tblNbar );
    gap&#62; elms:= PossibleActionsForTypeMGA( tblC, tblG, tblNbar );
    [ [ [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7 ], [ 8 ], [ 9 ], [ 10 ], 
          [ 11 ], [ 12 ], [ 13 ], [ 14 ], [ 15 ], [ 16 ], [ 17 ], [ 18 ], 
          [ 19, 23 ], [ 20, 24 ], [ 21, 25 ], [ 22, 26 ], [ 27, 33 ], [ 28, 34 ], 
          [ 29, 35 ], [ 30, 36 ], [ 31, 37 ], [ 32, 38 ], [ 39, 51 ], [ 40, 52 ], 
          [ 41, 53 ], [ 42, 54 ], [ 43, 55 ], [ 44, 56 ], [ 45, 57 ], [ 46, 58 ], 
          [ 47, 59 ], [ 48, 60 ], [ 49, 61 ], [ 50, 62 ] ], 
      [ [ 1 ], [ 2, 8 ], [ 3 ], [ 4, 10 ], [ 5 ], [ 6, 12 ], [ 7 ], [ 9 ], 
          [ 11 ], [ 13 ], [ 14 ], [ 15 ], [ 16 ], [ 17 ], [ 18 ], [ 19, 23 ], 
          [ 20, 26 ], [ 21, 25 ], [ 22, 24 ], [ 27 ], [ 28, 34 ], [ 29 ], 
          [ 30, 36 ], [ 31 ], [ 32, 38 ], [ 33 ], [ 35 ], [ 37 ], [ 39, 51 ], 
          [ 40, 58 ], [ 41, 53 ], [ 42, 60 ], [ 43, 55 ], [ 44, 62 ], [ 45, 57 ], 
          [ 46, 52 ], [ 47, 59 ], [ 48, 54 ], [ 49, 61 ], [ 50, 56 ] ], 
      [ [ 1 ], [ 2, 8 ], [ 3 ], [ 4, 10 ], [ 5 ], [ 6, 12 ], [ 7 ], [ 9 ], 
          [ 11 ], [ 13 ], [ 14 ], [ 15 ], [ 16 ], [ 17 ], [ 18 ], [ 19, 23 ], 
          [ 20, 26 ], [ 21, 25 ], [ 22, 24 ], [ 27, 33 ], [ 28 ], [ 29, 35 ], 
          [ 30 ], [ 31, 37 ], [ 32 ], [ 34 ], [ 36 ], [ 38 ], [ 39, 51 ], 
          [ 40, 58 ], [ 41, 53 ], [ 42, 60 ], [ 43, 55 ], [ 44, 62 ], [ 45, 57 ], 
          [ 46, 52 ], [ 47, 59 ], [ 48, 54 ], [ 49, 61 ], [ 50, 56 ] ] ]
    gap&#62; poss:= List( elms, pi -&#62; PossibleCharacterTablesOfTypeMGA(
    &#62;                 tblC, tblG, tblNbar, pi, "12.A6.2_3" ) );
    [ [  ], [  ], 
      [
          rec( MGfusMGA := [ 1, 2, 3, 4, 5, 6, 7, 2, 8, 4, 9, 6, 10, 11, 12, 13, 14,
                  15, 16, 17, 18, 19, 16, 19, 18, 17, 20, 21, 22, 23, 24, 25, 20,
                  26, 22, 27, 24, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
                  40, 29, 36, 31, 38, 33, 40, 35, 30, 37, 32, 39, 34 ],
              table := CharacterTable( "12.A6.2_3" ) ) ] ]

</pre>

<div class="p"><!----></div>
So we get again a unique solution.
It coincides with the character table that is stored in the <font face="helvetica">GAP</font>
Character Table Library.

<div class="p"><!----></div>

<pre>
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( poss[3][1].table,
    &#62;                  CharacterTable( "12.A6.2_3" ) ) );
    true

</pre>

<div class="p"><!----></div>
The construction of the character table of 4.L<sub>2</sub>(25).2<sub>3</sub> is analogous
to that of the table of 4.A<sub>6</sub>.2<sub>3</sub>.
We get a unique table that coincides with the table in the <font face="helvetica">GAP</font> library.

<div class="p"><!----></div>

<pre>
    gap&#62; c2:= CharacterTable( "Cyclic", 2 );;
    gap&#62; tblC:= CharacterTableIsoclinic( CharacterTable( "2.L2(25)" ) * c2 );;
    gap&#62; ord2:= Filtered( ClassPositionsOfNormalSubgroups( tblC ),
    &#62;               x -&#62; Length( x ) = 2 );
    [ [ 1, 3 ] ]
    gap&#62; tblG:= tblC / ord2[1];;
    gap&#62; tblNbar:= CharacterTableIsoclinic( CharacterTable( "L2(25).2_3" ) * c2 );;
    gap&#62; fus:= PossibleClassFusions( tblG, tblNbar );
    [ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 10, 11, 12, 13, 14, 13, 14, 15, 16, 15, 
          16, 17, 18, 17, 18, 19, 20, 19, 20 ], 
      [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 10, 11, 12, 13, 14, 13, 14, 17, 18, 17, 
          18, 19, 20, 19, 20, 15, 16, 15, 16 ], 
      [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 10, 11, 12, 13, 14, 13, 14, 19, 20, 19, 
          20, 15, 16, 15, 16, 17, 18, 17, 18 ] ]
    gap&#62; rep:= RepresentativesFusions( Group( () ), fus, tblNbar );
    [ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 10, 11, 12, 13, 14, 13, 14, 15, 16, 15, 
          16, 17, 18, 17, 18, 19, 20, 19, 20 ] ]
    gap&#62; StoreFusion( tblG, rep[1], tblNbar );
    gap&#62; elms:= PossibleActionsForTypeMGA( tblC, tblG, tblNbar );
    [ [ [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7 ], [ 8 ], [ 9 ], [ 10 ], 
          [ 11, 13 ], [ 12, 14 ], [ 15, 19 ], [ 16, 20 ], [ 17, 21 ], [ 18, 22 ], 
          [ 23, 25 ], [ 24, 26 ], [ 27, 33 ], [ 28, 34 ], [ 29, 31 ], [ 30, 32 ], 
          [ 35, 39 ], [ 36, 40 ], [ 37, 41 ], [ 38, 42 ], [ 43, 47 ], [ 44, 48 ], 
          [ 45, 49 ], [ 46, 50 ], [ 51, 55 ], [ 52, 56 ], [ 53, 57 ], [ 54, 58 ] ]
        , [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7 ], [ 8, 10 ], [ 9 ], 
          [ 11 ], [ 12, 14 ], [ 13 ], [ 15, 19 ], [ 16, 22 ], [ 17, 21 ], 
          [ 18, 20 ], [ 23, 25 ], [ 24 ], [ 26 ], [ 27, 31 ], [ 28, 34 ], 
          [ 29, 33 ], [ 30, 32 ], [ 35, 39 ], [ 36, 42 ], [ 37, 41 ], [ 38, 40 ], 
          [ 43, 47 ], [ 44, 50 ], [ 45, 49 ], [ 46, 48 ], [ 51, 55 ], [ 52, 58 ], 
          [ 53, 57 ], [ 54, 56 ] ], 
      [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7 ], [ 8, 10 ], [ 9 ], 
          [ 11, 13 ], [ 12 ], [ 14 ], [ 15, 19 ], [ 16, 22 ], [ 17, 21 ], 
          [ 18, 20 ], [ 23, 25 ], [ 24 ], [ 26 ], [ 27, 33 ], [ 28, 32 ], 
          [ 29, 31 ], [ 30, 34 ], [ 35, 39 ], [ 36, 42 ], [ 37, 41 ], [ 38, 40 ], 
          [ 43, 47 ], [ 44, 50 ], [ 45, 49 ], [ 46, 48 ], [ 51, 55 ], [ 52, 58 ], 
          [ 53, 57 ], [ 54, 56 ] ] ]
    gap&#62; poss:= List( elms, pi -&#62; PossibleCharacterTablesOfTypeMGA(
    &#62;                 tblC, tblG, tblNbar, pi, "4.L2(25).2_3" ) );
    [ [  ], [  ], 
      [
          rec( MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 7, 9, 10, 9, 11, 12, 13, 14,
                  15, 12, 15, 14, 13, 16, 17, 16, 18, 19, 20, 21, 22, 21, 20, 19,
                  22, 23, 24, 25, 26, 23, 26, 25, 24, 27, 28, 29, 30, 27, 30, 29,
                  28, 31, 32, 33, 34, 31, 34, 33, 32 ],
              table := CharacterTable( "4.L2(25).2_3" ) ) ] ]
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( poss[3][1].table,
    &#62;                  CharacterTable( "4.L2(25).2_3" ) ) );
    true

</pre>

<div class="p"><!----></div>

 
     <h3><a name="tth_sEc4.12">
4.12</a>&nbsp;&nbsp;
 <A name="pseudo_tables_MGA">
 Pseudo Character Tables of the Type M.G.A
 </A> (May 2004)</h3>
<a name="pseudo">
</a>

<div class="p"><!----></div>
With the construction method for character tables of groups of the type
M.G.A, one can construct tables that have many properties of character
tables but that are not character tables of groups, cf.&nbsp;[<a href="#Gag86" name="CITEGag86">Gag86</a>].
For example, the group 3.A<sub>6</sub>.2<sub>3</sub> has a <em>central</em> subgroup of order 3,
so it is not of the type M.G.A with fixed-point free action on the
faithful characters of M.G.

<div class="p"><!----></div>
However, if we apply the "M.G.A construction" to the groups M.G = 3.A<sub>6</sub>,
G = A<sub>6</sub>, and G.A = A<sub>6</sub>.2<sub>3</sub> then we get a (in this case unique) result.

<div class="p"><!----></div>

<pre>
    gap&#62; tblMG := CharacterTable( "3.A6" );;
    gap&#62; tblG  := CharacterTable( "A6" );;
    gap&#62; tblGA := CharacterTable( "A6.2_3" );;
    gap&#62; elms:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );  
    [ [ [ 1 ], [ 2, 3 ], [ 4 ], [ 5, 6 ], [ 7, 8 ], [ 9 ], [ 10, 11 ],
          [ 12, 15 ], [ 13, 17 ], [ 14, 16 ] ] ]
    gap&#62; poss:= PossibleCharacterTablesOfTypeMGA(                  
    &#62;                 tblMG, tblG, tblGA, elms[1], "pseudo" );    
    [ rec( MGfusMGA := [ 1, 2, 2, 3, 4, 4, 5, 5, 6, 7, 7, 8, 9, 10, 8, 10, 9 ],
          table := CharacterTable( "pseudo" ) ) ]

</pre>

<div class="p"><!----></div>
Such a table automatically satisfies the orthogonality relations,
and the tensor product of two "irreducible characters" of which at least
one is a row from G.A decomposes into a sum of the
"irreducible characters",
where the coefficients are nonnegative integers.

<div class="p"><!----></div>
In this example, any tensor product decomposes with nonnegative integral
coefficients,
n-th symmetrizations of "irreducible characters" decompose,
for n  &#8804; 5,
and the "class multiplication coefficients" are nonnegative integers.

<div class="p"><!----></div>

<pre>
    gap&#62; pseudo:= poss[1].table;
    CharacterTable( "pseudo" )
    gap&#62; Display( pseudo );
    pseudo
    
          2  4   3  4  3  .  3   2  .   .   .  2  3  3
          3  3   3  1  1  2  1   1  1   1   1  .  .  .
          5  1   1  .  .  .  .   .  1   1   1  .  .  .
    
            1a  3a 2a 6a 3b 4a 12a 5a 15a 15b 4b 8a 8b
         2P 1a  3a 1a 3a 3b 2a  6a 5a 15a 15b 2a 4a 4a
         3P 1a  1a 2a 2a 1a 4a  4a 5a  5a  5a 4b 8a 8b
         5P 1a  3a 2a 6a 3b 4a 12a 1a  3a  3a 4b 8b 8a
    
    X.1      1   1  1  1  1  1   1  1   1   1  1  1  1
    X.2      1   1  1  1  1  1   1  1   1   1 -1 -1 -1
    X.3     10  10  2  2  1 -2  -2  .   .   .  .  .  .
    X.4     16  16  .  . -2  .   .  1   1   1  .  .  .
    X.5      9   9  1  1  .  1   1 -1  -1  -1  1 -1 -1
    X.6      9   9  1  1  .  1   1 -1  -1  -1 -1  1  1
    X.7     10  10 -2 -2  1  .   .  .   .   .  .  B -B
    X.8     10  10 -2 -2  1  .   .  .   .   .  . -B  B
    X.9      6  -3 -2  1  .  2  -1  1   A  /A  .  .  .
    X.10     6  -3 -2  1  .  2  -1  1  /A   A  .  .  .
    X.11    12  -6  4 -2  .  .   .  2  -1  -1  .  .  .
    X.12    18  -9  2 -1  .  2  -1 -2   1   1  .  .  .
    X.13    30 -15 -2  1  . -2   1  .   .   .  .  .  .
    
    A = -E(15)-E(15)^2-E(15)^4-E(15)^8
      = (-1-Sqrt(-15))/2 = -1-b15
    B = E(8)+E(8)^3
      = Sqrt(-2) = i2
    gap&#62; IsInternallyConsistent( pseudo );
    true
    gap&#62; irr:= Irr( pseudo );;
    gap&#62; test:= Concatenation( List( [ 2 .. 5 ],
    &#62;               n -&#62; Symmetrizations( pseudo, irr, n ) ) );;
    gap&#62; Append( test, Set( Tensored( irr, irr ) ) );
    gap&#62; fail in Decomposition( irr, test, "nonnegative" );
    false
    gap&#62; if ForAny( Tuples( [ 1 .. NrConjugacyClasses( pseudo ) ], 3 ),        
    &#62;      t -&#62; not ClassMultiplicationCoefficient( pseudo, t[1], t[2], t[3] )   
    &#62;               in NonnegativeIntegers ) then                           
    &#62;      Error( "contradiction" );
    &#62; fi;

</pre>

<div class="p"><!----></div>
I do not know a character-theoretic argument for showing that this table is
<em>not</em> the character table of a group,
but we can use the following group-theoretic argument.
Suppose that the group G, say, has the above character table.
Then G has a unique composition series with factors of the orders
3, 360, and 2, respectively.
Let N denote the normal subgroup of order 3 in G.
The factor group F = G/N is an automorphic extension of A<sub>6</sub>,
and according to&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;4] it is isomorphic with M<sub>10</sub> = A<sub>6</sub>.2<sub>3</sub>
and has Sylow 3 normalizers of the structure 3<sup>2</sup> : Q<sub>8</sub>.
Since the Sylow 3 subgroup of G is a self-centralizing nonabelian group
of order 3<sup>3</sup> and of exponent 3,
the Sylow 3 normalizers in G have the structure 3<sup>1+2</sup><sub>+</sub> : Q<sub>8</sub>,
but the Q<sub>8</sub> type subgroups of <span class="roman">Aut</span>( 3<sup>1+2</sup><sub>+</sub> ) act trivially on the
centre of 3<sup>1+2</sup><sub>+</sub>, contrary to the situation in the above table.

<div class="p"><!----></div>
In general, this construction need not produce tables for which all
symmetrizations of irreducible characters decompose properly.
For example, applying <tt>PossibleCharacterTablesOfTypeMGA</tt> to the case
M.G = 3.L<sub>3</sub>(4) and G.A = L<sub>3</sub>(4).2<sub>1</sub> does not yield a table because
the function suppresses tables that do not admit p-th power maps,
for prime divisors p of the order of M.G.A,
and in this case no compatible 2-power map exists.

<div class="p"><!----></div>

<pre>
    gap&#62; tblMG := CharacterTable( "3.L3(4)" );;
    gap&#62; tblG  := CharacterTable( "L3(4)" );;
    gap&#62; tblGA := CharacterTable( "L3(4).2_1" );;
    gap&#62; elms:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );
    [ [ [ 1 ], [ 2, 3 ], [ 4 ], [ 5, 6 ], [ 7 ], [ 8 ], [ 9, 10 ], [ 11 ], 
          [ 12, 13 ], [ 14 ], [ 15, 16 ], [ 17, 20 ], [ 18, 22 ], [ 19, 21 ], 
          [ 23, 26 ], [ 24, 28 ], [ 25, 27 ] ] ]
    gap&#62; PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, elms[1], "?" );
    [  ]

</pre>

<div class="p"><!----></div>
Also, it may happen that already <tt>PossibleActionsForTypeMGA</tt> returns
an empty list.
Examples are M.G = 3<sub>1</sub>.U<sub>4</sub>(3), G.A = U<sub>4</sub>(3).2<sub>2</sub> and
M.G = 3<sub>2</sub>.U<sub>4</sub>(3), G.A = U<sub>4</sub>(3).2<sub>3</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; tblG  := CharacterTable( "U4(3)" );;
    gap&#62; tblMG := CharacterTable( "3_1.U4(3)" );;
    gap&#62; tblGA := CharacterTable( "U4(3).2_2" );;
    gap&#62; PossibleActionsForTypeMGA( tblMG, tblG, tblGA );
    [  ]
    gap&#62; tblMG:= CharacterTable( "3_2.U4(3)" );;
    gap&#62; tblGA:= CharacterTable( "U4(3).2_3" );;
    gap&#62; PossibleActionsForTypeMGA( tblMG, tblG, tblGA );
    [  ]

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.13">
4.13</a>&nbsp;&nbsp;Some Extra-ordinary p-Modular Tables of the Type M.G.A
(September 2005)</h3>

<div class="p"><!----></div>
For a group M.G.A in the sense of Section&nbsp;<a href="#theorMGA">3.1</a>
such that <b>not</b> all ordinary irreducible characters &#967; have the property
that M is contained in the kernel of &#967; or &#967; is induced from
M.G,
it may happen that there are primes p such that all irreducible p-modular
characters have this property.
This happens if and only if the preimages in M.G.A of each p-regular
conjugacy class in G.A \G form one conjugacy class.

<div class="p"><!----></div>
The following function can be used to decide whether this situation applies
to a character table in the <font face="helvetica">GAP</font> Character Table Library;
here we assume that for the library table of a group with the structure
M.G.A, the class fusions from M.G and to G.A are stored.

<div class="p"><!----></div>

<pre>
    gap&#62; FindExtraordinaryCase:= function( tblMGA )
    &#62;    local result, der, nsg, tblMGAclasses, orders, tblMG,
    &#62;          tblMGfustblMGA, tblMGclasses, pos, M, Mimg, tblMGAfustblGA, tblGA,
    &#62;          outer, inv, filt, other, primes, p;
    &#62;    result:= [];
    &#62;    der:= ClassPositionsOfDerivedSubgroup( tblMGA );
    &#62;    nsg:= ClassPositionsOfNormalSubgroups( tblMGA );
    &#62;    tblMGAclasses:= SizesConjugacyClasses( tblMGA );
    &#62;    orders:= OrdersClassRepresentatives( tblMGA );
    &#62;    if Length( der ) &lt; NrConjugacyClasses( tblMGA ) then
    &#62;      # Look for tables of normal subgroups of the form $M.G$.
    &#62;      for tblMG in Filtered( List( NamesOfFusionSources( tblMGA ),
    &#62;                                   CharacterTable ), x -&#62; x &lt;&#62; fail ) do
    &#62;        tblMGfustblMGA:= GetFusionMap( tblMG, tblMGA );
    &#62;        tblMGclasses:= SizesConjugacyClasses( tblMG );
    &#62;        pos:= Position( nsg, Set( tblMGfustblMGA ) );
    &#62;        if pos &lt;&#62; fail and
    &#62;           Size( tblMG ) = Sum( tblMGAclasses{ nsg[ pos ] } ) then
    &#62;          # Look for normal subgroups of the form $M$.
    &#62;          for M in Difference( ClassPositionsOfNormalSubgroups( tblMG ),
    &#62;                       [ [ 1 ], [ 1 .. NrConjugacyClasses( tblMG ) ] ] ) do
    &#62;            Mimg:= Set( tblMGfustblMGA{ M } );
    &#62;            if Sum( tblMGAclasses{ Mimg } ) = Sum( tblMGclasses{ M } ) then
    &#62;              tblMGAfustblGA:= First( ComputedClassFusions( tblMGA ),
    &#62;                  r -&#62; ClassPositionsOfKernel( r.map ) = Mimg );
    &#62;              if tblMGAfustblGA &lt;&#62; fail then
    &#62;                tblGA:= CharacterTable( tblMGAfustblGA.name );
    &#62;                tblMGAfustblGA:= tblMGAfustblGA.map;
    &#62;                outer:= Difference( [ 1 .. NrConjugacyClasses( tblGA ) ],
    &#62;                    CompositionMaps( tblMGAfustblGA, tblMGfustblMGA ) );
    &#62;                inv:= InverseMap( tblMGAfustblGA ){ outer };
    &#62;                filt:= Flat( Filtered( inv, IsList ) );
    &#62;                if not IsEmpty( filt ) then
    &#62;                  other:= Filtered( inv, IsInt );
    &#62;                  primes:= Filtered( Set( Factors( Size( tblMGA ) ) ),
    &#62;                     p -&#62; ForAll( orders{ filt }, x -&#62; x mod p = 0 )
    &#62;                          and ForAny( orders{ other }, x -&#62; x mod p &lt;&#62; 0 ) );
    &#62;                  for p in primes do
    &#62;                    Add( result, [ Identifier( tblMG ),
    &#62;                                   Identifier( tblMGA ),
    &#62;                                   Identifier( tblGA ), p ] );
    &#62;                  od;
    &#62;                fi;
    &#62;              fi;
    &#62;            fi;
    &#62;          od;
    &#62;        fi;
    &#62;      od;
    &#62;    fi;
    &#62;    return result;
    &#62; end;;

</pre>

<div class="p"><!----></div>
Let us list the tables which are found by this function.

<div class="p"><!----></div>

<pre>
    gap&#62; cases:= [];;
    gap&#62; for name in AllCharacterTableNames() do
    &#62;      Append( cases, FindExtraordinaryCase( CharacterTable( name ) ) );
    &#62;    od;
    gap&#62; for i in Set( cases ) do
    &#62;      Print( i, "\n" ); 
    &#62;    od;
    [ "2.A6", "2.A6.2_1", "A6.2_1", 3 ]
    [ "2.Fi22", "2.Fi22.2", "Fi22.2", 3 ]
    [ "2.L2(25)", "2.L2(25).2_2", "L2(25).2_2", 5 ]
    [ "2.L2(49)", "2.L2(49).2_2", "L2(49).2_2", 7 ]
    [ "2.L2(81)", "2.L2(81).2_1", "L2(81).2_1", 3 ]
    [ "2.L2(81)", "2.L2(81).4_1", "L2(81).4_1", 3 ]
    [ "2.L2(81).2_1", "2.L2(81).4_1", "L2(81).4_1", 3 ]
    [ "2.L4(3)", "2.L4(3).2_2", "L4(3).2_2", 3 ]
    [ "2.L4(3)", "2.L4(3).2_3", "L4(3).2_3", 3 ]
    [ "2.U4(3).2_1", "2.U4(3).(2^2)_{12*2*}", "U4(3).(2^2)_{122}", 3 ]
    [ "2.U4(3).2_1", "2.U4(3).(2^2)_{122}", "U4(3).(2^2)_{122}", 3 ]
    [ "2.U4(3).2_1", "2.U4(3).(2^2)_{13*3*}", "U4(3).(2^2)_{133}", 3 ]
    [ "2.U4(3).2_1", "2.U4(3).(2^2)_{133}", "U4(3).(2^2)_{133}", 3 ]
    [ "3.U3(8)", "3.U3(8).3_1", "U3(8).3_1", 2 ]
    [ "3.U3(8)", "3.U3(8).6", "U3(8).6", 2 ]
    [ "3.U3(8)", "3.U3(8).6", "U3(8).6", 3 ]
    [ "3.U3(8).2", "3.U3(8).6", "U3(8).6", 2 ]
    [ "5^(1+2):8:4", "2.HS.2N5", "HS.2N5", 5 ]
    [ "6.A6", "6.A6.2_1", "3.A6.2_1", 3 ]
    [ "6.A6", "6.A6.2_1", "A6.2_1", 3 ]
    [ "6.Fi22", "6.Fi22.2", "3.Fi22.2", 3 ]
    [ "6.Fi22", "6.Fi22.2", "Fi22.2", 3 ]
    [ "Isoclinic(2.U4(3).2_1)", "2.U4(3).(2^2)_{1*2*2}", "U4(3).(2^2)_{122}", 3 ]
    [ "Isoclinic(2.U4(3).2_1)", "2.U4(3).(2^2)_{1*3*3}", "U4(3).(2^2)_{133}", 3 ]

</pre>

<div class="p"><!----></div>
The smallest example in this list is 2.A<sub>6</sub>.2<sub>1</sub>,
the double cover of the symmetric group on six points.
The 3-modular table of this group looks as follows.

<div class="p"><!----></div>

<pre>
    gap&#62; Display( CharacterTable( "2.A6.2_1" ) mod 3 );
    2.A6.2_1mod3
    
         2  5   5  4  3  1   1  4  4  3
         3  2   2  .  .  .   .  1  1  .
         5  1   1  .  .  1   1  .  .  .
    
           1a  2a 4a 8a 5a 10a 2b 4b 8b
        2P 1a  1a 2a 4a 5a  5a 1a 2a 4a
        3P 1a  2a 4a 8a 5a 10a 2b 4b 8b
        5P 1a  2a 4a 8a 1a  2a 2b 4b 8b
    
    X.1     1   1  1  1  1   1  1  1  1
    X.2     1   1  1  1  1   1 -1 -1 -1
    X.3     6   6 -2  2  1   1  .  .  .
    X.4     4   4  . -2 -1  -1  2 -2  .
    X.5     4   4  . -2 -1  -1 -2  2  .
    X.6     9   9  1  1 -1  -1  3  3 -1
    X.7     9   9  1  1 -1  -1 -3 -3  1
    X.8     4  -4  .  . -1   1  .  .  .
    X.9    12 -12  .  .  2  -2  .  .  .

</pre>

<div class="p"><!----></div>
We see that the two faithful irreducible characters vanish on the three
classes outside 2.A<sub>6</sub>.

<div class="p"><!----></div>
For the groups in the above list,
the function <tt>BrauerTableOfTypeMGA</tt> can be used to construct the p-modular
tables of M.G.A from the tables of M.G and G.A,
for the given special primes p.
The computations can be performed as follows.

<div class="p"><!----></div>

<pre>
    gap&#62; for input in cases do
    &#62;      p:= input[4];
    &#62;      modtblMG:=  CharacterTable( input[1] ) mod p;
    &#62;      ordtblMGA:= CharacterTable( input[2] );
    &#62;      modtblGA:=  CharacterTable( input[3] ) mod p;
    &#62;      name:= Concatenation( Identifier( ordtblMGA ), " mod ", String(p) );
    &#62;      if ForAll( [ modtblMG, modtblGA ], IsCharacterTable ) then
    &#62;        poss:= BrauerTableOfTypeMGA( modtblMG, modtblGA, ordtblMGA );
    &#62;        modlib:= ordtblMGA mod p;
    &#62;        if IsCharacterTable( modlib ) then
    &#62;          trans:= TransformingPermutationsCharacterTables( poss.table,
    &#62;                      modlib );
    &#62;          if not IsRecord( trans ) then
    &#62;            Print( "#E  computed table and library table for ", name,
    &#62;                   " differ\n" );
    &#62;          fi;
    &#62;        else
    &#62;          Print( "#I  no library table for ", name, "\n" );
    &#62;        fi;
    &#62;      else
    &#62;        Print( "#I  not all input tables for ", name, " available\n" );
    &#62;      fi;
    &#62;    od;
    #I  not all input tables for 2.L2(49).2_2 mod 7 available
    #I  not all input tables for 2.L2(81).2_1 mod 3 available
    #I  not all input tables for 2.L2(81).4_1 mod 3 available
    #I  not all input tables for 2.L2(81).4_1 mod 3 available

</pre>

<div class="p"><!----></div>
The examples 2.A<sub>6</sub>.2<sub>1</sub>, 2.L<sub>2</sub>(25).2<sub>2</sub>, and 2.L<sub>2</sub>(49).2<sub>2</sub>
belong to the infinite series of semiliniear groups <span class="roman">&#931;L</span>(2,p<sup>2</sup>),
for odd primes p.
All groups in this series have the property that all faithful irreducible
characters vanish on the p-regular classes outside SL(2,p<sup>2</sup>).
(Cf.&nbsp;Section&nbsp;<a href="#isoclinicATLAS">2.5</a> for another property of the groups
in this series.)

<div class="p"><!----></div>

 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Examples for the Type G.S<sub>3</sub></h2><a name="GS3">
</a>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;Small Examples</h3>

<div class="p"><!----></div>
The symmetric group S<sub>4</sub> on four points has the form G.S<sub>3</sub>
where G is the Klein four group V<sub>4</sub>,
G.2 is the dihedral group D<sub>8</sub> of order 8,
and G.3 is the alternating group A<sub>4</sub>.
The trivial character of A<sub>4</sub> extends twofold to S<sub>4</sub>, in the same way
as the trivial character of V<sub>4</sub> extends to the dihedral group.
The nontrivial linear characters of A<sub>4</sub> induce irreducibly to S<sub>4</sub>.
The irreducible degree three character of A<sub>4</sub> is induced from any of the
three nontrivial linear characters of V<sub>4</sub>,
it extends to S<sub>4</sub> in the same way as the unique constituent of the
restriction to V<sub>4</sub> that is invariant in the chosen D<sub>8</sub> extends to D<sub>8</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; c2:= CharacterTable( "Cyclic", 2 );;
    gap&#62; t:= c2 * c2;;
    gap&#62; tC:= CharacterTable( "Dihedral", 8 );;
    gap&#62; tK:= CharacterTable( "Alternating", 4 );;
    gap&#62; tfustC:= PossibleClassFusions( t, tC );
    [ [ 1, 3, 4, 4 ], [ 1, 3, 5, 5 ], [ 1, 4, 3, 4 ], [ 1, 4, 4, 3 ], 
      [ 1, 5, 3, 5 ], [ 1, 5, 5, 3 ] ]
    gap&#62; StoreFusion( t, tfustC[1], tC );
    gap&#62; tfustK:= PossibleClassFusions( t, tK );
    [ [ 1, 2, 2, 2 ] ]
    gap&#62; StoreFusion( t, tfustK[1], tK );
    gap&#62; elms:= PossibleActionsForTypeGS3( t, tC, tK );
    [ (3,4) ]
    gap&#62; new:= CharacterTableOfTypeGS3( t, tC, tK, elms[1], "S4" );
    rec( table := CharacterTable( "S4" ), tblCfustblKC := [ 1, 4, 2, 2, 5 ], 
      tblKfustblKC := [ 1, 2, 3, 3 ] )
    gap&#62; Display( new.table );
    S4
    
         2  3  3  .  2  2
         3  1  .  1  .  .
    
           1a 2a 3a 4a 2b
        2P 1a 1a 3a 2a 1a
        3P 1a 2a 1a 4a 2b
    
    X.1     1  1  1  1  1
    X.2     1  1  1 -1 -1
    X.3     3 -1  .  1 -1
    X.4     3 -1  . -1  1
    X.5     2  2 -1  .  .

</pre>

<div class="p"><!----></div>
The case e  &gt;  1 occurs in the following example.
We choose G the cyclic group of order two,
G.C the cyclic group of order six,
G.K the quaternion group of order eight,
and construct the character table of G.F = SL<sub>2</sub>(3),
with F  &#8773; A<sub>4</sub>.

<div class="p"><!----></div>
We get three extensions of the trivial character of G.K to G.F,
a degree three character induced from the nontrivial linear characters
of G.K,
and three extensions of the irreducible degree 2 character of G.K.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "Cyclic", 2 );;
    gap&#62; tC:= CharacterTable( "Cyclic", 6 );;
    gap&#62; tK:= CharacterTable( "Quaternionic", 8 );;
    gap&#62; tfustC:= PossibleClassFusions( t, tC );
    [ [ 1, 4 ] ]
    gap&#62; StoreFusion( t, tfustC[1], tC );
    gap&#62; tfustK:= PossibleClassFusions( t, tK );
    [ [ 1, 3 ] ]
    gap&#62; StoreFusion( t, tfustK[1], tK );
    gap&#62; elms:= PossibleActionsForTypeGS3( t, tC, tK );
    [ (2,5,4) ]
    gap&#62; new:= CharacterTableOfTypeGS3( t, tC, tK, elms[1], "SL(2,3)" );
    rec( table := CharacterTable( "SL(2,3)" ), 
      tblCfustblKC := [ 1, 4, 5, 3, 6, 7 ], tblKfustblKC := [ 1, 2, 3, 2, 2 ] )
    gap&#62; Display( new.table );
    SL(2,3)
    
         2  3  2  3  1   1   1  1
         3  1  .  1  1   1   1  1
    
           1a 4a 2a 6a  3a  3b 6b
        2P 1a 2a 1a 3a  3b  3a 3b
        3P 1a 4a 2a 2a  1a  1a 2a
    
    X.1     1  1  1  1   1   1  1
    X.2     1  1  1  A  /A   A /A
    X.3     1  1  1 /A   A  /A  A
    X.4     3 -1  3  .   .   .  .
    X.5     2  . -2 /A  -A -/A  A
    X.6     2  . -2  1  -1  -1  1
    X.7     2  . -2  A -/A  -A /A
    
    A = E(3)
      = (-1+Sqrt(-3))/2 = b3

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp; A<font size="-2">TLAS</font> Tables of the Type G.S<sub>3</sub></h3><a name="xplGS3">
</a>

<div class="p"><!----></div>
We demonstrate the construction of all those ordinary and modular character
tables in the <font face="helvetica">GAP</font> Character Table Library that are of the type G.S<sub>3</sub>
where G is a simple group or a central extension of a simple group whose
character table is contained in the  A<font size="-2">TLAS</font>.
Here is the list of <tt>Identifier</tt> values needed for accessing the input
tables and the known library tables corresponding to the output.

<div class="p"><!----></div>

<pre>
    gap&#62; listGS3:= [
    &#62; [ "U3(5)",      "U3(5).2",      "U3(5).3",      "U3(5).S3"        ],
    &#62; [ "3.U3(5)",    "3.U3(5).2",    "3.U3(5).3",    "3.U3(5).S3"      ],
    &#62; [ "L3(4)",      "L3(4).2_2",    "L3(4).3",      "L3(4).3.2_2"     ],
    &#62; [ "L3(4)",      "L3(4).2_3",    "L3(4).3",      "L3(4).3.2_3"     ],
    &#62; [ "3.L3(4)",    "3.L3(4).2_2",  "3.L3(4).3",    "3.L3(4).3.2_2"   ],
    &#62; [ "2^2.L3(4)",  "2^2.L3(4).2_2","2^2.L3(4).3",  "2^2.L3(4).3.2_2" ],
    &#62; [ "2^2.L3(4)",  "2^2.L3(4).2_3","2^2.L3(4).3",  "2^2.L3(4).3.2_3" ],
    &#62; [ "U6(2)",      "U6(2).2",      "U6(2).3",      "U6(2).3.2"       ],
    &#62; [ "3.U6(2)",    "3.U6(2).2",    "3.U6(2).3",    "3.U6(2).3.2"     ],
    &#62; [ "2^2.U6(2)",  "2^2.U6(2).2",  "2^2.U6(2).3",  "2^2.U6(2).3.2"   ],
    &#62; [ "O8+(2)",     "O8+(2).2",     "O8+(2).3",     "O8+(2).3.2"      ],
    &#62; [ "2^2.O8+(2)", "2^2.O8+(2).2", "2^2.O8+(2).3", "2^2.O8+(2).3.2"  ],
    &#62; [ "L3(7)",      "L3(7).2",      "L3(7).3",      "L3(7).S3"        ],
    &#62; [ "3.L3(7)",    "3.L3(7).2",    "3.L3(7).3",    "3.L3(7).S3"      ],
    &#62; [ "U3(8)",      "U3(8).2",      "U3(8).3_2",    "U3(8).S3"        ],
    &#62; [ "3.U3(8)",    "3.U3(8).2",    "3.U3(8).3_2",  "3.U3(8).S3"      ],
    &#62; [ "U3(11)",     "U3(11).2",     "U3(11).3",     "U3(11).S3"       ],
    &#62; [ "3.U3(11)",   "3.U3(11).2",   "3.U3(11).3",   "3.U3(11).S3"     ],
    &#62; [ "O8+(3)",     "O8+(3).2_2",   "O8+(3).3",     "O8+(3).S3"       ],
    &#62; [ "2E6(2)",     "2E6(2).2",     "2E6(2).3",     "2E6(2).S3"       ],
    &#62; [ "2^2.2E6(2)", "2^2.2E6(2).2", "2^2.2E6(2).3", "2^2.2E6(2).S3"   ],
    &#62; ];;

</pre>

<div class="p"><!----></div>
(For G one of L<sub>3</sub>(4), U<sub>6</sub>(2), O<sub>8</sub><sup>+</sup>(2), and <sup>2</sup>E<sub>6</sub>(2),
the tables of 2<sup>2</sup>.G, 2<sup>2</sup>.G.2, and 2<sup>2</sup>.G.3 can be constructed
with the methods described in Section&nbsp;<a href="#theorV4G">3.4</a>
and Section&nbsp;<a href="#theorMGA">3.1</a>, respectively.)

<div class="p"><!----></div>
Analogously, the automorphism groups of L<sub>3</sub>(4) and O<sub>8</sub><sup>+</sup>(3)
have factor groups isomorphic with S<sub>3</sub>;
in these cases, we choose G = L<sub>3</sub>(4).2<sub>1</sub> and G = O<sub>8</sub><sup>+</sup>(3).2<sup>2</sup><sub>111</sub>,
respectively.

<div class="p"><!----></div>

<pre>
    gap&#62; Append( listGS3, [
    &#62; [ "L3(4).2_1",          "L3(4).2^2",     "L3(4).6",     "L3(4).D12"     ],
    &#62; [ "2^2.L3(4).2_1",      "2^2.L3(4).2^2", "2^2.L3(4).6", "2^2.L3(4).D12" ],
    &#62; [ "O8+(3).(2^2)_{111}", "O8+(3).D8",     "O8+(3).A4",   "O8+(3).S4"     ],
    &#62; ] );

</pre>

<div class="p"><!----></div>
In all these cases, the required table automorphism of G.3 is uniquely
determined.
We first compute the ordinary character table of G.S<sub>3</sub> and then
the p-modular tables,
for all prime divisors p of the order of G such that
the <font face="helvetica">GAP</font> Character Table Library contains the necessary p-modular
input tables.

<div class="p"><!----></div>
In each case, we compare the computed character tables with the ones in
the <font face="helvetica">GAP</font> Character Table Library.
Note that in order to avoid conflicts of the class fusions that arise in
the construction with the class fusions that are already stored on the
library tables, we choose identifiers for the result tables that are
different from the identifiers of the library tables.

<div class="p"><!----></div>

<pre>
    gap&#62; ProcessGS3Example:= function( t, tC, tK, identifier, pi )
    &#62;    local tF, lib, trans, p, tmodp, tCmodp, tKmodp, modtF;
    &#62; 
    &#62;    tF:= CharacterTableOfTypeGS3( t, tC, tK, pi,
    &#62;             Concatenation( identifier, "new" ) );
    &#62;    lib:= CharacterTable( identifier );
    &#62;    if lib &lt;&#62; fail then
    &#62;      trans:= TransformingPermutationsCharacterTables( tF.table, lib );
    &#62;      if not IsRecord( trans ) then
    &#62;        Print( "#E  computed table and library table for `", identifier,
    &#62;               "' differ\n" );
    &#62;      fi;
    &#62;    else
    &#62;      Print( "#I  no library table for `", identifier, "'\n" );
    &#62;    fi;
    &#62;    StoreFusion( tC, tF.tblCfustblKC, tF.table );
    &#62;    StoreFusion( tK, tF.tblKfustblKC, tF.table );
    &#62;    for p in Set( Factors( Size( t ) ) ) do
    &#62;      tmodp := t  mod p;
    &#62;      tCmodp:= tC mod p;
    &#62;      tKmodp:= tK mod p;
    &#62;      if IsCharacterTable( tmodp ) and
    &#62;         IsCharacterTable( tCmodp ) and
    &#62;         IsCharacterTable( tKmodp ) then
    &#62;        modtF:= CharacterTableOfTypeGS3( tmodp, tCmodp, tKmodp,
    &#62;                    tF.table,
    &#62;                    Concatenation(  identifier, "mod", String( p ) ) );
    &#62;        if   Length( Irr( modtF.table ) ) &lt;&#62;
    &#62;             Length( Irr( modtF.table )[1] ) then
    &#62;          Print( "#E  nonsquare result table for `",
    &#62;                 identifier, " mod ", p, "'\n" );
    &#62;        elif lib &lt;&#62; fail and IsCharacterTable( lib mod p ) then
    &#62;          trans:= TransformingPermutationsCharacterTables( modtF.table,
    &#62;                                                           lib mod p );
    &#62;          if not IsRecord( trans ) then
    &#62;            Print( "#E  computed table and library table for `",
    &#62;                   identifier, " mod ", p, "' differ\n" );
    &#62;          fi;
    &#62;        else
    &#62;          Print( "#I  no library table for `", identifier, " mod ",
    &#62;                 p, "'\n" );
    &#62;        fi;
    &#62;      else
    &#62;        Print( "#I  not all inputs available for `", identifier,
    &#62;               " mod ", p, "'\n" );
    &#62;      fi;
    &#62;    od;
    &#62; end;;

</pre>

<div class="p"><!----></div>
Now we call the function for the examples in the list.

<div class="p"><!----></div>

<pre>
    gap&#62; for input in listGS3 do
    &#62;      t := CharacterTable( input[1] );
    &#62;      tC:= CharacterTable( input[2] );
    &#62;      tK:= CharacterTable( input[3] );
    &#62;      identifier:= input[4];
    &#62;      elms:= PossibleActionsForTypeGS3( t, tC, tK );
    &#62;      if Length( elms ) = 1 then
    &#62;        ProcessGS3Example( t, tC, tK, identifier, elms[1] );
    &#62;      else
    &#62;        Print( "#I  ", Length( elms ), " actions possible for `",
    &#62;               identifier, "'\n" );
    &#62;      fi;
    &#62;    od;
    #I  not all inputs available for `O8+(3).S3 mod 3'
    #I  not all inputs available for `2E6(2).S3 mod 2'
    #I  not all inputs available for `2E6(2).S3 mod 3'
    #I  not all inputs available for `2E6(2).S3 mod 5'
    #I  not all inputs available for `2E6(2).S3 mod 7'
    #I  not all inputs available for `2E6(2).S3 mod 11'
    #I  not all inputs available for `2E6(2).S3 mod 13'
    #I  not all inputs available for `2E6(2).S3 mod 17'
    #I  not all inputs available for `2E6(2).S3 mod 19'
    #I  not all inputs available for `2^2.2E6(2).S3 mod 2'
    #I  not all inputs available for `2^2.2E6(2).S3 mod 3'
    #I  not all inputs available for `2^2.2E6(2).S3 mod 5'
    #I  not all inputs available for `2^2.2E6(2).S3 mod 7'
    #I  not all inputs available for `2^2.2E6(2).S3 mod 11'
    #I  not all inputs available for `2^2.2E6(2).S3 mod 13'
    #I  not all inputs available for `2^2.2E6(2).S3 mod 17'
    #I  not all inputs available for `2^2.2E6(2).S3 mod 19'
    #I  not all inputs available for `O8+(3).S4 mod 3'

</pre>

<div class="p"><!----></div>
Also the ordinary character table of the automorphic extension
of the simple  A<font size="-2">TLAS</font> group O<sub>8</sub><sup>+</sup>(3) by A<sub>4</sub> can be constructed
with the same approach.
Here we get four possible permutations, which lead to essentially the
same character table.

<div class="p"><!----></div>

<pre>
    gap&#62; input:= [ "O8+(3)", "O8+(3).3", "O8+(3).(2^2)_{111}", "O8+(3).A4" ];;
    gap&#62; t := CharacterTable( input[1] );;
    gap&#62; tC:= CharacterTable( input[2] );;
    gap&#62; tK:= CharacterTable( input[3] );;
    gap&#62; identifier:= input[4];;
    gap&#62; elms:= PossibleActionsForTypeGS3( t, tC, tK );;
    gap&#62; Length( elms );
    4
    gap&#62; differ:= MovedPoints( Group( List( elms, x -&#62; x / elms[1] ) ) );;
    gap&#62; List( elms, x -&#62; RestrictedPerm( x, differ ) );
    [ (118,216,169)(119,217,170)(120,218,167)(121,219,168), 
      (118,216,170)(119,217,169)(120,219,168)(121,218,167), 
      (118,217,169)(119,216,170)(120,218,168)(121,219,167), 
      (118,217,170)(119,216,169)(120,219,167)(121,218,168) ]
    gap&#62; poss:= List( elms, pi -&#62; CharacterTableOfTypeGS3( t, tC, tK, pi,
    &#62;             Concatenation( identifier, "new" ) ) );;
    gap&#62; lib:= CharacterTable( identifier );;
    gap&#62; ForAll( poss, r -&#62; IsRecord(
    &#62;        TransformingPermutationsCharacterTables( r.table, lib ) ) );
    true

</pre>

<div class="p"><!----></div>
Also the construction of the p-modular tables of O<sub>8</sub><sup>+</sup>(3).A<sub>4</sub> works.

<div class="p"><!----></div>

<pre>
    gap&#62; ProcessGS3Example( t, tC, tK, identifier, elms[1] );
    #I  not all inputs available for `O8+(3).A4 mod 3'

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;Examples for the Type G.2<sup>2</sup></h2><a name="xplGV4">
</a>

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;The Character Table of A<sub>6</sub>.2<sup>2</sup></h3>

<div class="p"><!----></div>
As the first example,
we consider the automorphism group <span class="roman">Aut</span>( A<sub>6</sub> )  &#8773; A<sub>6</sub>.2<sup>2</sup> of the
alternating group A<sub>6</sub> on six points.

<div class="p"><!----></div>
In this case, the triple of actions on the subgroups A<sub>6</sub>.2<sub>i</sub> is uniquely
determined by the condition on the number of conjugacy classes
in Section&nbsp;<a href="#theorGV4">3.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; tblG:= CharacterTable( "A6" );;
    gap&#62; tblsG2:= List( [ "A6.2_1", "A6.2_2", "A6.2_3" ], CharacterTable );;
    gap&#62; List( tblsG2, NrConjugacyClasses );
    [ 11, 11, 8 ]
    gap&#62; possact:= List( tblsG2, x -&#62; Filtered( Elements( 
    &#62;        AutomorphismsOfTable( x ) ), y -&#62; Order( y ) &lt;= 2 ) );
    [ [ (), (3,4)(7,8)(10,11) ], [ (), (8,9), (5,6)(10,11), (5,6)(8,9)(10,11) ], 
      [ (), (7,8) ] ]

</pre>

<div class="p"><!----></div>
Note that n<sub>1</sub> = n<sub>2</sub> implies f<sub>1</sub> = f<sub>2</sub>, and n<sub>1</sub> &#8722; n<sub>3</sub> = 3 implies
f<sub>1</sub> &#8722; f<sub>3</sub> = 2,
so we get f<sub>1</sub> = 3 and f<sub>3</sub> = 1,
and A<sub>6</sub>.2<sup>2</sup> has 2 &#183;11 &#8722; 3 &#183;3 = 2 &#183;8 &#8722; 3 &#183;1 = 13
classes.

<div class="p"><!----></div>
(The compatibility on the classes inside A<sub>6</sub> yields only that the classes
3 and 4 of A<sub>6</sub>.2<sub>1</sub>  &#8773; S<sub>6</sub> must be fused in A<sub>6</sub>.2<sup>2</sup>,
as well as the classes 5 and 6 of A<sub>6</sub>.2<sub>2</sub>  &#8773; <span class="roman">PGL</span>(2,9).)

<div class="p"><!----></div>

<pre>
    gap&#62; List( tblsG2, x -&#62; GetFusionMap( tblG, x ) );
    [ [ 1, 2, 3, 4, 5, 6, 6 ], [ 1, 2, 3, 3, 4, 5, 6 ], [ 1, 2, 3, 3, 4, 5, 5 ] ]

</pre>

<div class="p"><!----></div>
These arguments are used by the <font face="helvetica">GAP</font> function <tt>PossibleActionsForTypeGV4</tt>,
which returns the list of all possible triples of permutations such that
the i-th permutation describes the action of A<sub>6</sub>.2<sup>2</sup> on the classes of
A<sub>6</sub>.2<sub>i</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; acts:= PossibleActionsForTypeGV4( tblG, tblsG2 );    
    [ [ (3,4)(7,8)(10,11), (5,6)(8,9)(10,11), (7,8) ] ]

</pre>

<div class="p"><!----></div>
For the given actions, the <font face="helvetica">GAP</font> function <tt>PossibleCharacterTablesOfTypeGV4</tt>
then computes the possibilities for the character table of A<sub>6</sub>.2<sup>2</sup>;
in this case, the result is unique.

<div class="p"><!----></div>

<pre>
    gap&#62; poss:= PossibleCharacterTablesOfTypeGV4( tblG, tblsG2, acts[1], "A6.2^2" );
    [ rec(
          G2fusGV4 := [ [ 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 8 ],
              [ 1, 2, 3, 4, 5, 5, 9, 10, 10, 11, 11 ],
              [ 1, 2, 3, 4, 5, 12, 13, 13 ] ],
          table := CharacterTable( "A6.2^2" ) ) ]
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( poss[1].table,
    &#62;                  CharacterTable( "A6.2^2" ) ) );
    true

</pre>

<div class="p"><!----></div>
Finally, possible p-modular tables can be computed from the p-modular
input tables and the ordinary table of A<sub>6</sub>.2<sup>2</sup>;
here we show this for p = 3.

<div class="p"><!----></div>

<pre>
    gap&#62; PossibleCharacterTablesOfTypeGV4( tblG mod 3,
    &#62;        List( tblsG2, t -&#62; t mod 3 ), poss[1].table );
    [ rec(
          G2fusGV4 := [ [ 1, 2, 3, 4, 5, 5, 6 ], [ 1, 2, 3, 4, 4, 7, 8, 8, 9, 9 ],
              [ 1, 2, 3, 4, 10, 11, 11 ] ], table := BrauerTable( "A6.2^2", 3 ) )
     ]

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp; A<font size="-2">TLAS</font> Tables of the Type G.2<sup>2</sup> - Easy Cases</h3><a name="xplGV43.A6.V4">
</a>

<div class="p"><!----></div>
We demonstrate the construction of all those ordinary and modular character
tables in the <font face="helvetica">GAP</font> Character Table Library that are of the type G.2<sup>2</sup>
where G is a simple group or a central extension of a simple group whose
character table is contained in the  A<font size="-2">TLAS</font>.
Here is the list of <tt>Identifier</tt> values needed for accessing the input
tables and the result tables.

<div class="p"><!----></div>
(The construction of the character table of O<sub>8</sub><sup>+</sup>(3).2<sup>2</sup><sub>111</sub> is more
involved and will be described in Section&nbsp;<a href="#O_8^+(3).2^2_{111}">6.10</a>.
The construction of the character tables of groups of the type
2.L<sub>3</sub>(4).2<sup>2</sup> and 6.L<sub>3</sub>(4).2<sup>2</sup> is described in the sections&nbsp;<a href="#2L34V4">6.4</a>
and&nbsp;<a href="#6L34V4">6.5</a>, respectively.
The construction of the character tables of groups of the type
2.U<sub>4</sub>(3).2<sup>2</sup> is described in Section&nbsp;<a href="#2U43V4">6.6</a>.)

<div class="p"><!----></div>

<pre>
    gap&#62; listGV4:= [
    &#62; [ "A6",      "A6.2_1",      "A6.2_2",      "A6.2_3",      "A6.2^2"      ],
    &#62; [ "3.A6",    "3.A6.2_1",    "3.A6.2_2",    "3.A6.2_3",    "3.A6.2^2"    ],
    &#62; [ "L2(25)",  "L2(25).2_1",  "L2(25).2_2",  "L2(25).2_3",  "L2(25).2^2"  ],
    &#62; [ "L3(4)",   "L3(4).2_1",   "L3(4).2_2",   "L3(4).2_3",   "L3(4).2^2"   ],
    &#62; [ "2^2.L3(4)", "2^2.L3(4).2_1", "2^2.L3(4).2_2", "2^2.L3(4).2_3",
    &#62;                                                         "2^2.L3(4).2^2" ],
    &#62; [ "3.L3(4)", "3.L3(4).2_1", "3.L3(4).2_2", "3.L3(4).2_3", "3.L3(4).2^2" ],
    &#62; [ "U4(3)",   "U4(3).2_1",   "U4(3).2_2",   "U4(3).2_2'",
    &#62;                                                     "U4(3).(2^2)_{122}" ],
    &#62; [ "U4(3)",   "U4(3).2_1",   "U4(3).2_3",   "U4(3).2_3'",
    &#62;                                                     "U4(3).(2^2)_{133}" ],
    &#62; [ "3_1.U4(3)", "3_1.U4(3).2_1", "3_1.U4(3).2_2", "3_1.U4(3).2_2'",
    &#62;                                                 "3_1.U4(3).(2^2)_{122}" ],
    &#62; [ "3_2.U4(3)", "3_2.U4(3).2_1", "3_2.U4(3).2_3", "3_2.U4(3).2_3'",
    &#62;                                                 "3_2.U4(3).(2^2)_{133}" ],
    &#62; [ "L2(49)",  "L2(49).2_1",  "L2(49).2_2",  "L2(49).2_3",  "L2(49).2^2"  ],
    &#62; [ "L2(81)",  "L2(81).2_1",  "L2(81).2_2",  "L2(81).2_3",  "L2(81).2^2"  ],
    &#62; [ "L3(9)",   "L3(9).2_1",   "L3(9).2_2",   "L3(9).2_3",   "L3(9).2^2"   ],
    &#62; [ "O8+(3)",  "O8+(3).2_1",  "O8+(3).2_2",  "O8+(3).2_2'",
    &#62;                                                    "O8+(3).(2^2)_{122}" ],
    &#62; [ "O8-(3)",  "O8-(3).2_1",  "O8-(3).2_2",  "O8-(3).2_3",  "O8-(3).2^2"  ],
    &#62; ];;

</pre>

<div class="p"><!----></div>
Analogously,
the automorphism groups L<sub>3</sub>(4).D<sub>12</sub> of L<sub>3</sub>(4)
and U<sub>4</sub>(3).D<sub>8</sub> of U<sub>4</sub>(3),
and the subgroup O<sub>8</sub><sup>+</sup>(3).D<sub>8</sub> of the automorphism group O<sub>8</sub><sup>+</sup>(3).S<sub>4</sub>
have factor groups that are isomorphic with 2<sup>2</sup>;
in these cases,
we choose G = L<sub>3</sub>(4).3, G = U<sub>4</sub>(3).2<sub>1</sub>, and G = O<sub>8</sub><sup>+</sup>(3).2<sub>1</sub>,
respectively.

<div class="p"><!----></div>
Also the group 2<sup>2</sup>.L<sub>3</sub>(4).D<sub>12</sub> has a factor group isomorphic with 2<sup>2</sup>.
Note that the character tables of L<sub>3</sub>(4).D<sub>12</sub> and 2<sup>2</sup>.L<sub>3</sub>(4).D<sub>12</sub>
have been constructed already in Section&nbsp;<a href="#xplGS3">5.2</a>.

<div class="p"><!----></div>
The automorphism groups of L<sub>4</sub>(4) and U<sub>4</sub>(5) have the structure
L<sub>4</sub>(4).2<sup>2</sup> and U<sub>4</sub>(5).2<sup>2</sup>, respectively;
their tables are contained in the <font face="helvetica">GAP</font> Character Table Library
but not in the  A<font size="-2">TLAS</font>.

<div class="p"><!----></div>

<pre>
    gap&#62; Append( listGV4, [
    &#62; [ "L3(4).3", "L3(4).6",     "L3(4).3.2_2", "L3(4).3.2_3", "L3(4).D12"   ],
    &#62; [ "2^2.L3(4).3", "2^2.L3(4).6", "2^2.L3(4).3.2_2", "2^2.L3(4).3.2_3",
    &#62;                                                         "2^2.L3(4).D12" ],
    &#62; [ "U4(3).2_1", "U4(3).4", "U4(3).(2^2)_{122}", "U4(3).(2^2)_{133}",
    &#62;                                                              "U4(3).D8" ],
    &#62; [ "O8+(3).2_1", "O8+(3).(2^2)_{111}", "O8+(3).(2^2)_{122}", "O8+(3).4",
    &#62;                                                             "O8+(3).D8" ],
    &#62; [ "L4(4)",   "L4(4).2_1",   "L4(4).2_2",   "L4(4).2_3",   "L4(4).2^2"   ],
    &#62; [ "U4(5)",   "U4(5).2_1",   "U4(5).2_2",   "U4(5).2_3",   "U4(5).2^2"   ],
    &#62; ] );

</pre>

<div class="p"><!----></div>
Now we proceed in two steps, the computation of the possible ordinary
character tables from the ordinary tables of the relevant subgroups,
and then the computation of the Brauer tables from the Brauer tables of the
relevant subgroups and from the ordinary table of the group.

<div class="p"><!----></div>
The following function first computes the possible triples of actions on the
subgroups G.2<sub>i</sub>, using the function <tt>PossibleActionsForTypeGV4</tt>.
Then the union of the candidate tables for these actions is computed,
this list is returned in the end.
and representatives of classes of permutation equivalent candidates are
inspected further with consistency checks.
If there is a unique solution up to permutation equivalence,
this table is compared with the one that is contained in the
<font face="helvetica">GAP</font> Character Table Library.

<div class="p"><!----></div>

<pre>
    gap&#62; ConstructOrdinaryGV4Table:= function( tblG, tblsG2, name, lib )
    &#62;      local acts, nam, poss, reps, i, trans;
    &#62; 
    &#62;      # Compute the possible actions for the ordinary tables.
    &#62;      acts:= PossibleActionsForTypeGV4( tblG, tblsG2 );
    &#62;      # Compute the possible ordinary tables for the given actions.
    &#62;      nam:= Concatenation( "new", name );
    &#62;      poss:= Concatenation( List( acts, triple -&#62; 
    &#62;          PossibleCharacterTablesOfTypeGV4( tblG, tblsG2, triple, nam ) ) );
    &#62;      # Test the possibilities for permutation equivalence.
    &#62;      reps:= RepresentativesCharacterTables( poss );
    &#62;      if 1 &lt; Length( reps ) then
    &#62;        Print( "#I  ", name, ": ", Length( reps ),
    &#62;               " equivalence classes\n" );
    &#62;      elif Length( reps ) = 0 then
    &#62;        Print( "#E  ", name, ": no solution\n" );
    &#62;      else
    &#62;        # Compare the computed table with the library table.
    &#62;        if not IsCharacterTable( lib ) then
    &#62;          Print( "#I  no library table for ", name, "\n" );
    &#62;          PrintToLib( name, poss[1].table );
    &#62;          for i in [ 1 .. 3 ] do
    &#62;            Print( LibraryFusion( tblsG2[i],
    &#62;                       rec( name:= name, map:= poss[1].G2fusGV4[i] ) ) );
    &#62;          od;
    &#62;        else
    &#62;          trans:= TransformingPermutationsCharacterTables( poss[1].table,
    &#62;                      lib );
    &#62;          if not IsRecord( trans ) then
    &#62;            Print( "#E  computed table and library table for ", name,
    &#62;                   " differ\n" );
    &#62;          fi;
    &#62;          # Compare the computed fusions with the stored ones.
    &#62;          if List( poss[1].G2fusGV4, x -&#62; OnTuples( x, trans.columns ) )
    &#62;                 &lt;&#62; List( tblsG2, x -&#62; GetFusionMap( x, lib ) ) then
    &#62;            Print( "#E  computed and stored fusions for ", name,
    &#62;                   " differ\n" );
    &#62;          fi;
    &#62;        fi;
    &#62;      fi;
    &#62;      return poss;
    &#62;    end;;

</pre>

<div class="p"><!----></div>
The following function computes, for all those prime divisors p of the
group order in question such that the p-modular Brauer tables of the
subgroups G.2<sub>i</sub> are available, the possible p-modular Brauer tables.
If the solution is unique up to permutation equivalence,
it is compared with the table that is contained in the
<font face="helvetica">GAP</font> Character Table Library.

<div class="p"><!----></div>
It may happen (even in the case that the ordinary character table is
unique up to permutation equivalence) that some candidates for the
ordinary character table are excluded due to information provided by
some p-modular table.
In this case, a message is printed, and the ordinary character table
from the <font face="helvetica">GAP</font> Character Table Library is checked again under the
additional restrictions.

<div class="p"><!----></div>

<pre>
    gap&#62; ConstructModularGV4Tables:= function( tblG, tblsG2, ordposs,
    &#62;                                          ordlibtblGV4 )
    &#62;      local name, modposs, primes, checkordinary, i, record, p, tmodp,
    &#62;            t2modp, poss, modlib, trans, reps;
    &#62; 
    &#62;      if not IsCharacterTable( ordlibtblGV4 ) then
    &#62;        Print( "#I  no ordinary library table ...\n" );
    &#62;        return [];
    &#62;      fi;
    &#62;      name:= Identifier( ordlibtblGV4 );
    &#62;      modposs:= [];
    &#62;      primes:= Set( Factors( Size( tblG ) ) );
    &#62;      ordposs:= ShallowCopy( ordposs );
    &#62;      checkordinary:= false;
    &#62;      for i in [ 1 .. Length( ordposs ) ] do
    &#62;        modposs[i]:= [];
    &#62;        record:= ordposs[i];
    &#62;        for p in primes do
    &#62;          tmodp := tblG  mod p;
    &#62;          t2modp:= List( tblsG2, t2 -&#62; t2 mod p );
    &#62;          if IsCharacterTable( tmodp ) and
    &#62;             ForAll( t2modp, IsCharacterTable ) then
    &#62;            poss:= PossibleCharacterTablesOfTypeGV4( tmodp, t2modp,
    &#62;                       record.table, record.G2fusGV4 );
    &#62;            poss:= RepresentativesCharacterTables( poss );
    &#62;            if   Length( poss ) = 0 then
    &#62;              Print( "#I  excluded cand. ", i, " (out of ",
    &#62;                     Length( ordposs ), ") for ", name, " by ", p,
    &#62;                     "-mod. table\n" );
    &#62;              Unbind( ordposs[i] );
    &#62;              Unbind( modposs[i] );
    &#62;              checkordinary:= true;
    &#62;              break;
    &#62;            elif Length( poss ) = 1 then
    &#62;              # Compare the computed table with the library table.
    &#62;              modlib:= ordlibtblGV4 mod p;
    &#62;              if IsCharacterTable( modlib ) then
    &#62;                trans:= TransformingPermutationsCharacterTables(
    &#62;                            poss[1].table, modlib );
    &#62;                if not IsRecord( trans ) then
    &#62;                  Print( "#E  computed table and library table for ",
    &#62;                         name, " mod ", p, " differ\n" );
    &#62;                fi;
    &#62;              else
    &#62;                Print( "#I  no library table for ",
    &#62;                       name, " mod ", p, "\n" );
    &#62;                PrintToLib( name, poss[1].table );
    &#62;              fi;
    &#62;            else
    &#62;              Print( "#I  ", name, " mod ", p, ": ", Length( poss ),
    &#62;                     " equivalence classes\n" );
    &#62;            fi;
    &#62;            Add( modposs[i], poss );
    &#62;          else
    &#62;            Print( "#I  not all input tables for ", name, " mod ", p,
    &#62;                   " available\n" );
    &#62;            primes:= Difference( primes, [ p ] );
    &#62;          fi;
    &#62;        od;
    &#62;      od;
    &#62;      if checkordinary then
    &#62;        # Test whether the ordinary table is admissible.
    &#62;        ordposs:= Compacted( ordposs );
    &#62;        modposs:= Compacted( modposs );
    &#62;        reps:= RepresentativesCharacterTables( ordposs );
    &#62;        if 1 &lt; Length( reps ) then
    &#62;          Print( "#I  ", name, ": ", Length( reps ),
    &#62;                 " equivalence classes (ord. table)\n" );
    &#62;        elif Length( reps ) = 0 then
    &#62;          Print( "#E  ", name, ": no solution (ord. table)\n" );
    &#62;        else
    &#62;          # Compare the computed table with the library table.
    &#62;          trans:= TransformingPermutationsCharacterTables(
    &#62;                      ordposs[1].table, ordlibtblGV4 );
    &#62;          if not IsRecord( trans ) then
    &#62;            Print( "#E  computed table and library table for ", name,
    &#62;                   " differ\n" );
    &#62;          fi;
    &#62;          # Compare the computed fusions with the stored ones.
    &#62;          if List( ordposs[1].G2fusGV4, x -&#62; OnTuples( x, trans.columns ) )
    &#62;               &lt;&#62; List( tblsG2, x -&#62; GetFusionMap( x, ordlibtblGV4 ) ) then
    &#62;            Print( "#E  computed and stored fusions for ", name,
    &#62;                   " differ\n" );
    &#62;          fi;
    &#62;        fi;
    &#62;      fi;
    &#62;      return rec( ordinary:= ordposs, modular:= modposs );
    &#62;    end;;

</pre>

<div class="p"><!----></div>
Finally, here is the loop over the list of tables.

<div class="p"><!----></div>

<pre>
    gap&#62; for input in listGV4 do
    &#62;      tblG   := CharacterTable( input[1] );
    &#62;      tblsG2 := List( input{ [ 2 .. 4 ] }, CharacterTable );
    &#62;      lib    := CharacterTable( input[5] );
    &#62;      poss   := ConstructOrdinaryGV4Table( tblG, tblsG2, input[5], lib );
    &#62;      ConstructModularGV4Tables( tblG, tblsG2, poss, lib );
    &#62;    od;
    #I  excluded cand. 2 (out of 2) for L3(4).2^2 by 3-mod. table
    #I  excluded cand. 2 (out of 8) for 2^2.L3(4).2^2 by 7-mod. table
    #I  excluded cand. 3 (out of 8) for 2^2.L3(4).2^2 by 5-mod. table
    #I  excluded cand. 4 (out of 8) for 2^2.L3(4).2^2 by 5-mod. table
    #I  excluded cand. 5 (out of 8) for 2^2.L3(4).2^2 by 5-mod. table
    #I  excluded cand. 6 (out of 8) for 2^2.L3(4).2^2 by 5-mod. table
    #I  excluded cand. 7 (out of 8) for 2^2.L3(4).2^2 by 7-mod. table
    #I  excluded cand. 2 (out of 2) for 3.L3(4).2^2 by 3-mod. table
    #I  not all input tables for L2(49).2^2 mod 7 available
    #I  not all input tables for L2(81).2^2 mod 3 available
    #I  excluded cand. 2 (out of 2) for L3(9).2^2 by 7-mod. table
    #I  not all input tables for O8+(3).(2^2)_{122} mod 3 available
    #I  not all input tables for O8-(3).2^2 mod 2 available
    #I  not all input tables for O8-(3).2^2 mod 3 available
    #I  not all input tables for O8-(3).2^2 mod 5 available
    #I  not all input tables for O8-(3).2^2 mod 7 available
    #I  not all input tables for O8-(3).2^2 mod 13 available
    #I  not all input tables for O8-(3).2^2 mod 41 available
    #I  excluded cand. 2 (out of 2) for L3(4).D12 by 3-mod. table
    #I  excluded cand. 2 (out of 2) for 2^2.L3(4).D12 by 7-mod. table
    #I  not all input tables for O8+(3).D8 mod 3 available
    #I  not all input tables for L4(4).2^2 mod 3 available
    #I  not all input tables for L4(4).2^2 mod 5 available
    #I  not all input tables for L4(4).2^2 mod 7 available
    #I  not all input tables for L4(4).2^2 mod 17 available
    #I  not all input tables for U4(5).2^2 mod 2 available
    #I  not all input tables for U4(5).2^2 mod 3 available
    #I  not all input tables for U4(5).2^2 mod 5 available
    #I  not all input tables for U4(5).2^2 mod 7 available
    #I  not all input tables for U4(5).2^2 mod 13 available

</pre>

<div class="p"><!----></div>
The groups 3.A<sub>6</sub>.2<sup>2</sup>, 3.L<sub>3</sub>(4).2<sup>2</sup>, and 3<sub>2</sub>.U<sub>4</sub>(3).(2<sup>2</sup>)<sub>133</sub>
have also the structure M.G.A,
with M.G equal to 3.A<sub>6</sub>.2<sub>3</sub>, 3.L<sub>3</sub>(4).2<sub>1</sub>, and 3<sub>2</sub>.U<sub>4</sub>(3).2<sub>3</sub>,
respectively,
and G.A equal to A<sub>6</sub>.2<sup>2</sup>, L<sub>3</sub>(4).2<sup>2</sup>, and U<sub>4</sub>(3).(2<sup>2</sup>)<sub>133</sub>,
respectively (see Section&nbsp;<a href="#3.A_6.2^2etc">4.3</a>).

<div class="p"><!----></div>
Similarly, the group L<sub>3</sub>(4).D<sub>12</sub> has also the structure G.S<sub>3</sub>,
with G = L<sub>3</sub>(4).2<sub>1</sub>, G.2 = L<sub>3</sub>(4).2<sup>2</sup>, and G.3 = L<sub>3</sub>(4).6,
respectively (see Section&nbsp;<a href="#xplGS3">5.2</a>).

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;The Character Table of S<sub>4</sub>(9).2<sup>2</sup> (September 2011)</h3>
<div class="p"><!----></div>
The available functions yield two possibilities for the ordinary character
table of S<sub>4</sub>(9).2<sup>2</sup>.

<div class="p"><!----></div>

<pre>
    gap&#62; tblG:= CharacterTable( "S4(9)" );;
    gap&#62; tblsG2:= List( [ "S4(9).2_1", "S4(9).2_2", "S4(9).2_3" ],
    &#62;                   CharacterTable );;
    gap&#62; lib:= CharacterTable( "S4(9).2^2" );;
    gap&#62; poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, "newS4(9).2^2", lib );;
    #I  newS4(9).2^2: 2 equivalence classes
    gap&#62; poss:= RepresentativesCharacterTables( poss );;

</pre>

<div class="p"><!----></div>
The two candidates differ w.&nbsp;r.&nbsp;t. the action of S<sub>4</sub>(9).2<sup>2</sup> on the classes
of element order 80 in S<sub>4</sub>(9).2<sub>2</sub>.
In the two possible tables, each element of order 80 is conjugate to its
third power or to its 13-th power, respectively.

<div class="p"><!----></div>

<pre>
    gap&#62; order80:= PositionsProperty( OrdersClassRepresentatives( tblsG2[2] ),
    &#62;                  x -&#62; x = 80 );
    [ 98, 99, 100, 101, 102, 103, 104, 105 ]
    gap&#62; List( poss, r -&#62; r.G2fusGV4[2]{ order80 } );
    [ [ 77, 77, 78, 79, 80, 78, 79, 80 ], [ 77, 78, 79, 79, 77, 80, 80, 78 ] ]
    gap&#62; PowerMap( tblsG2[2], 3 ){ order80 };
    [ 99, 98, 103, 104, 105, 100, 101, 102 ]
    gap&#62; PowerMap( tblsG2[2], 13 ){ order80 };
    [ 102, 105, 101, 100, 98, 104, 103, 99 ]

</pre>

<div class="p"><!----></div>
We claim that the first candidate is the correct one.
For that, first note that S<sub>4</sub>(9).2<sub>2</sub> is the extension of the simple group
by a diagonal automorphism.
(An easy way to see this is that for any subgroup of S<sub>4</sub>(9)
isomorphic with S<sub>2</sub>(81)  &#8773; L<sub>2</sub>(81), the extension by a diagonal
automorphism contains elements of order 80 -this group is isomorphic with
PGL(2,81)- and only S<sub>4</sub>(9).2<sub>2</sub> contains elements of order 80.)

<div class="p"><!----></div>

<pre>
    gap&#62; List( tblsG2, x -&#62; 80 in OrdersClassRepresentatives( x ) );
    [ false, true, false ]

</pre>

<div class="p"><!----></div>
Now the field automorphism of S<sub>4</sub>(9).2<sub>2</sub> maps each element x of order 80
in S<sub>4</sub>(9).2<sub>2</sub> to a conjugate of x<sup>3</sup>.

<div class="p"><!----></div>

<pre>
    gap&#62; tbl:= poss[1].table;;
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( tbl, lib ) );
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.4">
6.4</a>&nbsp;&nbsp;The Character Tables of Groups of the Type 2.L<sub>3</sub>(4).2<sup>2</sup>
(June 2010)</h3><a name="2L34V4">
</a>

<div class="p"><!----></div>
The outer automorphism group of the group L<sub>3</sub>(4) is a dihedral group
of order 12; its Sylow 2-subgroups are Klein four groups,
so there is a unique almost simple group H of the type L<sub>3</sub>(4).2<sup>2</sup>,
up to isomorphism.
In this section, we construct the character tables of the double covers
of this group with the approach from Section&nbsp;<a href="#theorGV4">3.3</a>.

<div class="p"><!----></div>
The group H has three subgroups of index two,
of the types L<sub>3</sub>(4).2<sub>1</sub>, L<sub>3</sub>(4).2<sub>2</sub>, and L<sub>3</sub>(4).2<sub>3</sub>, respectively.
So any double cover of H contains one subgroup of each of the types
2.L<sub>3</sub>(4).2<sub>1</sub>, 2.L<sub>3</sub>(4).2<sub>2</sub>, and 2.L<sub>3</sub>(4).2<sub>3</sub>,
and there are two isoclinic variants of each of these group to consider,
see Section&nbsp;<a href="#isoclinicATLAS">2.5</a>.
So we start with eight different inputs for the construction of the
character tables of double covers.

<div class="p"><!----></div>

<pre>
    gap&#62; names:= List( [ 1 .. 3 ],
    &#62;                  i -&#62; Concatenation( "2.L3(4).2_", String( i ) ) );;
    gap&#62; tbls:= List( names, CharacterTable );
    [ CharacterTable( "2.L3(4).2_1" ), CharacterTable( "2.L3(4).2_2" ), 
      CharacterTable( "2.L3(4).2_3" ) ]
    gap&#62; isos:= List( names, nam -&#62; CharacterTable( Concatenation( nam, "*" ) ) );
    [ CharacterTable( "Isoclinic(2.L3(4).2_1)" ), 
      CharacterTable( "Isoclinic(2.L3(4).2_2)" ), 
      CharacterTable( "Isoclinic(2.L3(4).2_3)" ) ]
    gap&#62; inputs:= [
    &#62; [ tbls[1], tbls[2], tbls[3], "2.L3(4).(2^2)_{123}" ],
    &#62; [ tbls[1], isos[2], tbls[3], "2.L3(4).(2^2)_{12*3}" ],
    &#62; [ tbls[1], tbls[2], isos[3], "2.L3(4).(2^2)_{123*}" ],
    &#62; [ tbls[1], isos[2], isos[3], "2.L3(4).(2^2)_{12*3*}" ],
    &#62; [ isos[1], tbls[2], tbls[3], "2.L3(4).(2^2)_{1*23}" ],
    &#62; [ isos[1], isos[2], tbls[3], "2.L3(4).(2^2)_{1*2*3}" ],
    &#62; [ isos[1], tbls[2], isos[3], "2.L3(4).(2^2)_{1*23*}" ],
    &#62; [ isos[1], isos[2], isos[3], "2.L3(4).(2^2)_{1*2*3*}" ] ];;
    gap&#62; tblG:= CharacterTable( "2.L3(4)" );;
    gap&#62; result:= [];;
    gap&#62; for input in inputs do
    &#62;      tblsG2:= input{ [ 1 .. 3 ] };
    &#62;      lib:= CharacterTable( input[4] );
    &#62;      poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );
    &#62;      ConstructModularGV4Tables( tblG, tblsG2, poss, lib );
    &#62;      Append( result, RepresentativesCharacterTables( poss ) );
    &#62;    od;
    #I  excluded cand. 2 (out of 8) for 2.L3(4).(2^2)_{123} by 5-mod. table
    #I  excluded cand. 3 (out of 8) for 2.L3(4).(2^2)_{123} by 5-mod. table
    #I  excluded cand. 4 (out of 8) for 2.L3(4).(2^2)_{123} by 7-mod. table
    #I  excluded cand. 5 (out of 8) for 2.L3(4).(2^2)_{123} by 7-mod. table
    #I  excluded cand. 6 (out of 8) for 2.L3(4).(2^2)_{123} by 5-mod. table
    #I  excluded cand. 7 (out of 8) for 2.L3(4).(2^2)_{123} by 5-mod. table
    #I  excluded cand. 2 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 5-mod. table
    #I  excluded cand. 3 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 5-mod. table
    #I  excluded cand. 4 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 7-mod. table
    #I  excluded cand. 5 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 7-mod. table
    #I  excluded cand. 6 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 5-mod. table
    #I  excluded cand. 7 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 5-mod. table
    #I  excluded cand. 2 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 5-mod. table
    #I  excluded cand. 3 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 5-mod. table
    #I  excluded cand. 4 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 7-mod. table
    #I  excluded cand. 5 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 7-mod. table
    #I  excluded cand. 6 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 5-mod. table
    #I  excluded cand. 7 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 5-mod. table
    #I  excluded cand. 2 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 5-mod. table
    #I  excluded cand. 3 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 5-mod. table
    #I  excluded cand. 4 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 7-mod. table
    #I  excluded cand. 5 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 7-mod. table
    #I  excluded cand. 6 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 5-mod. table
    #I  excluded cand. 7 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 5-mod. table
    gap&#62; result:= List( result, x -&#62; x.table );
    [ CharacterTable( "new2.L3(4).(2^2)_{123}" ), 
      CharacterTable( "new2.L3(4).(2^2)_{12*3}" ), 
      CharacterTable( "new2.L3(4).(2^2)_{123*}" ), 
      CharacterTable( "new2.L3(4).(2^2)_{12*3*}" ), 
      CharacterTable( "new2.L3(4).(2^2)_{1*23}" ), 
      CharacterTable( "new2.L3(4).(2^2)_{1*2*3}" ), 
      CharacterTable( "new2.L3(4).(2^2)_{1*23*}" ), 
      CharacterTable( "new2.L3(4).(2^2)_{1*2*3*}" ) ]

</pre>

<div class="p"><!----></div>
We get exactly one character table for each input.
For each of these tables, there are three possibilities to form an
isoclinic table, corresponding to the three subgroups of index two.
It turns out that the eight solutions form two orbits under forming
some isoclinic table.
Tables in different orbits are essentially different,
already their numbers of conjugacy classes differ.

<div class="p"><!----></div>

<pre>
    gap&#62; List( result, NrConjugacyClasses );
    [ 39, 33, 33, 39, 33, 39, 39, 33 ]
    gap&#62; t:= result[1];;
    gap&#62; nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
    &#62;            x -&#62; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
    gap&#62; iso:= List( nsg, x -&#62; CharacterTableIsoclinic( t, x ) );;
    gap&#62; List( iso, x -&#62; PositionProperty( result, y -&#62;
    &#62;            TransformingPermutationsCharacterTables( x, y ) &lt;&#62; fail ) );
    [ 4, 7, 6 ]
    gap&#62; t:= result[2];;
    gap&#62; nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
    &#62;            x -&#62; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
    gap&#62; iso:= List( nsg, x -&#62; CharacterTableIsoclinic( t, x ) );;
    gap&#62; List( iso, x -&#62; PositionProperty( result, y -&#62;
    &#62;            TransformingPermutationsCharacterTables( x, y ) &lt;&#62; fail ) );
    [ 3, 8, 5 ]

</pre>

<div class="p"><!----></div>
Up to now, it is not clear that the character tables we have constructed
are really the character tables of some groups.
The existence of groups for the first orbit of character tables
can be established as follows.

<div class="p"><!----></div>
The group U<sub>6</sub>(2).2 contains a maximal subgroup M of the type L<sub>3</sub>(4).2<sup>2</sup>,
see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;115].
Its derived subgroup M&#8242; of the type L<sub>3</sub>(4) lies inside U<sub>6</sub>(2),
and we claim that the preimage of M&#8242; under the natural epimorphism from
2.U<sub>6</sub>(2) to U<sub>6</sub>(2) is a double cover of L<sub>3</sub>(4).
Unfortunately, L<sub>3</sub>(4) admits class fusions into 2.U<sub>6</sub>(2),
so this criterion cannot be used.

<div class="p"><!----></div>

<pre>
    gap&#62; l34:= CharacterTable( "L3(4)" );;
    gap&#62; u:= CharacterTable( "U6(2)" );;
    gap&#62; 2u:= CharacterTable( "2.U6(2)" );;
    gap&#62; cand:= PossibleClassFusions( l34, 2u );
    [ [ 1, 5, 12, 16, 22, 22, 23, 23, 41, 41 ], 
      [ 1, 5, 12, 22, 16, 22, 23, 23, 41, 41 ], 
      [ 1, 5, 12, 22, 22, 16, 23, 23, 41, 41 ] ]
    gap&#62; OrdersClassRepresentatives( l34 );
    [ 1, 2, 3, 4, 4, 4, 5, 5, 7, 7 ]

</pre>

<div class="p"><!----></div>
Consider the three classes of elements of order four in L<sub>3</sub>(4).
Under the possible fusions into 2.U<sub>6</sub>(2),
they are mapped to the classes 16 and 22,
which are preimages of the classes 10 and 14 (<tt>4C</tt> and <tt>4G</tt>) of U<sub>6</sub>(2).
Note that the maximal subgroups of type L<sub>3</sub>(4).2 in U<sub>6</sub>(2) extend to
L<sub>3</sub>(4).6 type subgroups in U<sub>6</sub>(2).3,
and the three classes <tt>4C</tt>, <tt>4D</tt>, <tt>4E</tt> form one orbit under the action of an
outer automorphism of order three of U<sub>6</sub>(2).

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( 2u, u ){ [ 16, 22 ] };
    [ 10, 14 ]
    gap&#62; ClassNames( u, "ATLAS" ){ [ 10, 14 ] };
    [ "4C", "4G" ]
    gap&#62; GetFusionMap( u, CharacterTable( "U6(2).3" ) );
    [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 
      20, 21, 22, 23, 24, 24, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 
      36, 36, 37, 38, 39, 40 ]

</pre>

<div class="p"><!----></div>
This means that any L<sub>3</sub>(4) type subgroup of U<sub>6</sub>(2) that extends to an
L<sub>3</sub>(4).6 type subgroup in U<sub>6</sub>(2).3 either contains elements from all
thrre classes <tt>4C</tt>, <tt>4D</tt>, <tt>4E</tt> of U<sub>6</sub>(2), or contains no element from
these classes.
Thus we know that any double cover of U<sub>6</sub>(2).2 contains a double cover of
L<sub>3</sub>(4).2<sup>2</sup>.
Only the first of our result tables admits a class fusion into the table
of 2.U<sub>6</sub>(2).2.

<div class="p"><!----></div>

<pre>
    gap&#62; 2u2:= CharacterTable( "2.U6(2).2" );;
    gap&#62; fus:= List( result, x -&#62; PossibleClassFusions( x, 2u2 ) );;
    gap&#62; List( fus, Length );
    [ 4, 0, 0, 0, 0, 0, 0, 0 ]

</pre>

<div class="p"><!----></div>
As a consequence, the fourth result table is established
as that of a maximal subgroup of the group isoclinic to 2.U<sub>6</sub>(2).2.

<div class="p"><!----></div>

<pre>
    gap&#62; 2u2iso:= CharacterTableIsoclinic( 2u2 );;
    gap&#62; fus:= List( result, x -&#62; PossibleClassFusions( x, 2u2iso ) );;
    gap&#62; List( fus, Length );
    [ 0, 0, 0, 4, 0, 0, 0, 0 ]

</pre>

<div class="p"><!----></div>
Similarly, the group HS.2 contains a maximal subgroup M of the type
L<sub>3</sub>(4).2<sup>2</sup>, see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;80].
Its derived subgroup M&#8242; of the type L<sub>3</sub>(4) lies inside HS,
and the preimage of M&#8242; under the natural epimorphism from
2.HS to HS is a double cover of L<sub>3</sub>(4),
because L<sub>3</sub>(4) does not admit a class fusion into 2.HS.2.

<div class="p"><!----></div>

<pre>
    gap&#62; h2:= CharacterTable( "HS.2" );;
    gap&#62; 2h2:= CharacterTable( "2.HS.2" );;
    gap&#62; PossibleClassFusions( l34, 2h2 );
    [  ]

</pre>

<div class="p"><!----></div>
Only the fifth of our result tables admits a class fusion into 2.HS.2,
which means that 2.L<sub>3</sub>(4).(2<sup>2</sup>)<sub>1&#8727;23</sub> is a subgroup of 2.HS.2,
and the eighth result table -2.L<sub>3</sub>(4).(2<sup>2</sup>)<sub>1&#8727;2&#8727;3&#8727;</sub>-
admits a class fusion into the isoclinic variant of 2.HS.2
This shows the existence of groups for the tables from the second orbit.

<div class="p"><!----></div>

<pre>
    gap&#62; fus:= List( result, x -&#62; PossibleClassFusions( x, 2h2 ) );;
    gap&#62; List( fus, Length );
    [ 0, 0, 0, 0, 4, 0, 0, 0 ]
    gap&#62; 2h2iso:= CharacterTableIsoclinic( 2h2 );;
    gap&#62; fus:= List( result, x -&#62; PossibleClassFusions( x, 2h2iso ) );;
    gap&#62; List( fus, Length );
    [ 0, 0, 0, 0, 0, 0, 0, 4 ]

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.5">
6.5</a>&nbsp;&nbsp;The Character Tables of Groups of the Type 6.L<sub>3</sub>(4).2<sup>2</sup>
(October 2011)</h3><a name="6L34V4">
</a>

<div class="p"><!----></div>
We have two approaches for constructing the character tables of these groups.

<div class="p"><!----></div>
First, we may regard them as normal products of the three normal subgroups
of index two, each of them having the structure 6.L<sub>3</sub>(4).2,
and use the approach from Section&nbsp;<a href="#theorGV4">3.3</a>,
as we did in Section&nbsp;<a href="#2L34V4">6.4</a> for the groups of the structure
2.L<sub>3</sub>(4).2<sup>2</sup>.

<div class="p"><!----></div>
Second, we may use the approach from Section&nbsp;<a href="#theorMGA">3.1</a>.
Note that the factor group L<sub>3</sub>(4).2<sup>2</sup> contains each of the three groups
L<sub>3</sub>(4).2<sub>i</sub> as a subgroup, for 1  &#8804; i  &#8804; 3,
and the groups of the type 6.L<sub>3</sub>(4).2<sub>1</sub> have a centre of order six,
whereas the centres of the 6.L<sub>3</sub>(4).2<sub>2</sub> and 6.L<sub>3</sub>(4).2<sub>3</sub> type groups
have order two.
For that, the character tables of the subgroups 6.L<sub>3</sub>(4).2<sub>1</sub> and
6.L<sub>3</sub>(4).2<sub>1</sub><sup>&#8727;</sup> are needed,
as well as the character tables of the eight possible factor groups
2.L<sub>3</sub>(4).2<sup>2</sup>; the latter tables are known from Section&nbsp;<a href="#2L34V4">6.4</a>.

<div class="p"><!----></div>
We show both approaches.
(The second approach is better suited for storing the character tables
in the Character Table Library, since the irreducible characters need not
be stored, and since the Brauer tables of the groups can be derived from
the Brauer tables of the compound tables.)

<div class="p"><!----></div>

<pre>
    gap&#62; tbls:= List( [ "1", "2", "3" ],
    &#62;      i -&#62; CharacterTable( Concatenation( "6.L3(4).2_", i ) ) );
    [ CharacterTable( "6.L3(4).2_1" ), CharacterTable( "6.L3(4).2_2" ), 
      CharacterTable( "6.L3(4).2_3" ) ]
    gap&#62; isos:= List( [ "1", "2", "3" ],
    &#62;      i -&#62; CharacterTable( Concatenation( "6.L3(4).2_", i, "*" ) ) );
    [ CharacterTable( "Isoclinic(6.L3(4).2_1)" ), 
      CharacterTable( "Isoclinic(6.L3(4).2_2)" ), 
      CharacterTable( "Isoclinic(6.L3(4).2_3)" ) ]
    gap&#62; inputs:= [
    &#62; [ tbls[1], tbls[2], tbls[3], "6.L3(4).(2^2)_{123}" ],
    &#62; [ tbls[1], isos[2], tbls[3], "6.L3(4).(2^2)_{12*3}" ],
    &#62; [ tbls[1], tbls[2], isos[3], "6.L3(4).(2^2)_{123*}" ],
    &#62; [ tbls[1], isos[2], isos[3], "6.L3(4).(2^2)_{12*3*}" ],
    &#62; [ isos[1], tbls[2], tbls[3], "6.L3(4).(2^2)_{1*23}" ],
    &#62; [ isos[1], isos[2], tbls[3], "6.L3(4).(2^2)_{1*2*3}" ],
    &#62; [ isos[1], tbls[2], isos[3], "6.L3(4).(2^2)_{1*23*}" ],
    &#62; [ isos[1], isos[2], isos[3], "6.L3(4).(2^2)_{1*2*3*}" ] ];;
    gap&#62; tblG:= CharacterTable( "6.L3(4)" );;
    gap&#62; result:= [];;
    gap&#62; for input in inputs do
    &#62;      tblsG2:= input{ [ 1 .. 3 ] };
    &#62;      lib:= CharacterTable( input[4] );
    &#62;      poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );
    &#62;      ConstructModularGV4Tables( tblG, tblsG2, poss, lib );
    &#62;      Append( result, RepresentativesCharacterTables( poss ) );
    &#62;    od;
    #I  excluded cand. 2 (out of 8) for 6.L3(4).(2^2)_{123} by 5-mod. table
    #I  excluded cand. 3 (out of 8) for 6.L3(4).(2^2)_{123} by 5-mod. table
    #I  excluded cand. 4 (out of 8) for 6.L3(4).(2^2)_{123} by 7-mod. table
    #I  excluded cand. 5 (out of 8) for 6.L3(4).(2^2)_{123} by 7-mod. table
    #I  excluded cand. 6 (out of 8) for 6.L3(4).(2^2)_{123} by 5-mod. table
    #I  excluded cand. 7 (out of 8) for 6.L3(4).(2^2)_{123} by 5-mod. table
    #I  excluded cand. 2 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 5-mod. table
    #I  excluded cand. 3 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 5-mod. table
    #I  excluded cand. 4 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 7-mod. table
    #I  excluded cand. 5 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 7-mod. table
    #I  excluded cand. 6 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 5-mod. table
    #I  excluded cand. 7 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 5-mod. table
    #I  excluded cand. 2 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 5-mod. table
    #I  excluded cand. 3 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 5-mod. table
    #I  excluded cand. 4 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 7-mod. table
    #I  excluded cand. 5 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 7-mod. table
    #I  excluded cand. 6 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 5-mod. table
    #I  excluded cand. 7 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 5-mod. table
    #I  excluded cand. 2 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 5-mod. table
    #I  excluded cand. 3 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 5-mod. table
    #I  excluded cand. 4 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 7-mod. table
    #I  excluded cand. 5 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 7-mod. table
    #I  excluded cand. 6 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 5-mod. table
    #I  excluded cand. 7 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 5-mod. table
    gap&#62; result:= List( result, x -&#62; x.table );
    [ CharacterTable( "new6.L3(4).(2^2)_{123}" ), 
      CharacterTable( "new6.L3(4).(2^2)_{12*3}" ), 
      CharacterTable( "new6.L3(4).(2^2)_{123*}" ), 
      CharacterTable( "new6.L3(4).(2^2)_{12*3*}" ), 
      CharacterTable( "new6.L3(4).(2^2)_{1*23}" ), 
      CharacterTable( "new6.L3(4).(2^2)_{1*2*3}" ), 
      CharacterTable( "new6.L3(4).(2^2)_{1*23*}" ), 
      CharacterTable( "new6.L3(4).(2^2)_{1*2*3*}" ) ]

</pre>

<div class="p"><!----></div>
As in Section&nbsp;<a href="#2L34V4">6.4</a>,
we get exactly one character table for each input,
and the eight solutions lie in two orbits under isoclinism.

<div class="p"><!----></div>

<pre>
    gap&#62; List( result, NrConjugacyClasses );
    [ 59, 53, 53, 59, 53, 59, 59, 53 ]
    gap&#62; t:= result[1];;
    gap&#62; nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
    &#62;            x -&#62; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
    gap&#62; iso:= List( nsg, x -&#62; CharacterTableIsoclinic( t, x ) );;
    gap&#62; List( iso, x -&#62; PositionProperty( result, y -&#62;
    &#62;            TransformingPermutationsCharacterTables( x, y ) &lt;&#62; fail ) );
    [ 7, 6, 4 ]
    gap&#62; t:= result[2];;
    gap&#62; nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
    &#62;            x -&#62; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
    gap&#62; iso:= List( nsg, x -&#62; CharacterTableIsoclinic( t, x ) );;
    gap&#62; List( iso, x -&#62; PositionProperty( result, y -&#62;
    &#62;            TransformingPermutationsCharacterTables( x, y ) &lt;&#62; fail ) );
    [ 8, 5, 3 ]

</pre>

<div class="p"><!----></div>
Up to now, it is not clear that the character tables we have constructed
are really the character tables of some groups.
The existence of groups for the first orbit of character tables
can be established as follows.

<div class="p"><!----></div>
We have shown in Section&nbsp;<a href="#2L34V4">6.4</a> that the maximal subgroups M
of the type L<sub>3</sub>(4).2<sup>2</sup> in U<sub>6</sub>(2).2 lift to double covers 2.L<sub>3</sub>(4).2<sup>2</sup>
in 2.U<sub>6</sub>(2).2.
The preimages of these groups under the natural epimorphism from 6.U<sub>6</sub>(2).2
have the structure 6.L<sub>3</sub>(4).2<sup>2</sup>, where the derived subgroup is the
six-fold cover of L<sub>3</sub>(4);
this follows from the fact that 6.U<sub>6</sub>(2) does not admit a class fusion
from the double cover 2.L<sub>3</sub>(4).

<div class="p"><!----></div>

<pre>
    gap&#62; 2l34:= CharacterTable( "2.L3(4)" );;
    gap&#62; 6u:= CharacterTable( "6.U6(2)" );;
    gap&#62; cand:= PossibleClassFusions( 2l34, 6u );
    [  ]

</pre>

<div class="p"><!----></div>
This establishes the first and the fourth result as character tables
of subgroups of 6.U<sub>6</sub>(2) and its isoclinic variant, respectively.

<div class="p"><!----></div>

<pre>
    gap&#62; 6u2:= CharacterTable( "6.U6(2).2" );;
    gap&#62; fus:= List( result, x -&#62; PossibleClassFusions( x, 6u2 ) );;
    gap&#62; List( fus, Length );
    [ 8, 0, 0, 0, 0, 0, 0, 0 ]
    gap&#62; 6u2iso:= CharacterTableIsoclinic( 6u2 );;
    gap&#62; fus:= List( result, x -&#62; PossibleClassFusions( x, 6u2iso ) );;
    gap&#62; List( fus, Length );
    [ 0, 0, 0, 8, 0, 0, 0, 0 ]

</pre>

<div class="p"><!----></div>
Similarly, the group G<sub>2</sub>(4).2 contains a maximal subgroup M of the type
3.L<sub>3</sub>(4).2<sup>2</sup>, see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;97].
Its derived subgroup M&#8242; of the type 3.L<sub>3</sub>(4) lies inside G<sub>2</sub>(4),
and the preimage of M&#8242; under the natural epimorphism from
2.G<sub>2</sub>(4) to G<sub>2</sub>(4) is a double cover of 3.L<sub>3</sub>(4),
because 3.L<sub>3</sub>(4) does not admit a class fusion into 2.G<sub>2</sub>(4).2.

<div class="p"><!----></div>

<pre>
    gap&#62; 3l34:= CharacterTable( "3.L3(4)" );;
    gap&#62; g2:= CharacterTable( "G2(4).2" );;
    gap&#62; 2g2:= CharacterTable( "2.G2(4).2" );;
    gap&#62; PossibleClassFusions( 3l34, 2g2 );
    [  ]

</pre>

<div class="p"><!----></div>
Only the third and eighth of our result tables admit a class fusion into
2.G<sub>2</sub>(4).2 and its isoclinic variant, respectively.
This shows the existence of groups for the tables from the second orbit.

<div class="p"><!----></div>

<pre>
    gap&#62; fus:= List( result, x -&#62; PossibleClassFusions( x, 2g2 ) );;
    gap&#62; List( fus, Length );
    [ 0, 0, 16, 0, 0, 0, 0, 0 ]
    gap&#62; 2g2iso:= CharacterTableIsoclinic( 2g2 );;
    gap&#62; fus:= List( result, x -&#62; PossibleClassFusions( x, 2g2iso ) );;
    gap&#62; List( fus, Length );
    [ 0, 0, 0, 0, 0, 0, 0, 16 ]

</pre>

<div class="p"><!----></div>
Now we try the second approach and compare the results.

<div class="p"><!----></div>

<pre>
    gap&#62; names:= [ "L3(4).(2^2)_{123}", "L3(4).(2^2)_{12*3}",
    &#62;              "L3(4).(2^2)_{123*}", "L3(4).(2^2)_{12*3*}" ];;
    gap&#62; inputs1:= List( names, nam -&#62; [ "6.L3(4).2_1", "2.L3(4).2_1",
    &#62;                Concatenation( "2.", nam ), Concatenation( "6.", nam ) ] );;
    gap&#62; names:= List( names, nam -&#62; ReplacedString( nam, "1", "1*" ) );;
    gap&#62; inputs2:= List( names, nam -&#62; [ "6.L3(4).2_1*", "2.L3(4).2_1*",
    &#62;                Concatenation( "2.", nam ), Concatenation( "6.", nam ) ] );;
    gap&#62; inputs:= Concatenation( inputs1, inputs2 );
    [ [ "6.L3(4).2_1", "2.L3(4).2_1", "2.L3(4).(2^2)_{123}", 
          "6.L3(4).(2^2)_{123}" ], 
      [ "6.L3(4).2_1", "2.L3(4).2_1", "2.L3(4).(2^2)_{12*3}", 
          "6.L3(4).(2^2)_{12*3}" ], 
      [ "6.L3(4).2_1", "2.L3(4).2_1", "2.L3(4).(2^2)_{123*}", 
          "6.L3(4).(2^2)_{123*}" ], 
      [ "6.L3(4).2_1", "2.L3(4).2_1", "2.L3(4).(2^2)_{12*3*}", 
          "6.L3(4).(2^2)_{12*3*}" ], 
      [ "6.L3(4).2_1*", "2.L3(4).2_1*", "2.L3(4).(2^2)_{1*23}", 
          "6.L3(4).(2^2)_{1*23}" ], 
      [ "6.L3(4).2_1*", "2.L3(4).2_1*", "2.L3(4).(2^2)_{1*2*3}", 
          "6.L3(4).(2^2)_{1*2*3}" ], 
      [ "6.L3(4).2_1*", "2.L3(4).2_1*", "2.L3(4).(2^2)_{1*23*}", 
          "6.L3(4).(2^2)_{1*23*}" ], 
      [ "6.L3(4).2_1*", "2.L3(4).2_1*", "2.L3(4).(2^2)_{1*2*3*}", 
          "6.L3(4).(2^2)_{1*2*3*}" ] ]
    gap&#62; result2:= [];;
    gap&#62; for  input in inputs do
    &#62;      tblMG := CharacterTable( input[1] );
    &#62;      tblG  := CharacterTable( input[2] );
    &#62;      tblGA := CharacterTable( input[3] );
    &#62;      name  := Concatenation( "new", input[4] );
    &#62;      lib   := CharacterTable( input[4] );
    &#62;      poss:= ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );
    &#62;      Append( result2, poss );
    &#62;    od;
    gap&#62; result2:= List( result2, x -&#62; x.table );
    [ CharacterTable( "new6.L3(4).(2^2)_{123}" ), 
      CharacterTable( "new6.L3(4).(2^2)_{12*3}" ), 
      CharacterTable( "new6.L3(4).(2^2)_{123*}" ), 
      CharacterTable( "new6.L3(4).(2^2)_{12*3*}" ), 
      CharacterTable( "new6.L3(4).(2^2)_{1*23}" ), 
      CharacterTable( "new6.L3(4).(2^2)_{1*2*3}" ), 
      CharacterTable( "new6.L3(4).(2^2)_{1*23*}" ), 
      CharacterTable( "new6.L3(4).(2^2)_{1*2*3*}" ) ]
    gap&#62; trans:= List( [ 1 .. 8 ], i -&#62;
    &#62;        TransformingPermutationsCharacterTables( result[i], result2[i] ) );;
    gap&#62; ForAll( trans, IsRecord );
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.6">
6.6</a>&nbsp;&nbsp;The Character Tables of Groups of the Type 2.U<sub>4</sub>(3).2<sup>2</sup>
(February 2012)</h3><a name="2U43V4">
</a>

<div class="p"><!----></div>
The outer automorphism group of the group U<sub>4</sub>(3) is a dihedral group
of order 8.
There are two almost simple groups of the type U<sub>4</sub>(3).2<sup>2</sup>,
up to isomorphism, denoted as U<sub>4</sub>(3).(2<sup>2</sup>)<sub>122</sub> and U<sub>4</sub>(3).(2<sup>2</sup>)<sub>133</sub>,
respectively.
Note that U<sub>4</sub>(3).2<sub>1</sub> is the extension by the central involution of the
outer automorphism group of U<sub>4</sub>(3),
the other two subgroups of index two in U<sub>4</sub>(3).(2<sup>2</sup>)<sub>122</sub> are
U<sub>4</sub>(3).2<sub>2</sub> and U<sub>4</sub>(3).2<sup>&#8242;</sup><sub>2</sub>, respectively,
and the other two subgroups of index two in U<sub>4</sub>(3).(2<sup>2</sup>)<sub>133</sub> are
U<sub>4</sub>(3).2<sub>3</sub> and U<sub>4</sub>(3).2<sup>&#8242;</sup><sub>3</sub>, respectively.

<div class="p"><!----></div>
Since <span class="roman">Aut</span>( U<sub>4</sub>(3) ) possesses a double cover (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;52]),
double covers of U<sub>4</sub>(3).(2<sup>2</sup>)<sub>122</sub> and U<sub>4</sub>(3).(2<sup>2</sup>)<sub>133</sub> exist.

<div class="p"><!----></div>
First we deal with the double covers of U<sub>4</sub>(3).(2<sup>2</sup>)<sub>122</sub>.
Any such group contains one subgroup of the type 2.U<sub>4</sub>(3).2<sub>1</sub> and two
subgroups of the type 2.U<sub>4</sub>(3).2<sub>2</sub>,
and there are two isoclinic variants of each of these group to consider,
see Section&nbsp;<a href="#isoclinicATLAS">2.5</a>.
Thus we start with six different inputs for the construction of the
character tables of double covers.

<div class="p"><!----></div>

<pre>
    gap&#62; tbls:= List( [ "1", "2", "2'" ], i -&#62;
    &#62;      CharacterTable( Concatenation( "2.U4(3).2_", i ) ) );;
    gap&#62; isos:= List( [ "1", "2", "2'" ], i -&#62;
    &#62;      CharacterTable( Concatenation( "Isoclinic(2.U4(3).2_", i, ")" ) ) );;
    gap&#62; inputs:= [
    &#62; [ tbls[1], tbls[2], tbls[3], "2.U4(3).(2^2)_{122}" ],
    &#62; [ isos[1], tbls[2], tbls[3], "2.U4(3).(2^2)_{1*22}" ],
    &#62; [ tbls[1], isos[2], tbls[3], "2.U4(3).(2^2)_{12*2}" ],
    &#62; [ isos[1], isos[2], tbls[3], "2.U4(3).(2^2)_{1*2*2}" ],
    &#62; [ tbls[1], isos[2], isos[3], "2.U4(3).(2^2)_{12*2*}" ],
    &#62; [ isos[1], isos[2], isos[3], "2.U4(3).(2^2)_{1*2*2*}" ] ];;
    gap&#62; tblG:= CharacterTable( "2.U4(3)" );;
    gap&#62; result:= [];;
    gap&#62; for input in inputs do
    &#62;      tblsG2:= input{ [ 1 .. 3 ] };
    &#62;      lib:= CharacterTable( input[4] );
    &#62;      poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );
    &#62;      ConstructModularGV4Tables( tblG, tblsG2, poss, lib );
    &#62;      Append( result, RepresentativesCharacterTables( poss ) );
    &#62;    od;
    gap&#62; result:= List( result, x -&#62; x.table );
    [ CharacterTable( "new2.U4(3).(2^2)_{122}" ), 
      CharacterTable( "new2.U4(3).(2^2)_{1*22}" ), 
      CharacterTable( "new2.U4(3).(2^2)_{12*2}" ), 
      CharacterTable( "new2.U4(3).(2^2)_{1*2*2}" ), 
      CharacterTable( "new2.U4(3).(2^2)_{12*2*}" ), 
      CharacterTable( "new2.U4(3).(2^2)_{1*2*2*}" ) ]

</pre>

<div class="p"><!----></div>
We get exactly one character table for each input.
For each of these tables, there are three possibilities to form an
isoclinic table, corresponding to the three subgroups of index two.
It turns out that the six solutions form two orbits under forming
some isoclinic table.
Tables in different orbits are essentially different,
already their numbers of conjugacy classes differ.

<div class="p"><!----></div>

<pre>
    gap&#62; List( result, NrConjugacyClasses );
    [ 87, 102, 102, 87, 87, 102 ]
    gap&#62; t:= result[1];;
    gap&#62; nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
    &#62;            x -&#62; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
    gap&#62; iso:= List( nsg, x -&#62; CharacterTableIsoclinic( t, x ) );;
    gap&#62; List( iso, x -&#62; PositionProperty( result, y -&#62;
    &#62;            TransformingPermutationsCharacterTables( x, y ) &lt;&#62; fail ) );
    [ 4, 4, 5 ]
    gap&#62; t:= result[2];;
    gap&#62; nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
    &#62;            x -&#62; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
    gap&#62; iso:= List( nsg, x -&#62; CharacterTableIsoclinic( t, x ) );;
    gap&#62; List( iso, x -&#62; PositionProperty( result, y -&#62;
    &#62;            TransformingPermutationsCharacterTables( x, y ) &lt;&#62; fail ) );
    [ 3, 3, 6 ]

</pre>

<div class="p"><!----></div>
Up to now, it is not clear that the character tables we have constructed
are really the character tables of some groups.
The existence of groups for the first orbit of character tables
can be established as follows.

<div class="p"><!----></div>
The group O<sub>8</sub><sup>+</sup>(3) contains maximal subgroups of the type 2.U<sub>4</sub>(3).2<sup>2</sup>,
see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;140].
Only the first of our result tables admits a class fusion into the table
of O<sub>8</sub><sup>+</sup>(3).

<div class="p"><!----></div>

<pre>
    gap&#62; u:= CharacterTable( "O8+(3)" );;
    gap&#62; fus:= List( result, x -&#62; PossibleClassFusions( x, u ) );;
    gap&#62; List( fus, Length );
    [ 24, 0, 0, 0, 0, 0 ]

</pre>

<div class="p"><!----></div>
A table in the second orbit belongs to a maximal subgroup of O<sub>7</sub>(3).2,
see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;109].

<div class="p"><!----></div>

<pre>
    gap&#62; u:= CharacterTable( "O7(3).2" );;
    gap&#62; fus:= List( result, x -&#62; PossibleClassFusions( x, u ) );;
    gap&#62; List( fus, Length );
    [ 0, 16, 0, 0, 0, 0 ]

</pre>

<div class="p"><!----></div>
Note that this subgroup of O<sub>7</sub>(3).2  &#8773; SO(7,3)
is the orthogonal group GO<sub>6</sub><sup>&#8722;</sup>(3).

<div class="p"><!----></div>

<div class="p"><!----></div>
Now we deal with the double covers of U<sub>4</sub>(3).(2<sup>2</sup>)<sub>133</sub>.
The constructions of the character tables are completely analogous
to those in the case of U<sub>4</sub>(3).(2<sup>2</sup>)<sub>122</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; tbls:= List( [ "1", "3", "3'" ],
    &#62;      i -&#62; CharacterTable( Concatenation( "2.U4(3).2_", i ) ) );;
    gap&#62; isos:= List( [ "1", "3", "3'" ], i -&#62;
    &#62;      CharacterTable( Concatenation( "Isoclinic(2.U4(3).2_", i, ")" ) ) );;
    gap&#62; inputs:= [
    &#62; [ tbls[1], tbls[2], tbls[3], "2.U4(3).(2^2)_{133}" ],
    &#62; [ isos[1], tbls[2], tbls[3], "2.U4(3).(2^2)_{1*33}" ],
    &#62; [ tbls[1], isos[2], tbls[3], "2.U4(3).(2^2)_{13*3}" ],
    &#62; [ isos[1], isos[2], tbls[3], "2.U4(3).(2^2)_{1*3*3}" ],
    &#62; [ tbls[1], isos[2], isos[3], "2.U4(3).(2^2)_{13*3*}" ],
    &#62; [ isos[1], isos[2], isos[3], "2.U4(3).(2^2)_{1*3*3*}" ] ];;
    gap&#62; tblG:= CharacterTable( "2.U4(3)" );;
    gap&#62; result:= [];;
    gap&#62; for input in inputs do
    &#62;      tblsG2:= input{ [ 1 .. 3 ] };
    &#62;      lib:= CharacterTable( input[4] );
    &#62;      poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );
    &#62;      ConstructModularGV4Tables( tblG, tblsG2, poss, lib );
    &#62;      Append( result, RepresentativesCharacterTables( poss ) );
    &#62;    od;
    #I  excluded cand. 2 (out of 4) for 2.U4(3).(2^2)_{1*33} by 3-mod. table
    #I  excluded cand. 3 (out of 4) for 2.U4(3).(2^2)_{1*33} by 3-mod. table
    #I  excluded cand. 2 (out of 4) for 2.U4(3).(2^2)_{13*3} by 3-mod. table
    #I  excluded cand. 3 (out of 4) for 2.U4(3).(2^2)_{13*3} by 3-mod. table
    #I  excluded cand. 2 (out of 4) for 2.U4(3).(2^2)_{1*3*3*} by 3-mod. table
    #I  excluded cand. 3 (out of 4) for 2.U4(3).(2^2)_{1*3*3*} by 3-mod. table
    gap&#62; result:= List( result, x -&#62; x.table );
    [ CharacterTable( "new2.U4(3).(2^2)_{133}" ), 
      CharacterTable( "new2.U4(3).(2^2)_{1*33}" ), 
      CharacterTable( "new2.U4(3).(2^2)_{13*3}" ), 
      CharacterTable( "new2.U4(3).(2^2)_{1*3*3}" ), 
      CharacterTable( "new2.U4(3).(2^2)_{13*3*}" ), 
      CharacterTable( "new2.U4(3).(2^2)_{1*3*3*}" ) ]
    gap&#62; List( result, NrConjugacyClasses );
    [ 69, 72, 72, 69, 69, 72 ]
    gap&#62; t:= result[1];;
    gap&#62; nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
    &#62;            x -&#62; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
    gap&#62; iso:= List( nsg, x -&#62; CharacterTableIsoclinic( t, x ) );;
    gap&#62; List( iso, x -&#62; PositionProperty( result, y -&#62;
    &#62;            TransformingPermutationsCharacterTables( x, y ) &lt;&#62; fail ) );
    [ 4, 4, 5 ]
    gap&#62; t:= result[2];;
    gap&#62; nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
    &#62;            x -&#62; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
    gap&#62; iso:= List( nsg, x -&#62; CharacterTableIsoclinic( t, x ) );;
    gap&#62; List( iso, x -&#62; PositionProperty( result, y -&#62;
    &#62;            TransformingPermutationsCharacterTables( x, y ) &lt;&#62; fail ) );
    [ 3, 3, 6 ]

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.7">
6.7</a>&nbsp;&nbsp;The Character Tables of Groups of the Type 4<sub>1</sub>.L<sub>3</sub>(4).2<sup>2</sup>
(October 2011)</h3><a name="41L34V4">
</a>

<div class="p"><!----></div>
The situation with 4<sub>1</sub>.L<sub>3</sub>(4).2<sup>2</sup> is analogous to that with 6.L<sub>3</sub>(4).2<sup>2</sup>,
see Section&nbsp;<a href="#6L34V4">6.5</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; tbls:= List( [ "1", "2", "3" ],
    &#62;      i -&#62; CharacterTable( Concatenation( "4_1.L3(4).2_", i ) ) );
    [ CharacterTable( "4_1.L3(4).2_1" ), CharacterTable( "4_1.L3(4).2_2" ), 
      CharacterTable( "4_1.L3(4).2_3" ) ]
    gap&#62; isos:= List( [ "1", "2", "3" ],
    &#62;      i -&#62; CharacterTable( Concatenation( "4_1.L3(4).2_", i, "*" ) ) );
    [ CharacterTable( "Isoclinic(4_1.L3(4).2_1)" ), 
      CharacterTable( "Isoclinic(4_1.L3(4).2_2)" ), 
      CharacterTable( "4_1.L3(4).2_3*" ) ]

</pre>

<div class="p"><!----></div>
Note that the group 4<sub>1</sub>.L<sub>3</sub>(4).2<sub>3</sub> has a centre of order four,
so one cannot construct the isoclinic variant by calling
the one argument version of <tt>CharacterTableIsoclinic</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; List( tbls, ClassPositionsOfCentre );
    [ [ 1, 3 ], [ 1, 3 ], [ 1, 2, 3, 4 ] ]
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( tbls[3],
    &#62;        CharacterTableIsoclinic( tbls[3] ) ) );
    true

</pre>

<div class="p"><!----></div>
Again, we get eight different character tables,
in two orbits.

<div class="p"><!----></div>

<pre>
    gap&#62; inputs:= [
    &#62; [ tbls[1], tbls[2], tbls[3], "4_1.L3(4).(2^2)_{123}" ],
    &#62; [ isos[1], tbls[2], tbls[3], "4_1.L3(4).(2^2)_{1*23}" ],
    &#62; [ tbls[1], isos[2], tbls[3], "4_1.L3(4).(2^2)_{12*3}" ],
    &#62; [ isos[1], isos[2], tbls[3], "4_1.L3(4).(2^2)_{1*2*3}" ],
    &#62; [ tbls[1], tbls[2], isos[3], "4_1.L3(4).(2^2)_{123*}" ],
    &#62; [ isos[1], tbls[2], isos[3], "4_1.L3(4).(2^2)_{1*23*}" ],
    &#62; [ tbls[1], isos[2], isos[3], "4_1.L3(4).(2^2)_{12*3*}" ],
    &#62; [ isos[1], isos[2], isos[3], "4_1.L3(4).(2^2)_{1*2*3*}" ] ];;
    gap&#62; tblG:= CharacterTable( "4_1.L3(4)" );;
    gap&#62; result:= [];;
    gap&#62; for input in inputs do
    &#62;      tblsG2:= input{ [ 1 .. 3 ] };
    &#62;      lib:= CharacterTable( input[4] );
    &#62;      poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );
    &#62;      ConstructModularGV4Tables( tblG, tblsG2, poss, lib );
    &#62;      Append( result, RepresentativesCharacterTables( poss ) );
    &#62;    od;
    #I  excluded cand. 2 (out of 8) for 4_1.L3(4).(2^2)_{123} by 5-mod. table
    #I  excluded cand. 3 (out of 8) for 4_1.L3(4).(2^2)_{123} by 5-mod. table
    #I  excluded cand. 4 (out of 8) for 4_1.L3(4).(2^2)_{123} by 7-mod. table
    #I  excluded cand. 5 (out of 8) for 4_1.L3(4).(2^2)_{123} by 7-mod. table
    #I  excluded cand. 6 (out of 8) for 4_1.L3(4).(2^2)_{123} by 5-mod. table
    #I  excluded cand. 7 (out of 8) for 4_1.L3(4).(2^2)_{123} by 5-mod. table
    #I  excluded cand. 2 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 5-mod. table
    #I  excluded cand. 3 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 5-mod. table
    #I  excluded cand. 4 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 7-mod. table
    #I  excluded cand. 5 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 7-mod. table
    #I  excluded cand. 6 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 5-mod. table
    #I  excluded cand. 7 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 5-mod. table
    #I  excluded cand. 2 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 5-mod. table
    #I  excluded cand. 3 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 5-mod. table
    #I  excluded cand. 4 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 7-mod. table
    #I  excluded cand. 5 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 7-mod. table
    #I  excluded cand. 6 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 5-mod. table
    #I  excluded cand. 7 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 5-mod. table
    #I  excluded cand. 2 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 5-mod. table
    #I  excluded cand. 3 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 5-mod. table
    #I  excluded cand. 4 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 7-mod. table
    #I  excluded cand. 5 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 7-mod. table
    #I  excluded cand. 6 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 5-mod. table
    #I  excluded cand. 7 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 5-mod. table
    gap&#62; result:= List( result, x -&#62; x.table );
    [ CharacterTable( "new4_1.L3(4).(2^2)_{123}" ), 
      CharacterTable( "new4_1.L3(4).(2^2)_{1*23}" ), 
      CharacterTable( "new4_1.L3(4).(2^2)_{12*3}" ), 
      CharacterTable( "new4_1.L3(4).(2^2)_{1*2*3}" ), 
      CharacterTable( "new4_1.L3(4).(2^2)_{123*}" ), 
      CharacterTable( "new4_1.L3(4).(2^2)_{1*23*}" ), 
      CharacterTable( "new4_1.L3(4).(2^2)_{12*3*}" ), 
      CharacterTable( "new4_1.L3(4).(2^2)_{1*2*3*}" ) ]
    gap&#62; List( result, NrConjugacyClasses );
    [ 48, 48, 48, 48, 42, 42, 42, 42 ]
    gap&#62; t:= result[1];;
    gap&#62; nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
    &#62;            x -&#62; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
    gap&#62; iso:= List( nsg, x -&#62; CharacterTableIsoclinic( t, x ) );;
    gap&#62; List( iso, x -&#62; PositionProperty( result, y -&#62;
    &#62;            TransformingPermutationsCharacterTables( x, y ) &lt;&#62; fail ) );
    [ 3, 2, 4 ]
    gap&#62; t:= result[5];;
    gap&#62; nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
    &#62;            x -&#62; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
    gap&#62; iso:= List( nsg, x -&#62; CharacterTableIsoclinic( t, x ) );;
    gap&#62; List( iso, x -&#62; PositionProperty( result, y -&#62;
    &#62;            TransformingPermutationsCharacterTables( x, y ) &lt;&#62; fail ) );
    [ 7, 6, 8 ]

</pre>

<div class="p"><!----></div>
Note that only two out of the eight tables of the type 2.L<sub>3</sub>(4).2<sup>2</sup>
occur as factors of the eight tables.

<div class="p"><!----></div>

<pre>
    gap&#62; facts:= [ CharacterTable( "2.L3(4).(2^2)_{123}" ), 
    &#62;              CharacterTable( "2.L3(4).(2^2)_{123*}" ) ];;
    gap&#62; factresults:= List( result, t -&#62; t / ClassPositionsOfCentre( t ) );;
    gap&#62; List( factresults, t -&#62; PositionProperty( facts, f -&#62;
    &#62;            IsRecord( TransformingPermutationsCharacterTables( t, f ) ) ) );
    [ 1, 1, 1, 1, 2, 2, 2, 2 ]

</pre>

<div class="p"><!----></div>
This is not surprising;
note that for 1  &#8804; i  &#8804; 2,
the two isoclinic variants of 4<sub>1</sub>.L<sub>3</sub>(4).2<sub>i</sub> have isomorphic
factor groups of the type 2.L<sub>3</sub>(4).2<sub>i</sub>.
(For i = 3, this is not the case.)

<div class="p"><!----></div>

<pre>
    gap&#62; test:= [ CharacterTable( "4_1.L3(4).2_1" ),
    &#62;             CharacterTable( "4_1.L3(4).2_1*" ) ];;
    gap&#62; List( test, ClassPositionsOfCentre );
    [ [ 1, 3 ], [ 1, 3 ] ]
    gap&#62; fact:= List( test, t -&#62; t / ClassPositionsOfCentre( t ) );;
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( fact[1], fact[2] ) );
    true
    gap&#62; test:= [ CharacterTable( "4_1.L3(4).2_2" ),
    &#62;             CharacterTable( "4_1.L3(4).2_2*" ) ];;
    gap&#62; List( test, ClassPositionsOfCentre );
    [ [ 1, 3 ], [ 1, 3 ] ]
    gap&#62; fact:= List( test, t -&#62; t / ClassPositionsOfCentre( t ) );;
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( fact[1], fact[2] ) );
    true

</pre>

<div class="p"><!----></div>
Now we try the second approach and compare the results.
By the abovementioned asymmetry,
it is clear that the tables are not uniquely determined by the input data.

<div class="p"><!----></div>

<pre>
    gap&#62; names:= [ "L3(4).(2^2)_{123}", "L3(4).(2^2)_{1*23}",
    &#62;              "L3(4).(2^2)_{12*3}", "L3(4).(2^2)_{1*2*3}" ];;
    gap&#62; inputs1:= List( names, nam -&#62; [ "4_1.L3(4).2_3", "2.L3(4).2_3",
    &#62;      Concatenation( "2.", nam ), Concatenation( "4_1.", nam ) ] );;
    gap&#62; names:= List( names, nam -&#62; ReplacedString( nam, "3}", "3*}" ) );;
    gap&#62; inputs2:= List( names, nam -&#62; [ "4_1.L3(4).2_3*", "2.L3(4).2_3*",
    &#62;      Concatenation( "2.", nam ), Concatenation( "4_1.", nam ) ] );;
    gap&#62; inputs:= Concatenation( inputs1, inputs2 );
    [ [ "4_1.L3(4).2_3", "2.L3(4).2_3", "2.L3(4).(2^2)_{123}", 
          "4_1.L3(4).(2^2)_{123}" ], 
      [ "4_1.L3(4).2_3", "2.L3(4).2_3", "2.L3(4).(2^2)_{1*23}", 
          "4_1.L3(4).(2^2)_{1*23}" ], 
      [ "4_1.L3(4).2_3", "2.L3(4).2_3", "2.L3(4).(2^2)_{12*3}", 
          "4_1.L3(4).(2^2)_{12*3}" ], 
      [ "4_1.L3(4).2_3", "2.L3(4).2_3", "2.L3(4).(2^2)_{1*2*3}", 
          "4_1.L3(4).(2^2)_{1*2*3}" ], 
      [ "4_1.L3(4).2_3*", "2.L3(4).2_3*", "2.L3(4).(2^2)_{123*}", 
          "4_1.L3(4).(2^2)_{123*}" ], 
      [ "4_1.L3(4).2_3*", "2.L3(4).2_3*", "2.L3(4).(2^2)_{1*23*}", 
          "4_1.L3(4).(2^2)_{1*23*}" ], 
      [ "4_1.L3(4).2_3*", "2.L3(4).2_3*", "2.L3(4).(2^2)_{12*3*}", 
          "4_1.L3(4).(2^2)_{12*3*}" ], 
      [ "4_1.L3(4).2_3*", "2.L3(4).2_3*", "2.L3(4).(2^2)_{1*2*3*}", 
          "4_1.L3(4).(2^2)_{1*2*3*}" ] ]
    gap&#62; result2:= [];;
    gap&#62; for  input in inputs do
    &#62;      tblMG := CharacterTable( input[1] );
    &#62;      tblG  := CharacterTable( input[2] );
    &#62;      tblGA := CharacterTable( input[3] );
    &#62;      name  := Concatenation( "new", input[4] );
    &#62;      lib   := CharacterTable( input[4] );
    &#62;      poss:= ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );
    &#62;      Append( result2, poss );
    &#62;    od;
    #E  4 possibilities for new4_1.L3(4).(2^2)_{123}
    #E  no solution for new4_1.L3(4).(2^2)_{1*23}
    #E  no solution for new4_1.L3(4).(2^2)_{12*3}
    #E  no solution for new4_1.L3(4).(2^2)_{1*2*3}
    #E  4 possibilities for new4_1.L3(4).(2^2)_{123*}
    #E  no solution for new4_1.L3(4).(2^2)_{1*23*}
    #E  no solution for new4_1.L3(4).(2^2)_{12*3*}
    #E  no solution for new4_1.L3(4).(2^2)_{1*2*3*}
    gap&#62; Length( result2 );
    8
    gap&#62; result2:= List( result2, x -&#62; x.table );
    [ CharacterTable( "new4_1.L3(4).(2^2)_{123}" ), 
      CharacterTable( "new4_1.L3(4).(2^2)_{123}" ), 
      CharacterTable( "new4_1.L3(4).(2^2)_{123}" ), 
      CharacterTable( "new4_1.L3(4).(2^2)_{123}" ), 
      CharacterTable( "new4_1.L3(4).(2^2)_{123*}" ), 
      CharacterTable( "new4_1.L3(4).(2^2)_{123*}" ), 
      CharacterTable( "new4_1.L3(4).(2^2)_{123*}" ), 
      CharacterTable( "new4_1.L3(4).(2^2)_{123*}" ) ]
    gap&#62; List( result, t1 -&#62; PositionsProperty( result2, t2 -&#62; IsRecord(
    &#62;      TransformingPermutationsCharacterTables( t1, t2 ) ) ) );
    [ [ 1 ], [ 4 ], [ 3 ], [ 2 ], [ 7 ], [ 6 ], [ 5 ], [ 8 ] ]

</pre>

<div class="p"><!----></div>
At the moment, I do not know interesting groups that contain one of the
4<sub>1</sub>.L<sub>3</sub>(4).2<sup>2</sup> type groups and whose character tables are available.

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.8">
6.8</a>&nbsp;&nbsp;The Character Tables of Groups of the Type 4<sub>2</sub>.L<sub>3</sub>(4).2<sup>2</sup>
(October 2011)</h3><a name="42L34V4">
</a>

<div class="p"><!----></div>
The situation with 4<sub>2</sub>.L<sub>3</sub>(4).2<sup>2</sup> is analogous to that with 6.L<sub>3</sub>(4).2<sup>2</sup>,
see Section&nbsp;<a href="#6L34V4">6.5</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; tbls:= List( [ "1", "2", "3" ],
    &#62;      i -&#62; CharacterTable( Concatenation( "4_2.L3(4).2_", i ) ) );
    [ CharacterTable( "4_2.L3(4).2_1" ), CharacterTable( "4_2.L3(4).2_2" ), 
      CharacterTable( "4_2.L3(4).2_3" ) ]
    gap&#62; isos:= List( [ "1", "2", "3" ], 
    &#62;      i -&#62; CharacterTable( Concatenation( "4_2.L3(4).2_", i, "*" ) ) );
    [ CharacterTable( "Isoclinic(4_2.L3(4).2_1)" ), 
      CharacterTable( "4_2.L3(4).2_2*" ), 
      CharacterTable( "Isoclinic(4_2.L3(4).2_3)" ) ]

</pre>

<div class="p"><!----></div>
Note that the group 4<sub>1</sub>.L<sub>3</sub>(4).2<sub>2</sub> has a centre of order four,
so one cannot construct the isoclinic variant not by calling
the one argument version of <tt>CharacterTableIsoclinic</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; List( tbls, ClassPositionsOfCentre );
    [ [ 1, 3 ], [ 1, 2, 3, 4 ], [ 1, 3 ] ]
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( tbls[2],
    &#62;        CharacterTableIsoclinic( tbls[2] ) ) );
    true

</pre>

<div class="p"><!----></div>
Again, we get eight different character tables,
in two orbits.

<div class="p"><!----></div>

<pre>
    gap&#62; inputs:= [
    &#62; [ tbls[1], tbls[2], tbls[3], "4_2.L3(4).(2^2)_{123}" ],
    &#62; [ isos[1], tbls[2], tbls[3], "4_2.L3(4).(2^2)_{1*23}" ],
    &#62; [ tbls[1], isos[2], tbls[3], "4_2.L3(4).(2^2)_{12*3}" ],
    &#62; [ tbls[1], tbls[2], isos[3], "4_2.L3(4).(2^2)_{123*}" ],
    &#62; [ isos[1], isos[2], tbls[3], "4_2.L3(4).(2^2)_{1*2*3}" ],
    &#62; [ isos[1], tbls[2], isos[3], "4_2.L3(4).(2^2)_{1*23*}" ],
    &#62; [ tbls[1], isos[2], isos[3], "4_2.L3(4).(2^2)_{12*3*}" ],
    &#62; [ isos[1], isos[2], isos[3], "4_2.L3(4).(2^2)_{1*2*3*}" ] ];;
    gap&#62; tblG:= CharacterTable( "4_2.L3(4)" );;
    gap&#62; result:= [];;
    gap&#62; for input in inputs do
    &#62;      tblsG2:= input{ [ 1 .. 3 ] };
    &#62;      lib:= CharacterTable( input[4] );
    &#62;      poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );
    &#62;      ConstructModularGV4Tables( tblG, tblsG2, poss, lib );
    &#62;      Append( result, RepresentativesCharacterTables( poss ) );
    &#62;    od;
    #I  excluded cand. 2 (out of 8) for 4_2.L3(4).(2^2)_{123} by 5-mod. table
    #I  excluded cand. 3 (out of 8) for 4_2.L3(4).(2^2)_{123} by 5-mod. table
    #I  excluded cand. 4 (out of 8) for 4_2.L3(4).(2^2)_{123} by 7-mod. table
    #I  excluded cand. 5 (out of 8) for 4_2.L3(4).(2^2)_{123} by 7-mod. table
    #I  excluded cand. 6 (out of 8) for 4_2.L3(4).(2^2)_{123} by 5-mod. table
    #I  excluded cand. 7 (out of 8) for 4_2.L3(4).(2^2)_{123} by 5-mod. table
    #I  excluded cand. 2 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 5-mod. table
    #I  excluded cand. 3 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 5-mod. table
    #I  excluded cand. 4 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 7-mod. table
    #I  excluded cand. 5 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 7-mod. table
    #I  excluded cand. 6 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 5-mod. table
    #I  excluded cand. 7 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 5-mod. table
    #I  excluded cand. 2 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 5-mod. table
    #I  excluded cand. 3 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 5-mod. table
    #I  excluded cand. 4 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 7-mod. table
    #I  excluded cand. 5 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 7-mod. table
    #I  excluded cand. 6 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 5-mod. table
    #I  excluded cand. 7 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 5-mod. table
    #I  excluded cand. 2 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 5-mod. table
    #I  excluded cand. 3 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 5-mod. table
    #I  excluded cand. 4 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 7-mod. table
    #I  excluded cand. 5 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 7-mod. table
    #I  excluded cand. 6 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 5-mod. table
    #I  excluded cand. 7 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 5-mod. table
    gap&#62; result:= List( result, x -&#62; x.table );
    [ CharacterTable( "new4_2.L3(4).(2^2)_{123}" ), 
      CharacterTable( "new4_2.L3(4).(2^2)_{1*23}" ), 
      CharacterTable( "new4_2.L3(4).(2^2)_{12*3}" ), 
      CharacterTable( "new4_2.L3(4).(2^2)_{123*}" ), 
      CharacterTable( "new4_2.L3(4).(2^2)_{1*2*3}" ), 
      CharacterTable( "new4_2.L3(4).(2^2)_{1*23*}" ), 
      CharacterTable( "new4_2.L3(4).(2^2)_{12*3*}" ), 
      CharacterTable( "new4_2.L3(4).(2^2)_{1*2*3*}" ) ]
    gap&#62; List( result, NrConjugacyClasses );
    [ 50, 50, 44, 50, 44, 50, 44, 44 ]
    gap&#62; t:= result[1];;
    gap&#62; nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
    &#62;            x -&#62; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
    gap&#62; iso:= List( nsg, x -&#62; CharacterTableIsoclinic( t, x ) );;
    gap&#62; List( iso, x -&#62; PositionProperty( result, y -&#62;
    &#62;            TransformingPermutationsCharacterTables( x, y ) &lt;&#62; fail ) );
    [ 4, 2, 6 ]
    gap&#62; t:= result[3];;
    gap&#62; nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
    &#62;            x -&#62; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
    gap&#62; iso:= List( nsg, x -&#62; CharacterTableIsoclinic( t, x ) );;
    gap&#62; List( iso, x -&#62; PositionProperty( result, y -&#62;
    &#62;            TransformingPermutationsCharacterTables( x, y ) &lt;&#62; fail ) );
    [ 7, 5, 8 ]

</pre>

<div class="p"><!----></div>
Note that only two out of the eight tables of the type 2.L<sub>3</sub>(4).2<sup>2</sup>
occur as factors of the eight tables.

<div class="p"><!----></div>

<pre>
    gap&#62; facts:= [ CharacterTable( "2.L3(4).(2^2)_{123}" ),
    &#62;              CharacterTable( "2.L3(4).(2^2)_{12*3}" ) ];;
    gap&#62; factresults:= List( result, t -&#62; t / ClassPositionsOfCentre( t ) );;
    gap&#62; List( factresults, t -&#62; PositionProperty( facts, f -&#62;
    &#62;            IsRecord( TransformingPermutationsCharacterTables( t, f ) ) ) );
    [ 1, 1, 2, 1, 2, 1, 2, 2 ]

</pre>

<div class="p"><!----></div>
This is not surprising;
note that for i  &#8712; { 1, 3 },
the two isoclinic variants of 4<sub>1</sub>.L<sub>3</sub>(4).2<sub>i</sub> have isomorphic
factor groups of the type 2.L<sub>3</sub>(4).2<sub>i</sub>.
(For i = 2, this is not the case.)

<div class="p"><!----></div>

<pre>
    gap&#62; test:= [ CharacterTable( "4_2.L3(4).2_1" ),
    &#62;             CharacterTable( "4_2.L3(4).2_1*" ) ];;
    gap&#62; List( test, ClassPositionsOfCentre );
    [ [ 1, 3 ], [ 1, 3 ] ]
    gap&#62; fact:= List( test, t -&#62; t / ClassPositionsOfCentre( t ) );;
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( fact[1], fact[2] ) );
    true
    gap&#62; test:= [ CharacterTable( "4_2.L3(4).2_3" ),
    &#62;             CharacterTable( "4_2.L3(4).2_3*" ) ];;
    gap&#62; List( test, ClassPositionsOfCentre );
    [ [ 1, 3 ], [ 1, 3 ] ]
    gap&#62; fact:= List( test, t -&#62; t / ClassPositionsOfCentre( t ) );;
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( fact[1], fact[2] ) );
    true

</pre>

<div class="p"><!----></div>
Now we try the second approach and compare the results.
By the abovementioned asymmetry,
it is clear that the tables are not uniquely determined by the input data.

<div class="p"><!----></div>

<pre>
    gap&#62; names:= [ "L3(4).(2^2)_{123}", "L3(4).(2^2)_{1*23}",
    &#62;              "L3(4).(2^2)_{123*}", "L3(4).(2^2)_{1*23*}" ];;
    gap&#62; inputs1:= List( names, nam -&#62; [ "4_2.L3(4).2_2", "2.L3(4).2_2",
    &#62;      Concatenation( "2.", nam ), Concatenation( "4_2.", nam ) ] );;
    gap&#62; names:= List( names, nam -&#62; ReplacedString( nam, "23", "2*3" ) );;
    gap&#62; inputs2:= List( names, nam -&#62; [ "4_2.L3(4).2_2*", "2.L3(4).2_2*",
    &#62;      Concatenation( "2.", nam ), Concatenation( "4_2.", nam ) ] );;
    gap&#62; inputs:= Concatenation( inputs1, inputs2 );
    [ [ "4_2.L3(4).2_2", "2.L3(4).2_2", "2.L3(4).(2^2)_{123}", 
          "4_2.L3(4).(2^2)_{123}" ], 
      [ "4_2.L3(4).2_2", "2.L3(4).2_2", "2.L3(4).(2^2)_{1*23}", 
          "4_2.L3(4).(2^2)_{1*23}" ], 
      [ "4_2.L3(4).2_2", "2.L3(4).2_2", "2.L3(4).(2^2)_{123*}", 
          "4_2.L3(4).(2^2)_{123*}" ], 
      [ "4_2.L3(4).2_2", "2.L3(4).2_2", "2.L3(4).(2^2)_{1*23*}", 
          "4_2.L3(4).(2^2)_{1*23*}" ], 
      [ "4_2.L3(4).2_2*", "2.L3(4).2_2*", "2.L3(4).(2^2)_{12*3}", 
          "4_2.L3(4).(2^2)_{12*3}" ], 
      [ "4_2.L3(4).2_2*", "2.L3(4).2_2*", "2.L3(4).(2^2)_{1*2*3}", 
          "4_2.L3(4).(2^2)_{1*2*3}" ], 
      [ "4_2.L3(4).2_2*", "2.L3(4).2_2*", "2.L3(4).(2^2)_{12*3*}", 
          "4_2.L3(4).(2^2)_{12*3*}" ], 
      [ "4_2.L3(4).2_2*", "2.L3(4).2_2*", "2.L3(4).(2^2)_{1*2*3*}", 
          "4_2.L3(4).(2^2)_{1*2*3*}" ] ]
    gap&#62; result2:= [];;
    gap&#62; for  input in inputs do
    &#62;      tblMG := CharacterTable( input[1] );
    &#62;      tblG  := CharacterTable( input[2] );
    &#62;      tblGA := CharacterTable( input[3] );
    &#62;      name  := Concatenation( "new", input[4] );
    &#62;      lib   := CharacterTable( input[4] );
    &#62;      poss:= ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );
    &#62;      Append( result2, poss );
    &#62;    od;
    #E  4 possibilities for new4_2.L3(4).(2^2)_{123}
    #E  no solution for new4_2.L3(4).(2^2)_{1*23}
    #E  no solution for new4_2.L3(4).(2^2)_{123*}
    #E  no solution for new4_2.L3(4).(2^2)_{1*23*}
    #E  4 possibilities for new4_2.L3(4).(2^2)_{12*3}
    #E  no solution for new4_2.L3(4).(2^2)_{1*2*3}
    #E  no solution for new4_2.L3(4).(2^2)_{12*3*}
    #E  no solution for new4_2.L3(4).(2^2)_{1*2*3*}
    gap&#62; Length( result2 );
    8
    gap&#62; result2:= List( result2, x -&#62; x.table );
    [ CharacterTable( "new4_2.L3(4).(2^2)_{123}" ), 
      CharacterTable( "new4_2.L3(4).(2^2)_{123}" ), 
      CharacterTable( "new4_2.L3(4).(2^2)_{123}" ), 
      CharacterTable( "new4_2.L3(4).(2^2)_{123}" ), 
      CharacterTable( "new4_2.L3(4).(2^2)_{12*3}" ), 
      CharacterTable( "new4_2.L3(4).(2^2)_{12*3}" ), 
      CharacterTable( "new4_2.L3(4).(2^2)_{12*3}" ), 
      CharacterTable( "new4_2.L3(4).(2^2)_{12*3}" ) ]
    gap&#62; List( result, t1 -&#62; PositionsProperty( result2, t2 -&#62; IsRecord(
    &#62;      TransformingPermutationsCharacterTables( t1, t2 ) ) ) );
    [ [ 1 ], [ 4 ], [ 7 ], [ 3 ], [ 6 ], [ 2 ], [ 5 ], [ 8 ] ]

</pre>

<div class="p"><!----></div>
The group ON.2 contains a maximal subgroup M of the type
4<sub>2</sub>.L<sub>3</sub>(4).2<sup>2</sup>, see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;132].
Only the third result table admits a class fusion into ON.2.
This shows the existence of groups for the tables from the second orbit.

<div class="p"><!----></div>

<pre>
    gap&#62; on2:= CharacterTable( "ON.2" );;
    gap&#62; fus:= List( result, x -&#62; PossibleClassFusions( x, on2 ) );;
    gap&#62; List( fus, Length );
    [ 0, 0, 16, 0, 0, 0, 0, 0 ]

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.9">
6.9</a>&nbsp;&nbsp;The Character Table of <span class="roman">Aut</span>(L<sub>2</sub>(81))</h3>

<div class="p"><!----></div>
The group <span class="roman">Aut</span>(L<sub>2</sub>(81))  &#8773; L<sub>2</sub>(81).(2 &times;4) has the structure
G.2<sup>2</sup> where G = L<sub>2</sub>(81).2<sub>1</sub>.
Here we get two triples of possible actions on the tables of the groups
G.2<sub>i</sub>, and one possible character table for each triple.

<div class="p"><!----></div>

<pre>
    gap&#62; input:= [ "L2(81).2_1", "L2(81).4_1", "L2(81).4_2", "L2(81).2^2",
    &#62;                                                        "L2(81).(2x4)" ];;
    gap&#62; tblG   := CharacterTable( input[1] );;
    gap&#62; tblsG2 := List( input{ [ 2 .. 4 ] }, CharacterTable );;
    gap&#62; name   := Concatenation( "new", input[5] );;
    gap&#62; lib    := CharacterTable( input[5] );;
    gap&#62; poss   := ConstructOrdinaryGV4Table( tblG, tblsG2, name, lib );;
    #I  newL2(81).(2x4): 2 equivalence classes
    gap&#62; reps:= RepresentativesCharacterTables( poss );;
    gap&#62; Length( reps );
    2

</pre>

<div class="p"><!----></div>
Due to the different underlying actions, the power maps of the two candidate
tables differ.

<div class="p"><!----></div>

<pre>
    gap&#62; ord:= OrdersClassRepresentatives( reps[1].table );;
    gap&#62; ord = OrdersClassRepresentatives( reps[2].table ); 
    true
    gap&#62; pos:= Position( ord, 80 );
    33
    gap&#62; PowerMap( reps[1].table, 3 )[ pos ];
    34
    gap&#62; PowerMap( reps[2].table, 3 )[ pos ];
    33

</pre>

<div class="p"><!----></div>
<span class="roman">Aut</span>(L<sub>2</sub>(81)) can be generated by <span class="roman">PGL</span>(2,81) = L<sub>2</sub>(81).2<sub>2</sub>
and the Frobenius automorphism of order four that is defined on GL(2,81)
as the map that cubes the matrix entries.
The elements of order 80 in <span class="roman">Aut</span>(L<sub>2</sub>(81)) are conjugates of diagonal
matrices modulo scalar matrices,
which are mapped to their third powers by the Frobenius homomorphism.
So the third power map of <span class="roman">Aut</span>(L<sub>2</sub>(81)) fixes the classes of elements of
order 80.
In other words, the second of the two tables is the right one.

<div class="p"><!----></div>

<pre>
    gap&#62; trans:= TransformingPermutationsCharacterTables( reps[2].table, lib );;
    gap&#62; IsRecord( trans );
    true
    gap&#62; List( reps[2].G2fusGV4, x -&#62; OnTuples( x, trans.columns ) )
    &#62;  = List( tblsG2, x -&#62; GetFusionMap( x, lib ) );
    true
    gap&#62; ConstructModularGV4Tables( tblG, tblsG2, poss, lib );;
    #I  not all input tables for L2(81).(2x4) mod 3 available
    #I  not all input tables for L2(81).(2x4) mod 5 available
    #I  not all input tables for L2(81).(2x4) mod 41 available

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.10">
6.10</a>&nbsp;&nbsp;The Character Table of O<sub>8</sub><sup>+</sup>(3).2<sup>2</sup><sub>111</sub></h3><a name="O_8^+(3).2^2_{111}">
</a>

<div class="p"><!----></div>
The construction of the character table of the group O<sub>8</sub><sup>+</sup>(3).2<sup>2</sup><sub>111</sub>
is not as straightforward as the constructions shown
in Section&nbsp;<a href="#xplGV43.A6.V4">6.2</a>.
Here we get 26 triples of actions on the tables of the three subgroups
G.2<sub>i</sub> of index two,
but only one of them leads to candidates for the desired character table.
Specifically, we get 64 such candidates, in two equivalence classes
w.r.t.&nbsp;permutation equivalence.

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; input:= [ "O8+(3)", "O8+(3).2_1",  "O8+(3).2_1'", "O8+(3).2_1''",
    &#62;                                                  "O8+(3).(2^2)_{111}" ];;
    gap&#62; tblG   := CharacterTable( input[1] );;
    gap&#62; tblsG2 := List( input{ [ 2 .. 4 ] }, CharacterTable );;
    gap&#62; name   := Concatenation( "new", input[5] );;
    gap&#62; lib    := CharacterTable( input[5] );;
    gap&#62; poss   := ConstructOrdinaryGV4Table( tblG, tblsG2, name, lib );;
    #I  newO8+(3).(2^2)_{111}: 2 equivalence classes
    gap&#62; Length( poss );
    64
    gap&#62; reps:= RepresentativesCharacterTables( poss );;
    gap&#62; Length( reps );
    2

</pre>

<div class="p"><!----></div>
The two candidate tables differ only in four irreducible characters
involving irrationalities on the classes of element order 28.
All three subgroups G.2<sub>i</sub> contain elements of order 28 that do not lie
in the simple group G;
these classes are roots of the same (unique) class of element order 7.
The centralizer C of an order 7 element in G.2<sup>2</sup> has order
112 = 2<sup>4</sup> &#183;7, the intersection of C with G has the structure
2<sup>2</sup> &times;7 since G contains three classes of cyclic subgroups of
the order 14,
and each of the intersections of C with one of the subgroups G.2<sub>i</sub>
has the structure 2 &times;4 &times;7,
so the structure of C is 4<sup>2</sup> &times;7  &#8773; 4 &times;28.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= reps[1].table;;
    gap&#62; ord7:= Filtered( [ 1 .. NrConjugacyClasses( t ) ],                        
    &#62;               i -&#62; OrdersClassRepresentatives( t )[i] = 7 );
    [ 37 ]
    gap&#62; SizesCentralizers( t ){ ord7 };
    [ 112 ]
    gap&#62; ord28:= Filtered( [ 1 .. NrConjugacyClasses( t ) ],
    &#62;               i -&#62; OrdersClassRepresentatives( t )[i] = 28 );
    [ 112, 113, 114, 115, 161, 162, 163, 164, 210, 211, 212, 213 ]
    gap&#62; List( reps[1].G2fusGV4, x -&#62; Intersection( ord28, x ) );
    [ [ 112, 113, 114, 115 ], [ 161, 162, 163, 164 ], [ 210, 211, 212, 213 ] ]
    gap&#62; sub:= CharacterTable( "Cyclic", 28 ) * CharacterTable( "Cyclic", 4 );;
    gap&#62; List( reps, x -&#62; Length( PossibleClassFusions( sub, x.table ) ) );
    [ 0, 96 ]

</pre>

<div class="p"><!----></div>
It turns out that only one of the two candidate tables admits a class fusion
from the character table of C,
thus we have determined the ordinary character table of O<sub>8</sub><sup>+</sup>(3).2<sup>2</sup><sub>111</sub>.

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; trans:= TransformingPermutationsCharacterTables( reps[2].table, lib );;
    gap&#62; IsRecord( trans );
    true
    gap&#62; List( reps[2].G2fusGV4, x -&#62; OnTuples( x, trans.columns ) )
    &#62;  = List( tblsG2, x -&#62; GetFusionMap( x, lib ) );
    true
    gap&#62; ConstructModularGV4Tables( tblG, tblsG2, poss, lib );;
    #I  not all input tables for O8+(3).(2^2)_{111} mod 3 available

</pre>

<div class="p"><!----></div>
So also the p-modular tables of O<sub>8</sub><sup>+</sup>(3).2<sup>2</sup><sub>111</sub> can be computed
this way, provided that the p-modular tables of the index 2 subgroups
are available.

<div class="p"><!----></div>

 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;Examples for the Type 2<sup>2</sup>.G</h2><a name="xplV4G">
</a>

<div class="p"><!----></div>
We compute the character table of a group of the type 2<sup>2</sup>.G from the
character tables of the three factor groups of the type 2.G,
using the function <tt>PossibleCharacterTablesOfTypeV4G</tt>,
see Section&nbsp;<a href="#theorV4G">3.4</a>.

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;The Character Table of 2<sup>2</sup>.Sz(8)</h3><a name="2^2.Sz(8)">
</a>

<div class="p"><!----></div>
The three central involutions in 2<sup>2</sup>.Sz(8) are permuted cyclicly by an
outer automorphism &#945; of order three.
In order to apply <tt>PossibleCharacterTablesOfTypeV4G</tt>,
we need the character table of the group 2.Sz(8) and the action on the
classes of Sz(8) that is induced by &#945;.

<div class="p"><!----></div>
The ordinary character table of G = Sz(8) admits exactly five
table automorphisms of order dividing 3.
Each of these possibilities leads to exactly one possible character table
of 2<sup>2</sup>.G, and the five tables are permutation equivalent.
From this point of view, we need not know which of the table automorphisms
are induced by outer <em>group</em> automorphisms of G.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "Sz(8)" );;
    gap&#62; 2t:= CharacterTable( "2.Sz(8)" );;
    gap&#62; aut:= AutomorphismsOfTable( t );;
    gap&#62; elms:= Set( List( Filtered( aut, x -&#62; Order( x ) in [ 1, 3 ] ),           
    &#62;                      SmallestGeneratorPerm ) );
    [ (), (9,10,11), (6,7,8), (6,7,8)(9,10,11), (6,7,8)(9,11,10) ]
    gap&#62; poss:= List( elms,                                         
    &#62;       pi -&#62; PossibleCharacterTablesOfTypeV4G( t, 2t, pi, "2^2.Sz(8)" ) );
    [ [ CharacterTable( "2^2.Sz(8)" ) ], [ CharacterTable( "2^2.Sz(8)" ) ], 
      [ CharacterTable( "2^2.Sz(8)" ) ], [ CharacterTable( "2^2.Sz(8)" ) ], 
      [ CharacterTable( "2^2.Sz(8)" ) ] ]
    gap&#62; reps:= RepresentativesCharacterTables( Concatenation( poss ) );
    [ CharacterTable( "2^2.Sz(8)" ) ]

</pre>

<div class="p"><!----></div>
The tables coincide with the one that is stored in the <font face="helvetica">GAP</font> library.

<div class="p"><!----></div>

<pre>
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( reps[1],
    &#62;        CharacterTable( "2^2.Sz(8)" ) ) );
    true

</pre>

<div class="p"><!----></div>
The computation of the p-modular character table of 2<sup>2</sup>.G from the
p-modular character table of 2.G and the three factor fusions from
2<sup>2</sup>.G to 2.G is straightforward, as is stated in Section&nbsp;<a href="#theorV4G">3.4</a>.
The three fusions are stored on the tables returned by
<tt>PossibleCharacterTablesOfTypeV4G</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( poss[1][1], 2t, "1" );
    [ 1, 1, 2, 2, 3, 4, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 
      13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19 ]
    gap&#62; GetFusionMap( poss[1][1], 2t, "2" );
    [ 1, 2, 1, 2, 3, 4, 5, 6, 7, 6, 7, 8, 9, 8, 9, 10, 11, 10, 11, 12, 13, 12, 
      13, 14, 15, 14, 15, 16, 17, 16, 17, 18, 19, 18, 19 ]
    gap&#62; GetFusionMap( poss[1][1], 2t, "3" );
    [ 1, 2, 2, 1, 3, 4, 5, 6, 7, 7, 6, 8, 9, 9, 8, 10, 11, 11, 10, 12, 13, 13, 
      12, 14, 15, 15, 14, 16, 17, 17, 16, 18, 19, 19, 18 ]

</pre>

<div class="p"><!----></div>
The <font face="helvetica">GAP</font> library function <tt>BrauerTableOfTypeV4G</tt> can be used
to derive Brauer tables of 2<sup>2</sup>.G.
We have to compute the p-modular tables for prime divisors p of &#124;G&#124;,
that is, for p  &#8712; { 2, 5, 7, 13 }.

<div class="p"><!----></div>

<pre>
    gap&#62; Set( Factors( Size( t ) ) );
    [ 2, 5, 7, 13 ]

</pre>

<div class="p"><!----></div>
Clearly p = 2 is uninteresting from this point of view
because the 2-modular table of 2<sup>2</sup>.G
can be identified with the 2-modular table of G.

<div class="p"><!----></div>
For each of the five ordinary tables (corresponding to the five possible
table automorphisms of G) constructed above,
we get one candidate of a 5-modular table.
However, these tables are <b>not</b> all equivalent.
There are two equivalence classes, and one of the two possibilities is
inconsistent in the sense that not all tensor products of irreducibles
decompose into irreducibles.

<div class="p"><!----></div>

<pre>
    gap&#62; cand:= List( poss, l -&#62; BrauerTableOfTypeV4G( l[1], 2t mod 5,
    &#62;      ConstructionInfoCharacterTable( l[1] )[3] ) );
    [ BrauerTable( "2^2.Sz(8)", 5 ), BrauerTable( "2^2.Sz(8)", 5 ), 
      BrauerTable( "2^2.Sz(8)", 5 ), BrauerTable( "2^2.Sz(8)", 5 ), 
      BrauerTable( "2^2.Sz(8)", 5 ) ]
    gap&#62; Length( RepresentativesCharacterTables( cand ) );
    2
    gap&#62; List( cand, CTblLib.Test.TensorDecomposition );
    [ false, true, false, true, true ]
    gap&#62; Length( RepresentativesCharacterTables( cand{ [ 2, 4, 5 ] } ) );
    1
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( cand[2],
    &#62;        CharacterTable( "2^2.Sz(8)" ) mod 5 ) );
    true

</pre>

<div class="p"><!----></div>
This implies that only those table automorphisms of G can be induced by
an outer group automorphism that move the classes of element order 13.

<div class="p"><!----></div>
The 7-modular table of 2<sup>2</sup>.G is uniquely determined, independent of the
choice of the table automorphism of G.

<div class="p"><!----></div>

<pre>
    gap&#62; cand:= List( poss, l -&#62; BrauerTableOfTypeV4G( l[1], 2t mod 7,
    &#62;      ConstructionInfoCharacterTable( l[1] )[3] ) );
    [ BrauerTable( "2^2.Sz(8)", 7 ), BrauerTable( "2^2.Sz(8)", 7 ), 
      BrauerTable( "2^2.Sz(8)", 7 ), BrauerTable( "2^2.Sz(8)", 7 ), 
      BrauerTable( "2^2.Sz(8)", 7 ) ]
    gap&#62; Length( RepresentativesCharacterTables( cand ) );
    1
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( cand[1],      
    &#62;        CharacterTable( "2^2.Sz(8)" ) mod 7 ) );
    true

</pre>

<div class="p"><!----></div>
We get two candidates for the 13-modular table of 2<sup>2</sup>.G,
also if we consider only the three admissible table automorphisms.

<div class="p"><!----></div>

<pre>
    gap&#62; elms:= elms{ [ 2, 4, 5 ] };
    [ (9,10,11), (6,7,8)(9,10,11), (6,7,8)(9,11,10) ]
    gap&#62; poss:= poss{ [ 2, 4, 5 ] };;                                     
    gap&#62; cand:= List( poss, l -&#62; BrauerTableOfTypeV4G( l[1], 2t mod 13,
    &#62;      ConstructionInfoCharacterTable( l[1] )[3] ) );
    [ BrauerTable( "2^2.Sz(8)", 13 ), BrauerTable( "2^2.Sz(8)", 13 ), 
      BrauerTable( "2^2.Sz(8)", 13 ) ]
    gap&#62; Length( RepresentativesCharacterTables( cand ) );
    2
    gap&#62; List( cand, CTblLib.Test.TensorDecomposition );                      
    [ true, true, true ]

</pre>

<div class="p"><!----></div>
The action of the outer automorphism of order three of G can be read off
from the 2-modular table of G.
Note that the ordinary and the 5-modular character table of G
possess two independent table automorphisms of order three,
whereas the group of table automorphisms of the 2-modular table
has order three.
(The reason is that the irrational values on the classes of the
element orders 7 and 13 appear in the same irreducible 2-modular
Brauer characters.)

<div class="p"><!----></div>

<pre>
    gap&#62; mod2:= CharacterTable( "Sz(8)" ) mod 2;
    BrauerTable( "Sz(8)", 2 )
    gap&#62; AutomorphismsOfTable( mod2 );
    Group([ (3,4,5)(6,7,8) ])
    gap&#62; OrdersClassRepresentatives( mod2 );
    [ 1, 5, 7, 7, 7, 13, 13, 13 ]

</pre>

<div class="p"><!----></div>
This means that the first candidate is ruled out;
this determines the 13-modular character table of 2<sup>2</sup>.G.

<div class="p"><!----></div>

<pre>
    gap&#62; Length( RepresentativesCharacterTables( cand{ [ 2, 3 ] } ) );
    1
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( cand[2],
    &#62;        CharacterTable( "2^2.Sz(8)" ) mod 13 ) );
    true

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp; A<font size="-2">TLAS</font> Tables of the Type 2<sup>2</sup>.G (September 2005)</h3><a name="V4GATLAS">
</a>

<div class="p"><!----></div>
Besides 2<sup>2</sup>.Sz(8) (cf.&nbsp;Section&nbsp;<a href="#2^2.Sz(8)">7.1</a>),
2<sup>2</sup>.O<sub>8</sub><sup>+</sup>(3) (cf.&nbsp;Section&nbsp;<a href="#MultO8p3">7.3</a>),
and certain central extensions of L<sub>3</sub>(4) (cf.&nbsp;Section&nbsp;<a href="#MultL34">7.4</a>),
the following examples of central extensions of nearly simple  A<font size="-2">TLAS</font> groups
G by a Klein four group occur.

<div class="p"><!----></div>

<pre>
    gap&#62; listV4G:= [
    &#62;      [ "2^2.L3(4)",         "2.L3(4)",     "L3(4)"       ],
    &#62;      [ "2^2.L3(4).2_1",     "2.L3(4).2_1", "L3(4).2_1"   ],
    &#62;      [ "(2^2x3).L3(4)",     "6.L3(4)",     "3.L3(4)"     ],
    &#62;      [ "(2^2x3).L3(4).2_1", "6.L3(4).2_1", "3.L3(4).2_1" ],
    &#62;      [ "2^2.O8+(2)",        "2.O8+(2)",    "O8+(2)"      ],
    &#62;      [ "2^2.U6(2)",         "2.U6(2)",     "U6(2)"       ],
    &#62;      [ "(2^2x3).U6(2)",     "6.U6(2)",     "3.U6(2)"     ],
    &#62;      [ "2^2.2E6(2)",        "2.2E6(2)",    "2E6(2)"      ],
    &#62;      [ "(2^2x3).2E6(2)",    "6.2E6(2)",    "3.2E6(2)"    ],
    &#62; ];;

</pre>

<div class="p"><!----></div>
(For the tables of (2<sup>2</sup> &times;3).G, with G one of L<sub>3</sub>(4), U<sub>6</sub>(2),
or <sup>2</sup>E<sub>6</sub>(2),
we could alternatively use the tables of 2<sup>2</sup>.G and 3.G,
and the construction described in&nbsp;[<a href="#CCE" name="CITECCE">Bre</a>].)

<div class="p"><!----></div>
The function for computing the candidates for the ordinary character tables
is similar to the one from Section&nbsp;<a href="#xplGV43.A6.V4">6.2</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; ConstructOrdinaryV4GTable:= function( tblG, tbl2G, name, lib )
    &#62;      local ord3, nam, poss, reps, trans;
    &#62; 
    &#62;      # Compute the possible actions for the ordinary tables.
    &#62;      ord3:= Set( List( Filtered( AutomorphismsOfTable( tblG ),
    &#62;                                  x -&#62; Order( x ) = 3 ),
    &#62;                        SmallestGeneratorPerm ) );
    &#62;      if 1 &lt; Length( ord3 ) then
    &#62;        Print( "#I  ", name,
    &#62;               ": the action of the automorphism is not unique" );
    &#62;      fi;
    &#62;      # Compute the possible ordinary tables for the given actions.
    &#62;      nam:= Concatenation( "new", name );
    &#62;      poss:= Concatenation( List( ord3, pi -&#62;
    &#62;             PossibleCharacterTablesOfTypeV4G( tblG, tbl2G, pi, nam ) ) );
    &#62;      # Test the possibilities for permutation equivalence.
    &#62;      reps:= RepresentativesCharacterTables( poss );
    &#62;      if 1 &lt; Length( reps ) then
    &#62;        Print( "#I  ", name, ": ", Length( reps ),
    &#62;               " equivalence classes\n" );
    &#62;      elif Length( reps ) = 0 then
    &#62;        Print( "#E  ", name, ": no solution\n" );
    &#62;      else
    &#62;        # Compare the computed table with the library table.
    &#62;        if not IsCharacterTable( lib ) then
    &#62;          Print( "#I  no library table for ", name, "\n" );
    &#62;          PrintToLib( name, poss[1].table );
    &#62;        else
    &#62;          trans:= TransformingPermutationsCharacterTables( reps[1], lib );
    &#62;          if not IsRecord( trans ) then
    &#62;            Print( "#E  computed table and library table for ", name,
    &#62;                   " differ\n" );
    &#62;          fi;
    &#62;        fi;
    &#62;      fi;
    &#62;      return poss;
    &#62;    end;;

</pre>

<div class="p"><!----></div>
Concerning the Brauer tables, the same ambiguity problem may occur as in
Section&nbsp;<a href="#xplGV43.A6.V4">6.2</a>:
Some candidates for the ordinary table may be excluded due to information
provided by some p-modular table,
see Section&nbsp;<a href="#2^2.Sz(8)">7.1</a> for an easy example.
Our strategy is analogous to the one used in Section&nbsp;<a href="#xplGV43.A6.V4">6.2</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; ConstructModularV4GTables:= function( tblG, tbl2G, ordposs,
    &#62;                                          ordlibtblV4G )
    &#62;      local name, modposs, primes, checkordinary, i, p, tmodp, 2tmodp, aut,
    &#62;            poss, modlib, trans, reps;
    &#62; 
    &#62;      if not IsCharacterTable( ordlibtblV4G ) then
    &#62;        Print( "#I  no ordinary library table ...\n" );
    &#62;        return [];
    &#62;      fi;
    &#62;      name:= Identifier( ordlibtblV4G );
    &#62;      modposs:= [];
    &#62;      primes:= Set( Factors( Size( tblG ) ) );
    &#62;      ordposs:= ShallowCopy( ordposs );
    &#62;      checkordinary:= false;
    &#62;      for i in [ 1 .. Length( ordposs ) ] do
    &#62;        modposs[i]:= [];
    &#62;        for p in primes do
    &#62;          tmodp := tblG  mod p;
    &#62;          2tmodp:= tbl2G mod p;
    &#62;          if IsCharacterTable( tmodp ) and IsCharacterTable( 2tmodp ) then
    &#62;            aut:= ConstructionInfoCharacterTable( ordposs[i] )[3];
    &#62;            poss:= BrauerTableOfTypeV4G( ordposs[i], 2tmodp, aut );
    &#62;            if CTblLib.Test.TensorDecomposition( poss, false ) = false then
    &#62;              Print( "#I  excluded cand. ", i, " (out of ",
    &#62;                     Length( ordposs ), ") for ", name, " by ", p,
    &#62;                     "-mod. table\n" );
    &#62;              Unbind( ordposs[i] );
    &#62;              Unbind( modposs[i] );
    &#62;              checkordinary:= true;
    &#62;              break;
    &#62;            fi;
    &#62;            Add( modposs[i], poss );
    &#62;          else
    &#62;            Print( "#I  not all input tables for ", name, " mod ", p,
    &#62;                   " available\n" );
    &#62;            primes:= Difference( primes, [ p ] );
    &#62;          fi;
    &#62;        od;
    &#62;        if IsBound( modposs[i] ) then
    &#62;          # Compare the computed Brauer tables with the library tables.
    &#62;          for poss in modposs[i] do
    &#62;            p:= UnderlyingCharacteristic( poss );
    &#62;            modlib:= ordlibtblV4G mod p;
    &#62;            if IsCharacterTable( modlib ) then
    &#62;              trans:= TransformingPermutationsCharacterTables(
    &#62;                          poss, modlib );
    &#62;              if not IsRecord( trans ) then
    &#62;                Print( "#E  computed table and library table for ",
    &#62;                       name, " mod ", p, " differ\n" );
    &#62;              fi;
    &#62;            else
    &#62;              Print( "#I  no library table for ",
    &#62;                     name, " mod ", p, "\n" );
    &#62;              PrintToLib( name, poss );
    &#62;            fi;
    &#62;          od;
    &#62;        fi;
    &#62;      od;
    &#62;      if checkordinary then
    &#62;        # Test whether the ordinary table is admissible.
    &#62;        ordposs:= Compacted( ordposs );
    &#62;        modposs:= Compacted( modposs );
    &#62;        reps:= RepresentativesCharacterTables( ordposs );
    &#62;        if 1 &lt; Length( reps ) then
    &#62;          Print( "#I  ", name, ": ", Length( reps ),
    &#62;                 " equivalence classes (ord. table)\n" );
    &#62;        elif Length( reps ) = 0 then
    &#62;          Print( "#E  ", name, ": no solution (ord. table)\n" );
    &#62;        else
    &#62;          # Compare the computed table with the library table.
    &#62;          trans:= TransformingPermutationsCharacterTables( reps[1],
    &#62;                      ordlibtblV4G );
    &#62;          if not IsRecord( trans ) then
    &#62;            Print( "#E  computed table and library table for ", name,
    &#62;                   " differ\n" );
    &#62;          fi;
    &#62;        fi;
    &#62;      fi;
    &#62;      # Test the uniqueness of the Brauer tables.
    &#62;      for poss in TransposedMat( modposs ) do
    &#62;        reps:= RepresentativesCharacterTables( poss );
    &#62;        if Length( reps ) &lt;&#62; 1 then
    &#62;          Print( "#I  ", name, ": ", Length( reps ), " candidates for the ",
    &#62;                 UnderlyingCharacteristic( reps[1] ), "-modular table\n" );
    &#62;        fi;
    &#62;      od;
    &#62;      return rec( ordinary:= ordposs, modular:= modposs );
    &#62;    end;;

</pre>

<div class="p"><!----></div>
In our examples,
the action of the outer automorphism of order three on the classes of G
turns out to be uniquely determined by the table automorphisms
of the character table of G.

<div class="p"><!----></div>

<pre>
    gap&#62; for input in listV4G do
    &#62;      tblG  := CharacterTable( input[3] );
    &#62;      tbl2G := CharacterTable( input[2] );
    &#62;      lib   := CharacterTable( input[1] );
    &#62;      poss  := ConstructOrdinaryV4GTable( tblG, tbl2G, input[1], lib );
    &#62;      ConstructModularV4GTables( tblG, tbl2G, poss, lib );
    &#62;    od;
    #I  excluded cand. 1 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
    #I  excluded cand. 2 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
    #I  excluded cand. 7 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
    #I  excluded cand. 10 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
    #I  excluded cand. 15 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
    #I  excluded cand. 16 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
    #I  excluded cand. 1 (out of 16) for (2^2x3).L3(4).2_1 by 7-mod. table
    #I  excluded cand. 2 (out of 16) for (2^2x3).L3(4).2_1 by 7-mod. table
    #I  excluded cand. 7 (out of 16) for (2^2x3).L3(4).2_1 by 7-mod. table
    #I  excluded cand. 10 (out of 16) for (2^2x3).L3(4).2_1 by 7-mod. table
    #I  excluded cand. 15 (out of 16) for (2^2x3).L3(4).2_1 by 7-mod. table
    #I  excluded cand. 16 (out of 16) for (2^2x3).L3(4).2_1 by 7-mod. table
    #I  not all input tables for 2^2.2E6(2) mod 2 available
    #I  not all input tables for 2^2.2E6(2) mod 3 available
    #I  not all input tables for 2^2.2E6(2) mod 5 available
    #I  not all input tables for 2^2.2E6(2) mod 7 available
    #I  not all input tables for (2^2x3).2E6(2) mod 2 available
    #I  not all input tables for (2^2x3).2E6(2) mod 3 available
    #I  not all input tables for (2^2x3).2E6(2) mod 5 available
    #I  not all input tables for (2^2x3).2E6(2) mod 7 available
    #I  not all input tables for (2^2x3).2E6(2) mod 11 available
    #I  not all input tables for (2^2x3).2E6(2) mod 13 available
    #I  not all input tables for (2^2x3).2E6(2) mod 17 available
    #I  not all input tables for (2^2x3).2E6(2) mod 19 available

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;The Character Table of 2<sup>2</sup>.O<sub>8</sub><sup>+</sup>(3)
(March 2009)</h3><a name="MultO8p3">
</a>

<div class="p"><!----></div>
When one tries to construct the character table of the central extensions of
G = O<sub>8</sub><sup>+</sup>(3) by a Klein four group,
in the same way as in Section&nbsp;<a href="#V4GATLAS">7.2</a>,
one notices that the order three automorphism that relates the three central
extensions of G by an involution is <em>not</em> uniquely determined.

<div class="p"><!----></div>

<pre>
    gap&#62; entry:= [ "2^2.O8+(3)", "2.O8+(3)", "O8+(3)" ];;
    gap&#62; tblG:= CharacterTable( entry[3] );;
    gap&#62; aut:= AutomorphismsOfTable( tblG );;
    gap&#62; ord3:= Set( List( Filtered( aut, x -&#62; Order( x ) = 3 ),
    &#62;                      SmallestGeneratorPerm ) );;
    gap&#62; Length( ord3 );
    4

</pre>

<div class="p"><!----></div>
However, the table candidates one gets from the four possible automorphisms
turn out to be all equivalent,
hence the character table of 2<sup>2</sup>.O<sub>8</sub><sup>+</sup>(3) can be constructed as follows.

<div class="p"><!----></div>

<pre>
    gap&#62; poss:= [];;
    gap&#62; tbl2G:= CharacterTable( entry[2] );
    CharacterTable( "2.O8+(3)" )
    gap&#62; for pi in ord3 do
    &#62;   Append( poss,
    &#62;           PossibleCharacterTablesOfTypeV4G( tblG, tbl2G, pi, entry[1] ) );
    &#62; od;
    gap&#62; Length( poss );
    32
    gap&#62; poss:= RepresentativesCharacterTables( poss );;
    gap&#62; Length( poss );
    1

</pre>

<div class="p"><!----></div>
The computed table coincides with the library table.

<div class="p"><!----></div>

<pre>
    gap&#62; lib:= CharacterTable( entry[1] );;
    gap&#62; if TransformingPermutationsCharacterTables( poss[1], lib ) = fail then
    &#62;      Print( "#E  differences for ", entry[1], "\n" );
    &#62;    fi;

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.4">
7.4</a>&nbsp;&nbsp;The Character Table of the Schur Cover of L<sub>3</sub>(4)
(September 2005)</h3><a name="MultL34">
</a>

<div class="p"><!----></div>
The Schur cover of G = L<sub>3</sub>(4) has the structure (4<sup>2</sup> &times;3).L<sub>3</sub>(4).
Following&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;23], we regard the multiplier of G as

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 M = &#9001;a, b, c, d  | [a,b] = [a,c] = [a,d] = [b,c] = [b,d] = [c,d] = a<sup>4</sup> = b<sup>4</sup> = c<sup>4</sup> = d<sup>3</sup> = abc &#9002;,</td></tr></table>
</td></tr></table>


and we will consider the automorphism &#945; of M.G
that acts as (a,b,c)(d) on M.

<div class="p"><!----></div>
The subgroup lattice of the subgroup
&#9001;a, b, c &#9002; =  &#9001;a, b &#9002; &#8773; 4<sup>2</sup> of M
looks as follows.
(The subgroup in the centre of the picture is the Klein four group
&#9001;a<sup>2</sup>, b<sup>2</sup>, c<sup>2</sup> &#9002; =  &#9001;a<sup>2</sup>, b<sup>2</sup> &#9002;.)

<div class="p"><!----></div>

<center> <img src="ctblcons17.png" alt="ctblcons17.png" />

</center>

<div class="p"><!----></div>
(The symmetry w.r.t.&nbsp;&#945; would be reflected better
in a three dimensional model,
with &#9001;a, b &#9002;, &#9001;a<sup>2</sup>, b<sup>2</sup> &#9002;, and the
trivial subgroup on a vertical symmetry axis,
and with the remaining subgroups on three circles such that &#945;
induces a rotation.)

<div class="p"><!----></div>

<div class="p"><!----></div>
We have
(M / &#9001;a &#9002;).G  &#8773; (M / &#9001;b &#9002;).G  &#8773; (M / &#9001;c &#9002;).G  &#8773; 12<sub>2</sub>.G
and
(M / &#9001;a b<sup>2</sup> &#9002;).G  &#8773; (M / &#9001;b c<sup>2</sup> &#9002;).G  &#8773; (M / &#9001;c a<sup>2</sup> &#9002;).G  &#8773; 12<sub>1</sub>.G.
This is because the action of G.2<sub>2</sub> fixes a, and swaps b and c;
so b is inverted modulo &#9001;a &#9002; but fixed modulo
&#9001;a b<sup>2</sup> &#9002;,
and the normal subgroup of order four in 4<sub>2</sub>.G.2<sub>2</sub> is central
but that in 4<sub>1</sub>.G.2<sub>2</sub> is not central.

<div class="p"><!----></div>
The constructions of the character tables of 4<sup>2</sup>.G and (4<sup>2</sup> &times;3).G
are essentially the same.
We start with the table of 4<sup>2</sup>.G.
It can be regarded as a central extension H = V.2<sup>2</sup>.G of
2<sup>2</sup>.G by a Klein four group V.
The three subgroups of order two in V are cyclicly permuted
by the automorphism of M / &#9001;d &#9002; induced by &#945;,
so the three factors by these subgroups are isomorphic groups F, say,
with the structure (2 &times;4).G.

<div class="p"><!----></div>
The group F itself is a central extension of 2.G by a Klein four group,
but in this case the three factor groups by the order two subgroups of the
Klein four group are nonisomorphic groups, of the types
4<sub>1</sub>.G, 4<sub>2</sub>.G, and 2<sup>2</sup>.G, respectively.
The <font face="helvetica">GAP</font> function <tt>PossibleCharacterTablesOfTypeV4G</tt> can be used
to construct the character table of F from the three factors.
Note that in this case, no information about table automorphisms is
required.

<div class="p"><!----></div>

<pre>
    gap&#62; tblG:= CharacterTable( "2.L3(4)" );;
    gap&#62; tbls2G:= List( [ "4_1.L3(4)", "4_2.L3(4)", "2^2.L3(4)"],
    &#62;                   CharacterTable );;
    gap&#62; poss:= PossibleCharacterTablesOfTypeV4G( tblG, tbls2G, "(2x4).L3(4)" );;
    gap&#62; Length( poss );
    2
    gap&#62; reps:= RepresentativesCharacterTables( poss );
    [ CharacterTable( "(2x4).L3(4)" ) ]
    gap&#62; lib:= CharacterTable( "(2x4).L3(4)" );;
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( reps[1], lib ) );
    true

</pre>

<div class="p"><!----></div>
In the second step, we construct the table of 4<sup>2</sup>.G from that of
(2 &times;4).G and the table automorphism of 2<sup>2</sup>.G
that is induced by &#945;;
it turns out that the group of table automorphisms of 2<sup>2</sup>.G contains
a unique subgroup of order three.

<div class="p"><!----></div>

<pre>
    gap&#62; tblG:= tbls2G[3];
    CharacterTable( "2^2.L3(4)" )
    gap&#62; tbl2G:= lib;       
    CharacterTable( "(2x4).L3(4)" )
    gap&#62; aut:= AutomorphismsOfTable( tblG );;
    gap&#62; ord3:= Set( List( Filtered( aut, x -&#62; Order( x ) = 3 ),
    &#62;                  SmallestGeneratorPerm ) );
    [ (2,3,4)(6,7,8)(10,11,12)(13,15,17)(14,16,18)(20,21,22)(24,25,26)(28,29,
        30)(32,33,34) ]
    gap&#62; pi:= ord3[1];;
    gap&#62; poss:= PossibleCharacterTablesOfTypeV4G( tblG, tbl2G, pi, "4^2.L3(4)" );;
    gap&#62; Length( poss );
    4
    gap&#62; reps:= RepresentativesCharacterTables( poss );        
    [ CharacterTable( "4^2.L3(4)" ) ]
    gap&#62; lib:= CharacterTable( "4^2.L3(4)" );;
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( reps[1], lib ) );
    true

</pre>

<div class="p"><!----></div>
With the same approach,
we compute the table of (2 &times;12).G = 2<sup>2</sup>.6.G
from the tables of the three nonisomorphic factor groups 12<sub>1</sub>.G, 12<sub>2</sub>.G,
and (2<sup>2</sup> &times;3).G,
and we compute the table of (4<sup>2</sup> &times;3).G = 2<sup>2</sup>.(2<sup>2</sup> &times;3).G
from the three tables of the factor groups (2 &times;12).G and the action
induced by &#945;.

<div class="p"><!----></div>

<pre>
    gap&#62; tblG:= CharacterTable( "6.L3(4)" );;
    gap&#62; tbls2G:= List( [ "12_1.L3(4)", "12_2.L3(4)", "(2^2x3).L3(4)"],            
    &#62;                   CharacterTable );;
    gap&#62; poss:= PossibleCharacterTablesOfTypeV4G( tblG, tbls2G, "(2x12).L3(4)" );;
    gap&#62; Length( poss );
    2
    gap&#62; reps:= RepresentativesCharacterTables( poss );
    [ CharacterTable( "(2x12).L3(4)" ) ]
    gap&#62; lib:= CharacterTable( "(2x12).L3(4)" );;
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( reps[1], lib ) );
    true
    gap&#62; tblG:= CharacterTable( "(2^2x3).L3(4)" ); 
    CharacterTable( "(2^2x3).L3(4)" )
    gap&#62; tbl2G:= CharacterTable( "(2x12).L3(4)" );
    CharacterTable( "(2x12).L3(4)" )
    gap&#62; aut:= AutomorphismsOfTable( tblG );;
    gap&#62; ord3:= Set( List( Filtered( aut, x -&#62; Order( x ) = 3 ),
    &#62;                  SmallestGeneratorPerm ) );
    [ (2,7,8)(3,4,10)(6,11,12)(14,19,20)(15,16,22)(18,23,24)(26,27,28)(29,35,
        41)(30,37,43)(31,39,45)(32,36,42)(33,38,44)(34,40,46)(48,53,54)(49,50,
        56)(52,57,58)(60,65,66)(61,62,68)(64,69,70)(72,77,78)(73,74,80)(76,81,
        82)(84,89,90)(85,86,92)(88,93,94) ]
    gap&#62; pi:= ord3[1];;
    gap&#62; poss:= PossibleCharacterTablesOfTypeV4G( tblG, tbl2G, pi,
    &#62;                                             "(4^2x3).L3(4)" );;
    gap&#62; Length( poss );
    4
    gap&#62; reps:= RepresentativesCharacterTables( poss );
    [ CharacterTable( "(4^2x3).L3(4)" ) ]
    gap&#62; lib:= CharacterTable( "(4^2x3).L3(4)" );;
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( reps[1], lib ) );
    true

</pre>

<div class="p"><!----></div>

 <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;Examples of Extensions by p-singular Automorphisms</h2><a name="xplpsing">
</a>

<div class="p"><!----></div>

     <h3><a name="tth_sEc8.1">
8.1</a>&nbsp;&nbsp;Some p-Modular Tables of Groups of the Type M.G.A</h3>

<div class="p"><!----></div>
We show an alternative construction of p-modular tables
of certain groups that have been met in Section&nbsp;<a href="#ATLASMGA">4.3</a>.
Each entry in the <font face="helvetica">GAP</font> list <tt>listMGA</tt> contains the <tt>Identifier</tt> values of
character tables of groups of the types M.G, G, G.A, and M.G.A.
For each entry with &#124;A&#124; = p, a prime integer, we fetch the p-modular
table of G and the ordinary table of G.A, compute the action of G.A
on the p-regular classes of G,
and then compute the p-modular table of G.A.
Analogously, we compute the p-modular table of M.G.A from the p-modular
table of M.G and the ordinary table of M.G.A.

<div class="p"><!----></div>

<pre>
    gap&#62; for input in listMGA do
    &#62;      ordtblMG  := CharacterTable( input[1] );
    &#62;      ordtblG   := CharacterTable( input[2] );
    &#62;      ordtblGA  := CharacterTable( input[3] );
    &#62;      ordtblMGA := CharacterTable( input[4] );
    &#62;      p:= Size( ordtblGA ) / Size( ordtblG );
    &#62;      if IsPrimeInt( p ) then
    &#62;        modtblG:= ordtblG mod p;
    &#62;        if modtblG &lt;&#62; fail then
    &#62;          modtblGA := CharacterTableRegular( ordtblGA, p );
    &#62;          SetIrr( modtblGA, IBrOfExtensionBySingularAutomorphism( modtblG,
    &#62;                                ordtblGA ) );
    &#62;          if TransformingPermutationsCharacterTables( modtblGA,
    &#62;                 ordtblGA mod p ) = fail then
    &#62;            Print( "#E  computed table and library table for ", input[3],
    &#62;                   " mod ", p, " differ\n" );
    &#62;          fi;
    &#62;        fi;
    &#62;        modtblMG:= ordtblMG mod p;
    &#62;        if modtblMG &lt;&#62; fail then
    &#62;          modtblMGA := CharacterTableRegular( ordtblMGA, p );
    &#62;          SetIrr( modtblMGA, IBrOfExtensionBySingularAutomorphism( modtblMG,
    &#62;                                 ordtblMGA ) );
    &#62;          if TransformingPermutationsCharacterTables( modtblMGA,
    &#62;                 ordtblMGA mod p ) = fail then
    &#62;            Print( "#E  computed table and library table for ", input[4],
    &#62;                   " mod ", p, " differ\n" );
    &#62;          fi;
    &#62;        fi;
    &#62;      fi;
    &#62;    od;

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc8.2">
8.2</a>&nbsp;&nbsp;Some p-Modular Tables of Groups of the Type G.S<sub>3</sub></h3>

<div class="p"><!----></div>
We show an alternative construction of 2- and 3-modular tables
of certain groups that have been met in Section&nbsp;<a href="#xplGS3">5.2</a>.
Each entry in the <font face="helvetica">GAP</font> list <tt>listGS3</tt> contains the <tt>Identifier</tt> values of
character tables of groups of the types G, G.2, G.3, and G.S<sub>3</sub>.
For each entry, we fetch the 2-modular table of G and the ordinary table
of G.2, compute the action of G.2 on the 2-regular classes of G,
and then compute the 2-modular table of G.2.
Analogously, we compute the 3-modular table of G.3 from the 3-modular
table of G and the ordinary table of G.3,
and we compute the 2-modular table of G.S<sub>3</sub> from the 2-modular table
of G.3 and the ordinary table of G.S<sub>3</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; for input in listGS3 do
    &#62;      modtblG:= CharacterTable( input[1] ) mod 2;
    &#62;      if modtblG &lt;&#62; fail then
    &#62;        ordtblG2 := CharacterTable( input[2] );
    &#62;        modtblG2 := CharacterTableRegular( ordtblG2, 2 );
    &#62;        SetIrr( modtblG2, IBrOfExtensionBySingularAutomorphism( modtblG,
    &#62;                              ordtblG2 ) );
    &#62;        if TransformingPermutationsCharacterTables( modtblG2,
    &#62;               ordtblG2 mod 2 ) = fail then
    &#62;          Print( "#E  computed table and library table for ", input[2],
    &#62;                 " mod 2 differ\n" );
    &#62;        fi;
    &#62;      fi;
    &#62;      modtblG:= CharacterTable( input[1] ) mod 3;
    &#62;      if modtblG &lt;&#62; fail then
    &#62;      ordtblG3 := CharacterTable( input[3] );
    &#62;        modtblG3 := CharacterTableRegular( ordtblG3, 3 );
    &#62;        SetIrr( modtblG3, IBrOfExtensionBySingularAutomorphism( modtblG,
    &#62;                              ordtblG3 ) );
    &#62;        if TransformingPermutationsCharacterTables( modtblG3,
    &#62;               ordtblG3 mod 3 ) = fail then
    &#62;          Print( "#E  computed table and library table for ", input[3],
    &#62;                 " mod 3 differ\n" );
    &#62;        fi;
    &#62;      fi;
    &#62;      modtblG3:= CharacterTable( input[3] ) mod 2;
    &#62;      if modtblG3 &lt;&#62; fail then
    &#62;        ordtblGS3 := CharacterTable( input[4] );
    &#62;        modtblGS3 := CharacterTableRegular( ordtblGS3, 2 );
    &#62;        SetIrr( modtblGS3, IBrOfExtensionBySingularAutomorphism( modtblG3,
    &#62;                               ordtblGS3 ) );
    &#62;        if TransformingPermutationsCharacterTables( modtblGS3,
    &#62;               ordtblGS3 mod 2 ) = fail then
    &#62;          Print( "#E  computed table and library table for ", input[4],
    &#62;                 " mod 2 differ\n" );
    &#62;        fi;
    &#62;      fi;
    &#62;    od;

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc8.3">
8.3</a>&nbsp;&nbsp;2-Modular Tables of Groups of the Type G.2<sup>2</sup></h3>

<div class="p"><!----></div>
We show an alternative construction of 2-modular tables
of certain groups that have been met in Section&nbsp;<a href="#xplGV43.A6.V4">6.2</a>.
Each entry in the <font face="helvetica">GAP</font> list <tt>listGV4</tt> contains the <tt>Identifier</tt> values of
character tables of groups of the types G, G.2<sub>1</sub>, G.2<sub>2</sub>, G.2<sub>3</sub>,
and G.2<sup>2</sup>.
For each entry, we fetch the 2-modular table of G and the ordinary tables
of the groups G.2<sub>i</sub>, and compute the 2-modular tables of G.2<sub>i</sub>;
Then we compute from this modular table and the ordinary table of G.2<sup>2</sup>
the 2-modular table of G.2<sup>2</sup>.

<div class="p"><!----></div>

<pre>
    gap&#62; for input in listGV4 do
    &#62;      modtblG   := CharacterTable( input[1] ) mod 2;
    &#62;      if modtblG &lt;&#62; fail then
    &#62;        ordtblsG2 := List( input{ [ 2 .. 4 ] }, CharacterTable );
    &#62;        ordtblGV4 := CharacterTable( input[5] );
    &#62;        for tblG2 in ordtblsG2 do
    &#62;          modtblG2:= CharacterTableRegular( tblG2, 2 );
    &#62;          SetIrr( modtblG2, IBrOfExtensionBySingularAutomorphism( modtblG,
    &#62;                                tblG2 ) );
    &#62;          if TransformingPermutationsCharacterTables( modtblG2,
    &#62;                 tblG2 mod 2 ) = fail then
    &#62;            Print( "#E  computed table and library table for ",
    &#62;                   Identifier( tblG2 ), " mod 2 differ\n" );
    &#62;          fi;
    &#62;          modtblGV4:= CharacterTableRegular( ordtblGV4, 2 );
    &#62;          SetIrr( modtblGV4, IBrOfExtensionBySingularAutomorphism( modtblG2,
    &#62;                                ordtblGV4 ) );
    &#62;          if TransformingPermutationsCharacterTables( modtblGV4,
    &#62;                 ordtblGV4 mod 2 ) = fail then
    &#62;            Print( "#E  computed table and library table for ", input[5],
    &#62;                   " mod 2 differ\n" );
    &#62;          fi;
    &#62;        od;
    &#62;      fi;
    &#62;    od;

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

 <h2><a name="tth_sEc9">
9</a>&nbsp;&nbsp;Examples of Subdirect Products of Index Two</h2><a name="Gsubdir">
</a>

<div class="p"><!----></div>
Typical examples of this construction are those maximal subgroups of
alternating groups A<sub>n</sub> that extend in the corresponding symmetric groups
S<sub>n</sub> to direct products of the structures S<sub>m</sub> &times;S<sub>n&#8722;m</sub>,
for 2  &lt;  m  &lt;  n/2.
Also certain subgroups of these maximal subgroups that have this structure
can be interesting, see Section&nbsp;<a href="#A12N7">4.2</a>.

<div class="p"><!----></div>

     <h3><a name="tth_sEc9.1">
9.1</a>&nbsp;&nbsp;Certain Dihedral Groups as Subdirect Products of Index Two</h3><a name="dihedralsubdir">
</a>

<div class="p"><!----></div>
Also dihedral groups of order 2 n with n divisible by at least two
different primes have the required structure:
Let n = n<sub>1</sub> n<sub>2</sub> with coprime n<sub>1</sub>, n<sub>2</sub>,
and let the normal subgroups H<sub>1</sub>, H<sub>2</sub> be cyclic subgroups of order n<sub>1</sub>
and n<sub>2</sub>, respectively, inside the cyclic subgroup of index two.
Then the factors G/N<sub>1</sub>, G/N<sub>2</sub> are themselves dihedral groups.

<div class="p"><!----></div>
So an example (with n<sub>1</sub> = 3 and n<sub>2</sub> = 5) is the construction of
the dihedral group D<sub>30</sub> as a subdirect product of index two
in the direct product D<sub>6</sub> &times;D<sub>10</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; tblh1:= CharacterTable( "C3" );;
    gap&#62; tblg1:= CharacterTable( "S3" );;
    gap&#62; StoreFusion( tblh1, PossibleClassFusions( tblh1, tblg1 )[1], tblg1 );
    gap&#62; tblh2:= CharacterTable( "C5" );;
    gap&#62; tblg2:= CharacterTable( "D10" );;
    gap&#62; StoreFusion( tblh2, PossibleClassFusions( tblh2, tblg2 )[1], tblg2 );
    gap&#62; subdir:= CharacterTableOfIndexTwoSubdirectProduct( tblh1, tblg1,
    &#62;                 tblh2, tblg2, "D30" );;
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( subdir.table,
    &#62;                  CharacterTable( "Dihedral", 30 ) ) );
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc9.2">
9.2</a>&nbsp;&nbsp;The Character Table of (D<sub>10</sub> &times;HN).2  &lt;  M (June 2008)</h3>

<div class="p"><!----></div>
The sporadic simple Monster group contains maximal subgroups with the
structure (D<sub>10</sub> &times;HN).2 (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;234]),
the factor group modulo D<sub>10</sub> is the automorphism group HN.2 of HN,
and the factor group modulo HN is the Frobenius group 5:4 of order 20.

<div class="p"><!----></div>

<pre>
    gap&#62; tblh1:= CharacterTable( "D10" );;
    gap&#62; tblg1:= CharacterTable( "5:4" );;
    gap&#62; tblh2:= CharacterTable( "HN" );;
    gap&#62; tblg2:= CharacterTable( "HN.2" );;
    gap&#62; subdir:= CharacterTableOfIndexTwoSubdirectProduct( tblh1, tblg1,
    &#62;                 tblh2, tblg2, "(D10xHN).2" );;
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( subdir.table,
    &#62;                  CharacterTable( "(D10xHN).2" ) ) );
    true
    gap&#62; m:= CharacterTable( "M" );;
    gap&#62; fus:= PossibleClassFusions( subdir.table, m );;
    gap&#62; Length( fus );
    16
    gap&#62; Length( RepresentativesFusions( subdir.table, fus, m ) );
    1

</pre>

<div class="p"><!----></div>
An alternative construction is the one described in Section&nbsp;<a href="#theorMGA">3.1</a>,
as (D<sub>10</sub> &times;HN).2 = M.G.A with G = 2 &times;HN,
M.G = D<sub>10</sub> &times;HN, and G.A the subdirect product of HN.2 and
a cyclic group of order four
(which can be constructed as the isoclinic variant of 2 &times;HN.2,
see Section&nbsp;<a href="#isoclinism">2.4</a>).

<div class="p"><!----></div>
Here is this construction:

<div class="p"><!----></div>

<pre>
    gap&#62; c2:= CharacterTable( "C2" );;
    gap&#62; hn:= CharacterTable( "HN" );;
    gap&#62; g:= c2 * hn;;
    gap&#62; d10:= CharacterTable( "D10" );;
    gap&#62; mg:= d10 * hn;;
    gap&#62; nsg:= ClassPositionsOfNormalSubgroups( mg );
    [ [ 1 ], [ 1, 55 .. 109 ], [ 1, 55 .. 163 ], [ 1 .. 54 ], [ 1 .. 162 ], 
      [ 1 .. 216 ] ]
    gap&#62; SizesConjugacyClasses( mg ){ nsg[2] };
    [ 1, 2, 2 ]
    gap&#62; g:= mg / nsg[2];
    CharacterTable( "D10xHN/[ 1, 55, 109 ]" )
    gap&#62; help:= c2 * CharacterTable( "HN.2" );
    CharacterTable( "C2xHN.2" )
    gap&#62; ga:= CharacterTableIsoclinic( help ); 
    CharacterTable( "Isoclinic(C2xHN.2)" )
    gap&#62; gfusga:= PossibleClassFusions( g, ga ); 
    [ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11, 12, 13, 14, 15, 16, 17, 18, 19, 
          20, 21, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 32, 33, 33, 
          34, 35, 36, 37, 37, 38, 39, 40, 40, 41, 42, 42, 43, 43, 44, 44, 79, 80, 
          81, 82, 83, 84, 85, 86, 87, 88, 89, 89, 90, 91, 92, 93, 94, 95, 96, 97, 
          98, 99, 100, 101, 101, 102, 103, 103, 104, 105, 106, 107, 108, 109, 
          110, 110, 111, 111, 112, 113, 114, 115, 115, 116, 117, 118, 118, 119, 
          120, 120, 121, 121, 122, 122 ], 
      [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11, 12, 13, 14, 15, 16, 17, 18, 19, 
          20, 21, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 32, 33, 33, 
          35, 34, 36, 37, 37, 38, 39, 40, 40, 41, 42, 42, 43, 43, 44, 44, 79, 80, 
          81, 82, 83, 84, 85, 86, 87, 88, 89, 89, 90, 91, 92, 93, 94, 95, 96, 97, 
          98, 99, 100, 101, 101, 102, 103, 103, 104, 105, 106, 107, 108, 109, 
          110, 110, 111, 111, 113, 112, 114, 115, 115, 116, 117, 118, 118, 119, 
          120, 120, 121, 121, 122, 122 ] ]
    gap&#62; StoreFusion( g, gfusga[1], ga );
    gap&#62; acts:= PossibleActionsForTypeMGA( mg, g, ga );;
    gap&#62; Length( acts );
    1
    gap&#62; poss:= PossibleCharacterTablesOfTypeMGA( mg, g, ga, acts[1],       
    &#62;               "(D10xHN).2" );;
    gap&#62; Length( poss );
    1
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( poss[1].table,
    &#62;                  CharacterTable( "(D10xHN).2" ) ) );
    true

</pre>

<div class="p"><!----></div>


<div class="p"><!----></div>

<h2>References</h2>

<dl compact="compact">
 <dt><a href="#CITECCE" name="CCE">[Bre]</a></dt><dd>
T.&nbsp;Breuer, <em>Constructing character tables of central extensions in
  <font face="helvetica">GAP</font></em>, <a href="http://www.math.rwth-aachen.de/~Thomas.Breuer/ctbllib/doc/ctocenex.pdf"><tt>http://www.math.rwth-aachen.de/</tt>
<tt><tt>~</tt>Thomas.Breuer/</tt>
<tt>ctbllib/</tt><tt>doc/</tt>
<tt>ctocenex.pdf</tt></a>.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITECTblLib1.2" name="CTblLib1.2">[Bre12]</a></dt><dd>
<br /><table align="left" border="0"><tr><td width="50">
<hr />
</td></tr></table><!--hbox-->
 , <em>The <font face="helvetica">GAP</font> Character Table Library, Version 1.2</em>,
  <a href="http://www.math.rwth-aachen.de/~Thomas.Breuer/ctbllib"><tt>http://www.math.rwth-aachen.de/</tt>
<tt><tt>~</tt>Thomas.Breuer/</tt>
<tt>ctbllib</tt></a>, Mar 2012, <font face="helvetica">GAP</font> package.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITECCN85" name="CCN85">[CCN<sup>+</sup>85]</a></dt><dd>
J.&nbsp;H. Conway, R.&nbsp;T. Curtis, S.&nbsp;P. Norton, R.&nbsp;A. Parker, and R.&nbsp;A. Wilson,
  <em>Atlas of finite groups</em>, Oxford University Press, Eynsham, 1985,
  Maximal subgroups and ordinary characters for simple groups, With
  computational assistance from J. G. Thackray. MR 827219 (88g:20025)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEFeit82" name="Feit82">[Fei82]</a></dt><dd>
W.&nbsp;Feit, <em>The representation theory of finite groups</em>, North-Holland
  Mathematical Library, vol.&nbsp;25, North-Holland Publishing Co., 1982, xiv+502
  pp., ISBN 0-444-86155-6. MR 661045 (83g:20001)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEGag86" name="Gag86">[Gag86]</a></dt><dd>
S.&nbsp;M. Gagola, Jr., <em>Formal character tables</em>, Michigan Math. J.
  <b>33</b> (1986), no.&nbsp;1, 3-10. MR 817904 (86k:20010)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEGAP4" name="GAP4">[GAP04]</a></dt><dd>
The GAP&nbsp;Group, <em>GAP-Groups, Algorithms, and
  Programming, Version 4.4</em>, 2004, <a href="http://www.gap-system.org"><tt>http://www.gap-system.org</tt></a>.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEHL94" name="HL94">[HL94]</a></dt><dd>
G.&nbsp;Hiss and K.&nbsp;Lux, <em>The 5-modular characters of the sporadic simple
  Fischer groups <span class="roman">Fi</span><sub>22</sub> and <span class="roman">Fi</span><sub>23</sub></em>, Comm. Algebra
  <b>22</b> (1994), no.&nbsp;9, 3563-3590, With an appendix by Thomas
  Breuer. MR 1278806 (95e:20020)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEIsa76" name="Isa76">[Isa76]</a></dt><dd>
I.&nbsp;M. Isaacs, <em>Character theory of finite groups</em>, Academic Press
  [Harcourt Brace Jovanovich Publishers], New York, 1976, Pure and Applied
  Mathematics, No. 69. MR 0460423 (57 #417)</dd>
</dl>


<div class="p"><!----></div>

<div class="p"><!----></div>

<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 3.59.<br />On  5 May 2012, 09:04.</small>
</html>
