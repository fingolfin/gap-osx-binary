<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.59">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 

               
<title> GAP Computations Concerning Probabilistic Generation of Finite Simple Groups</title>
 
<h1 align="center">GAP Computations Concerning Probabilistic Generation of Finite Simple Groups </h1>
  <body bgcolor="FFFFFF"> 

<div class="p"><!----></div>

<h3 align="center"> T<font size="-2">HOMAS</font> B<font size="-2">REUER</font> <br />
<i>Lehrstuhl D f&#252;r Mathematik</i> <br />
<i>RWTH, 52056 Aachen, Germany</i> </h3>

<div class="p"><!----></div>

<h3 align="center">March 28th, 2012 </h3>

<div class="p"><!----></div>


<div class="p"><!----></div>

This is a collection of examples showing how
the <font face="helvetica">GAP</font> system&nbsp;[<a href="#GAP" name="CITEGAP">GAP12</a>]
can be used to compute information about the probabilistic generation of
finite almost simple groups.
It includes all examples that were needed for the computational results
in&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>].

<div class="p"><!----></div>
The purpose of this writeup is twofold.
On the one hand, the computations are documented this way.
On the other hand, the <font face="helvetica">GAP</font> code shown for the examples can be used as
test input for automatic checking of the data and the functions used.

<div class="p"><!----></div>
A first version of this document, which was based on <font face="helvetica">GAP</font>&nbsp;4.4.10,
had been accessible in the web since April&nbsp;2006
and is available in the arXiv (no. 0710.3267) since October&nbsp;2007.
The differences to the current version are as follows.

<ul>
<li>  The format of the <font face="helvetica">GAP</font> output was adjusted to the changed behaviour
  of <font face="helvetica">GAP</font>&nbsp;4.5.
  This affects mainly the way how <font face="helvetica">GAP</font> records are printed.
<div class="p"><!----></div>
</li>

<li>
  Several computations are now easier because more character tables of
  almost simple groups and maximal subgroups of such groups are available
  in the <font face="helvetica">GAP</font> Character Table Library.
  (The more involved computations from the original version have been kept
  in the file.)
<div class="p"><!----></div>
</li>

<li>
  The computation of all conjugacy classes of a subgroup of <span class="roman">P</span>&#8486;<sup>+</sup>(12,3)
  has been replaced by the computation of the conjugacy classes of elements
  of prime order in this subgroup.
<div class="p"><!----></div>
</li>

<li>
  The irreducible element chosen in the simple group <span class="roman">P</span>&#8486;<sup>&#8722;</sup>(10,3) has
  order 61 not 122.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>



<div class="p"><!----></div>

<h1>Contents </h1><a href="#tth_sEc1"
>1&nbsp; Overview</a><br />
<a href="#tth_sEc2"
>2&nbsp; Prerequisites</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.1"
>2.1&nbsp; Theoretical Background</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.2"
>2.2&nbsp; Computational Criteria</a><br />
<a href="#tth_sEc3"
>3&nbsp; <font face="helvetica">GAP</font> Functions for the Computations</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.1"
>3.1&nbsp; General Utilities</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2"
>3.2&nbsp; Character-Theoretic Computations</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.3"
>3.3&nbsp; Computations with Groups</a><br />
<a href="#tth_sEc4"
>4&nbsp; Character-Theoretic Computations</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1"
>4.1&nbsp; Sporadic Simple Groups</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2"
>4.2&nbsp; Automorphism Groups of Sporadic Simple Groups</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3"
>4.3&nbsp; Other Simple Groups - Easy Cases</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.4"
>4.4&nbsp; Automorphism Groups of other Simple Groups - Easy Cases</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.5"
>4.5&nbsp; O<sub>8</sub><sup>&#8722;</sup>(3)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.6"
>4.6&nbsp; O<sub>10</sub><sup>+</sup>(2)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.7"
>4.7&nbsp; O<sub>10</sub><sup>&#8722;</sup>(2)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.8"
>4.8&nbsp; O<sub>12</sub><sup>+</sup>(2)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.9"
>4.9&nbsp; O<sub>12</sub><sup>&#8722;</sup>(2)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.10"
>4.10&nbsp; S<sub>6</sub>(4)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.11"
>4.11&nbsp; &#8727;&nbsp;S<sub>6</sub>(5)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.12"
>4.12&nbsp; S<sub>8</sub>(3)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.13"
>4.13&nbsp; U<sub>4</sub>(4)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.14"
>4.14&nbsp; U<sub>6</sub>(2)</a><br />
<a href="#tth_sEc5"
>5&nbsp; Computations using Groups</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1"
>5.1&nbsp; A<sub>2m+1</sub>, 2  &#8804; m  &#8804; 11</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2"
>5.2&nbsp; A<sub>5</sub></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.3"
>5.3&nbsp; A<sub>6</sub></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.4"
>5.4&nbsp; A<sub>7</sub></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.5"
>5.5&nbsp; L<sub>d</sub>(q)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.6"
>5.6&nbsp; &#8727;&nbsp;L<sub>d</sub>(q) with prime d</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.7"
>5.7&nbsp; Automorphic Extensions of L<sub>d</sub>(q)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.8"
>5.8&nbsp; L<sub>3</sub>(2)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.9"
>5.9&nbsp; M<sub>11</sub></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.10"
>5.10&nbsp; M<sub>12</sub></a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.11"
>5.11&nbsp; O<sub>7</sub>(3)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.12"
>5.12&nbsp; O<sub>8</sub><sup>+</sup>(2)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.13"
>5.13&nbsp; O<sub>8</sub><sup>+</sup>(3)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.14"
>5.14&nbsp; O<sup>+</sup><sub>8</sub>(4)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.15"
>5.15&nbsp; &#8727;&nbsp;O<sub>9</sub>(3)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.16"
>5.16&nbsp; O<sub>10</sub><sup>&#8722;</sup>(3)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.17"
>5.17&nbsp; O<sub>14</sub><sup>&#8722;</sup>(2)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.18"
>5.18&nbsp; O<sub>12</sub><sup>+</sup>(3)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.19"
>5.19&nbsp; &#8727;&nbsp;S<sub>4</sub>(8)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.20"
>5.20&nbsp; S<sub>6</sub>(2)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.21"
>5.21&nbsp; S<sub>8</sub>(2)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.22"
>5.22&nbsp; &#8727;&nbsp;S<sub>10</sub>(2)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.23"
>5.23&nbsp; U<sub>4</sub>(2)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.24"
>5.24&nbsp; U<sub>4</sub>(3)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.25"
>5.25&nbsp; U<sub>6</sub>(3)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.26"
>5.26&nbsp; U<sub>8</sub>(2)</a><br />



<div class="p"><!----></div>

<div class="p"><!----></div>

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Overview</h2>

<div class="p"><!----></div>
The main purpose of this note is to document the <font face="helvetica">GAP</font> computations
that were carried out in order to obtain the computational results
in&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>].
Table&nbsp;<a href="#thetable">1</a> lists the simple groups among these examples.
The first column gives the group names, the second and third columns contain
a plus sign + or a minus sign &#8722;, depending on whether the quantities
&#963;(G,s) and P(G,s), respectively, are less than 1/3.
The fourth column lists the orders of elements s which either prove
the + signs or cover most of the cases for proving these signs.
The fifth column lists the sections in this note where the example is
treated.
The rows of the table are ordered alphabetically w.r.t.&nbsp;the group names.

<div class="p"><!----></div>
In order to keep this note self-contained,
we first describe the theory needed, in Section&nbsp;<a href="#background">2</a>.
The translation of the relevant formulae into <font face="helvetica">GAP</font> functions
can be found in Section&nbsp;<a href="#functions">3</a>.
Then Section&nbsp;<a href="#chartheor">4</a> describes the computations that only require
(ordinary) character tables in the
<font face="helvetica">GAP</font> Character Table Library&nbsp;[<a href="#CTblLib1.2" name="CITECTblLib1.2">Bre12</a>].
Computations using also the groups are shown in Section&nbsp;<a href="#hard">5</a>.
In each of the last two sections, the examples are ordered alphabetically
w.r.t.&nbsp;the names of the simple groups.

<div class="p"><!----></div>

<div class="p"><!----></div>
<a name="tth_tAb1">
</a> <center>Table 1: Computations needed in&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>]</center><a name="thetable">
</a>

<center>

  <table><tr><td valign="top"> 

<table border="1">
<tr><td>G           </td><td align="center">&#963; &lt;  [1/3]
                          </td><td align="center">P &lt;  [1/3]
                                </td><td align="right">&#124;s&#124; </td><td align="right">see </td></tr>
<tr><td>A<sub>5</sub>         </td><td align="center">&#8722; </td><td align="center">&#8722; </td><td align="right">5 </td><td align="right"><a href="#A5">5.2</a>  </td></tr>
<tr><td>A<sub>6</sub>         </td><td align="center">&#8722; </td><td align="center">&#8722; </td><td align="right">4 </td><td align="right"><a href="#A6">5.3</a>  </td></tr>
<tr><td>A<sub>7</sub>         </td><td align="center">&#8722; </td><td align="center">&#8722; </td><td align="right">7 </td><td align="right"><a href="#A7">5.4</a>  </td></tr>
<tr><td>A<sub>8</sub>         </td><td align="center">+ </td><td align="center"></td><td align="right">15 </td><td align="right"><a href="#easyloop">4.3</a>, <a href="#SL">5.5</a> </td></tr>
<tr><td>A<sub>9</sub>         </td><td align="center">+ </td><td align="center"></td><td align="right">9 </td><td align="right"><a href="#easyloop">4.3</a>, <a href="#Aodd">5.1</a> </td></tr>
<tr><td>A<sub>11</sub>      </td><td align="center">+ </td><td align="center"></td><td align="right">11 </td><td align="right"><a href="#easyloop">4.3</a>, <a href="#Aodd">5.1</a> </td></tr>
<tr><td>A<sub>13</sub>      </td><td align="center">+ </td><td align="center"></td><td align="right">13 </td><td align="right"><a href="#easyloop">4.3</a>, <a href="#Aodd">5.1</a> </td></tr>
<tr><td>A<sub>15</sub>      </td><td align="center">+ </td><td align="center"></td><td align="right">15 </td><td align="right"><a href="#Aodd">5.1</a> </td></tr>
<tr><td>A<sub>17</sub>      </td><td align="center">+ </td><td align="center"></td><td align="right">17 </td><td align="right"><a href="#Aodd">5.1</a> </td></tr>
<tr><td>A<sub>19</sub>      </td><td align="center">+ </td><td align="center"></td><td align="right">19 </td><td align="right"><a href="#Aodd">5.1</a> </td></tr>
<tr><td>A<sub>21</sub>      </td><td align="center">+ </td><td align="center"></td><td align="right">21 </td><td align="right"><a href="#Aodd">5.1</a> </td></tr>
<tr><td>A<sub>23</sub>      </td><td align="center">+ </td><td align="center"></td><td align="right">23 </td><td align="right"><a href="#Aodd">5.1</a> </td></tr>
<tr><td>L<sub>3</sub>(2)      </td><td align="center">+ </td><td align="center"></td><td align="right">7 </td><td align="right"><a href="#easyloop">4.3</a>, <a href="#easyloopaut">4.4</a>, </td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="right"></td><td align="right"><a href="#SL">5.5</a>, <a href="#L32">5.8</a> </td></tr>
<tr><td>L<sub>3</sub>(3)      </td><td align="center">+ </td><td align="center"></td><td align="right">13 </td><td align="right"><a href="#easyloop">4.3</a>, <a href="#easyloopaut">4.4</a>, </td></tr>
<tr><td></td><td align="center"></td><td align="center"></td><td align="right"></td><td align="right"><a href="#SL">5.5</a> </td></tr>
<tr><td>L<sub>3</sub>(4)      </td><td align="center">+ </td><td align="center"></td><td align="right">7 </td><td align="right"><a href="#easyloop">4.3</a>, <a href="#easyloopaut">4.4</a> </td></tr>
<tr><td>L<sub>4</sub>(3)      </td><td align="center">+ </td><td align="center"></td><td align="right">20 </td><td align="right"><a href="#easyloop">4.3</a>, <a href="#SL">5.5</a> </td></tr>
<tr><td>L<sub>4</sub>(4)      </td><td align="center">+ </td><td align="center"></td><td align="right">85 </td><td align="right"><a href="#SL">5.5</a> </td></tr>
<tr><td>L<sub>6</sub>(2)      </td><td align="center">+ </td><td align="center"></td><td align="right">63 </td><td align="right"><a href="#SL">5.5</a> </td></tr>
<tr><td>L<sub>6</sub>(3)      </td><td align="center">+ </td><td align="center"></td><td align="right">182 </td><td align="right"><a href="#SL">5.5</a> </td></tr>
<tr><td>L<sub>6</sub>(4)      </td><td align="center">+ </td><td align="center"></td><td align="right">455 </td><td align="right"><a href="#SL">5.5</a> </td></tr>
<tr><td>L<sub>6</sub>(5)      </td><td align="center">+ </td><td align="center"></td><td align="right">1953 </td><td align="right"><a href="#SL">5.5</a> </td></tr>
<tr><td>L<sub>8</sub>(2)      </td><td align="center">+ </td><td align="center"></td><td align="right">255 </td><td align="right"><a href="#SL">5.5</a> </td></tr>
<tr><td>L<sub>10</sub>(2)   </td><td align="center">+ </td><td align="center"></td><td align="right">1023 </td><td align="right"><a href="#SL">5.5</a> </td></tr>
<tr><td>M<sub>11</sub>      </td><td align="center">&#8722; </td><td align="center">&#8722; </td><td align="right">11 </td><td align="right"><a href="#spreadM11">5.9</a> </td></tr>
<tr><td>M<sub>12</sub>      </td><td align="center">&#8722; </td><td align="center">+ </td><td align="right">10 </td><td align="right"><a href="#sporaut">4.2</a>, <a href="#spreadM12">5.10</a> </td></tr></table>


  </td><td>&nbsp;&nbsp;&nbsp;</td><td valign="top"> 

<table border="1">
<tr><td>G           </td><td align="center">&#963; &lt;  [1/3]
                          </td><td align="center">P &lt;  [1/3]
                                </td><td align="right">&#124;s&#124; </td><td align="right">see </td></tr>
<tr><td>O<sup>+</sup><sub>8</sub>(2)    </td><td align="center">&#8722; </td><td align="center">&#8722; </td><td align="right">15 </td><td align="right"><a href="#O8p2">5.12</a> </td></tr>
<tr><td>O<sup>+</sup><sub>8</sub>(3)    </td><td align="center">&#8722; </td><td align="center">&#8722; </td><td align="right">20 </td><td align="right"><a href="#O8p3">5.13</a> </td></tr>
<tr><td>O<sup>+</sup><sub>8</sub>(4)    </td><td align="center">+ </td><td align="center"></td><td align="right">65 </td><td align="right"><a href="#O8p4">5.14</a> </td></tr>
<tr><td>O<sup>+</sup><sub>10</sub>(2) </td><td align="center">+ </td><td align="center"></td><td align="right">45 </td><td align="right"><a href="#O10p2">4.6</a> </td></tr>
<tr><td>O<sup>+</sup><sub>12</sub>(2) </td><td align="center">+ </td><td align="center"></td><td align="right">85 </td><td align="right"><a href="#O12p2">4.8</a> </td></tr>
<tr><td>O<sup>+</sup><sub>12</sub>(3) </td><td align="center">+ </td><td align="center"></td><td align="right">205 </td><td align="right"><a href="#O12p3">5.18</a> </td></tr>
<tr><td>O<sup>&#8722;</sup><sub>8</sub>(2)    </td><td align="center">+ </td><td align="center"></td><td align="right">17 </td><td align="right"><a href="#easyloop">4.3</a> </td></tr>
<tr><td>O<sup>&#8722;</sup><sub>8</sub>(3)    </td><td align="center">+ </td><td align="center"></td><td align="right">41 </td><td align="right"><a href="#O8m3">4.5</a> </td></tr>
<tr><td>O<sup>&#8722;</sup><sub>10</sub>(2) </td><td align="center">+ </td><td align="center"></td><td align="right">33 </td><td align="right"><a href="#O10m2">4.7</a> </td></tr>
<tr><td>O<sup>&#8722;</sup><sub>10</sub>(3) </td><td align="center">+ </td><td align="center"></td><td align="right">122 </td><td align="right"><a href="#O10m3">5.16</a> </td></tr>
<tr><td>O<sup>&#8722;</sup><sub>12</sub>(2) </td><td align="center">+ </td><td align="center"></td><td align="right">65 </td><td align="right"><a href="#O12m2">4.9</a> </td></tr>
<tr><td>O<sup>&#8722;</sup><sub>14</sub>(2) </td><td align="center">+ </td><td align="center"></td><td align="right">129 </td><td align="right"><a href="#O14m2">5.17</a> </td></tr>
<tr><td>O<sub>7</sub>(3)      </td><td align="center">&#8722; </td><td align="center">&#8722; </td><td align="right">14 </td><td align="right"><a href="#O73">5.11</a> </td></tr>
<tr><td>S<sub>4</sub>(4)      </td><td align="center">+ </td><td align="center"></td><td align="right">17 </td><td align="right"><a href="#easyloop">4.3</a>, <a href="#easyloopaut">4.4</a> </td></tr>
<tr><td>S<sub>6</sub>(2)      </td><td align="center">&#8722; </td><td align="center">&#8722; </td><td align="right">9 </td><td align="right"><a href="#S62">5.20</a> </td></tr>
<tr><td>S<sub>6</sub>(3)      </td><td align="center">+ </td><td align="center"></td><td align="right">14 </td><td align="right"><a href="#easyloop">4.3</a>, <a href="#easyloopaut">4.4</a> </td></tr>
<tr><td>S<sub>6</sub>(4)      </td><td align="center">+ </td><td align="center"></td><td align="right">65 </td><td align="right"><a href="#S64">4.10</a> </td></tr>
<tr><td>S<sub>8</sub>(2)      </td><td align="center">&#8722; </td><td align="center">&#8722; </td><td align="right">17 </td><td align="right"><a href="#S82">5.21</a> </td></tr>
<tr><td>S<sub>8</sub>(3)      </td><td align="center">+ </td><td align="center"></td><td align="right">41 </td><td align="right"><a href="#S83">4.12</a> </td></tr>
<tr><td>U<sub>3</sub>(3)      </td><td align="center">+ </td><td align="center"></td><td align="right">6 </td><td align="right"><a href="#easyloop">4.3</a>, <a href="#easyloopaut">4.4</a> </td></tr>
<tr><td>U<sub>3</sub>(5)      </td><td align="center">+ </td><td align="center"></td><td align="right">10 </td><td align="right"><a href="#easyloop">4.3</a>, <a href="#easyloopaut">4.4</a> </td></tr>
<tr><td>U<sub>4</sub>(2)      </td><td align="center">&#8722; </td><td align="center">&#8722; </td><td align="right">9 </td><td align="right"><a href="#U42">5.23</a> </td></tr>
<tr><td>U<sub>4</sub>(3)      </td><td align="center">&#8722; </td><td align="center">+ </td><td align="right">7 </td><td align="right"><a href="#U43">5.24</a> </td></tr>
<tr><td>U<sub>4</sub>(4)      </td><td align="center">+ </td><td align="center"></td><td align="right">65 </td><td align="right"><a href="#U44">4.13</a> </td></tr>
<tr><td>U<sub>5</sub>(2)      </td><td align="center">+ </td><td align="center"></td><td align="right">11 </td><td align="right"><a href="#easyloop">4.3</a> </td></tr>
<tr><td>U<sub>6</sub>(2)      </td><td align="center">+ </td><td align="center"></td><td align="right">11 </td><td align="right"><a href="#U62">4.14</a> </td></tr>
<tr><td>U<sub>6</sub>(3)      </td><td align="center">+ </td><td align="center"></td><td align="right">122 </td><td align="right"><a href="#U63">5.25</a> </td></tr>
<tr><td>U<sub>8</sub>(2)      </td><td align="center">+ </td><td align="center"></td><td align="right">129 </td><td align="right"><a href="#U82">5.26</a> </td></tr></table>


  </td></tr></table> 
</center>

<div class="p"><!----></div>
Contrary to&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>], <font face="helvetica">ATLAS</font> notation is used throughout this note,
because the identifiers used for character tables in the
<font face="helvetica">GAP</font> Character Table Library follow mainly the <font face="helvetica">ATLAS</font>&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>].
For example, we write
L<sub>d</sub>(q) for <span class="roman">PSL</span>(d,q),
S<sub>d</sub>(q) for <span class="roman">PSp</span>(d,q),
U<sub>d</sub>(q) for <span class="roman">PSU</span>(d,q), and
O<sup>+</sup><sub>2d</sub>(q), O<sup>&#8722;</sup><sub>2d</sub>(q), O<sub>2d+1</sub>(q) for
<span class="roman">P</span>&#8486;<sup>+</sup>(2d,q), <span class="roman">P</span>&#8486;<sup>&#8722;</sup>(2d,q), <span class="roman">P</span>&#8486;(2d+1,q), respectively.

<div class="p"><!----></div>
Furthermore, in the case of classical groups,
the character tables of the (almost) <em>simple</em> groups
are considered
not the tables of the matrix groups (which are in fact often not available
in the <font face="helvetica">GAP</font> Character Table Library).
Consequently, also element orders and the description of maximal subgroups
refer to the (almost) simple groups not to the matrix groups.

<div class="p"><!----></div>
This note contains also several examples that are not needed for the proofs
in&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>].
Besides several small simple groups G whose character table
is contained in the <font face="helvetica">GAP</font> Character Table Library
and for which enough information is available for computing &#963;(G),
in Section&nbsp;<a href="#easyloop">4.3</a>,
a few such examples appear in individual sections.
In the table of contents, the section headers of the latter kind of examples
are marked with an asterisk (&#8727;).

<div class="p"><!----></div>
The examples use the <font face="helvetica">GAP</font> Character Table Library,
the <font face="helvetica">GAP</font> Library of Tables of Marks,
and the <font face="helvetica">GAP</font> interface&nbsp;[<a href="#AtlasRep" name="CITEAtlasRep">WPN<sup>+</sup>11</a>] to the
<font face="helvetica">ATLAS</font> of Group Representations&nbsp;[<a href="#AGR" name="CITEAGR">WWT<sup>+</sup></a>],
so we first load these three packages in the required versions.
The <font face="helvetica">GAP</font> output was adjusted to the versions shown below;
in older versions, features necessary for the computations may be missing,
and it may happen that newer versions, the behaviour is different.

<div class="p"><!----></div>
Also, we force the assertion level to zero;
this is the default in interactive <font face="helvetica">GAP</font> sessions
but the level is automatically set to 1 when a file is read with
<tt>ReadTest</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; CompareVersionNumbers( GAPInfo.Version, "4.5.0" );
    true
    gap&#62; LoadPackage( "ctbllib", "1.2" );
    true
    gap&#62; LoadPackage( "tomlib", "1.2" );
    true
    gap&#62; LoadPackage( "atlasrep", "1.5" );
    true
    gap&#62; SetAssertionLevel( 0 );

</pre>

<div class="p"><!----></div>
Some of the computations in Section&nbsp;<a href="#hard">5</a>
require about 800 MB of space (on 32 bit machines).
Therefore we check whether <font face="helvetica">GAP</font> was started with sufficient maximal
memory; the command line option for this is <tt>-o 800m</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; max:= GAPInfo.CommandLineOptions.o;;
    gap&#62; IsSubset( max, "m" ) and Int( Filtered( max, IsDigitChar ) ) &#62;= 800;
    true

</pre>

<div class="p"><!----></div>
Several computations involve calls to the <font face="helvetica">GAP</font> function <tt>Random</tt>.
In order to make the results of individual examples reproducible,
independent of the rest of the computations,
we reset the relevant random number generators
whenever this is appropriate.
For that, we store the initial states in the variable <tt>staterandom</tt>,
and provide a function for resetting the random number generators.
(The <tt>Random</tt> calls in the <font face="helvetica">GAP</font> library use the two random number
generators <tt>GlobalRandomSource</tt> and <tt>GlobalMersenneTwister</tt>.)

<div class="p"><!----></div>

<pre>
    gap&#62; staterandom:= [ State( GlobalRandomSource ),
    &#62;                    State( GlobalMersenneTwister ) ];;
    gap&#62; ResetGlobalRandomNumberGenerators:= function()
    &#62;     Reset( GlobalRandomSource, staterandom[1] );
    &#62;     Reset( GlobalMersenneTwister, staterandom[2] );
    &#62; end;;

</pre>

<div class="p"><!----></div>

 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Prerequisites</h2><a name="background">
</a>

<div class="p"><!----></div>

     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Theoretical Background</h3>

<div class="p"><!----></div>
Let G be a finite group, S the socle of G,
and denote by G<sup>&times;</sup> the set of nonidentity elements in G.
For s, g  &#8712; G<sup>&times;</sup>, let
P( g, s ): = &#124;{ h  &#8712; G; S  &#8836; eq &#9001;s<sup>h</sup>, g &#9002;}&#124; / &#124;G&#124;,
the proportion of elements in the class s<sup>G</sup> which fail to generate
at least S with g;
we set P( G, s ): = max{ P( g, s ); g  &#8712; G<sup>&times;</sup> }.
We are interested in finding a class s<sup>G</sup> of elements in S
such that P( G, s )  &lt;  1/3 holds.

<div class="p"><!----></div>
First consider g  &#8712; S,
and let <font face="helvetica"><i>M</i></font>(S,s) denote the set of those maximal subgroups of S
that contain s.
We have

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 &#124;{ h  &#8712; S; S  &#8836; eq &#9001;s<sup>h</sup>, g &#9002;}&#124; </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 = </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&#124;{ h  &#8712; S; &#9001;s, h g h<sup>&#8722;1</sup> &#9002; &#8800; S }&#124; </td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 &#8804; </td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1"></td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>M  &#8712; <font face="helvetica"><i>M</i></font>(S,s)</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&#124;{ h  &#8712; S; h g h<sup>&#8722;1</sup>  &#8712; M }&#124;</td></tr></table></td><td width="50%"></td></tr></table>
</td></tr></table>


Since h g h<sup>&#8722;1</sup>  &#8712; M holds if and only if the coset M h is fixed by g
under the permutation action of S on the right cosets of M in S,
we get that
&#124;{ h  &#8712; S; h g h<sup>&#8722;1</sup>  &#8712; M }&#124; = &#124;C<sub>S</sub>(g)&#124; &#183;&#124;g<sup>S</sup> &#8745;M&#124; = &#124;M&#124; &#183;1<sub>M</sub><sup>S</sup>(g),
where 1<sub>M</sub><sup>S</sup> is the permutation character of this action,
of degree &#124;S&#124;/&#124;M&#124;.
Thus

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 &#124;{ h  &#8712; S; &#9001;s, h g h<sup>&#8722;1</sup> &#9002; &#8800; S }&#124; / &#124;S&#124; </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 &#8804; </td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1"></td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>M  &#8712; <font face="helvetica"><i>M</i></font>(S,s)</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
1<sub>M</sub><sup>S</sup>(g) / 1<sub>M</sub><sup>S</sup>(1) .</td></tr></table></td><td width="50%"></td></tr></table>
</td></tr></table>


We abbreviate the right hand side of this inequality by &#963;( g, s ),
set &#963;( S, s ): = max{ &#963;( g, s ); g  &#8712; S<sup>&times;</sup> },
and choose a transversal T of S in G.
Then P( g, s )  &#8804; &#124;T&#124;<sup>&#8722;1</sup> &#183;&#8721;<sub>t  &#8712; T</sub> &#963;( g<sup>t</sup>, s )
and thus P( G, s )  &#8804; &#963;( S, s ) holds.

<div class="p"><!----></div>
If S = G and if <font face="helvetica"><i>M</i></font>(G,s) consists of a single maximal subgroup M of G
then equality holds,
i.e., P( g, s ) = &#963;( g, s ) = 1<sub>M</sub><sup>S</sup>(g) / 1<sub>M</sub><sup>S</sup>(1).

<div class="p"><!----></div>
The quantity 1<sub>M</sub><sup>S</sup>(g) / 1<sub>M</sub><sup>S</sup>(1) = &#124;g<sup>S</sup> &#8745;M&#124; / &#124;g<sup>S</sup>&#124;
is the proportion of fixed points of g in the permutation action of S
on the right cosets of its subgroup M.
This is called the <em>fixed point ratio</em> of g w.&nbsp;r.&nbsp;t.&nbsp;S/M,
and is denoted as &#956;(g,S/M).

<div class="p"><!----></div>
For a subgroup M of S, the number n of S-conjugates of M
containing s is equal to &#124;M<sup>S</sup>&#124; &#183;&#124;s<sup>S</sup> &#8745;M&#124; / &#124;s<sup>S</sup>&#124;.
To see this, consider the set { (s<sup>h</sup>, M<sup>k</sup>); h, k  &#8712; S, s<sup>h</sup>  &#8712; M<sup>k</sup> },
the cardinality of which can be counted either as &#124;M<sup>S</sup>&#124; &#183;&#124;s<sup>S</sup> &#8745;M&#124;
or as &#124;s<sup>S</sup>&#124; &#183;n.
So we get n = &#124;M&#124; &#183;1<sub>M</sub><sup>S</sup>(s) / &#124;N<sub>S</sub>(M)&#124;.

<div class="p"><!----></div>
If S is a finite <em>nonabelian simple</em> group
then each maximal subgroup in S is self-normalizing,
and we have n = 1<sub>M</sub><sup>S</sup>(s) if M is maximal.
So we can replace the summation over <font face="helvetica"><i>M</i></font>(S,s) by one over a set
<font face="helvetica"><i>M</i></font>/&#160;&#8764;&#160;(S,s) of representatives of conjugacy classes
of maximal subgroups of S,
and get that

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 &#963;( g, s ) = </td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>M  &#8712; <font face="helvetica"><i>M</i></font>/&#160;&#8764;&#160;(S,s)</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
1<sub>M</sub><sup>S</sup>(s) &#183;1<sub>M</sub><sup>S</sup>(g)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>1<sub>M</sub><sup>S</sup>(1)<br /></td><td nowrap="nowrap" align="center">
.</td></tr></table>
</td></tr></table>


Furthermore, we have &#124;<font face="helvetica"><i>M</i></font>(S,s)&#124; = &#8721;<sub>M  &#8712; <font face="helvetica"><i>M</i></font>/&#160;&#8764;&#160;(S,s)</sub> 1<sub>M</sub><sup>S</sup>(s).

<div class="p"><!----></div>
In the following, we will often deal with the quantities
&#963;(S): = min{ &#963;( S, s ); s  &#8712; S<sup>&times;</sup> } and
<font face="helvetica"><i>S</i></font>(S): = &#63726;1 / &#963;(S) &#8722; 1 &#63737;.
These values can be computed easily from the primitive
permutation characters of S.

<div class="p"><!----></div>
Analogously, we set
P(S): = min{ P( S, s ); s  &#8712; S<sup>&times;</sup> } and
<font face="helvetica"><i>P</i></font>(S): = &#63726;1 / P(S) &#8722; 1 &#63737;.
Clearly we have P(S)  &#8804; &#963;(S) and <font face="helvetica"><i>P</i></font>(S)  &#8805; <font face="helvetica"><i>S</i></font>(S).

<div class="p"><!----></div>
One interpretation of <font face="helvetica"><i>P</i></font>(S) is that if this value is at least k
then it follows that for any g<sub>1</sub>, g<sub>2</sub>, &#8230;, g<sub>k</sub>  &#8712; S<sup>&times;</sup>,
there is some s  &#8712; S such that S = &#9001;g<sub>i</sub>, s &#9002;,
for 1  &#8804; i  &#8804; k.
In this case, S is said to have <em>spread</em> at least k.
(Note that the lower bound <font face="helvetica"><i>S</i></font>(S) for <font face="helvetica"><i>P</i></font>(S) can be computed
from the list of primitive permutation characters of S.)

<div class="p"><!----></div>
Moreover, <font face="helvetica"><i>P</i></font>(S)  &#8805; k implies that the element s can be chosen
uniformly from a fixed conjugacy class of S.
This is called <em>uniform spread</em> at least k in&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>].

<div class="p"><!----></div>
It is proved in&nbsp;[<a href="#GK" name="CITEGK">GK00</a>] that all finite simple groups have uniform spread
at least 1,
that is, for any element x  &#8712; S<sup>&times;</sup>,
there is an element y in a prescribed class of S
such that G = &#9001;x, y &#9002; holds.
In&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Corollary&nbsp;1.3],
it is shown that all finite simple groups have uniform spread at least 2,
and the finite simple groups with (uniform) spread exactly 2 are listed.

<div class="p"><!----></div>
Concerning the spread, it should be mentioned that the methods used here and
in&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>] are nonconstructive in the sense that they cannot be used for
finding an element s that generates G together with each of the k
prescribed elements g<sub>1</sub>, g<sub>2</sub>, &#8230;, g<sub>k</sub>.

<div class="p"><!----></div>
Now consider g  &#8712; G \S.
Since P( g<sup>k</sup>, s )  &#8805; P( g, s ) for any positive integer k,
we can assume that g has prime order p, say.
We set H = &#9001;S, g &#9002; &#8804; G, with [H:S] = p,
choose a transversal T of H in G,
let <font face="helvetica"><i>M</i></font><sup>&#8242;</sup>(H,s): = <font face="helvetica"><i>M</i></font>(H,s) \{ S },
and let <font face="helvetica"><i>M</i></font>/&#160;&#8764;&#160;<sup>&#8242;</sup>(H,s) denote a set of representatives of
H-conjugacy classes of these groups.
As above,

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 &#124;{ h  &#8712; H; S  &#8836; eq &#9001;s<sup>h</sup>, g &#9002;}&#124; / &#124;H&#124; </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 = </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&#124;{ h  &#8712; H; &#9001;s<sup>h</sup>, g &#9002; &#8800; H }&#124; / &#124;H&#124; </td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 &#8804; </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>M  &#8712; <font face="helvetica"><i>M</i></font><sup>&#8242;</sup>(H,s)</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&#124;{ h  &#8712; H; h g h<sup>&#8722;1</sup>  &#8712; M }&#124; / &#124;H&#124; </td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 = </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>M  &#8712; <font face="helvetica"><i>M</i></font><sup>&#8242;</sup>(H,s)</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
1<sub>M</sub><sup>H</sup>(g) / 1<sub>M</sub><sup>H</sup>(1) </td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 = </td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1"></td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>M  &#8712; <font face="helvetica"><i>M</i></font>/&#160;&#8764;&#160;<sup>&#8242;</sup>(H,s)</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
1<sub>M</sub><sup>H</sup>(g) &#183;1<sub>M</sub><sup>H</sup>(s) / 1<sub>M</sub><sup>H</sup>(1)</td></tr></table></td><td width="50%"></td></tr></table>
</td></tr></table>


(Note that no summand for M = S occurs,
so each group in <font face="helvetica"><i>M</i></font>/&#160;&#8764;&#160;<sup>&#8242;</sup>(H,s) is self-normalizing.)
We abbreviate the right hand side by &#963;(H,g,s),
and set &#963;<sup>&#8242;</sup>( H, s ) = max{ &#963;(H,g,s); g  &#8712; H \S, &#124;g&#124; = [H:S] }.
Then we get
P( g, s )  &#8804; &#124;T&#124;<sup>&#8722;1</sup> &#183;&#8721;<sub>t  &#8712; T</sub> &#963;(H<sup>t</sup>,g<sup>t</sup>,s)
and thus

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 P( G, s )  &#8804; </td><td nowrap="nowrap" align="center">
max<br />
</td><td nowrap="nowrap">{ P( S, s ), </td><td nowrap="nowrap" align="center">
max<br />
</td><td nowrap="nowrap">{ &#963;<sup>&#8242;</sup>( H, s ); S  &#8804; H  &#8804; G, [H:S] &nbsp;<span class="roman">prime</span> } } .</td></tr></table>
</td></tr></table>



<div class="p"><!----></div>
For convenience, we set
P<sup>&#8242;</sup>(G,s) = max{ P(g,s); g  &#8712; G \S }.

<div class="p"><!----></div>

     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;Computational Criteria</h3><a name="criteria">
</a>

<div class="p"><!----></div>
The following criteria will be used when we have to show
the existence or nonexistence of x<sub>1</sub>, x<sub>2</sub>, &#8230;, x<sub>k</sub>, and s  &#8712; G
with the property
&#9001;x<sub>i</sub>, s &#9002; =  G for 1  &#8804; i  &#8804; k.
Note that manipulating lists of integers (representing fixed or moved points)
is much more efficient than testing whether certain permutations generate
a given group.

<div class="p"><!----></div>

  <b>Lemma 1</b> <em><a name="existsgoodconjugate">
</a>
Let G be a finite group, s  &#8712; G<sup>&times;</sup>,
and X = &#8746;<sub>M  &#8712; <font face="helvetica"><i>M</i></font>(G,s)</sub> G/M.
For x<sub>1</sub>, x<sub>2</sub>, &#8230;, x<sub>k</sub>  &#8712; G,
the conjugate s<sup>&#8242;</sup> of s satisfies
&#9001;x<sub>i</sub>, s<sup>&#8242;</sup> &#9002; =  G for 1  &#8804; i  &#8804; k
if and only if
<span class="roman">Fix</span><sub>X</sub>(s<sup>&#8242;</sup>) &#8745;&#8746;<sub>i=1</sub><sup>k</sup> <span class="roman">Fix</span><sub>X</sub>(x<sub>i</sub>) = &#8709;
holds.

<div class="p"><!----></div>
</em>  P<font size="-2">ROOF</font>.
If s<sup>g</sup>  &#8712; U  &#8804; G for some g  &#8712; G then
<span class="roman">Fix</span><sub>X</sub>(U) = &#8709; if and only if U = G holds;
note that <span class="roman">Fix</span><sub>X</sub>(G) = &#8709;,
and <span class="roman">Fix</span><sub>X</sub>(U) = &#8709; implies that U  &#8836; eq h<sup>&#8722;1</sup> M h
holds for all h  &#8712; G and M  &#8712; <font face="helvetica"><i>M</i></font>(G,s), thus U = G.

<div class="p"><!----></div>
Applied to U = &#9001;x<sub>i</sub>, s<sup>&#8242;</sup> &#9002;,
we get &#9001;x<sub>i</sub>, s<sup>&#8242;</sup> &#9002; =  G if and only if
<span class="roman">Fix</span><sub>X</sub>(s<sup>&#8242;</sup>) &#8745;<span class="roman">Fix</span><sub>X</sub>(x<sub>i</sub>) = <span class="roman">Fix</span><sub>X</sub>(U) = &#8709;.

 <font size="+1"><font size="-2"><sup>[<u>&#175;</u>]</sup></font></font>

<div class="p"><!----></div>

<div class="p"><!----></div>

   <b>Corollary 2</b> <em><a name="existsgoodconjugate1">
</a>
If <font face="helvetica"><i>M</i></font>(G,s) = { M } in the situation of Lemma&nbsp;<a href="#existsgoodconjugate">2.1</a>
then there is a conjugate s<sup>&#8242;</sup> of s that satisfies
&#9001;x<sub>i</sub>, s<sup>&#8242;</sup> &#9002; =  G for 1  &#8804; i  &#8804; k
if and only if
&#8746;<sub>i=1</sub><sup>k</sup> <span class="roman">Fix</span><sub>X</sub>(x<sub>i</sub>)  &#8800; X.

<div class="p"><!----></div>
</em>
   <b>Corollary 3</b> <em><a name="disprovespread">
</a>
Let G be a finite simple group
and let X  be a G-set such that each g  &#8712; G fixes at least one
point in X but that <span class="roman">Fix</span><sub>X</sub>(G) = &#8709; holds.
If x<sub>1</sub>, x<sub>2</sub>, &#8230;x<sub>k</sub> are elements in G such that
&#8746;<sub>i=1</sub><sup>k</sup> <span class="roman">Fix</span><sub>X</sub>(x<sub>i</sub>) = X holds
then for each s  &#8712; G there is at least one i with
&#9001;x<sub>i</sub>, s &#9002; &#8800; G.

<div class="p"><!----></div>
</em>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;<font face="helvetica">GAP</font> Functions for the Computations</h2><a name="functions">
</a>

<div class="p"><!----></div>
After the introduction of general utilities in Section&nbsp;<a href="#utils">3.1</a>,
we distinguish two different tasks.
Section&nbsp;<a href="#ctfun">3.2</a> introduces functions that will be used
in the following to compute &#963;(g,s) with character-theoretic methods.
Functions for computing P(g,s) or an upper bound for this value
will be introduced in Section&nbsp;<a href="#groups">3.3</a>.

<div class="p"><!----></div>
The <font face="helvetica">GAP</font> functions shown in Section&nbsp;<a href="#functions">3</a>
are collected in the file <tt>tst/probgen.g</tt> that is
distributed with the <font face="helvetica">GAP</font> Character Table Library,
see&nbsp;<a href="http://www.math.rwth-aachen.de/~Thomas.Breuer/ctbllib"><tt>http://www.math.rwth-aachen.de/~Thomas.Breuer/ctbllib</tt></a>

<div class="p"><!----></div>
The functions have been designed for the examples in the later sections,
they could be generalized and optimized for other examples.
It is not our aim to provide a package for this functionality.

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;General Utilities</h3><a name="utils">
</a>

<div class="p"><!----></div>
Let <tt>list</tt> be a dense list and <tt>prop</tt> be a unary function that returns
<tt>true</tt> or <tt>false</tt> when applied to the entries of <tt>list</tt>.
<tt>PositionsProperty</tt> returns the set of positions in <tt>list</tt> for which
<tt>true</tt> is returned.

<div class="p"><!----></div>

<pre>
    gap&#62; if not IsBound( PositionsProperty ) then
    &#62;      PositionsProperty:= function( list, prop )
    &#62;        return Filtered( [ 1 .. Length( list ) ], i -&#62; prop( list[i] ) );
    &#62;      end;
    &#62;    fi;

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
The following two functions implement loops over ordered triples
(and quadruples, respectively) in a Cartesian product.
A prescribed function <tt>prop</tt> is subsequently applied to the triples
(quadruples),
and if the result of this call is <tt>true</tt> then this triple (quadruple)
is returned immediately;
if none of the calls to <tt>prop</tt> yields <tt>true</tt> then <tt>fail</tt> is returned.

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "TripleWithProperty", function( threelists, prop )
    &#62;     local i, j, k, test;
    &#62; 
    &#62;     for i in threelists[1] do
    &#62;       for j in threelists[2] do
    &#62;         for k in threelists[3] do
    &#62;           test:= [ i, j, k ];
    &#62;           if prop( test ) then
    &#62;               return test;
    &#62;           fi;
    &#62;         od;
    &#62;       od;
    &#62;     od;
    &#62; 
    &#62;     return fail;
    &#62; end );
    
    gap&#62; BindGlobal( "QuadrupleWithProperty", function( fourlists, prop )
    &#62;     local i, j, k, l, test;
    &#62; 
    &#62;     for i in fourlists[1] do
    &#62;       for j in fourlists[2] do
    &#62;         for k in fourlists[3] do
    &#62;           for l in fourlists[4] do
    &#62;             test:= [ i, j, k, l ];
    &#62;             if prop( test ) then
    &#62;               return test;
    &#62;             fi;
    &#62;           od;
    &#62;         od;
    &#62;       od;
    &#62;     od;
    &#62; 
    &#62;     return fail;
    &#62; end );

</pre>

<div class="p"><!----></div>
Of course one could do better by considering <em>un</em>ordered n-tuples
when several of the argument lists are equal,
and in practice, backtrack searches would often allow one to prune parts
of the search tree in early stages.
However, the above loops are not time critical in the examples presented
here, so the possible improvements are not worth the effort for our
purposes.

<div class="p"><!----></div>
The function <tt>PrintFormattedArray</tt> prints the matrix <tt>array</tt> in a columnwise
formatted way.
(The only diference to the <font face="helvetica">GAP</font> library function <tt>PrintArray</tt> is that
<tt>PrintFormattedArray</tt> chooses each column width according to the entries
only in this column not w.r.t.&nbsp;the whole matrix.)

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "PrintFormattedArray", function( array )
    &#62;      local colwidths, n, row;
    &#62;      array:= List( array, row -&#62; List( row, String ) );
    &#62;      colwidths:= List( TransposedMat( array ),
    &#62;                        col -&#62; Maximum( List( col, Length ) ) );
    &#62;      n:= Length( array[1] );
    &#62;      for row in List( array, row -&#62; List( [ 1 .. n ],
    &#62;                   i -&#62; FormattedString( row[i], colwidths[i] ) ) ) do
    &#62;        Print( "  ", JoinStringsWithSeparator( row, " " ), "\n" );
    &#62;      od;
    &#62; end );

</pre>

<div class="p"><!----></div>
Finally, <tt>CleanWorkspace</tt> is a utility for reducing the space needed.
This is achieved by unbinding those user variables
that are not write protected and are not mentioned in the list
<tt>NeededVariables</tt> of variable names that are bound now,
and by flushing the caches of tables of marks and character tables.

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "NeededVariables", NamesUserGVars() );
    gap&#62; BindGlobal( "CleanWorkspace", function()
    &#62;       local name, record;
    &#62; 
    &#62;       for name in Difference( NamesUserGVars(), NeededVariables ) do
    &#62;        if not IsReadOnlyGlobal( name ) then
    &#62;          UnbindGlobal( name );
    &#62;        fi;
    &#62;      od;
    &#62;      for record in [ LIBTOMKNOWN, LIBTABLE ] do
    &#62;        for name in RecNames( record.LOADSTATUS ) do
    &#62;          Unbind( record.LOADSTATUS.( name ) );
    &#62;          Unbind( record.( name ) );
    &#62;        od;
    &#62;      od;
    &#62; end );

</pre>

<div class="p"><!----></div>
The function <tt>PossiblePermutationCharacters</tt> takes two ordinary character
tables <tt>sub</tt> and <tt>tbl</tt>,
computes the possible class fusions from <tt>sub</tt> to <tt>tbl</tt>,
then induces the trivial character of <tt>sub</tt> to <tt>tbl</tt>, w.r.t.&nbsp;these fusions,
and returns the set of these class functions.
(So if <tt>sub</tt> and <tt>tbl</tt> are the character tables of groups H and G,
respectively, where H is a subgroup of G,
then the result contains the permutation character 1<sub>H</sub><sup>G</sup>.)

<div class="p"><!----></div>
Note that the columns of the character tables
in the <font face="helvetica">GAP</font> Character Table Library
are not explicitly associated with particular conjugacy classes of the
corresponding groups,
so from the character tables,
we can compute only <em>possible</em> class fusions,
i.e., maps between the columns of two tables that satisfy certain
necessary conditions, see the section about the function
<tt>PossibleClassFusions</tt> in the <font face="helvetica">GAP</font> Reference Manual for details.
There is no problem if the permutation character is uniquely determined
by the character tables, in all other cases we give ad hoc arguments
for resolving the ambiguities.

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "PossiblePermutationCharacters", function( sub, tbl )
    &#62;     local fus, triv;
    &#62; 
    &#62;     fus:= PossibleClassFusions( sub, tbl );
    &#62;     if fus = fail then
    &#62;       return fail;
    &#62;     fi;
    &#62;     triv:= [ TrivialCharacter( sub ) ];
    &#62; 
    &#62;     return Set( List( fus, map -&#62; Induced( sub, tbl, triv, map )[1] ) );
    &#62; end );

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;Character-Theoretic Computations</h3><a name="ctfun">
</a>

<div class="p"><!----></div>
We want to use the <font face="helvetica">GAP</font> libraries of character tables
and of tables of marks, and proceed in three steps.

<div class="p"><!----></div>
First we extract the primitive permutation characters from the library
information if this is available;
for that, we write the function <tt>PrimitivePermutationCharacters</tt>.
Then the result can be used as the input for the function <tt>ApproxP</tt>,
which computes the values &#963;( g, s ).
Finally, the functions <tt>ProbGenInfoSimple</tt> and <tt>ProbGenInfoAlmostSimple</tt>
compute <font face="helvetica"><i>S</i></font>( G ).

<div class="p"><!----></div>
For a group G whose character table T is contained in the <font face="helvetica">GAP</font>
character table library, the complete set of primitive permutation
characters can be easily computed if the character tables of all maximal
subgroups and their class fusions into T are known
(in this case, we check whether the attribute <tt>Maxes</tt> of T is bound)
or if the table of marks of G and the class fusion from T into this
table of marks are known
(in this case, we check whether the attribute <tt>FusionToTom</tt> of T is bound).
If the attribute <tt>UnderlyingGroup</tt> of T is bound then this group
can be used to compute the primitive permutation characters.
The latter happens if T was computed from the group object in <font face="helvetica">GAP</font>;
for tables in the <font face="helvetica">GAP</font> character table library,
this is not the case by default.

<div class="p"><!----></div>
The <font face="helvetica">GAP</font> function <tt>PrimitivePermutationCharacters</tt> tries to compute
the primitive permutation characters of a group using this information;
it returns the required list of characters if this can be computed this way,
otherwise <tt>fail</tt> is returned.
(For convenience, we use the <font face="helvetica">GAP</font> mechanism of <em>attributes</em>
in order to store the permutation characters in the character table object
once they have been computed.)

<div class="p"><!----></div>

<pre>
    gap&#62; DeclareAttribute( "PrimitivePermutationCharacters", IsCharacterTable );
    gap&#62; InstallMethod( PrimitivePermutationCharacters,
    &#62;     [ IsCharacterTable ],
    &#62;     function( tbl )
    &#62;     local maxes, tom, G;
    &#62; 
    &#62;     if HasMaxes( tbl ) then
    &#62;       maxes:= List( Maxes( tbl ), CharacterTable );
    &#62;       if ForAll( maxes, s -&#62; GetFusionMap( s, tbl ) &lt;&#62; fail ) then
    &#62;         return List( maxes, subtbl -&#62; TrivialCharacter( subtbl )^tbl );
    &#62;       fi;
    &#62;     elif HasFusionToTom( tbl ) then
    &#62;       tom:= TableOfMarks( tbl );
    &#62;       maxes:= MaximalSubgroupsTom( tom );
    &#62;       return PermCharsTom( tbl, tom ){ maxes[1] };
    &#62;     elif HasUnderlyingGroup( tbl ) then
    &#62;       G:= UnderlyingGroup( tbl );
    &#62;       return List( MaximalSubgroupClassReps( G ),
    &#62;                    M -&#62; TrivialCharacter( M )^tbl );
    &#62;     fi;
    &#62; 
    &#62;     return fail;
    &#62; end );

</pre>

<div class="p"><!----></div>
The function <tt>ApproxP</tt> takes a list <tt>primitives</tt> of primitive permutation
characters of a group G, say,
and the position <tt>spos</tt> of the class s<sup>G</sup> in the character table of G.

<div class="p"><!----></div>
Assume that the elements in <tt>primitives</tt> have the form 1<sub>M</sub><sup>G</sup>,
for suitable maximal subgroups M of G,
and let <font face="helvetica"><i>M</i></font>/&#160;&#8764;&#160; be the set of these groups M.
<tt>ApproxP</tt> returns the class function &#968; of G that is defined by
&#968;(1) = 0 and

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 &#968;(g) = </td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>M  &#8712; <font face="helvetica"><i>M</i></font>/&#160;&#8764;&#160;</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
1<sub>M</sub><sup>G</sup>(s) &#183;1<sub>M</sub><sup>G</sup>(g)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>1<sub>M</sub><sup>G</sup>(1)<br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>


otherwise.

<div class="p"><!----></div>
If <tt>primitives</tt> contains all those primitive permutation characters 1<sub>M</sub><sup>G</sup>
of G (with multiplicity according to the number of conjugacy classes
of these maximal subgroups) that do not vanish at s,
and if all these M are self-normalizing in G
-this holds for example if G is a finite simple group-
then &#968;(g) = &#963;( g, s ) holds.

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "ApproxP", function( primitives, spos )
    &#62;     local sum;
    &#62; 
    &#62;     sum:= ShallowCopy( Sum( List( primitives,
    &#62;                                   pi -&#62; pi[ spos ] * pi / pi[1] ) ) );
    &#62;     sum[1]:= 0;
    &#62; 
    &#62;     return sum;
    &#62; end );

</pre>

<div class="p"><!----></div>
Note that for computations with permutation characters,
it would make the functions more complicated (and not more efficient)
if we would consider only elements g of prime order,
and only one representative of Galois conjugate classes.

<div class="p"><!----></div>
The next functions needed in this context compute &#963;(S) and
<font face="helvetica"><i>S</i></font>( S ), for a simple group S,
and &#963;<sup>&#8242;</sup>(G,s) for an almost simple group G with socle S,
respectively.

<div class="p"><!----></div>
<tt>ProbGenInfoSimple</tt> takes the character table <tt>tbl</tt> of S as its argument.
If the full list of primitive permutation characters of S cannot be
computed with <tt>PrimitivePermutationCharacters</tt> then the function returns
<tt>fail</tt>.
Otherwise <tt>ProbGenInfoSimple</tt> returns a list containing
the identifier of the table,
the value &#963;(S),
the integer <font face="helvetica"><i>S</i></font>( S ),
a list of <font face="helvetica">ATLAS</font> names of representatives of Galois families of those
classes of elements s for which &#963;(S) = &#963;( S, s ) holds,
and the list of the corresponding cardinalities &#124;<font face="helvetica"><i>M</i></font>(S,s)&#124;.

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "ProbGenInfoSimple", function( tbl )
    &#62;     local prim, max, min, bound, s;
    &#62;     prim:= PrimitivePermutationCharacters( tbl );
    &#62;     if prim = fail then
    &#62;       return fail;
    &#62;     fi;
    &#62;     max:= List( [ 1 .. NrConjugacyClasses( tbl ) ],
    &#62;                 i -&#62; Maximum( ApproxP( prim, i ) ) );
    &#62;     min:= Minimum( max );
    &#62;     bound:= Inverse( min );
    &#62;     if IsInt( bound ) then
    &#62;       bound:= bound - 1;
    &#62;     else
    &#62;       bound:= Int( bound );
    &#62;     fi;
    &#62;     s:= PositionsProperty( max, x -&#62; x = min );
    &#62;     s:= List( Set( List( s, i -&#62; ClassOrbit( tbl, i ) ) ), i -&#62; i[1] );
    &#62;     return [ Identifier( tbl ),
    &#62;              min,
    &#62;              bound,
    &#62;              AtlasClassNames( tbl ){ s },
    &#62;              Sum( List( prim, pi -&#62; pi{ s } ) ) ];
    &#62; end );

</pre>

<div class="p"><!----></div>
<tt>ProbGenInfoAlmostSimple</tt> takes the character tables <tt>tblS</tt> and <tt>tblG</tt>
of S and G, and a list <tt>sposS</tt> of class positions (w.r.t.&nbsp;<tt>tblS</tt>)
as its arguments.
It is assumed that S is simple and has prime index in G.
If <tt>PrimitivePermutationCharacters</tt> can compute the full list
of primitive permutation characters of G then the function returns
a list containing
the identifier of <tt>tblG</tt>,
the maximum m of &#963;<sup>&#8242;</sup>( G, s ),
for s in the classes described by <tt>sposS</tt>,
a list of <font face="helvetica">ATLAS</font> names (in G) of the classes of elements s
for which this maximum is attained,
and the list of the corresponding cardinalities &#124;<font face="helvetica"><i>M</i></font><sup>&#8242;</sup>(G,s)&#124;.
When <tt>PrimitivePermutationCharacters</tt> returns <tt>fail</tt>,
also <tt>ProbGenInfoAlmostSimple</tt> returns <tt>fail</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "ProbGenInfoAlmostSimple", function( tblS, tblG, sposS )
    &#62;     local p, fus, inv, prim, sposG, outer, approx, l, max, min,
    &#62;           s, cards, i, names;
    &#62; 
    &#62;     p:= Size( tblG ) / Size( tblS );
    &#62;     if not IsPrimeInt( p )
    &#62;        or Length( ClassPositionsOfNormalSubgroups( tblG ) ) &lt;&#62; 3 then
    &#62;       return fail;
    &#62;     fi;
    &#62;     fus:= GetFusionMap( tblS, tblG );
    &#62;     if fus = fail then
    &#62;       return fail;
    &#62;     fi;
    &#62;     inv:= InverseMap( fus );
    &#62;     prim:= PrimitivePermutationCharacters( tblG );
    &#62;     if prim = fail then
    &#62;       return fail;
    &#62;     fi;
    &#62;     sposG:= Set( fus{ sposS } );
    &#62;     outer:= Difference( PositionsProperty(
    &#62;                 OrdersClassRepresentatives( tblG ), IsPrimeInt ), fus );
    &#62;     approx:= List( sposG, i -&#62; ApproxP( prim, i ){ outer } );
    &#62;     if IsEmpty( outer ) then
    &#62;       max:= List( approx, x -&#62; 0 );
    &#62;     else
    &#62;       max:= List( approx, Maximum );
    &#62;     fi;
    &#62;     min:= Minimum( max);
    &#62;     s:= sposG{ PositionsProperty( max, x -&#62; x = min ) };
    &#62;     cards:= List( prim, pi -&#62; pi{ s } );
    &#62;     for i in [ 1 .. Length( prim ) ] do
    &#62;       # Omit the character that is induced from the simple group.
    &#62;       if ForAll( prim[i], x -&#62; x = 0 or x = prim[i][1] ) then
    &#62;         cards[i]:= 0;
    &#62;       fi;
    &#62;     od;
    &#62;     names:= AtlasClassNames( tblG ){ s };
    &#62;     Perform( names, ConvertToStringRep );
    &#62; 
    &#62;     return [ Identifier( tblG ),
    &#62;              min,
    &#62;              names,
    &#62;              Sum( cards ) ];
    &#62; end );

</pre>

<div class="p"><!----></div>
The next function computes &#963;(G,s) from
the character table <tt>tbl</tt> of a simple or almost simple group G,
the name <tt>sname</tt> of the class of s in this table,
the list <tt>maxes</tt> of the character tables of all subgroups M
with M  &#8712; <font face="helvetica"><i>M</i></font>(G,s),
and the list <tt>numpermchars</tt> of the numbers of possible permutation characters
induced from <tt>maxes</tt>.
If the string <tt>"outer"</tt> is given as an optional argument then G is assumed
to be an automorphic extension of a simple group S, with [G:S] a prime,
and &#963;<sup>&#8242;</sup>(G,s) is returned.
In both situations,
the result is <tt>fail</tt> if the numbers of possible permutation characters
induced from <tt>maxes</tt> do not coincide with the numbers prescribed in
<tt>numpermchars</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "SigmaFromMaxes", function( arg )
    &#62;     local t, sname, maxes, numpermchars, prim, spos, outer;
    &#62; 
    &#62;     t:= arg[1];
    &#62;     sname:= arg[2];
    &#62;     maxes:= arg[3];
    &#62;     numpermchars:= arg[4];
    &#62;     prim:= List( maxes, s -&#62; PossiblePermutationCharacters( s, t ) );
    &#62;     spos:= Position( AtlasClassNames( t ), sname );
    &#62;     if ForAny( [ 1 .. Length( maxes ) ],
    &#62;                i -&#62; Length( prim[i] ) &lt;&#62; numpermchars[i] ) then
    &#62;       return fail;
    &#62;     elif Length( arg ) = 5 and arg[5] = "outer" then
    &#62;       outer:= Difference(
    &#62;           PositionsProperty( OrdersClassRepresentatives( t ), IsPrimeInt ),
    &#62;           ClassPositionsOfDerivedSubgroup( t ) );
    &#62;       return Maximum( ApproxP( Concatenation( prim ), spos ){ outer } );
    &#62;     else
    &#62;       return Maximum( ApproxP( Concatenation( prim ), spos ) );
    &#62;     fi;
    &#62; end );

</pre>

<div class="p"><!----></div>
The following function allows us to extract information about <font face="helvetica"><i>M</i></font>(G,s)
from the character table <tt>tbl</tt> of G and a list <tt>snames</tt> of class positions
of s.
If <tt>Maxes( tbl )</tt> is stored then the names of the character tables of the
subgroups in <font face="helvetica"><i>M</i></font>(G,s) and the number of conjugates are printed,
otherwise <tt>fail</tt> is printed.

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "DisplayProbGenMaxesInfo", function( tbl, snames )
    &#62;     local mx, prim, i, spos, nonz, indent, j;
    &#62; 
    &#62;     if not HasMaxes( tbl ) then
    &#62;       Print( Identifier( tbl ), ": fail\n" );
    &#62;       return;
    &#62;     fi;
    &#62; 
    &#62;     mx:= List( Maxes( tbl ), CharacterTable );
    &#62;     prim:= List( mx, s -&#62; TrivialCharacter( s )^tbl );
    &#62;     Assert( 1, SortedList( prim ) =
    &#62;                SortedList( PrimitivePermutationCharacters( tbl ) ) );
    &#62;     for i in [ 1 .. Length( prim ) ] do
    &#62;       # Deal with the case that the subgroup is normal.
    &#62;       if ForAll( prim[i], x -&#62; x = 0 or x = prim[i][1] ) then
    &#62;         prim[i]:= prim[i] / prim[i][1];
    &#62;       fi;
    &#62;     od;
    &#62; 
    &#62;     spos:= List( snames,
    &#62;                  nam -&#62; Position( AtlasClassNames( tbl ), nam ) );
    &#62;     nonz:= List( spos, x -&#62; PositionsProperty( prim, pi -&#62; pi[x] &lt;&#62; 0 ) );
    &#62;     for i in [ 1 .. Length( spos ) ] do
    &#62;       Print( Identifier( tbl ), ", ", snames[i], ": " );
    &#62;       indent:= ListWithIdenticalEntries(
    &#62;           Length( Identifier( tbl ) ) + Length( snames[i] ) + 4, ' ' );
    &#62;       if not IsEmpty( nonz[i] ) then
    &#62;         Print( Identifier( mx[ nonz[i][1] ] ), "  (",
    &#62;                prim[ nonz[i][1] ][ spos[i] ], ")\n" );
    &#62;         for j in [ 2 .. Length( nonz[i] ) ] do
    &#62;           Print( indent, Identifier( mx[ nonz[i][j] ] ), "  (",
    &#62;                prim[ nonz[i][j] ][ spos[i] ], ")\n" );
    &#62;         od;
    &#62;       else
    &#62;         Print( "\n" );
    &#62;       fi;
    &#62;     od;
    &#62; end );

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.3">
3.3</a>&nbsp;&nbsp;Computations with Groups</h3><a name="groups">
</a>

<div class="p"><!----></div>
Here, the task is to compute P(g,s) or P(G,s) using explicit
computations with G,
where the character-theoretic bounds are not sufficient.

<div class="p"><!----></div>
We start with small utilities that make the examples shorter.

<div class="p"><!----></div>
For a finite solvable group <tt>G</tt>,
the function <tt>PcConjugacyClassReps</tt> returns a list of representatives of
the conjugacy classes of <tt>G</tt>,
which are computed using a polycyclic presentation for <tt>G</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "PcConjugacyClassReps", function( G )
    &#62;      local iso;
    &#62; 
    &#62;      iso:= IsomorphismPcGroup( G );
    &#62;      return List( ConjugacyClasses( Image( iso ) ),
    &#62;               c -&#62; PreImagesRepresentative( iso, Representative( c ) ) );
    &#62; end );

</pre>

<div class="p"><!----></div>
For a finite group <tt>G</tt>, a list <tt>primes</tt> of prime integers,
and a normal subgroup <tt>N</tt> of <tt>G</tt>,
the function <tt>ClassesOfPrimeOrder</tt> returns a list of those conjugacy classes
of <tt>G</tt>
that are not contained in <tt>N</tt> and whose elements' orders occur in <tt>primes</tt>.

<div class="p"><!----></div>
For each prime p in <tt>primes</tt>, first class representatives of order p
in a Sylow p subgroup of <tt>G</tt> are computed,
then the representatives in <tt>N</tt> are discarded,
and then representatives w.&nbsp;r.&nbsp;t.&nbsp;conjugacy in <tt>G</tt> are computed.

<div class="p"><!----></div>
(Note that this approach may be inappropriate
for example if a large elementary abelian Sylow p subgroup occurs,
and if the conjugacy tests in <tt>G</tt> are expensive, see Section&nbsp;<a href="#O8p4">5.14</a>.)

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "ClassesOfPrimeOrder", function( G, primes, N )
    &#62;      local ccl, p, syl, reps;
    &#62; 
    &#62;      ccl:= [];
    &#62;      for p in primes do
    &#62;        syl:= SylowSubgroup( G, p );
    &#62;        reps:= Filtered( PcConjugacyClassReps( syl ),
    &#62;                   r -&#62; Order( r ) = p and not r in N );
    &#62;        Append( ccl, DuplicateFreeList( List( reps,
    &#62;                                          r -&#62; ConjugacyClass( G, r ) ) ) );
    &#62;      od;
    &#62; 
    &#62;      return ccl;
    &#62; end );

</pre>

<div class="p"><!----></div>
The function <tt>IsGeneratorsOfTransPermGroup</tt> takes a
<em>transitive</em> permutation group <tt>G</tt> and a list <tt>list</tt> of elements in <tt>G</tt>,
and returns <tt>true</tt> if the elements in <tt>list</tt> generate <tt>G</tt>,
and <tt>false</tt> otherwise.
The main point is that the return value <tt>true</tt> requires the group
generated by <tt>list</tt> to be transitive, and the check for transitivity
is much cheaper than the test whether this group is equal to <tt>G</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "IsGeneratorsOfTransPermGroup", function( G, list )
    &#62;     local S;
    &#62; 
    &#62;     if not IsTransitive( G ) then
    &#62;       Error( "&lt;G&#62; must be transitive on its moved points" );
    &#62;     fi;
    &#62;     S:= SubgroupNC( G, list );
    &#62; 
    &#62;     return IsTransitive( S, MovedPoints( G ) ) and Size( S ) = Size( G );
    &#62; end );

</pre>

<div class="p"><!----></div>
<tt>RatioOfNongenerationTransPermGroup</tt> takes a <em>transitive</em> permutation
group <tt>G</tt> and two elements <tt>g</tt> and <tt>s</tt> of <tt>G</tt>,
and returns the proportion P(g,s).
(The function tests the (non)generation only for representatives of
C<sub>G</sub>(g)-C<sub>G</sub>(s)-double cosets.
Note that for c<sub>1</sub>  &#8712; C<sub>G</sub>(g), c<sub>2</sub>  &#8712; C<sub>G</sub>(s),
and a representative r  &#8712; G,
we have &#9001;g<sup>c<sub>1</sub> r c<sub>2</sub></sup>, s &#9002; =  &#9001;g<sup>r</sup>, s &#9002;<sup>c<sub>2</sub></sup>.)

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "RatioOfNongenerationTransPermGroup", function( G, g, s )
    &#62;     local nongen, pair;
    &#62; 
    &#62;     if not IsTransitive( G ) then
    &#62;       Error( "&lt;G&#62; must be transitive on its moved points" );
    &#62;     fi;
    &#62;     nongen:= 0;
    &#62;     for pair in DoubleCosetRepsAndSizes( G, Centralizer( G, g ),
    &#62;                     Centralizer( G, s ) ) do
    &#62;       if not IsGeneratorsOfTransPermGroup( G, [ s, g^pair[1] ] ) then
    &#62;         nongen:= nongen + pair[2];
    &#62;       fi;
    &#62;     od;
    &#62; 
    &#62;     return nongen / Size( G );
    &#62; end );

</pre>

<div class="p"><!----></div>
Let G be a group, and let <tt>groups</tt> be a list [ G<sub>1</sub>, G<sub>2</sub>, &#8230;, G<sub>n</sub> ]
of permutation groups such that G<sub>i</sub> describes the action of G on a set
&#8486;<sub>i</sub>, say.
Moreover, we require that for 1  &#8804; i, j  &#8804; n,
mapping the <tt>GeneratorsOfGroup</tt> list of G<sub>i</sub> to that of G<sub>j</sub>
defines an isomorphism.
<tt>DiagonalProductOfPermGroups</tt> takes <tt>groups</tt> as its argument,
and returns the action of G on the disjoint union of
&#8486;<sub>1</sub>, &#8486;<sub>2</sub>, &#8230;, &#8486;<sub>n</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "DiagonalProductOfPermGroups", function( groups )
    &#62;     local prodgens, deg, i, gens, D, pi;
    &#62; 
    &#62;     prodgens:= GeneratorsOfGroup( groups[1] );
    &#62;     deg:= NrMovedPoints( prodgens );
    &#62;     for i in [ 2 .. Length( groups ) ] do
    &#62;       gens:= GeneratorsOfGroup( groups[i] );
    &#62;       D:= MovedPoints( gens );
    &#62;       pi:= MappingPermListList( D, [ deg+1 .. deg+Length( D ) ] );
    &#62;       deg:= deg + Length( D );
    &#62;       prodgens:= List( [ 1 .. Length( prodgens ) ],
    &#62;                        i -&#62; prodgens[i] * gens[i]^pi );
    &#62;     od;
    &#62; 
    &#62;     return Group( prodgens );
    &#62; end );

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
The following two functions are used to reduce checks of generation
to class representatives of maximal order.
Note that if &#9001;s, g &#9002; is a proper subgroup of G then
also &#9001;s<sup>k</sup>, g &#9002; is a proper subgroup of G,
so we need not check powers s<sup>k</sup> different from s in this situation.

<div class="p"><!----></div>
For an ordinary character table <tt>tbl</tt>,
the function <tt>RepresentativesMaximallyCyclicSubgroups</tt>
returns a list of class positions, containing one class of generators
for each class of maximally cyclic subgroups.

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "RepresentativesMaximallyCyclicSubgroups", function( tbl )
    &#62;     local n, result, orders, p, pmap, i, j;
    &#62; 
    &#62;     # Initialize.
    &#62;     n:= NrConjugacyClasses( tbl );
    &#62;     result:= BlistList( [ 1 .. n ], [ 1 .. n ] );
    &#62; 
    &#62;     # Omit powers of smaller order.
    &#62;     orders:= OrdersClassRepresentatives( tbl );
    &#62;     for p in Set( Factors( Size( tbl ) ) ) do
    &#62;       pmap:= PowerMap( tbl, p );
    &#62;       for i in [ 1 .. n ] do
    &#62;         if orders[ pmap[i] ] &lt; orders[i] then
    &#62;           result[ pmap[i] ]:= false;
    &#62;         fi;
    &#62;       od;
    &#62;     od;
    &#62; 
    &#62;     # Omit Galois conjugates.
    &#62;     for i in [ 1 .. n ] do
    &#62;       if result[i] then
    &#62;         for j in ClassOrbit( tbl, i ) do
    &#62;           if i &lt;&#62; j then
    &#62;             result[j]:= false;
    &#62;           fi;
    &#62;         od;
    &#62;       fi;
    &#62;     od;
    &#62; 
    &#62;     # Return the result.
    &#62;     return ListBlist( [ 1 .. n ], result );
    &#62; end );

</pre>

<div class="p"><!----></div>
Let <tt>G</tt> be a finite group, <tt>tbl</tt> be the ordinary character table of <tt>G</tt>,
and <tt>cols</tt> be a list of class positions in <tt>tbl</tt>,
for example the list returned by <tt>RepresentativesMaximallyCyclicSubgroups</tt>.
The function <tt>ClassesPerhapsCorrespondingToTableColumns</tt> returns the sublist
of those conjugacy classes of <tt>G</tt> for which the corresponding column in <tt>tbl</tt>
can be contained in <tt>cols</tt>, according to element order and class size.

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "ClassesPerhapsCorrespondingToTableColumns",
    &#62;    function( G, tbl, cols )
    &#62;     local orders, classes, invariants;
    &#62; 
    &#62;     orders:= OrdersClassRepresentatives( tbl );
    &#62;     classes:= SizesConjugacyClasses( tbl );
    &#62;     invariants:= List( cols, i -&#62; [ orders[i], classes[i] ] );
    &#62; 
    &#62;     return Filtered( ConjugacyClasses( G ),
    &#62;         c -&#62; [ Order( Representative( c ) ), Size(c) ] in invariants );
    &#62; end );

</pre>

<div class="p"><!----></div>
The next function computes,
for a finite group G and subgroups M<sub>1</sub>, M<sub>2</sub>, &#8230;, M<sub>n</sub> of G,
an upper bound for
max{ &#8721;<sub>i=1</sub><sup>n</sup> &#956;(g,G/M<sub>i</sub>); g  &#8712; G \Z(G) }.
So if the M<sub>i</sub> are the groups in <font face="helvetica"><i>M</i></font>(G,s), for some s  &#8712; G<sup>&times;</sup>,
then we get an upper bound for &#963;(G,s).

<div class="p"><!----></div>
The idea is that for M  &#8804; G and g  &#8712; G of order p, we have

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 &#956;(g,G/M) = &#124;g<sup>G</sup> &#8745;M&#124; / &#124;g<sup>G</sup>&#124;  &#8804; </td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>h  &#8712; C</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&#124;h<sup>M</sup>&#124; / &#124;g<sup>G</sup>&#124; = </td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>h  &#8712; C</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&#124;h<sup>M</sup>&#124; &#183;&#124;C<sub>G</sub>(g)&#124; / &#124;G&#124; ,</td></tr></table>
</td></tr></table>


where C is a set of class representatives h  &#8712; M of all those classes
that satisfy &#124;h&#124; = p and &#124;C<sub>G</sub>(h)&#124; = &#124;C<sub>G</sub>(g)&#124;,
and in the case that G is a permutation group additionally that
h and g move the same number of points.
(Note that it is enough to consider elements of <em>prime</em> order.)

<div class="p"><!----></div>
For computing the maximum of the rightmost term in this inequality,
for g  &#8712; G \Z(G),
we need not determine the G-conjugacy of class representatives in M.
Of course we pay the price that the result may be larger than the
leftmost term.
However,
if the maximal sum is in fact taken only over a single class representative,
we are sure that equality holds.
Thus we return a list of length two, containing the maximum of the
right hand side of the above inequality and a Boolean value indicating
whether this is equal to max{ &#956;(g,G/M); g  &#8712; G \Z(G) }
or just an upper bound.

<div class="p"><!----></div>
The arguments for <tt>UpperBoundFixedPointRatios</tt> are the group <tt>G</tt>,
a list <tt>maxesclasses</tt> such that the i-th entry is a list of conjugacy
classes of M<sub>i</sub>, which covers all classes of prime element order in M<sub>i</sub>,
and either <tt>true</tt> or <tt>false</tt>, where <tt>true</tt> means that the <em>exact</em> value
of &#963;(G,s) is computed, not just an upper bound;
this can be much more expensive because of the conjugacy tests in G
that may be necessary.
(We try to reduce the number of conjugacy tests in this case,
the second half of the code is not completely straightforward.
The special treatment of conjugacy checks for elements with the same sets
of fixed points is essential in the computation of &#963;<sup>&#8242;</sup>(G,s)
for G = <span class="roman">PGL</span>(6,4);
the critical input line is <tt>ApproxPForOuterClassesInGL( 6, 4 )</tt>,
see Section&nbsp;<a href="#SLaut">5.7</a>.
Currently the standard <font face="helvetica">GAP</font> conjugacy test for
an element of order three and its inverse in G \G<sup>&#8242;</sup>
requires hours of CPU time, whereas the check for existence of a conjugating
element in the stabilizer of the common set of fixed points of the two
elements is almost free of charge.)

<div class="p"><!----></div>
<tt>UpperBoundFixedPointRatios</tt> can be used to compute &#963;<sup>&#8242;</sup>(G,s)
in the case that G is an automorphic extension of a simple group S,
with [G:S] = p a prime;
if <font face="helvetica"><i>M</i></font><sup>&#8242;</sup>(G,s) = { M<sub>1</sub>, M<sub>2</sub>, &#8230;, M<sub>n</sub> } then
the i-th entry of <tt>maxesclasses</tt> must contain only
the classes of element order p in M<sub>i</sub> \(M<sub>i</sub> &#8745;S).

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "UpperBoundFixedPointRatios",
    &#62;    function( G, maxesclasses, truetest )
    &#62;     local myIsConjugate, invs, info, c, r, o, inv, pos, sums, max, maxpos,
    &#62;           maxlen, reps, split, i, found, j;
    &#62; 
    &#62;     myIsConjugate:= function( G, x, y )
    &#62;       local movx, movy;
    &#62; 
    &#62;       movx:= MovedPoints( x );
    &#62;       movy:= MovedPoints( y );
    &#62;       if movx = movy then
    &#62;         G:= Stabilizer( G, movx, OnSets );
    &#62;       fi;
    &#62;       return IsConjugate( G, x, y );
    &#62;     end;
    &#62; 
    &#62;     invs:= [];
    &#62;     info:= [];
    &#62; 
    &#62;     # First distribute the classes according to invariants.
    &#62;     for c in Concatenation( maxesclasses ) do
    &#62;       r:= Representative( c );
    &#62;       o:= Order( r );
    &#62;       # Take only prime order representatives.
    &#62;       if IsPrimeInt( o ) then
    &#62;         inv:= [ o, Size( Centralizer( G, r ) ) ];
    &#62;         # Omit classes that are central in `G'.
    &#62;         if inv[2] &lt;&#62; Size( G ) then
    &#62;           if IsPerm( r ) then
    &#62;             Add( inv, NrMovedPoints( r ) );
    &#62;           fi;
    &#62;           pos:= First( [ 1 .. Length( invs ) ], i -&#62; inv = invs[i] );
    &#62;           if pos = fail then
    &#62;             # This class is not `G'-conjugate to any of the previous ones.
    &#62;             Add( invs, inv );
    &#62;             Add( info, [ [ r, Size( c ) * inv[2] ] ] );
    &#62;           else
    &#62;             # This class may be conjugate to an earlier one.
    &#62;             Add( info[ pos ], [ r, Size( c ) * inv[2] ] );
    &#62;           fi;
    &#62;         fi;
    &#62;       fi;
    &#62;     od;
    &#62; 
    &#62;     if info = [] then
    &#62;       return [ 0, true ];
    &#62;     fi;
    &#62; 
    &#62;     repeat
    &#62;       # Compute the contributions of the classes with the same invariants.
    &#62;       sums:= List( info, x -&#62; Sum( List( x, y -&#62; y[2] ) ) );
    &#62;       max:= Maximum( sums );
    &#62;       maxpos:= Filtered( [ 1 .. Length( info ) ], i -&#62; sums[i] = max );
    &#62;       maxlen:= List( maxpos, i -&#62; Length( info[i] ) );
    &#62; 
    &#62;       # Split the sets with the same invariants if necessary
    &#62;       # and if we want to compute the exact value.
    &#62;       if truetest and not 1 in maxlen then
    &#62;         # Make one conjugacy test.
    &#62;         pos:= Position( maxlen, Minimum( maxlen ) );
    &#62;         reps:= info[ maxpos[ pos ] ];
    &#62;         if myIsConjugate( G, reps[1][1], reps[2][1] ) then
    &#62;           # Fuse the two classes.
    &#62;           reps[1][2]:= reps[1][2] + reps[2][2];
    &#62;           reps[2]:= reps[ Length( reps ) ];
    &#62;           Unbind( reps[ Length( reps ) ] );
    &#62;         else
    &#62;           # Split the list. This may require additional conjugacy tests.
    &#62;           Unbind( info[ maxpos[ pos ] ] );
    &#62;           split:= [ reps[1], reps[2] ];
    &#62;           for i in [ 3 .. Length( reps ) ] do
    &#62;             found:= false;
    &#62;             for j in split do
    &#62;               if myIsConjugate( G, reps[i][1], j[1] ) then
    &#62;                 j[2]:= reps[i][2] + j[2];
    &#62;                 found:= true;
    &#62;                 break;
    &#62;               fi;
    &#62;             od;
    &#62;             if not found then
    &#62;               Add( split, reps[i] );
    &#62;             fi;
    &#62;           od;
    &#62; 
    &#62;           info:= Compacted( Concatenation( info,
    &#62;                                            List( split, x -&#62; [ x ] ) ) );
    &#62;         fi;
    &#62;       fi;
    &#62;     until 1 in maxlen or not truetest;
    &#62; 
    &#62;     return [ max / Size( G ), 1 in maxlen ];
    &#62; end );

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
Suppose that C<sub>1</sub>, C<sub>2</sub>, C<sub>3</sub> are conjugacy classes in G,
and that we have to prove,
for each (x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>)  &#8712; C<sub>1</sub> &times;C<sub>2</sub> &times;C<sub>3</sub>,
the existence of an element s in a prescribed class C of G such that
&#9001;x<sub>1</sub>, s &#9002; =  &#9001;x<sub>2</sub>, s &#9002; =  &#9001;x<sub>2</sub>, s &#9002; =  G
holds.

<div class="p"><!----></div>
We have to check only representatives under the conjugation action of G
on C<sub>1</sub> &times;C<sub>2</sub> &times;C<sub>3</sub>.
For each representative, we try a prescribed number of random elements in C.
If this is successful then we are done.
The following two functions implement this idea.

<div class="p"><!----></div>
For a group G and a list [ g<sub>1</sub>, g<sub>2</sub>, &#8230;, g<sub>n</sub> ] of elements in G,
<tt>OrbitRepresentativesProductOfClasses</tt> returns a list
R(G, g<sub>1</sub>, g<sub>2</sub>, &#8230;, g<sub>n</sub>) of representatives of G-orbits
on the Cartesian product g<sub>1</sub><sup>G</sup> &times;g<sub>2</sub><sup>G</sup> &times;&#8230;&times;g<sub>n</sub><sup>G</sup>.

<div class="p"><!----></div>
The idea behind this function is to choose R(G, g<sub>1</sub>) = { ( g<sub>1</sub> ) }
in the case n = 1,
and, for n  &gt;  1,

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 R(G, g<sub>1</sub>, g<sub>2</sub>, &#8230;, g<sub>n</sub>) </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 = </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
{ (h<sub>1</sub>, h<sub>2</sub>, &#8230;, h<sub>n</sub>)  |  (h<sub>1</sub>, h<sub>2</sub>, &#8230;, h<sub>n&#8722;1</sub>)  &#8712; R(G, g<sub>1</sub>, g<sub>2</sub>, &#8230;, g<sub>n&#8722;1</sub>), </td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">h<sub>n</sub> = g<sub>n</sub><sup>d</sup>, &nbsp;<span class="roman">for</span>&nbsp; d  &#8712; D } ,</td></tr></table></td><td width="50%"></td></tr></table>
</td></tr></table>


where D is a set of representatives of double cosets
C<sub>G</sub>(g<sub>n</sub>) \G / &#8745;<sub>i=1</sub><sup>n&#8722;1</sup> C<sub>G</sub>(h<sub>i</sub>).

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "OrbitRepresentativesProductOfClasses",
    &#62;    function( G, classreps )
    &#62;     local cents, n, orbreps;
    &#62; 
    &#62;     cents:= List( classreps, x -&#62; Centralizer( G, x ) );
    &#62;     n:= Length( classreps );
    &#62; 
    &#62;     orbreps:= function( reps, intersect, pos )
    &#62;       if pos &#62; n then
    &#62;         return [ reps ];
    &#62;       fi;
    &#62;       return Concatenation( List(
    &#62;           DoubleCosetRepsAndSizes( G, cents[ pos ], intersect ),
    &#62;             r -&#62; orbreps( Concatenation( reps, [ classreps[ pos ]^r[1] ] ),
    &#62;                  Intersection( intersect, cents[ pos ]^r[1] ), pos+1 ) ) );
    &#62;     end;
    &#62; 
    &#62;     return orbreps( [ classreps[1] ], cents[1], 2 );
    &#62; end );

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
The function <tt>RandomCheckUniformSpread</tt> takes
a transitive permutation group G,
a list of class representatives g<sub>i</sub>  &#8712; G, an element s  &#8712; G,
and a positive integer N.
The return value is <tt>true</tt> if for each representative of G-orbits
on the product of the classes g<sub>i</sub><sup>G</sup>,
a good conjugate of s is found in at most N random tests.

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "RandomCheckUniformSpread", function( G, classreps, s, try )
    &#62;     local elms, found, i, conj;
    &#62; 
    &#62;     if not IsTransitive( G, MovedPoints( G ) ) then
    &#62;       Error( "&lt;G&#62; must be transitive on its moved points" );
    &#62;     fi;
    &#62; 
    &#62;     # Compute orbit representatives of G on the direct product,
    &#62;     # and try to find a good conjugate of s for each representative.
    &#62;     for elms in OrbitRepresentativesProductOfClasses( G, classreps ) do
    &#62;       found:= false;
    &#62;       for i in [ 1 .. try ] do
    &#62;         conj:= s^Random( G );
    &#62;         if ForAll( elms,
    &#62;               x -&#62; IsGeneratorsOfTransPermGroup( G, [ x, conj ] ) ) then
    &#62;           found:= true;
    &#62;           break;
    &#62;         fi;
    &#62;       od;
    &#62;       if not found then
    &#62;         return elms;
    &#62;       fi;
    &#62;     od;
    &#62; 
    &#62;     return true;
    &#62; end );

</pre>

<div class="p"><!----></div>
Of course this approach is not suitable for <em>dis</em>proving the existence
of s, but it is much cheaper than an exhaustive search in the class C.
(Typically, &#124;C&#124; is large whereas the &#124;C<sub>i</sub>&#124; are small.)

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
The following function can be used to verify that a given n-tuple
(x<sub>1</sub>, x<sub>2</sub>, &#8230;, x<sub>n</sub>) of elements in a group G has the property
that for all elements g  &#8712; G, at least one x<sub>i</sub> satisfies
&#9001;x<sub>i</sub>, g &#9002;.
The arguments are a transitive permutation group G,
a list of class representatives in G, and the n-tuple in question.
The return value is a conjugate g of the given representatives
that has the property if such an element exists,
and <tt>fail</tt> otherwise.

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "CommonGeneratorWithGivenElements",
    &#62;    function( G, classreps, tuple )
    &#62;     local inter, rep, repcen, pair;
    &#62; 
    &#62;     if not IsTransitive( G, MovedPoints( G ) ) then
    &#62;       Error( "&lt;G&#62; must be transitive on its moved points" );
    &#62;     fi;
    &#62; 
    &#62;     inter:= Intersection( List( tuple, x -&#62; Centralizer( G, x ) ) );
    &#62;     for rep in classreps do
    &#62;       repcen:= Centralizer( G, rep );
    &#62;       for pair in DoubleCosetRepsAndSizes( G, repcen, inter ) do
    &#62;         if ForAll( tuple,
    &#62;            x -&#62; IsGeneratorsOfTransPermGroup( G, [ x, rep^pair[1] ] ) ) then
    &#62;           return rep;
    &#62;         fi;
    &#62;       od;
    &#62;     od;
    &#62; 
    &#62;     return fail;
    &#62; end );

</pre>

<div class="p"><!----></div>

 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Character-Theoretic Computations</h2><a name="chartheor">
</a>

<div class="p"><!----></div>
In this section, we apply the functions introduced in Section&nbsp;<a href="#ctfun">3.2</a>
to the character tables of simple groups
that are available in the <font face="helvetica">GAP</font> Character Table Library.

<div class="p"><!----></div>
Our first examples are the sporadic simple groups, in Section&nbsp;<a href="#spor">4.1</a>,
then their automorphism groups are considered in Section&nbsp;<a href="#sporaut">4.2</a>.

<div class="p"><!----></div>
Then we consider those other simple groups for which <font face="helvetica">GAP</font> provides
enough information for automatically computing an upper bound on
&#963;(G,s) -see Section&nbsp;<a href="#easyloop">4.3</a>-
and their automorphic extensions -see Section&nbsp;<a href="#easyloopaut">4.4</a>.

<div class="p"><!----></div>
After that, individual groups are considered.

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Sporadic Simple Groups</h3><a name="spor">
</a>

<div class="p"><!----></div>
The <font face="helvetica">GAP</font> Character Table Library contains the tables of maximal subgroups
of all sporadic simple groups except B and M,
so all primitive permutation characters can be computed via the function
<tt>PrimitivePermutationCharacters</tt> for 24 of the 26 sporadic simple groups.

<div class="p"><!----></div>

<pre>
    gap&#62; sporinfo:= [];;
    gap&#62; spornames:= AllCharacterTableNames( IsSporadicSimple, true,
    &#62;                                        IsDuplicateTable, false );;
    gap&#62; for tbl in List( spornames, CharacterTable ) do
    &#62;      info:= ProbGenInfoSimple( tbl );
    &#62;      if info &lt;&#62; fail then
    &#62;        Add( sporinfo, info );
    &#62;      fi;
    &#62;    od;

</pre>

<div class="p"><!----></div>
We show the result as a formatted table.

<div class="p"><!----></div>

<pre>
    gap&#62; PrintFormattedArray( sporinfo );
       Co1    421/1545600         3671        [ "35A" ]    [ 4 ]
       Co2          1/270          269        [ "23A" ]    [ 1 ]
       Co3        64/6325           98        [ "21A" ]    [ 4 ]
       F3+ 1/269631216855 269631216854        [ "29A" ]    [ 1 ]
      Fi22         43/585           13        [ "16A" ]    [ 7 ]
      Fi23   2651/2416635          911        [ "23A" ]    [ 2 ]
        HN        4/34375         8593        [ "19A" ]    [ 1 ]
        HS        64/1155           18        [ "15A" ]    [ 2 ]
        He          3/595          198        [ "14C" ]    [ 3 ]
        J1           1/77           76        [ "19A" ]    [ 1 ]
        J2           5/28            5        [ "10C" ]    [ 3 ]
        J3          2/153           76        [ "19A" ]    [ 2 ]
        J4   1/1647124116   1647124115        [ "29A" ]    [ 1 ]
        Ly     1/35049375     35049374        [ "37A" ]    [ 1 ]
       M11            1/3            2        [ "11A" ]    [ 1 ]
       M12            1/3            2        [ "10A" ]    [ 3 ]
       M22           1/21           20        [ "11A" ]    [ 1 ]
       M23         1/8064         8063        [ "23A" ]    [ 1 ]
       M24       108/1265           11        [ "21A" ]    [ 2 ]
       McL      317/22275           70 [ "15A", "30A" ] [ 3, 3 ]
        ON       10/30723         3072        [ "31A" ]    [ 2 ]
        Ru         1/2880         2879        [ "29A" ]    [ 1 ]
       Suz       141/5720           40        [ "14A" ]    [ 3 ]
        Th       2/267995       133997 [ "27A", "27B" ] [ 2, 2 ]

</pre>

<div class="p"><!----></div>
We see that in all these cases, &#963;(G)  &lt;  1/2 and thus
<font face="helvetica"><i>P</i></font>( G )  &#8805; 2,
and all sporadic simple groups G except G = M<sub>11</sub> and G = M<sub>12</sub>
satisfy &#963;(G)  &lt;  1/3.
See&nbsp;<a href="#spreadM11">5.9</a> and&nbsp;<a href="#spreadM12">5.10</a> for a proof that also these
two groups have uniform spread at least three.

<div class="p"><!----></div>
The structures and multiplicities of the maximal subgroups containing s
are as follows.

<div class="p"><!----></div>

<pre>
    gap&#62; for entry in sporinfo do
    &#62;      DisplayProbGenMaxesInfo( CharacterTable( entry[1] ), entry[4] );
    &#62; od;
    Co1, 35A: (A5xJ2):2  (1)
              (A6xU3(3)):2  (2)
              (A7xL2(7)):2  (1)
    Co2, 23A: M23  (1)
    Co3, 21A: U3(5).3.2  (2)
              L3(4).D12  (1)
              s3xpsl(2,8).3  (1)
    F3+, 29A: 29:14  (1)
    Fi22, 16A: 2^10:m22  (1)
               (2x2^(1+8)):U4(2):2  (1)
               2F4(2)'  (4)
               2^(5+8):(S3xA6)  (1)
    Fi23, 23A: 2..11.m23  (1)
               L2(23)  (1)
    HN, 19A: U3(8).3_1  (1)
    HS, 15A: A8.2  (1)
             5:4xa5  (1)
    He, 14C: 2^1+6.psl(3,2)  (1)
             7^2:2psl(2,7)  (1)
             7^(1+2):(S3x3)  (1)
    J1, 19A: 19:6  (1)
    J2, 10C: 2^1+4b:a5  (1)
             a5xd10  (1)
             5^2:D12  (1)
    J3, 19A: L2(19)  (1)
             J3M3  (1)
    J4, 29A: frob  (1)
    Ly, 37A: 37:18  (1)
    M11, 11A: L2(11)  (1)
    M12, 10A: A6.2^2  (1)
              M12M4  (1)
              2xS5  (1)
    M22, 11A: L2(11)  (1)
    M23, 23A: 23:11  (1)
    M24, 21A: L3(4).3.2_2  (1)
              2^6:(psl(3,2)xs3)  (1)
    McL, 15A: 3^(1+4):2S5  (1)
              2.A8  (1)
              5^(1+2):3:8  (1)
    McL, 30A: 3^(1+4):2S5  (1)
              2.A8  (1)
              5^(1+2):3:8  (1)
    ON, 31A: L2(31)  (1)
             ONM8  (1)
    Ru, 29A: L2(29)  (1)
    Suz, 14A: J2.2  (2)
              (a4xpsl(3,4)):2  (1)
    Th, 27A: ThN3B  (1)
             ThM7  (1)
    Th, 27B: ThN3B  (1)
             ThM7  (1)

</pre>

<div class="p"><!----></div>
For the remaining two sporadic simple groups, B and M,
we choose suitable elements s.
If G = B and s  &#8712; G is of order 47 then, by&nbsp;[<a href="#Wil99" name="CITEWil99">Wil99</a>],
<font face="helvetica"><i>M</i></font>(G,s) = { 47:23 }.

<div class="p"><!----></div>

<pre>
    gap&#62; SigmaFromMaxes( CharacterTable( "B" ), "47A",
    &#62;        [ CharacterTable( "47:23" ) ], [ 1 ] );
    1/174702778623598780219392000000

</pre>

<div class="p"><!----></div>
If G = M and s  &#8712; G is of order 59 then, by&nbsp;[<a href="#HW04" name="CITEHW04">HW04</a>],
<font face="helvetica"><i>M</i></font>(G,s) = { L<sub>2</sub>(59) }.
In this case, the permutation character is not uniquely determined by the
character tables, but all possibilities lead to the same value for
&#963;(G).

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "M" );;
    gap&#62; s:= CharacterTable( "L2(59)" );;
    gap&#62; pi:= PossiblePermutationCharacters( s, t );;
    gap&#62; Length( pi );
    5
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 59 );
    152
    gap&#62; Set( List( pi, x -&#62; Maximum( ApproxP( [ x ], spos ) ) ) );
    [ 1/3385007637938037777290625 ]

</pre>

<div class="p"><!----></div>
Essentially the same approach is taken in&nbsp;[<a href="#GM01" name="CITEGM01">GM01</a>].
However, there s is restricted to classes of prime order.
Thus the results in the above table are better for J<sub>2</sub>, HS, M<sub>24</sub>,
McL, He, Suz, Co<sub>3</sub>, Fi<sub>22</sub>, Ly, Th, Co<sub>1</sub>, and J<sub>4</sub>.
Besides that, the value 10&nbsp;999 claimed in&nbsp;[<a href="#GM01" name="CITEGM01">GM01</a>]
for <font face="helvetica"><i>S</i></font>( HN ) is not correct.

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;Automorphism Groups of Sporadic Simple Groups</h3><a name="sporaut">
</a>

<div class="p"><!----></div>
Next we consider the automorphism groups of the sporadic simple groups.
There are exactly 12 cases where nontrivial outer automorphisms exist,
and then the simple group S has index 2 in its automorphism group G.

<div class="p"><!----></div>

<pre>
    gap&#62; sporautnames:= AllCharacterTableNames( IsSporadicSimple, true,
    &#62;                       IsDuplicateTable, false,
    &#62;                       OfThose, AutomorphismGroup );;
    gap&#62; sporautnames:= Difference( sporautnames, spornames );
    [ "F3+.2", "Fi22.2", "HN.2", "HS.2", "He.2", "J2.2", "J3.2", "M12.2",
      "M22.2", "McL.2", "ON.2", "Suz.2" ]

</pre>

<div class="p"><!----></div>
First we compute the values &#963;<sup>&#8242;</sup>(G,s),
for the same s  &#8712; S that were chosen for the simple group S
in Section&nbsp;<a href="#spor">4.1</a>.

<div class="p"><!----></div>
For six of the groups G in question,
the character tables of all maximal subgroups are available in the <font face="helvetica">GAP</font>
Character Table Library.
In these cases, the values &#963;<sup>&#8242;</sup>( G, s )
can be computed using <tt>ProbGenInfoAlmostSimple</tt>.

<div class="p"><!----></div>
<em>(The above statement can meanwhile be replaced by the statement that
the character tables of all maximal subgroups are available for all twelve
groups.
We show the table results for all these groups but keep the individual
computations from the original computations.)</em>

<div class="p"><!----></div>

<pre>
    gap&#62; sporautinfo:= [];;
    gap&#62; fails:= [];;
    gap&#62; for name in sporautnames do
    &#62;      tbl:= CharacterTable( name{ [ 1 .. Position( name, '.' ) - 1 ] } );
    &#62;      tblG:= CharacterTable( name );
    &#62;      info:= ProbGenInfoSimple( tbl );
    &#62;      info:= ProbGenInfoAlmostSimple( tbl, tblG,
    &#62;          List( info[4], x -&#62; Position( AtlasClassNames( tbl ), x ) ) );
    &#62;      if info = fail then
    &#62;        Add( fails, name );
    &#62;      else
    &#62;        Add( sporautinfo, info );
    &#62;      fi;
    &#62;    od;
    gap&#62; PrintFormattedArray( sporautinfo );
       F3+.2         0         [ "29AB" ]    [ 1 ]
      Fi22.2  251/3861         [ "16AB" ]    [ 7 ]
        HN.2    1/6875         [ "19AB" ]    [ 1 ]
        HS.2    36/275          [ "15A" ]    [ 2 ]
        He.2   37/9520         [ "14CD" ]    [ 3 ]
        J2.2      1/15         [ "10CD" ]    [ 3 ]
        J3.2    1/1080         [ "19AB" ]    [ 1 ]
       M12.2      4/99          [ "10A" ]    [ 1 ]
       M22.2      1/21         [ "11AB" ]    [ 1 ]
       McL.2      1/63 [ "15AB", "30AB" ] [ 3, 3 ]
        ON.2   1/84672         [ "31AB" ]    [ 1 ]
       Suz.2 661/46332          [ "14A" ]    [ 3 ]

</pre>

<div class="p"><!----></div>
Note that for S = McL, the bound &#963;<sup>&#8242;</sup>(G,s) for G = S.2
(in the second column) is worse than the bound for the simple group S.

<div class="p"><!----></div>
The structures and multiplicities of the maximal subgroups containing s
are as follows.

<div class="p"><!----></div>

<pre>
    gap&#62; for entry in sporautinfo do
    &#62;      DisplayProbGenMaxesInfo( CharacterTable( entry[1] ), entry[3] );
    &#62; od;
    F3+.2, 29AB: F3+  (1)
                 frob  (1)
    Fi22.2, 16AB: Fi22  (1)
                  Fi22.2M4  (1)
                  (2x2^(1+8)):(U4(2):2x2)  (1)
                  2F4(2)'.2  (4)
                  2^(5+8):(S3xS6)  (1)
    HN.2, 19AB: HN  (1)
                U3(8).6  (1)
    HS.2, 15A: HS  (1)
               S8x2  (1)
               5:4xS5  (1)
    He.2, 14CD: He  (1)
                2^(1+6)_+.L3(2).2  (1)
                7^2:2.L2(7).2  (1)
                7^(1+2):(S3x6)  (1)
    J2.2, 10CD: J2  (1)
                2^(1+4).S5  (1)
                (A5xD10).2  (1)
                5^2:(4xS3)  (1)
    J3.2, 19AB: J3  (1)
                19:18  (1)
    M12.2, 10A: M12  (1)
                (2^2xA5):2  (1)
    M22.2, 11AB: M22  (1)
                 L2(11).2  (1)
    McL.2, 15AB: McL  (1)
                 3^(1+4):4S5  (1)
                 Isoclinic(2.A8.2)  (1)
                 5^(1+2):(24:2)  (1)
    McL.2, 30AB: McL  (1)
                 3^(1+4):4S5  (1)
                 Isoclinic(2.A8.2)  (1)
                 5^(1+2):(24:2)  (1)
    ON.2, 31AB: ON  (1)
                31:30  (1)
    Suz.2, 14A: Suz  (1)
                J2.2x2  (2)
                (A4xL3(4):2_3):2  (1)

</pre>

<div class="p"><!----></div>
Note that the maximal subgroups L<sub>2</sub>(19) of J<sub>3</sub> do not extend
to J<sub>3</sub>.2 and that a class of maximal subgroups of the type 19:18 appears
in J<sub>3</sub>.2 whose intersection with J<sub>3</sub> is not maximal in J<sub>3</sub>.
Similarly, the maximal subgroups A<sub>6</sub>.2<sup>2</sup> of M<sub>12</sub> do not extend
to M<sub>12</sub>.2.

<div class="p"><!----></div>
For the other six groups, we use individual computations.

<div class="p"><!----></div>
In the case S = Fi<sub>24</sub><sup>&#8242;</sup>, the unique maximal subgroup 29:14
that contains an element s of order 29 extends to a group of the type
29:28 in Fi<sub>24</sub>,
which is a nonsplit extension of 29:14.

<div class="p"><!----></div>

<pre>
    gap&#62; SigmaFromMaxes( CharacterTable( "Fi24'.2" ), "29AB",
    &#62;        [ CharacterTable( "29:28" ) ], [ 1 ], "outer" );
    0

</pre>

<div class="p"><!----></div>
In the case S = Fi<sub>22</sub>, there are four classes of maximal subgroups
that contain s of order 16.
They extend to G = Fi<sub>22</sub>.2,
and none of the <em>novelties</em> in G (i.&nbsp;e., subgroups of G that are
maximal in G but whose intersections with S are not maximal in S)
contains s, cf.&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;163].

<div class="p"><!----></div>

<pre>
    gap&#62; 16 in OrdersClassRepresentatives( CharacterTable( "U4(2).2" ) );
    false
    gap&#62; 16 in OrdersClassRepresentatives( CharacterTable( "G2(3).2" ) );
    false

</pre>

<div class="p"><!----></div>
The character tables of three of the four extensions are available in the
<font face="helvetica">GAP</font> Character Table Library.
The permutation character on the cosets of the fourth extension can be
obtained as the extension of the permutation character of S on the
cosets of its maximal subgroup of the type 2<sup>5+8</sup>:(S<sub>3</sub> &times;A<sub>6</sub>).

<div class="p"><!----></div>

<pre>
    gap&#62; t2:= CharacterTable( "Fi22.2" );;
    gap&#62; prim:= List( [ "Fi22.2M4", "(2x2^(1+8)):(U4(2):2x2)", "2F4(2)" ],
    &#62;        n -&#62; PossiblePermutationCharacters( CharacterTable( n ), t2 ) );;
    gap&#62; t:= CharacterTable( "Fi22" );;
    gap&#62; pi:= PossiblePermutationCharacters(
    &#62;             CharacterTable( "2^(5+8):(S3xA6)" ), t );
    [ Character( CharacterTable( "Fi22" ), [ 3648645, 56133, 10629, 2245, 567, 
          729, 405, 81, 549, 165, 133, 37, 69, 20, 27, 81, 9, 39, 81, 19, 1, 13, 
          33, 13, 1, 0, 13, 13, 5, 1, 0, 0, 0, 8, 4, 0, 0, 9, 3, 15, 3, 1, 1, 1, 
          1, 3, 3, 1, 0, 0, 0, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2 ] ) ]
    gap&#62; torso:= CompositionMaps( pi[1], InverseMap( GetFusionMap( t, t2 ) ) );
    [ 3648645, 56133, 10629, 2245, 567, 729, 405, 81, 549, 165, 133, 37, 69, 20, 
      27, 81, 9, 39, 81, 19, 1, 13, 33, 13, 1, 0, 13, 13, 5, 1, 0, 0, 0, 8, 4, 0, 
      9, 3, 15, 3, 1, 1, 1, 3, 3, 1, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 1, 1, 2 ]
    gap&#62; ext:= PermChars( t2, rec( torso:= torso ) );;
    gap&#62; Add( prim, ext );
    gap&#62; prim:= Concatenation( prim );;  Length( prim );
    4
    gap&#62; spos:= Position( OrdersClassRepresentatives( t2 ), 16 );;
    gap&#62; List( prim, x -&#62; x[ spos ] );
    [ 1, 1, 4, 1 ]
    gap&#62; sigma:= ApproxP( prim, spos );;
    gap&#62; Maximum( sigma{ Difference( PositionsProperty(
    &#62;                        OrdersClassRepresentatives( t2 ), IsPrimeInt ),
    &#62;                        ClassPositionsOfDerivedSubgroup( t2 ) ) } );
    251/3861

</pre>

<div class="p"><!----></div>
In the case S = HN, the unique maximal subgroup U<sub>3</sub>(8).3
that contains the fixed element s of order 19
extends to a group of the type U<sub>3</sub>(8).6 in HN.2.

<div class="p"><!----></div>

<pre>
    gap&#62; SigmaFromMaxes( CharacterTable( "HN.2" ), "19AB",
    &#62;        [ CharacterTable( "U3(8).6" ) ], [ 1 ], "outer" );
    1/6875

</pre>

<div class="p"><!----></div>
In the case S = HS, there are two classes of maximal subgroups
that contain s of order 15.
They extend to G = HS.2,
and none of the novelties in G contains s (cf.&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;80]).

<div class="p"><!----></div>

<pre>
    gap&#62; SigmaFromMaxes( CharacterTable( "HS.2" ), "15A",
    &#62;      [ CharacterTable( "S8x2" ),
    &#62;        CharacterTable( "5:4" ) * CharacterTable( "A5.2" ) ], [ 1, 1 ],
    &#62;      "outer" );
    36/275

</pre>

<div class="p"><!----></div>
In the case S = He, there are three classes of maximal subgroups
that contain s in the class <tt>14C</tt>.
They extend to G = He.2,
and none of the novelties in G contains s (cf.&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;104]).
We compute the extensions of the corresponding primitive permutation
characters of S.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "He" );;
    gap&#62; t2:= CharacterTable( "He.2" );;
    gap&#62; prim:= PrimitivePermutationCharacters( t );;
    gap&#62; spos:= Position( AtlasClassNames( t ), "14C" );;
    gap&#62; prim:= Filtered( prim, x -&#62; x[ spos ] &lt;&#62; 0 );;
    gap&#62; map:= InverseMap( GetFusionMap( t, t2 ) );;
    gap&#62; torso:= List( prim, pi -&#62; CompositionMaps( pi, map ) );
    [ [ 187425, 945, 449, 0, 21, 21, 25, 25, 0, 0, 5, 0, 0, 7, 1, 0, 0, 1, 0, 1, 
          0, 0, 0, 0, 0, 0 ], 
      [ 244800, 0, 64, 0, 84, 0, 0, 16, 0, 0, 4, 24, 45, 3, 4, 0, 0, 0, 0, 1, 0, 
          0, 0, 0, 0, 0 ], 
      [ 652800, 0, 512, 120, 72, 0, 0, 0, 0, 0, 8, 8, 22, 1, 0, 0, 0, 0, 0, 1, 0, 
          0, 1, 1, 2, 0 ] ]
    gap&#62; ext:= List( torso, x -&#62; PermChars( t2, rec( torso:= x ) ) );
    [ [ Character( CharacterTable( "He.2" ), [ 187425, 945, 449, 0, 21, 21, 25, 
              25, 0, 0, 5, 0, 0, 7, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 315, 15, 
              0, 0, 3, 7, 7, 3, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0 ] ) ], 
      [ Character( CharacterTable( "He.2" ), [ 244800, 0, 64, 0, 84, 0, 0, 16, 0, 
              0, 4, 24, 45, 3, 4, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 360, 0, 0, 0, 
              6, 0, 0, 0, 0, 0, 3, 2, 2, 0, 0, 0, 0, 0, 0 ] ) ], 
      [ Character( CharacterTable( "He.2" ), [ 652800, 0, 512, 120, 72, 0, 0, 0, 
              0, 0, 8, 8, 22, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 2, 0, 480, 0, 120, 
              0, 12, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 1, 1 ] ) ] ]
    gap&#62; spos:= Position( AtlasClassNames( t2 ), "14CD" );;
    gap&#62; sigma:= ApproxP( Concatenation( ext ), spos );;
    gap&#62; Maximum( sigma{ Difference( PositionsProperty(
    &#62;                        OrdersClassRepresentatives( t2 ), IsPrimeInt ),
    &#62;                        ClassPositionsOfDerivedSubgroup( t2 ) ) } );
    37/9520

</pre>

<div class="p"><!----></div>
In the case S = O&#8242;N, the two classes of maximal subgroups of the type
L<sub>2</sub>(31) do not extend to G = O&#8242;N.2, and a class of novelties of the
structure 31:30 appears (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;132]).

<div class="p"><!----></div>

<pre>
    gap&#62; SigmaFromMaxes( CharacterTable( "ON.2" ), "31AB",
    &#62;        [ CharacterTable( "P:Q", [ 31, 30 ] ) ], [ 1 ], "outer" );
    1/84672

</pre>

<div class="p"><!----></div>
Now we consider also &#963;(G,[^s]),
for suitable [^s]  &#8712; G \S;
this yields lower bounds for the spread of the nonsimple groups G.
(These results are shown in the last two columns of&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Table&nbsp;9].)

<div class="p"><!----></div>
As above, we use the known character tables of the maximal subgroups
in order to compute the optimal choice for [^s]  &#8712; G \S.
(We may use the function <tt>ProbGenInfoSimple</tt> although the groups are not
simple; all we need is that the relevant maximal subgroups are
self-normalizing.)

<div class="p"><!----></div>

<pre>
    gap&#62; sporautinfo2:= [];;
    gap&#62; for name in List( sporautinfo, x -&#62; x[1] ) do
    &#62;      Add( sporautinfo2, ProbGenInfoSimple( CharacterTable( name ) ) );
    &#62;    od;
    gap&#62; PrintFormattedArray( sporautinfo2 );
       F3+.2    19/5684  299        [ "42E" ]   [ 10 ] 
      Fi22.2 1165/20592   17        [ "24G" ]    [ 3 ] 
        HN.2     1/1425 1424        [ "24B" ]    [ 4 ] 
        HS.2     21/550   26        [ "20C" ]    [ 4 ] 
        He.2    33/4165  126        [ "24A" ]    [ 2 ] 
        J2.2       1/15   14        [ "14A" ]    [ 1 ] 
        J3.2   77/10260  133        [ "34A" ]    [ 1 ] 
       M12.2    113/495    4        [ "12B" ]    [ 3 ] 
       M22.2       8/33    4        [ "10A" ]    [ 4 ] 
       McL.2      1/135  134        [ "22A" ]    [ 1 ] 
        ON.2  61/109368 1792 [ "22A", "38A" ] [ 1, 1 ] 
       Suz.2      1/351  350        [ "28A" ]    [ 1 ]
    gap&#62; for entry in sporautinfo2 do
    &#62;      DisplayProbGenMaxesInfo( CharacterTable( entry[1] ), entry[4] );
    &#62; od;
    F3+.2, 42E: 2^12.M24  (2)
                2^2.U6(2):S3x2  (1)
                2^(3+12).(L3(2)xS6)  (2)
                (S3xS3xG2(3)):2  (1)
                S6xL2(8):3  (1)
                7:6xS7  (1)
                7^(1+2)_+:(6xS3).2  (2)
    Fi22.2, 24G: Fi22.2M4  (1)
                 2^(5+8):(S3xS6)  (1)
                 3^5:(2xU4(2).2)  (1)
    HN.2, 24B: 2^(1+8)_+.(A5xA5).2^2  (1)
               5^2.5.5^2.4S5  (2)
               HN.2M13  (1)
    HS.2, 20C: (2xA6.2^2).2  (1)
               HS.2N5  (2)
               5:4xS5  (1)
    He.2, 24A: 2^(1+6)_+.L3(2).2  (1)
               S4xL3(2).2  (1)
    J2.2, 14A: L3(2).2x2  (1)
    J3.2, 34A: L2(17)x2  (1)
    M12.2, 12B: L2(11).2  (1)
                D8.(S4x2)  (1)
                3^(1+2):D8  (1)
    M22.2, 10A: M22.2M4  (1)
                A6.2^2  (1)
                L2(11).2  (2)
    McL.2, 22A: 2xM11  (1)
    ON.2, 22A: J1x2  (1)
    ON.2, 38A: J1x2  (1)
    Suz.2, 28A: (A4xL3(4):2_3):2  (1)

</pre>

<div class="p"><!----></div>
In the other six cases,
we do not have the complete lists of primitive permutation characters,
so we choose a suitable element [^s] for each group.
It is sufficient to prescribe &#124;[^s]&#124;, as follows.

<div class="p"><!----></div>

<pre>
    gap&#62; sporautchoices:= [
    &#62;        [ "Fi22",  "Fi22.2",  42 ],
    &#62;        [ "Fi24'", "Fi24'.2", 46 ],
    &#62;        [ "He",    "He.2",    42 ],
    &#62;        [ "HN",    "HN.2",    44 ],
    &#62;        [ "HS",    "HS.2",    30 ],
    &#62;        [ "ON",    "ON.2",    38 ], ];;

</pre>

<div class="p"><!----></div>
First we list the maximal subgroups of the corresponding simple groups
that contain the square of [^s].

<div class="p"><!----></div>

<pre>
    gap&#62; for triple in sporautchoices do
    &#62;      tbl:= CharacterTable( triple[1] );
    &#62;      tbl2:= CharacterTable( triple[2] );
    &#62;      spos2:= PowerMap( tbl2, 2,
    &#62;          Position( OrdersClassRepresentatives( tbl2 ), triple[3] ) );
    &#62;      spos:= Position( GetFusionMap( tbl, tbl2 ), spos2 );
    &#62;      DisplayProbGenMaxesInfo( tbl, AtlasClassNames( tbl ){ [ spos ] } );
    &#62;    od;
    Fi22, 21A: O8+(2).3.2  (1)
               S3xU4(3).2_2  (1)
               A10.2  (1)
               A10.2  (1)
    F3+, 23A: Fi23  (1)
              F3+M7  (1)
    He, 21B: 3.A7.2  (1)
             7^(1+2):(S3x3)  (1)
             7:3xpsl(3,2)  (2)
    HN, 22A: 2.HS.2  (1)
    HS, 15A: A8.2  (1)
             5:4xa5  (1)
    ON, 19B: L3(7).2  (1)
             ONM2  (1)
             J1  (1)

</pre>

<div class="p"><!----></div>
According to&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>], exactly
the following maximal subgroups of the simple group S in the above list
do <b>not</b> extend to <span class="roman">Aut</span>(S):
The two S<sub>10</sub> type subgroups of Fi<sub>22</sub>
and the two L<sub>3</sub>(7).2 type subgroups of O&#8242;N.

<div class="p"><!----></div>
Furthermore, the following maximal subgroups of <span class="roman">Aut</span>(S) with the property
that the intersection with S is not maximal in S have to be considered
whether they contain s<sup>&#8242;</sup>:
G<sub>2</sub>(3).2 and 3<sup>5</sup>:(2 &times;U<sub>4</sub>(2).2) in Fi<sub>22</sub>.2.
(Note that the order of the 7<sup>1+2</sup><sub>+</sub>:(3 &times;D<sub>16</sub>) type subgroup in
O&#8242;N.2 is obviously not divisible by 19.)

<div class="p"><!----></div>

<pre>
    gap&#62; 42 in OrdersClassRepresentatives( CharacterTable( "G2(3).2" ) );
    false
    gap&#62; Size( CharacterTable( "U4(2)" ) ) mod 7 = 0;
    false

</pre>

<div class="p"><!----></div>
So we take the extensions of the above maximal subgroups,
as described in&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>].

<div class="p"><!----></div>

<pre>
    gap&#62; SigmaFromMaxes( CharacterTable( "Fi22.2" ), "42A",
    &#62;     [ CharacterTable( "O8+(2).3.2" ) * CharacterTable( "Cyclic", 2 ),
    &#62;       CharacterTable( "S3" ) * CharacterTable( "U4(3).(2^2)_{122}" ) ],
    &#62;     [ 1, 1 ] );
    163/1170
    gap&#62; SigmaFromMaxes( CharacterTable( "Fi24'.2" ), "46A",
    &#62;      [ CharacterTable( "Fi23" ) * CharacterTable( "Cyclic", 2 ),
    &#62;        CharacterTable( "2^12.M24" ) ],
    &#62;      [ 1, 1 ] );
    566/5481
    gap&#62; SigmaFromMaxes( CharacterTable( "He.2" ), "42A",
    &#62;      [ CharacterTable( "3.A7.2" ) * CharacterTable( "Cyclic", 2 ),
    &#62;        CharacterTable( "7^(1+2):(S3x6)" ),
    &#62;        CharacterTable( "7:6" ) * CharacterTable( "L3(2)" ) ],
    &#62;      [ 1, 1, 1 ] );
    1/119
    gap&#62; SigmaFromMaxes( CharacterTable( "HN.2" ), "44A",
    &#62;      [ CharacterTable( "4.HS.2" ) ],
    &#62;      [ 1 ] );
    997/192375
    gap&#62; SigmaFromMaxes( CharacterTable( "HS.2" ), "30A",
    &#62;      [ CharacterTable( "S8" ) * CharacterTable( "C2" ),
    &#62;        CharacterTable( "5:4" ) * CharacterTable( "S5" ) ],
    &#62;      [ 1, 1 ] );
    36/275
    gap&#62; SigmaFromMaxes( CharacterTable( "ON.2" ), "38A",
    &#62;      [ CharacterTable( "J1" ) * CharacterTable( "C2" ) ],
    &#62;      [ 1 ] );
    61/109368

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.3">
4.3</a>&nbsp;&nbsp;Other Simple Groups - Easy Cases</h3><a name="easyloop">
</a>

<div class="p"><!----></div>
We are interested in simple groups G for which <tt>ProbGenInfoSimple</tt> does
not guarantee <font face="helvetica"><i>S</i></font>(G)  &#8805; 3.
So we examine the remaining tables of simple groups in the <font face="helvetica">GAP</font>
Character Table Library,
and distinguish the following three cases:
Either <tt>ProbGenInfoSimple</tt> yields the lower bound at least three,
or a smaller bound,
or the computation of a lower bound fails because not enough information
is available to compute the primitive permutation characters.

<div class="p"><!----></div>

<pre>
    gap&#62; names:= AllCharacterTableNames( IsSimple, true,
    &#62;                                    IsDuplicateTable, false );;
    gap&#62; names:= Difference( names, spornames );;
    gap&#62; fails:= [];;
    gap&#62; lessthan3:= [];;
    gap&#62; atleast3:= [];;
    gap&#62; for name in names do
    &#62;      tbl:= CharacterTable( name );
    &#62;      info:= ProbGenInfoSimple( tbl );
    &#62;      if info = fail then
    &#62;        Add( fails, name );
    &#62;      elif info[3] &lt; 3 then
    &#62;        Add( lessthan3, info );
    &#62;      else
    &#62;        Add( atleast3, info );
    &#62;      fi;
    &#62;    od;

</pre>

<div class="p"><!----></div>
For the following simple groups,
(currently) not enough information is available
in the <font face="helvetica">GAP</font> Character Table Library and in the <font face="helvetica">GAP</font> Library of Tables
of Marks,
for computing a lower bound for &#963;(G).
Some of these groups will be dealt with in later sections,
and for the other groups, the bounds derived with theoretical arguments
in&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>] are sufficient, so we need no <font face="helvetica">GAP</font> computations for them.

<div class="p"><!----></div>

<pre>
    gap&#62; fails;
    [ "2E6(2)", "2F4(8)", "A14", "A15", "A16", "A17", "A18", "E6(2)", "F4(2)", 
      "L4(4)", "L4(5)", "L4(9)", "L5(3)", "L6(2)", "L8(2)", "O10+(2)", "O10-(2)",
      "O10-(3)", "O7(5)", "O8-(3)", "O9(3)", "R(27)", "S10(2)", "S12(2)",
      "S4(7)", "S4(8)", "S4(9)", "S6(4)", "S6(5)", "S8(3)", "U4(4)", "U4(5)",
      "U5(3)", "U5(4)", "U7(2)" ]

</pre>

<div class="p"><!----></div>
The following simple groups appear in&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Table&nbsp;1-6].
More detailed computations can be found in the sections&nbsp;<a href="#A5">5.2</a>,
<a href="#A6">5.3</a>, <a href="#A7">5.4</a>, <a href="#O8p2">5.12</a>, <a href="#O8p3">5.13</a>, <a href="#S62">5.20</a>, <a href="#U42">5.23</a>, <a href="#U43">5.24</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; PrintFormattedArray( lessthan3 );
          A5      1/3 2                [ "5A" ]       [ 1 ]
          A6      2/3 1                [ "5A" ]       [ 2 ]
          A7      2/5 2                [ "7A" ]       [ 2 ]
       O7(3)  199/351 1               [ "14A" ]       [ 3 ]
      O8+(2)  334/315 0 [ "15A", "15B", "15C" ] [ 7, 7, 7 ]
      O8+(3) 863/1820 2 [ "20A", "20B", "20C" ] [ 8, 8, 8 ]
       S6(2)      4/7 1                [ "9A" ]       [ 4 ]
       S8(2)     8/15 1               [ "17A" ]       [ 3 ]
       U4(2)    21/40 1               [ "12A" ]       [ 2 ]
       U4(3)   53/135 2                [ "7A" ]       [ 7 ]

</pre>

<div class="p"><!----></div>
For the following simple groups G, the inequality &#963;(G)  &lt;  1/3
follows from the loop above.
The columns show the name of G, the values &#963;(G) and <font face="helvetica"><i>S</i></font>(G),
the class names of s for which these values are attained,
and &#124;<font face="helvetica"><i>M</i></font>(G,s)&#124;.

<div class="p"><!----></div>
(The entry for the group L<sub>7</sub>(2) would not fit on one screen line,
so we show it independently.)

<div class="p"><!----></div>

<pre>
    gap&#62; PrintFormattedArray( Filtered( atleast3, l -&#62; l[1] &lt;&#62; "L7(2)" ) );
      2F4(2)' 118/1755   14                           [ "16A" ]             [ 2 ]
       3D4(2)   1/5292 5291                           [ "13A" ]             [ 1 ]
          A10     3/10    3                           [ "21A" ]             [ 1 ]
          A11    2/105   52                           [ "11A" ]             [ 2 ]
          A12      2/9    4                           [ "35A" ]             [ 1 ]
          A13   4/1155  288                           [ "13A" ]             [ 5 ]
           A8     3/14    4                           [ "15A" ]             [ 1 ]
           A9     9/35    3                      [ "9A", "9B" ]          [ 4, 4 ]
        G2(3)      1/7    6                           [ "13A" ]             [ 3 ]
        G2(4)     1/21   20                           [ "13A" ]             [ 2 ]
        G2(5)     1/31   30                     [ "7A", "21A" ]         [ 10, 1 ]
      L2(101)    1/101  100                    [ "51A", "17A" ]          [ 1, 1 ]
      L2(103)  53/5253   99             [ "52A", "26A", "13A" ]       [ 1, 1, 1 ]
      L2(107)  55/5671  103 [ "54A", "27A", "18A", "9A", "6A" ] [ 1, 1, 1, 1, 1 ]
      L2(109)    1/109  108                    [ "55A", "11A" ]          [ 1, 1 ]
       L2(11)     7/55    7                            [ "6A" ]             [ 1 ]
      L2(113)    1/113  112                    [ "57A", "19A" ]          [ 1, 1 ]
      L2(121)    1/121  120                           [ "61A" ]             [ 1 ]
      L2(125)    1/125  124        [ "63A", "21A", "9A", "7A" ]    [ 1, 1, 1, 1 ]
       L2(13)     1/13   12                            [ "7A" ]             [ 1 ]
       L2(16)     1/15   14                           [ "17A" ]             [ 1 ]
       L2(17)     1/17   16                            [ "9A" ]             [ 1 ]
       L2(19)   11/171   15                           [ "10A" ]             [ 1 ]
       L2(23)   13/253   19                     [ "6A", "12A" ]          [ 1, 1 ]
       L2(25)     1/25   24                           [ "13A" ]             [ 1 ]
       L2(27)    5/117   23                     [ "7A", "14A" ]          [ 1, 1 ]
       L2(29)     1/29   28                           [ "15A" ]             [ 1 ]
       L2(31)   17/465   27                     [ "8A", "16A" ]          [ 1, 1 ]
       L2(32)     1/31   30              [ "3A", "11A", "33A" ]       [ 1, 1, 1 ]
       L2(37)     1/37   36                           [ "19A" ]             [ 1 ]
       L2(41)     1/41   40                     [ "21A", "7A" ]          [ 1, 1 ]
       L2(43)   23/903   39                    [ "22A", "11A" ]          [ 1, 1 ]
       L2(47)  25/1081   43        [ "24A", "12A", "8A", "6A" ]    [ 1, 1, 1, 1 ]
       L2(49)     1/49   48                           [ "25A" ]             [ 1 ]
       L2(53)     1/53   52                     [ "27A", "9A" ]          [ 1, 1 ]
       L2(59)  31/1711   55       [ "30A", "15A", "10A", "6A" ]    [ 1, 1, 1, 1 ]
       L2(61)     1/61   60                           [ "31A" ]             [ 1 ]
       L2(64)     1/63   62                    [ "65A", "13A" ]          [ 1, 1 ]
       L2(67)  35/2211   63                    [ "34A", "17A" ]          [ 1, 1 ]
       L2(71)  37/2485   67 [ "36A", "18A", "12A", "9A", "6A" ] [ 1, 1, 1, 1, 1 ]
       L2(73)     1/73   72                           [ "37A" ]             [ 1 ]
       L2(79)  41/3081   75       [ "40A", "20A", "10A", "8A" ]    [ 1, 1, 1, 1 ]
        L2(8)      1/7    6                      [ "3A", "9A" ]          [ 1, 1 ]
       L2(81)     1/81   80                           [ "41A" ]             [ 1 ]
       L2(83)  43/3403   79 [ "42A", "21A", "14A", "7A", "6A" ] [ 1, 1, 1, 1, 1 ]
       L2(89)     1/89   88              [ "45A", "15A", "9A" ]       [ 1, 1, 1 ]
       L2(97)     1/97   96                     [ "49A", "7A" ]          [ 1, 1 ]
       L3(11)   1/6655 6654                   [ "19A", "133A" ]          [ 1, 1 ]
        L3(2)      1/4    3                            [ "7A" ]             [ 1 ]
        L3(3)     1/24   23                           [ "13A" ]             [ 1 ]
        L3(4)      1/5    4                            [ "7A" ]             [ 3 ]
        L3(5)    1/250  249                           [ "31A" ]             [ 1 ]
        L3(7)   1/1372 1371                           [ "19A" ]             [ 1 ]
        L3(8)   1/1792 1791                           [ "73A" ]             [ 1 ]
        L3(9)   1/2880 2879                           [ "91A" ]             [ 1 ]
        L4(3)  53/1053   19                           [ "20A" ]             [ 1 ]
        L5(2)   1/5376 5375                           [ "31A" ]             [ 1 ]
       O8-(2)     1/63   62                           [ "17A" ]             [ 1 ]
        S4(4)     4/15    3                           [ "17A" ]             [ 2 ]
        S4(5)      1/5    4                           [ "13A" ]             [ 1 ]
        S6(3)    1/117  116                           [ "14A" ]             [ 2 ]
       Sz(32)   1/1271 1270                     [ "5A", "25A" ]          [ 1, 1 ]
        Sz(8)     1/91   90                            [ "5A" ]             [ 1 ]
       U3(11)   1/6655 6654                           [ "37A" ]             [ 1 ]
        U3(3)    16/63    3                     [ "6A", "12A" ]          [ 2, 2 ]
        U3(4)    1/160  159                           [ "13A" ]             [ 1 ]
        U3(5)   46/525   11                           [ "10A" ]             [ 2 ]
        U3(7)   1/1372 1371                           [ "43A" ]             [ 1 ]
        U3(8)   1/1792 1791                           [ "19A" ]             [ 1 ]
        U3(9)   1/3600 3599                           [ "73A" ]             [ 1 ]
        U5(2)     1/54   53                           [ "11A" ]             [ 1 ]
        U6(2)     5/21    4                           [ "11A" ]             [ 4 ]
    gap&#62; First( atleast3, l -&#62; l[1] = "L7(2)" );
    [ "L7(2)", 1/4388290560, 4388290559, [ "127A" ], [ 1 ] ]

</pre>

<div class="p"><!----></div>
It should be mentioned that&nbsp;[<a href="#BW1" name="CITEBW1">BW75</a>] states the following lower bounds
for the uniform spread of the groups L<sub>2</sub>(q).

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 </td><td nowrap="nowrap" align="center">
<table>
<tr><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
q&#8722;2 </td></tr></table></td><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">if</span> <span class="roman">4</span>  &#8804; <span class="roman">q</span> <span class="roman">is</span> <span class="roman">even</span><span class="roman">,</span> </td></tr></table></td></tr>
<tr><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
q&#8722;1 </td></tr></table></td><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">if</span> <span class="roman">11</span>  &#8804; <span class="roman">q</span>  &#8801; <span class="roman">1</span>  mod <span class="roman">4</span><span class="roman">,</span> </td></tr></table></td></tr>
<tr><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
q&#8722;4 </td></tr></table></td><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">if</span> <span class="roman">11</span>  &#8804; <span class="roman">q</span>  &#8801; &#8722;<span class="roman">1</span>  mod <span class="roman">4</span><span class="roman">.</span> </td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>


These bounds appear in the third column of the above table.
Furthermore, [<a href="#BW1" name="CITEBW1">BW75</a>] states that the (uniform) spread
of alternating groups of even degree at least 8 is exactly 4.

<div class="p"><!----></div>
For the sake of completeness, Table&nbsp;<a href="#maxtable">2</a> gives an overview of the
sets <font face="helvetica"><i>M</i></font>(G,s) for those cases in the above list that are needed in&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>]
but that do not require a further discussion here.
The structure of the maximal subgroups and the order of s in the table
refer to the matrix groups not to the simple groups.
The number of the subgroups has been shown above,
the structure follows from&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>].

<div class="p"><!----></div>

<div class="p"><!----></div>
<a name="tth_tAb2">
</a> <center>Table 2: Maximal subgroups</center><a name="maxtable">
</a>

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 </td><td nowrap="nowrap" align="center">
<table border="1">
<tr><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
G </td></tr></table></td><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<font face="helvetica"><i>M</i></font>(G,s) </td></tr></table></td><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#124;s&#124; </td></tr></table></td><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">see</span>&nbsp;<span class="roman">[</span><a href="#CCN85" name="CITECCN85"><span class="roman">CCN</span><sup><span class="roman">+</span></sup><span class="roman">85</span></a><span class="roman">]</span> </td></tr></table></td></tr><tr><td></td></tr>
<tr><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">SL</span>(3,4) = 3.L<sub>3</sub>(4) </td></tr></table></td><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
3 &times;L<sub>3</sub>(2), 3 &times;L<sub>3</sub>(2), 3 &times;L<sub>3</sub>(2) </td></tr></table></td><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
21 </td></tr></table></td><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
p.&nbsp;23 </td></tr></table></td></tr>
<tr><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#8486;<sup>&#8722;</sup>(8,2) = O<sup>&#8722;</sup><sub>8</sub>(2) </td></tr></table></td><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#8486;<sup>&#8722;</sup>(4,4).2 = L<sub>2</sub>(16).2 </td></tr></table></td><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
17 </td></tr></table></td><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
p.&nbsp;89 </td></tr></table></td></tr>
<tr><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">Sp</span>(4,4) = S<sub>4</sub>(4) </td></tr></table></td><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#8486;<sup>&#8722;</sup>(4,4).2 = L<sub>2</sub>(16).2, <span class="roman">Sp</span>(2,16).2 = L<sub>2</sub>(16).2 </td></tr></table></td><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
17 </td></tr></table></td><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
p.&nbsp;44 </td></tr></table></td></tr>
<tr><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">Sp</span>(6,3) = 2.S<sub>6</sub>(3) </td></tr></table></td><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
(4 &times;U<sub>3</sub>(3)).2, <span class="roman">Sp</span>(2,17).3 = 2.L<sub>2</sub>(27).3 </td></tr></table></td><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
28 </td></tr></table></td><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
p.&nbsp;113 </td></tr></table></td></tr>
<tr><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">SU</span>(3,3) = U<sub>3</sub>(3) </td></tr></table></td><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
3<sup>1+2</sup><sub>+</sub>:8, <span class="roman">GU</span>(2,3) = 4.S<sub>4</sub> </td></tr></table></td><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
6 </td></tr></table></td><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
p.&nbsp;14 </td></tr></table></td></tr>
<tr><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">SU</span>(3,5) = 3.U<sub>3</sub>(5) </td></tr></table></td><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
3 &times;5<sup>1+2</sup><sub>+</sub>:8, <span class="roman">GU</span>(2,5) = 3 &times;2S<sub>5</sub> </td></tr></table></td><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
30 </td></tr></table></td><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
p.&nbsp;34 </td></tr></table></td></tr>
<tr><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">SU</span>(5,2) = U<sub>5</sub>(2) </td></tr></table></td><td><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
L<sub>2</sub>(11) </td></tr></table></td><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
11 </td></tr></table></td><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
p.&nbsp;73 </td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<div class="p"><!----></div>

     <h3><a name="tth_sEc4.4">
4.4</a>&nbsp;&nbsp;Automorphism Groups of other Simple Groups - Easy Cases</h3><a name="easyloopaut">
</a>

<div class="p"><!----></div>
We deal with automorphic extensions of those simple groups that are
listed in Table&nbsp;<a href="#thetable">1</a> and that have been treated successfully in
Section&nbsp;<a href="#easyloop">4.3</a>.

<div class="p"><!----></div>
For the following groups, <tt>ProbGenInfoAlmostSimple</tt> can be used
because <font face="helvetica">GAP</font> can compute their primitive permutation characters.

<div class="p"><!----></div>

<pre>
    gap&#62; list:= [
    &#62;   [ "A5", "A5.2" ],
    &#62;   [ "A6", "A6.2_1" ],
    &#62;   [ "A6", "A6.2_2" ],
    &#62;   [ "A6", "A6.2_3" ],
    &#62;   [ "A7", "A7.2" ],
    &#62;   [ "A8", "A8.2" ],
    &#62;   [ "A9", "A9.2" ],
    &#62;   [ "A11", "A11.2" ],
    &#62;   [ "L3(2)", "L3(2).2" ],
    &#62;   [ "L3(3)", "L3(3).2" ],
    &#62;   [ "L3(4)", "L3(4).2_1" ],
    &#62;   [ "L3(4)", "L3(4).2_2" ],
    &#62;   [ "L3(4)", "L3(4).2_3" ],
    &#62;   [ "L3(4)", "L3(4).3" ],
    &#62;   [ "S4(4)", "S4(4).2" ],
    &#62;   [ "U3(3)", "U3(3).2" ],
    &#62;   [ "U3(5)", "U3(5).2" ],
    &#62;   [ "U3(5)", "U3(5).3" ],
    &#62;   [ "U4(2)", "U4(2).2" ],
    &#62;   [ "U4(3)", "U4(3).2_1" ],
    &#62;   [ "U4(3)", "U4(3).2_3" ],
    &#62; ];;
    gap&#62; autinfo:= [];;
    gap&#62; fails:= [];;
    gap&#62; for pair in list do
    &#62;      tbl:= CharacterTable( pair[1] );
    &#62;      tblG:= CharacterTable( pair[2] );
    &#62;      info:= ProbGenInfoSimple( tbl );
    &#62;      spos:= List( info[4], x -&#62; Position( AtlasClassNames( tbl ), x ) );
    &#62;      Add( autinfo, ProbGenInfoAlmostSimple( tbl, tblG, spos ) );
    &#62;    od;
    gap&#62; PrintFormattedArray( autinfo );
           A5.2      0        [ "5AB" ]    [ 1 ]
         A6.2_1    2/3        [ "5AB" ]    [ 2 ]
         A6.2_2    1/6         [ "5A" ]    [ 1 ]
         A6.2_3      0        [ "5AB" ]    [ 1 ]
           A7.2   1/15        [ "7AB" ]    [ 1 ]
           A8.2  13/28       [ "15AB" ]    [ 1 ]
           A9.2    1/4        [ "9AB" ]    [ 1 ]
          A11.2  1/945       [ "11AB" ]    [ 1 ]
        L3(2).2    1/4        [ "7AB" ]    [ 1 ]
        L3(3).2   1/18       [ "13AB" ]    [ 1 ]
      L3(4).2_1   3/10        [ "7AB" ]    [ 3 ]
      L3(4).2_2  11/60         [ "7A" ]    [ 1 ]
      L3(4).2_3   1/12        [ "7AB" ]    [ 1 ]
        L3(4).3   1/64         [ "7A" ]    [ 1 ]
        S4(4).2      0       [ "17AB" ]    [ 2 ]
        U3(3).2    2/7 [ "6A", "12AB" ] [ 2, 2 ]
        U3(5).2   2/21        [ "10A" ]    [ 2 ]
        U3(5).3 46/525        [ "10A" ]    [ 2 ]
        U4(2).2  16/45       [ "12AB" ]    [ 2 ]
      U4(3).2_1 76/135         [ "7A" ]    [ 3 ]
      U4(3).2_3 31/162        [ "7AB" ]    [ 3 ]

</pre>

<div class="p"><!----></div>
We see that from this list,
the two groups A<sub>6</sub>.2<sub>1</sub> = S<sub>6</sub> and U<sub>4</sub>(3).2<sub>1</sub> require further computations
(see Sections&nbsp;<a href="#A6">5.3</a> and&nbsp;<a href="#U43">5.24</a>, respectively)
because the bound in the second column is larger than 1/2.

<div class="p"><!----></div>
Also U<sub>4</sub>(2) is not done by the above,
because in&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Table&nbsp;4], an element s of order 9 is chosen
for the simple group, see Section&nbsp;<a href="#U42">5.23</a>.

<div class="p"><!----></div>
Finally, we deal with automorphic extensions of the groups L<sub>4</sub>(3),
O<sub>8</sub><sup>&#8722;</sup>(2), S<sub>6</sub>(3), and U<sub>5</sub>(2).

<div class="p"><!----></div>
For S = L<sub>4</sub>(3) and s  &#8712; S of order 20,
we have <font face="helvetica"><i>M</i></font>(S,s) = { (4 &times;A<sub>6</sub>):2 },
the subgroup has index 2&nbsp;106, see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;69].

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "L4(3)" );;
    gap&#62; prim:= PrimitivePermutationCharacters( t );;
    gap&#62; spos:= Position( AtlasClassNames( t ), "20A" );;
    gap&#62; prim:= Filtered( prim, x -&#62; x[ spos ] &lt;&#62; 0 );
    [ Character( CharacterTable( "L4(3)" ), [ 2106, 106, 42, 0, 27, 27, 0, 46, 6, 
          6, 1, 7, 7, 0, 3, 3, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1 ] ) ]

</pre>

<div class="p"><!----></div>
For the three automorphic extensions of the structure G = S.2,
we compute the extensions of the permutation character,
and the bounds &#963;<sup>&#8242;</sup>(G,s).

<div class="p"><!----></div>

<pre>
    gap&#62; for name in [ "L4(3).2_1", "L4(3).2_2", "L4(3).2_3" ] do
    &#62;      t2:= CharacterTable( name );
    &#62;      map:= InverseMap( GetFusionMap( t, t2 ) );
    &#62;      torso:= List( prim, pi -&#62; CompositionMaps( pi, map ) );
    &#62;      ext:= Concatenation( List( torso,
    &#62;                              x -&#62; PermChars( t2, rec( torso:= x ) ) ) );
    &#62;      sigma:= ApproxP( ext, Position( OrdersClassRepresentatives( t2 ), 20 ) );
    &#62;      max:= Maximum( sigma{ Difference( PositionsProperty(
    &#62;                           OrdersClassRepresentatives( t2 ), IsPrimeInt ),
    &#62;                           ClassPositionsOfDerivedSubgroup( t2 ) ) } );
    &#62;      Print( name, ":\n", ext, "\n", max, "\n" );
    &#62; od;
    L4(3).2_1:
    [ Character( CharacterTable( "L4(3).2_1" ), [ 2106, 106, 42, 0, 27, 0, 46, 6, 
          6, 1, 7, 0, 3, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 4, 0, 0, 6, 6, 6, 6, 
          2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1 ] ) ]
    0
    L4(3).2_2:
    [ Character( CharacterTable( "L4(3).2_2" ), 
        [ 2106, 106, 42, 0, 27, 27, 0, 46, 6, 6, 1, 7, 7, 0, 3, 3, 0, 0, 0, 1, 1, 
          1, 0, 0, 0, 1, 306, 306, 42, 6, 10, 10, 0, 0, 15, 15, 3, 3, 3, 3, 0, 0, 
          1, 1, 0, 1, 1, 0, 0 ] ) ]
    17/117
    L4(3).2_3:
    [ Character( CharacterTable( "L4(3).2_3" ), [ 2106, 106, 42, 0, 27, 0, 46, 6, 
          6, 1, 7, 0, 3, 0, 0, 1, 1, 0, 0, 0, 1, 36, 0, 0, 6, 6, 2, 2, 2, 1, 1, 
          0, 0, 0 ] ) ]
    2/117

</pre>

<div class="p"><!----></div>
For S = O<sub>8</sub><sup>&#8722;</sup>(2) and s  &#8712; S of order 17,
we have <font face="helvetica"><i>M</i></font>(S,s) = { L<sub>2</sub>(16).2 },
the subgroup extends to L<sub>2</sub>(16).4 in S.2, see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;89].
This is a non-split extension, so &#963;<sup>&#8242;</sup>(S.2,s) = 0 holds.

<div class="p"><!----></div>

<pre>
    gap&#62; SigmaFromMaxes( CharacterTable( "O8-(2).2" ), "17AB",
    &#62;        [ CharacterTable( "L2(16).4" ) ], [ 1 ], "outer" );
    0

</pre>

<div class="p"><!----></div>
For S = S<sub>6</sub>(3) and s  &#8712; S irreducible of order 14,
we have <font face="helvetica"><i>M</i></font>(S,s) = { (2 &times;U<sub>3</sub>(3)).2, L<sub>2</sub>(27).3 }.
In G = S.2, the subgroups extend to (4 &times;U<sub>3</sub>(3)).2 and L<sub>2</sub>(27).6,
respectively, see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;113].
In order to show that &#963;<sup>&#8242;</sup>(G,s) = 7/3240 holds,
we compute the primitive permutation characters of S
(cf.&nbsp;Section&nbsp;<a href="#easyloop">4.3</a>) and the unique extensions to G
of those which are nonzero on s.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "S6(3)" );;
    gap&#62; t2:= CharacterTable( "S6(3).2" );;
    gap&#62; prim:= PrimitivePermutationCharacters( t );;
    gap&#62; spos:= Position( AtlasClassNames( t ), "14A" );;
    gap&#62; prim:= Filtered( prim, x -&#62; x[ spos ] &lt;&#62; 0 );;
    gap&#62; map:= InverseMap( GetFusionMap( t, t2 ) );;
    gap&#62; torso:= List( prim, pi -&#62; CompositionMaps( pi, map ) );;
    gap&#62; ext:= List( torso, pi -&#62; PermChars( t2, rec( torso:= pi ) ) );
    [ [ Character( CharacterTable( "S6(3).2" ), [ 155520, 0, 288, 0, 0, 0, 216, 
              54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 1, 0, 0, 0, 0, 0, 6, 
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 144, 
              288, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 1, 1, 1, 
              1, 0, 0 ] ) ],
      [ Character( CharacterTable( "S6(3).2" ), [ 189540, 1620, 568, 0, 486, 0, 
              0, 27, 540, 84, 24, 0, 0, 0, 0, 0, 54, 0, 0, 10, 0, 7, 1, 6, 6, 0, 
              0, 0, 0, 0, 0, 18, 0, 0, 0, 6, 12, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 
              0, 0, 234, 64, 30, 8, 0, 3, 90, 6, 0, 4, 10, 6, 0, 2, 1, 0, 0, 0, 
              0, 0, 0, 0, 1, 1, 0, 0 ] ) ] ]
    gap&#62; spos:= Position( AtlasClassNames( t2 ), "14A" );;
    gap&#62; sigma:= ApproxP( Concatenation( ext ), spos );;
    gap&#62; Maximum( sigma{ Difference(
    &#62;      PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),
    &#62;      ClassPositionsOfDerivedSubgroup( t2 ) ) } );
    7/3240

</pre>

<div class="p"><!----></div>
For S = U<sub>5</sub>(2) and s  &#8712; S of order 11,
we have <font face="helvetica"><i>M</i></font>(S,s) = { L<sub>2</sub>(11) },
the subgroup extends to L<sub>2</sub>(11).2 in S.2, see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;73].

<div class="p"><!----></div>

<pre>
    gap&#62; SigmaFromMaxes( CharacterTable( "U5(2).2" ), "11AB",
    &#62;        [ CharacterTable( "L2(11).2" ) ], [ 1 ], "outer" );
    1/288

</pre>

<div class="p"><!----></div>
Here we clean the workspace for the first time.
This may save more than 100 megabytes, due to the fact that the caches
for tables of marks and character tables are flushed.

<div class="p"><!----></div>

<pre>
    gap&#62; CleanWorkspace();

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.5">
4.5</a>&nbsp;&nbsp;O<sub>8</sub><sup>&#8722;</sup>(3)</h3><a name="O8m3">
</a>

<div class="p"><!----></div>
We show that S = O<sub>8</sub><sup>&#8722;</sup>(3) = &#8486;<sup>&#8722;</sup>(8,3) satisfies the following.

<ol type="1">
<br />(a)
    For s  &#8712; S of order 41,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one group of the type
    L<sub>2</sub>(81).2<sub>1</sub> = &#8486;<sup>&#8722;</sup>(4,9).2.
<br />(b)
    &#963;(S,s) = 1/567.</ol>

<div class="p"><!----></div>
The only maximal subgroups of S containing elements of order 41
have the type L<sub>2</sub>(81).2<sub>1</sub>,
and there is one class of these subgroups, see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;141].

<div class="p"><!----></div>

<pre>
    gap&#62; SigmaFromMaxes( CharacterTable( "O8-(3)" ), "41A",
    &#62;    [ CharacterTable( "L2(81).2_1" ) ], [ 1 ] );
    1/567

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.6">
4.6</a>&nbsp;&nbsp;O<sub>10</sub><sup>+</sup>(2)</h3><a name="O10p2">
</a>

<div class="p"><!----></div>
We show that S = O<sub>10</sub><sup>+</sup>(2) = &#8486;<sup>+</sup>(10,2) satisfies the following.

<ol type="1">
<br />(a)
    For s  &#8712; S of order 45,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one group of the type
    (A<sub>5</sub> &times;U<sub>4</sub>(2)).2 = (&#8486;<sup>&#8722;</sup>(4,2) &times;&#8486;<sup>&#8722;</sup>(6,2)).2.
<br />(b)
    &#963;(S,s) = 43/4&nbsp;216.
<br />(c)
    For s as in (a),
    the maximal subgroup in (a) extends to S<sub>5</sub> &times;U<sub>4</sub>(2).2
    in G = <span class="roman">Aut</span>(S) = S.2,
    and &#963;<sup>&#8242;</sup>(G,s) = 23/248.</ol>

<div class="p"><!----></div>
The only maximal subgroups of S containing elements of order 45
are one class of groups
H = (A<sub>5</sub> &times;U<sub>4</sub>(2)):2, see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;146].
(Note that none of the groups S<sub>8</sub>(2), O<sub>8</sub><sup>+</sup>(2), L<sub>5</sub>(2), O<sub>8</sub><sup>&#8722;</sup>(2),
and A<sub>8</sub> contains elements of order 45.)
H extends to subgroups of the type H.2 = S<sub>5</sub> &times;U<sub>4</sub>(2):2 in G,
so we can compute 1<sub>H</sub><sup>S</sup> = (1<sub>H.2</sub><sup>G</sup>)<sub>S</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; ForAny( [ "S8(2)", "O8+(2)", "L5(2)", "O8-(2)", "A8" ],
    &#62;            x -&#62; 45 in OrdersClassRepresentatives( CharacterTable( x ) ) );
    false
    gap&#62; t:= CharacterTable( "O10+(2)" );;
    gap&#62; t2:= CharacterTable( "O10+(2).2" );;
    gap&#62; s2:= CharacterTable( "A5.2" ) * CharacterTable( "U4(2).2" );
    CharacterTable( "A5.2xU4(2).2" )
    gap&#62; pi:= PossiblePermutationCharacters( s2, t2 );;
    gap&#62; spos:= Position( OrdersClassRepresentatives( t2 ), 45 );;
    gap&#62; approx:= ApproxP( pi, spos );;
    gap&#62; Maximum( approx{ ClassPositionsOfDerivedSubgroup( t2 ) } );
    43/4216

</pre>

<div class="p"><!----></div>
Statement&nbsp;(c) follows from considering the outer classes
of prime element order.

<div class="p"><!----></div>

<pre>
    gap&#62; Maximum( approx{ Difference(
    &#62;      PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),
    &#62;      ClassPositionsOfDerivedSubgroup( t2 ) ) } );
    23/248

</pre>

<div class="p"><!----></div>
Alternatively, we can use <tt>SigmaFromMaxes</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; SigmaFromMaxes( t2, "45AB", [ s2 ], [ 1 ], "outer" );
    23/248

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.7">
4.7</a>&nbsp;&nbsp;O<sub>10</sub><sup>&#8722;</sup>(2)</h3><a name="O10m2">
</a>

<div class="p"><!----></div>
We show that S = O<sub>10</sub><sup>&#8722;</sup>(2) = &#8486;<sup>&#8722;</sup>(10,2) satisfies the following.

<ol type="1">
<br />(a)
    For s  &#8712; S of order 33,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one group of the type
    3 &times;U<sub>5</sub>(2) = <span class="roman">GU</span>(5,2).
<br />(b)
    &#963;(S,s) = 1/119.
<br />(c)
    For s as in (a),
    the maximal subgroup in (a) extends to (3 &times;U<sub>5</sub>(2)).2
    in G,
    and &#963;<sup>&#8242;</sup>(G,s) = 1/595.</ol>

<div class="p"><!----></div>
The only maximal subgroups of S containing elements of order 11
have the types A<sub>12</sub> and 3 &times;U<sub>5</sub>(2), see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;147].
So 3 &times;U<sub>5</sub>(2) is the unique class of subgroups containing elements
of order 33.
This shows statement&nbsp;(a),
and statement&nbsp;(b) follows using <tt>SigmaFromMaxes</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; SigmaFromMaxes( CharacterTable( "O10-(2)" ), "33A",
    &#62;    [ CharacterTable( "Cyclic", 3 ) * CharacterTable( "U5(2)" ) ], [ 1 ] );
    1/119

</pre>

<div class="p"><!----></div>
The structure of the maximal subgroup of G follows
from&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;147].
We create its character table with a generic construction
that is based on the fact that the outer automorphism acts nontrivially on
the two direct factors; this determines the character table uniquely.
(See&nbsp;[<a href="#Auto" name="CITEAuto">Breb</a>] for details.)

<div class="p"><!----></div>

<pre>
    gap&#62; tblG:= CharacterTable( "U5(2)" );;
    gap&#62; tblMG:= CharacterTable( "Cyclic", 3 ) * tblG;;
    gap&#62; tblGA:= CharacterTable( "U5(2).2" );;
    gap&#62; acts:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );;
    gap&#62; poss:= Concatenation( List( acts, pi -&#62;
    &#62;            PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, pi,
    &#62;                "(3xU5(2)).2" ) ) );
    [ rec( MGfusMGA := [ 1, 2, 3, 4, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 12, 13, 13,
              14, 14, 15, 15, 16, 17, 17, 18, 18, 19, 20, 21, 21, 22, 22, 23, 23,
              24, 24, 25, 25, 26, 27, 27, 28, 28, 29, 29, 30, 30, 31, 32, 33, 34,
              35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
              52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,
              69, 70, 71, 72, 73, 74, 75, 76, 77, 31, 32, 33, 35, 34, 37, 36, 38,
              39, 40, 41, 42, 43, 45, 44, 47, 46, 49, 48, 51, 50, 52, 54, 53, 56,
              55, 57, 58, 60, 59, 62, 61, 64, 63, 66, 65, 68, 67, 69, 71, 70, 73,
              72, 75, 74, 77, 76 ], table := CharacterTable( "(3xU5(2)).2" ) ) ]

</pre>

<div class="p"><!----></div>
Now statement&nbsp;(c) follows using <tt>SigmaFromMaxes</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; SigmaFromMaxes( CharacterTable( "O10-(2).2" ), "33AB",
    &#62;        [ poss[1].table ], [ 1 ], "outer" );
    1/595

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.8">
4.8</a>&nbsp;&nbsp;O<sub>12</sub><sup>+</sup>(2)</h3><a name="O12p2">
</a>

<div class="p"><!----></div>
We show that S = O<sub>12</sub><sup>+</sup>(2) = &#8486;<sup>+</sup>(12,2) satisfies the following.

<ol type="1">
<br />(a)
    For s  &#8712; S of the type 4<sup>&#8722;</sup> &#8869;8<sup>&#8722;</sup>
    (i.&nbsp;e., s decomposes the natural 12-dimensional module for
    <span class="roman">GO</span><sup>+</sup><sub>12</sub>(2) = S.2 into an orthogonal sum of two irreducible
    modules of the dimensions 4 and 8, respectively) and of order 85,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one group of the type
    G<sub>8</sub> = (&#8486;<sup>&#8722;</sup>(4,2) &times;&#8486;<sup>&#8722;</sup>(8,2)).2 and
    two groups of the type L<sub>4</sub>(4).2<sup>2</sup> = &#8486;<sup>+</sup>(6,4).2<sup>2</sup>
    that are conjugate in G = <span class="roman">Aut</span>(S) = S.2 = <span class="roman">SO</span><sup>+</sup>(12,2)
    but <em>not</em> conjugate in S.
<br />(b)
    &#963;(S,s) = 7&nbsp;675/1&nbsp;031&nbsp;184.
<br />(c)
    &#963;<sup>&#8242;</sup>(G,s) = 73/1&nbsp;008.</ol>

<div class="p"><!----></div>
The element s is a ppd(12,2;8)-element in the sense of&nbsp;[<a href="#GPPS" name="CITEGPPS">GPPS99</a>],
so the maximal subgroups of S that contain s are among the nine
cases (2.1)-(2.9) listed in this paper;
in the notation of this paper,
we have q = 2, d = 12, e = 8, and r = 17.
Case&nbsp;(2.1) does not occur for orthogonal groups and q = 2,
according to&nbsp;[<a href="#KlL90" name="CITEKlL90">KL90</a>];
case&nbsp;(2.2) contributes a unique maximal subgroup,
the stabilizer G<sub>8</sub> of the orthogonal decomposition;
the cases&nbsp;(2.3), (2.4)&nbsp;(a), (2.5), and (2.6)&nbsp;(a) do not occur
because r  &#8800; e+1 in our situation;
case&nbsp;(2.4)&nbsp;(b) describes extension field type subgroups that are contained
in &#915;<span class="roman">L</span>(6,4),
which yields the candidates <span class="roman">GU</span>(6,2).2  &#8773; 3.U<sub>6</sub>(2).S<sub>3</sub>
-but 3.U<sub>6</sub>(2).3 does not contain elements of order 85-
and &#8486;<sup>+</sup>(6,4).2<sup>2</sup>  &#8773; L<sub>4</sub>(4).2<sup>2</sup>
(two classes by&nbsp;[<a href="#KlL90" name="CITEKlL90">KL90</a>,Prop.&nbsp;4.3.14]);
the cases&nbsp;(2.6)&nbsp;(b)-(c) and&nbsp;(2.8) do not occur because they require
d  &#8804; 8;
case&nbsp;(2.7) does not occur because&nbsp;[<a href="#GPPS" name="CITEGPPS">GPPS99</a>,Table&nbsp;5] contains no entry for
r = 2e+1 = 17;
finally, case&nbsp;(2.9) does not occur because it requires e  &#8712; { d&#8722;1, d }
in the case r = 2e+1.

<div class="p"><!----></div>
So we need the permutation characters of the actions on the cosets of
L<sub>4</sub>(4).2<sup>2</sup> (two classes) and G<sub>8</sub>.
According to&nbsp;[<a href="#KlL90" name="CITEKlL90">KL90</a>,Prop.&nbsp;4.1.6],
G<sub>8</sub> has the structure (&#8486;<sup>&#8722;</sup>(4,2) &times;&#8486;<sup>&#8722;</sup>(8,2)).2.

<div class="p"><!----></div>
Currently the <font face="helvetica">GAP</font> Character Table Library does not contain the
character table of S, but the table of G is available,
and we work with this table.

<div class="p"><!----></div>
The two classes of L<sub>4</sub>(4).2<sup>2</sup> type subgroups in S are fused in G.
This can be seen from the fact that inducing the trivial character of
a subgroup H<sub>1</sub> = L<sub>4</sub>(4).2<sup>2</sup> of S to G yields a character &#968;
whose values are not all even;
note that if H<sub>1</sub> would extend in G to a subgroup of twice the size
of H<sub>1</sub> then &#968; would be induced from a degree two character
of this subgroup whose values are all even,
and induction preserves this property.

<div class="p"><!----></div>

<pre>
    gap&#62; CharacterTable( "O12+(2)" );
    fail
    gap&#62; t:= CharacterTable( "O12+(2).2" );;
    gap&#62; h1:= CharacterTable( "L4(4).2^2" );;
    gap&#62; psi:= PossiblePermutationCharacters( h1, t );;
    gap&#62; Length( psi );
    1
    gap&#62; ForAny( psi[1], IsOddInt );
    true

</pre>

<div class="p"><!----></div>
The fixed element s of order 85 is contained in a member of each
of the two conjugacy classes of the type L<sub>4</sub>(4).2<sup>2</sup> in S,
since S contains only one class of subgroups of the order 85;
note that the order of the Sylow 17 centralizer (in both S and G)
is not divisible by 25.

<div class="p"><!----></div>

<pre>
    gap&#62; SizesCentralizers( t ){ PositionsProperty(
    &#62;        OrdersClassRepresentatives( t ), x -&#62; x = 17 ) } / 25;
    [ 408/5, 408/5 ]

</pre>

<div class="p"><!----></div>
This implies that the restriction of &#968; to S
is the sum &#968;<sub>S</sub> = &#960;<sub>1</sub> + &#960;<sub>2</sub>, say,
of the first two interesting permutation characters of S.

<div class="p"><!----></div>
The subgroup G<sub>8</sub> of S extends to a group of the structure
H<sub>2</sub> = &#8486;<sup>&#8722;</sup>(4,2).2 &times;&#8486;<sup>&#8722;</sup>(8,2).2 in G,
inducing the trivial characters of H<sub>2</sub> to G yields
a permutation character &#981; of G whose restriction to S
is the third permutation character &#981;<sub>S</sub> = &#960;<sub>3</sub>, say.

<div class="p"><!----></div>

<pre>
    gap&#62; h2:= CharacterTable( "S5" ) * CharacterTable( "O8-(2).2" );;
    gap&#62; phi:= PossiblePermutationCharacters( h2, t );;
    gap&#62; Length( phi );
    1

</pre>

<div class="p"><!----></div>
We have &#960;<sub>1</sub>(1) = &#960;<sub>2</sub>(1) and &#960;<sub>1</sub>(s) = &#960;<sub>2</sub>(s),
the latter again because S contains only one class of subgroups
of order 85.

<div class="p"><!----></div>
Now statement&nbsp;(a) follows from the fact that &#960;<sub>i</sub>(s) = 1 holds
for 1  &#8804; i  &#8804; 3.

<div class="p"><!----></div>

<pre>
    gap&#62; prim:= Concatenation( psi, phi );;
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 85 );
    213
    gap&#62; List( prim, x -&#62; x[ spos ] );
    [ 2, 1 ]

</pre>

<div class="p"><!----></div>
For statement&nbsp;(b), we compute &#963;(S,s).
Note that we have to consider only classes inside S = G<sup>&#8242;</sup>,
and that

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 &#963;( g, s ) = </td><td nowrap="nowrap" align="center">
<small>3</small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i=1</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&#960;<sub>i</sub>(s) &#183;&#960;<sub>i</sub>(g)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#960;<sub>i</sub>(1)<br /></td><td nowrap="nowrap" align="center">
 = </td><td nowrap="nowrap" align="center">
&#968;(s) &#183;&#968;(g)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#968;(1)<br /></td><td nowrap="nowrap" align="center">
+ </td><td nowrap="nowrap" align="center">
&#981;(s) &#183;&#981;(g)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#981;(1)<br /></td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>


holds for g  &#8712; S<sup>&times;</sup>,
so the characters &#968; and &#981; are sufficient.

<div class="p"><!----></div>

<pre>
    gap&#62; approx:= ApproxP( prim, spos );;
    gap&#62; Maximum( approx{ ClassPositionsOfDerivedSubgroup( t ) } );
    7675/1031184

</pre>

<div class="p"><!----></div>
Statement&nbsp;(c) follows from considering the outer involution classes.
Note that by&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Remark after Proposition&nbsp;5.14],
only the subgroup H<sub>2</sub> need to be considered,
no novelties appear.

<div class="p"><!----></div>

<pre>
    gap&#62; Maximum( approx{ Difference(
    &#62;      PositionsProperty( OrdersClassRepresentatives( t ), IsPrimeInt ),
    &#62;      ClassPositionsOfDerivedSubgroup( t ) ) } );
    73/1008

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.9">
4.9</a>&nbsp;&nbsp;O<sub>12</sub><sup>&#8722;</sup>(2)</h3><a name="O12m2">
</a>

<div class="p"><!----></div>
We show that S = O<sub>12</sub><sup>&#8722;</sup>(2) = &#8486;<sup>&#8722;</sup>(12,2) satisfies the following.

<ol type="1">
<br />(a)
    For s  &#8712; S irreducible of order 2<sup>6</sup>+1 = 65,
    <font face="helvetica"><i>M</i></font>(S,s) consists of two groups of the types
    U<sub>4</sub>(4).2 = &#8486;<sup>&#8722;</sup>(6,4).2 and L<sub>2</sub>(64).3 = &#8486;<sup>&#8722;</sup>(4,8).3,
    respectively.
<br />(b)
    &#963;(S,s) = 1/1&nbsp;023.
<br />(c)
    &#963;<sup>&#8242;</sup>(<span class="roman">Aut</span>(S),s) = 1/347&nbsp;820.</ol>

<div class="p"><!----></div>
By&nbsp;[<a href="#Be00" name="CITEBe00">Ber00</a>], <font face="helvetica"><i>M</i></font>(S,s) consists of extension field subgroups,
which have the structures U<sub>4</sub>(4).2 and L<sub>2</sub>(64).3, respectively,
and by&nbsp;[<a href="#KlL90" name="CITEKlL90">KL90</a>,Prop.&nbsp;4.3.16],
there is just one class of each of these types.

<div class="p"><!----></div>
Currently the <font face="helvetica">GAP</font> Character Table Library does not contain the
character table of S, but the table of G = <span class="roman">Aut</span>(S) = O<sub>12</sub><sup>&#8722;</sup>(2).2
is available.
So we compute the permutation characters &#960;<sub>1</sub>, &#960;<sub>2</sub> of the extensions
of the groups in <font face="helvetica"><i>M</i></font>(S,s) to G
-these maximal subgroups have the structures U<sub>4</sub>(4).4 and L<sub>2</sub>(64).6,
respectively-
and compute the fixed point ratios of the restrictions to S.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "O12-(2)" );
    fail
    gap&#62; t:= CharacterTable( "O12-(2).2" );;
    gap&#62; s1:= CharacterTable( "U4(4).4" );;
    gap&#62; pi1:= PossiblePermutationCharacters( s1, t );;
    gap&#62; s2:= CharacterTable( "L2(64).6" );;
    gap&#62; pi2:= PossiblePermutationCharacters( s2, t );;
    gap&#62; prim:= Concatenation( pi1, pi2 );;  Length( prim );
    2

</pre>

<div class="p"><!----></div>
Now statement&nbsp;(a) follows from the fact that &#960;<sub>1</sub>(s) = &#960;<sub>2</sub>(s) = 1 holds.

<div class="p"><!----></div>

<pre>
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 65 );;
    gap&#62; List( prim, x -&#62; x[ spos ] );
    [ 1, 1 ]

</pre>

<div class="p"><!----></div>
For statement&nbsp;(b), we compute &#963;(S,s);
note that we have to consider only classes inside S = G<sup>&#8242;</sup>.

<div class="p"><!----></div>

<pre>
    gap&#62; approx:= ApproxP( prim, spos );;
    gap&#62; Maximum( approx{ ClassPositionsOfDerivedSubgroup( t ) } );
    1/1023

</pre>

<div class="p"><!----></div>
Statement&nbsp;(c) follows from the values on the outer involution classes.

<div class="p"><!----></div>

<pre>
    gap&#62; Maximum( approx{ Difference(
    &#62;      PositionsProperty( OrdersClassRepresentatives( t ), IsPrimeInt ),
    &#62;      ClassPositionsOfDerivedSubgroup( t ) ) } );
    1/347820

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.10">
4.10</a>&nbsp;&nbsp;S<sub>6</sub>(4)</h3><a name="S64">
</a>

<div class="p"><!----></div>
We show that S = S<sub>6</sub>(4) = <span class="roman">Sp</span>(6,4) satisfies the following.

<ol type="1">
<br />(a)
    For s  &#8712; S irreducible of order 65,
    <font face="helvetica"><i>M</i></font>(S,s) consists of two groups of the types
    U<sub>4</sub>(4).2 = &#8486;<sup>&#8722;</sup>(6,4).2 and L<sub>2</sub>(64).3 = <span class="roman">Sp</span>(2,64).3,
    respectively.
<br />(b)
    &#963;(S,s) = 16/63.
<br />(c)
    &#963;<sup>&#8242;</sup>(<span class="roman">Aut</span>(S),s) = 0.</ol>

<div class="p"><!----></div>
By&nbsp;[<a href="#Be00" name="CITEBe00">Ber00</a>], the element s is contained in maximal
subgroups of the given types,
and by&nbsp;[<a href="#KlL90" name="CITEKlL90">KL90</a>,Prop.&nbsp;4.3.10, 4.8.6],
there is exactly one class of these subgroups.

<div class="p"><!----></div>
The character tables of these two subgroups are currently not contained
in the <font face="helvetica">GAP</font> Character Table Library.
We compute the permutation character induced from the first subgroup
as the  unique character of the right degree that is combinatorially
possible (cf.&nbsp;[<a href="#BP98copy" name="CITEBP98copy">BP98</a>]).

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "S6(4)" );;
    gap&#62; degree:= Size( t ) / ( 2 * Size( CharacterTable( "U4(4)" ) ) );;
    gap&#62; pi1:= PermChars( t, rec( torso:= [ degree ] ) );;
    gap&#62; Length( pi1 );
    1

</pre>

<div class="p"><!----></div>
The index of the second subgroup is too large for this simpleminded
approach;
therefore, we first restrict the set of possible irreducible constituents
of the permutation character to those of 1<sub>H</sub><sup>G</sup>,
where H is the derived subgroup of L<sub>2</sub>(64).3,
for which the character table is available.

<div class="p"><!----></div>

<pre>
    gap&#62; CharacterTable( "L2(64).3" );  CharacterTable( "U4(4).2" );
    fail
    fail
    gap&#62; s:= CharacterTable( "L2(64)" );;
    gap&#62; subpi:= PossiblePermutationCharacters( s, t );;
    gap&#62; Length( subpi );
    1
    gap&#62; scp:= MatScalarProducts( t, Irr( t ), subpi );;
    gap&#62; nonzero:= PositionsProperty( scp[1], x -&#62; x &lt;&#62; 0 );
    [ 1, 11, 13, 14, 17, 18, 32, 33, 56, 58, 59, 73, 74, 77, 78, 79, 80, 93, 95, 
      96, 103, 116, 117, 119, 120 ]
    gap&#62; const:= RationalizedMat( Irr( t ){ nonzero } );;
    gap&#62; degree:= Size( t ) / ( 3 * Size( s ) );
    5222400
    gap&#62; pi2:= PermChars( t, rec( torso:= [ degree ], chars:= const ) );;
    gap&#62; Length( pi2 );
    1
    gap&#62; prim:= Concatenation( pi1, pi2 );;

</pre>

<div class="p"><!----></div>
Now statement&nbsp;(a) follows from the fact that &#960;<sub>1</sub>(s) = &#960;<sub>2</sub>(s) = 1 holds.

<div class="p"><!----></div>

<pre>
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 65 );;
    gap&#62; List( prim, x -&#62; x[ spos ] );
    [ 1, 1 ]

</pre>

<div class="p"><!----></div>
For statement&nbsp;(b), we compute &#963;(G,s).

<div class="p"><!----></div>

<pre>
    gap&#62; Maximum( ApproxP( prim, spos ) );
    16/63

</pre>

<div class="p"><!----></div>
In order to prove statement&nbsp;(c), we have to consider only the extensions
of the above permutation characters of S to <span class="roman">Aut</span>(S)  &#8773; S.2
(cf.&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Section&nbsp;2.2]).

<div class="p"><!----></div>

<pre>
    gap&#62; t2:= CharacterTable( "S6(4).2" );;
    gap&#62; tfust2:= GetFusionMap( t, t2 );;
    gap&#62; cand:= List( prim, x -&#62; CompositionMaps( x, InverseMap( tfust2 ) ) );;
    gap&#62; ext:= List( cand, pi -&#62; PermChars( t2, rec( torso:= pi ) ) );
    [ [ Character( CharacterTable( "S6(4).2" ), [ 2016, 512, 96, 128, 32, 120, 0, 
              6, 16, 40, 24, 0, 8, 136, 1, 6, 6, 1, 32, 0, 8, 6, 2, 0, 2, 0, 0, 
              4, 0, 16, 32, 1, 8, 2, 6, 2, 1, 2, 4, 0, 0, 1, 6, 0, 1, 10, 0, 1, 
              1, 0, 10, 10, 4, 0, 1, 0, 2, 0, 2, 1, 2, 2, 1, 1, 0, 0, 0, 1, 1, 1, 
              1, 0, 0, 0, 0, 0, 32, 0, 0, 8, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 8, 0, 
              0, 0, 2, 2, 0, 2, 2, 0, 2, 2, 2, 0, 0 ] ) ], 
      [ Character( CharacterTable( "S6(4).2" ), [ 5222400, 0, 0, 0, 1280, 0, 960, 
              120, 0, 0, 0, 0, 0, 0, 1600, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1, 0, 0, 
              15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 10, 0, 
              0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 
              0, 0, 0, 960, 0, 0, 0, 16, 0, 24, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
              0, 0, 4, 1, 0, 0, 3, 0, 0, 0, 0, 0 ] ) ] ]
    gap&#62; spos2:= Position( OrdersClassRepresentatives( t2 ), 65 );;
    gap&#62; sigma:= ApproxP( Concatenation( ext ), spos2 );;
    gap&#62; Maximum( approx{ Difference(
    &#62;      PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),
    &#62;      ClassPositionsOfDerivedSubgroup( t2 ) ) } );
    0

</pre>

<div class="p"><!----></div>
For the simple group, we can <em>alternatively</em> consider a reducible
element s: 2 &#8869;4 of order 85,
which is a multiple of the primitive prime divisor r = 17 of 4<sup>4</sup>&#8722;1.
So we have e = 4, d = 6, and q = 4, in the terminology of&nbsp;[<a href="#GPPS" name="CITEGPPS">GPPS99</a>].
Then <font face="helvetica"><i>M</i></font>(S,s) consists of two groups, of the types
&#8486;<sup>+</sup>(6,4).2  &#8773; L<sub>4</sub>(4).2<sub>2</sub> and <span class="roman">Sp</span>(2,4) &times;<span class="roman">Sp</span>(4,4).
This can be shown by checking&nbsp;[<a href="#GPPS" name="CITEGPPS">GPPS99</a>,Ex.&nbsp;2.1-2.9].
Ex.&nbsp;2.1 yields the candidates &#8486;<sup>&#177;</sup>(6,4).2,
but only &#8486;<sup>+</sup>(6,4).2 contains elements of order 85.
Ex.&nbsp;2.2 yields the stabilizer of a two-dimensional subspace,
which has the structure <span class="roman">Sp</span>(2,4) &times;<span class="roman">Sp</span>(4,4), by&nbsp;[<a href="#KlL90" name="CITEKlL90">KL90</a>].
All other cases except Ex.&nbsp;2.4&nbsp;(b) are excluded by the fact that r = 4e+1,
and Ex.&nbsp;2.4&nbsp;(b) does not apply because d/gcd(d,e) is odd.

<div class="p"><!----></div>

<pre>
    gap&#62; SigmaFromMaxes( CharacterTable( "S6(4)" ), "85A",
    &#62;    [ CharacterTable( "L4(4).2_2" ),
    &#62;      CharacterTable( "A5" ) * CharacterTable( "S4(4)" ) ], [ 1, 1 ] );
    142/455

</pre>

<div class="p"><!----></div>
This bound is not as good as the one obtained from the irreducible
element of order 65 used above.

<div class="p"><!----></div>

<pre>
    gap&#62; 16/63 &lt; 142/455;
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.11">
4.11</a>&nbsp;&nbsp;&#8727;&nbsp;S<sub>6</sub>(5)</h3><a name="S65">
</a>

<div class="p"><!----></div>
We show that S = S<sub>6</sub>(5) = <span class="roman">PSp</span>(6,5) satisfies the following.

<ol type="1">
<br />(a)
    For s  &#8712; S of the type 2 &#8869;4
    (i.&nbsp;e., the preimage of s in <span class="roman">Sp</span>(6,5) = 2.G decomposes
    the natural 6-dimensional module for
    <span class="roman">Sp</span>(6,5) into an orthogonal sum of two irreducible modules
    of the dimensions 2 and 4, respectively) and of order 78,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one group of the type
    G<sub>2</sub> = 2.(<span class="roman">PSp</span>(2,5) &times;<span class="roman">PSp</span>(4,5)).
<br />(b)
    &#963;(S,s) = 9/217.</ol>

<div class="p"><!----></div>
The order of s is a multiple of the primitive prime divisor r = 13
of 5<sup>4</sup>&#8722;1,
so we have e = 4, d = 6, and q = 5, in the terminology of&nbsp;[<a href="#GPPS" name="CITEGPPS">GPPS99</a>].
We check&nbsp;[<a href="#GPPS" name="CITEGPPS">GPPS99</a>,Ex.&nbsp;2.1-2.9].
Ex.&nbsp;2.1 does not apply because the classes <font face="helvetica"><i>C</i></font><sub>5</sub> and <font face="helvetica"><i>C</i></font><sub>8</sub>
are empty by&nbsp;[<a href="#KlL90" name="CITEKlL90">KL90</a>,Table&nbsp;3.5.C],
Ex.&nbsp;2.2 yields exactly the stabilizer G<sub>2</sub> of a 2-dimensional subspace,
Ex.&nbsp;2.4&nbsp;(b) does not apply because d/gcd(d,e) is odd,
and all other cases are excluded by the fact that r = 3e+1.

<div class="p"><!----></div>
The group G<sub>2</sub> has the structure 2.(<span class="roman">PSp</span>(2,5) &times;<span class="roman">PSp</span>(4,5)),
which is a central product of <span class="roman">Sp</span>(2,5)  &#8773; 2.A<sub>5</sub> and <span class="roman">Sp</span>(4,5) = 2.S<sub>4</sub>(5)
(see&nbsp;[<a href="#KlL90" name="CITEKlL90">KL90</a>,Prop.&nbsp;4.1.3]).
The character table of G<sub>2</sub> can be derived from that of the direct product
of 2.A<sub>5</sub> and 2.S<sub>4</sub>(5),
by factoring out the diagonal central subgroup of order two.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "S6(5)" );;
    gap&#62; s1:= CharacterTable( "2.A5" );;
    gap&#62; s2:= CharacterTable( "2.S4(5)" );;
    gap&#62; dp:= s1 * s2;
    CharacterTable( "2.A5x2.S4(5)" )
    gap&#62; c:= Difference( ClassPositionsOfCentre( dp ), Union(
    &#62;                        GetFusionMap( s1, dp ), GetFusionMap( s2, dp ) ) );
    [ 62 ]
    gap&#62; s:= dp / c;
    CharacterTable( "2.A5x2.S4(5)/[ 1, 62 ]" )

</pre>

<div class="p"><!----></div>
Now we compute &#963;(S,s).

<div class="p"><!----></div>

<pre>
    gap&#62; SigmaFromMaxes( t, "78A", [ s ], [ 1 ] );
    9/217

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.12">
4.12</a>&nbsp;&nbsp;S<sub>8</sub>(3)</h3><a name="S83">
</a>

<div class="p"><!----></div>
We show that S = S<sub>8</sub>(3) = <span class="roman">PSp</span>(8,3) satisfies the following.

<ol type="1">
<br />(a)
    For s  &#8712; S irreducible of order 41,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one group M of the type
    S<sub>4</sub>(9).2 = <span class="roman">PSp</span>(4,9).2.
<br />(b)
    &#963;(S,s) = 1/546.
<br />(c)
    The preimage of s in the matrix group 2.S<sub>8</sub>(3) = <span class="roman">Sp</span>(8,3)
    can be chosen of order 82,
    and the preimage of M is 2.S<sub>4</sub>(9).2 = <span class="roman">Sp</span>(4,9).2.</ol>

<div class="p"><!----></div>
By&nbsp;[<a href="#Be00" name="CITEBe00">Ber00</a>], the only maximal subgroups of S that contain irreducible
elements of order (3<sup>4</sup>+1)/2 = 41 are of extension field type,
and by&nbsp;[<a href="#KlL90" name="CITEKlL90">KL90</a>,Prop.&nbsp;4.3.10], these groups have the structure S<sub>4</sub>(9).2
and there is exactly one class of these groups.

<div class="p"><!----></div>
The group U = S<sub>4</sub>(9) has three nontrivial outer automorphisms,
the character table of the subgroup U.2 in question has the identifier
<tt>"S4(9).2_1"</tt>,
which follows from the fact that the extensions of U by the other two
outer automorphisms do not admit a class fusion into S.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "S8(3)" );;
    gap&#62; pi:= List( [ "S4(9).2_1", "S4(9).2_2", "S4(9).2_3" ],
    &#62;               name -&#62; PossiblePermutationCharacters(
    &#62;                           CharacterTable( name ), t ) );;
    gap&#62; List( pi, Length );
    [ 1, 0, 0 ]

</pre>

<div class="p"><!----></div>
Now statement&nbsp;(a) follows from the fact that (1<sub>U.2</sub>)<sup>S</sup>(s) = 1 holds.

<div class="p"><!----></div>

<pre>
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 41 );;
    gap&#62; pi[1][1][ spos ];
    1

</pre>

<div class="p"><!----></div>
Now we compute &#963;(S,s) in order to show statement&nbsp;(b).

<div class="p"><!----></div>

<pre>
    gap&#62; Maximum( ApproxP( pi[1], spos ) );
    1/546

</pre>

<div class="p"><!----></div>
Statement&nbsp;(c) is clear from the description of extension field type
subgroups in&nbsp;[<a href="#KlL90" name="CITEKlL90">KL90</a>].

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.13">
4.13</a>&nbsp;&nbsp;U<sub>4</sub>(4)</h3><a name="U44">
</a>

<div class="p"><!----></div>
We show that S = U<sub>4</sub>(4) = <span class="roman">SU</span>(4,4) satisfies the following.

<ol type="1">
<br />(a)
    For s  &#8712; S of the type 1 &#8869;3
    (i.&nbsp;e., s decomposes the natural 4-dimensional module for
    <span class="roman">SU</span>(4,4) into an orthogonal sum of two irreducible modules
    of the dimensions 1 and 3, respectively) and of order 4<sup>3</sup>+1 = 65,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one group of the type
    G<sub>1</sub> = 5 &times;U<sub>3</sub>(4) = <span class="roman">GU</span>(3,4).
<br />(b)
    &#963;(S,s) = 209/3&nbsp;264.</ol>

<div class="p"><!----></div>
By&nbsp;[<a href="#MSW94" name="CITEMSW94">MSW94</a>], the only maximal subgroups of S that contain s
are one class of stabilizers H  &#8773; 5 &times;U<sub>3</sub>(4)
of this decomposition,
and clearly there is only one such group containing s.

<div class="p"><!----></div>
Note that H has index 3&nbsp;264 in S,
since S has two orbits on the 1-dimensional subspaces,
of lengths 1&nbsp;105 and 3&nbsp;264, respectively,
and elements of order 13 = 65/5 lie in the stabilizers of points
in the latter orbit.

<div class="p"><!----></div>

<pre>
    gap&#62; g:= SU(4,4);;
    gap&#62; orbs:= Orbits( g, NormedRowVectors( GF(16)^4 ), OnLines );;
    gap&#62; orblen:= List( orbs, Length );
    [ 1105, 3264 ]
    gap&#62; List( orblen, x -&#62; x mod 13 );
    [ 0, 1 ]

</pre>

<div class="p"><!----></div>
We compute the permutation character 1<sub>G<sub>1</sub></sub><sup>S</sup>;
there is exactly one combinatorially possible permutation character
of degree 3&nbsp;264 (cf.&nbsp;[<a href="#BP98copy" name="CITEBP98copy">BP98</a>]).

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "U4(4)" );;
    gap&#62; pi:= PermChars( t, rec( torso:= [ orblen[2] ] ) );;
    gap&#62; Length( pi );
    1

</pre>

<div class="p"><!----></div>
Now we compute &#963;(S,s).

<div class="p"><!----></div>

<pre>
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 65 );;
    gap&#62; Maximum( ApproxP( pi, spos ) );
    209/3264

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.14">
4.14</a>&nbsp;&nbsp;U<sub>6</sub>(2)</h3><a name="U62">
</a>

<div class="p"><!----></div>
We show that S = U<sub>6</sub>(2) = <span class="roman">PSU</span>(6,2) satisfies the following.

<ol type="1">
<br />(a)
    For s  &#8712; S of order 11,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one group of the type U<sub>5</sub>(2) = <span class="roman">SU</span>(5,2)
    and three groups of the type M<sub>22</sub>.
<br />(b)
    &#963;(S,s) = 5/21.
<br />(c)
    The preimage of s in the matrix group <span class="roman">SU</span>(6,2) = 3.U<sub>6</sub>(2)
    can be chosen of order 33,
    and the preimages of the groups in <font face="helvetica"><i>M</i></font>(S,s) have the structures
    3 &times;U<sub>5</sub>(2)  &#8773; <span class="roman">GU</span>(5,2) and 3.M<sub>22</sub>, respectively.
<br />(d)
    With s as in&nbsp;(a), the automorphic extensions S.2, S.3 of S
    satisfy &#963;<sup>&#8242;</sup>(S.2,s) = 5/96 and
    &#963;<sup>&#8242;</sup>(S.3,s) = 59/224.</ol>

<div class="p"><!----></div>
According to the list of maximal subgroups of S in&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;115],
s is contained exactly in maximal subgroups of the types U<sub>5</sub>(2)
(one class) and M<sub>22</sub> (three classes).

<div class="p"><!----></div>
The permutation character of the action on the cosets of U<sub>5</sub>(2) type
subgroups is uniquely determined by the character tables.
We get three possibilities for the permutation character on the cosets of
M<sub>22</sub> type subgroups; they correspond to the three classes of such
subgroups, because each of these classes contains elements in exactly one
of the conjugacy classes <tt>4C</tt>, <tt>4D</tt>, and <tt>4E</tt> of elements in
S, and these classes are fused under the outer automorphism of S
of order three.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "U6(2)" );;
    gap&#62; s1:= CharacterTable( "U5(2)" );;
    gap&#62; pi1:= PossiblePermutationCharacters( s1, t );;
    gap&#62; Length( pi1 );
    1
    gap&#62; s2:= CharacterTable( "M22" );;
    gap&#62; pi2:= PossiblePermutationCharacters( s2, t );
    [ Character( CharacterTable( "U6(2)" ), [ 20736, 0, 384, 0, 0, 0, 54, 0, 0, 
          0, 0, 48, 0, 16, 6, 0, 0, 0, 0, 0, 0, 6, 0, 2, 0, 0, 0, 4, 0, 0, 0, 0, 
          1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] ), 
      Character( CharacterTable( "U6(2)" ), [ 20736, 0, 384, 0, 0, 0, 54, 0, 0, 
          0, 48, 0, 0, 16, 6, 0, 0, 0, 0, 0, 0, 6, 0, 2, 0, 0, 4, 0, 0, 0, 0, 0, 
          1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] ), 
      Character( CharacterTable( "U6(2)" ), [ 20736, 0, 384, 0, 0, 0, 54, 0, 0, 
          48, 0, 0, 0, 16, 6, 0, 0, 0, 0, 0, 0, 6, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 
          1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] ) ]
    gap&#62; imgs:= Set( List( pi2, x -&#62; Position( x, 48 ) ) );
    [ 10, 11, 12 ]
    gap&#62; AtlasClassNames( t ){ imgs };
    [ "4C", "4D", "4E" ]
    gap&#62; GetFusionMap( t, CharacterTable( "U6(2).3" ) ){ imgs };
    [ 10, 10, 10 ]
    gap&#62; prim:= Concatenation( pi1, pi2 );;

</pre>

<div class="p"><!----></div>
Now statement&nbsp;(a) follows from the fact that the permutation characters
have the value 1 on s.

<div class="p"><!----></div>

<pre>
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 11 );;
    gap&#62; List( prim, x -&#62; x[ spos ] );
    [ 1, 1, 1, 1 ]

</pre>

<div class="p"><!----></div>
For statement&nbsp;(b), we compute &#963;(S,s).

<div class="p"><!----></div>

<pre>
    gap&#62; Maximum( ApproxP( prim, spos ) );
    5/21

</pre>

<div class="p"><!----></div>
Statement&nbsp;(c) follows from&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>],
plus the information that 3.U<sub>6</sub>(2) does not contain groups of the structure
3 &times;M<sub>22</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; PossibleClassFusions(
    &#62;        CharacterTable( "Cyclic", 3 ) * CharacterTable( "M22" ),
    &#62;        CharacterTable( "3.U6(2)" ) );
    [  ]

</pre>

<div class="p"><!----></div>
For statement&nbsp;(d), we need that the relevant maximal subgroups of
S.2 are U<sub>5</sub>(2).2 and one subgroup M<sub>22</sub>.2,
and that the relevant maximal subgroup of S.3 is U<sub>5</sub>(2) &times;3,
see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;115].

<div class="p"><!----></div>

<pre>
    gap&#62; SigmaFromMaxes( CharacterTable( "U6(2).2" ), "11AB",
    &#62;        [ CharacterTable( "U5(2).2" ), CharacterTable( "M22.2" ) ],
    &#62;        [ 1, 1 ], "outer" );
    5/96
    gap&#62; SigmaFromMaxes( CharacterTable( "U6(2).3" ), "11A",
    &#62;        [ CharacterTable( "U5(2)" ) * CharacterTable( "Cyclic", 3 ) ],
    &#62;        [ 1 ], "outer" );
    59/224

</pre>

<div class="p"><!----></div>

 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Computations using Groups</h2><a name="hard">
</a>

<div class="p"><!----></div>
Before we start the computations using groups, we clean the workspace.

<div class="p"><!----></div>

<pre>
    gap&#62; CleanWorkspace();

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;A<sub>2m+1</sub>, 2  &#8804; m  &#8804; 11</h3><a name="Aodd">
</a>

<div class="p"><!----></div>
For alternating groups of odd degree n = 2m+1,
we choose s to be an n-cycle.
The interesting cases in&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Proposition&nbsp;6.7] are 5  &#8804; n  &#8804; 23.

<div class="p"><!----></div>
In each case, we compute representatives of the maximal subgroups of A<sub>n</sub>,
consider only those that contain an n-cycle, and then compute the
permutation characters.
Additionally, we show also the names that are used for the subgroups in
the <font face="helvetica">GAP</font> Library of Transitive Groups,
see&nbsp;[<a href="#HulpkeTG" name="CITEHulpkeTG">Hul05</a>]
and the documentation of this library in the <font face="helvetica">GAP</font> Reference Manual.

<div class="p"><!----></div>

<pre>
    gap&#62; PrimitivesInfoForOddDegreeAlternatingGroup:= function( n )
    &#62;     local G, max, cycle, spos, prim, nonz;
    &#62; 
    &#62;     G:= AlternatingGroup( n );
    &#62; 
    &#62;     # Compute representatives of the classes of maximal subgroups.
    &#62;     max:= MaximalSubgroupClassReps( G );
    &#62; 
    &#62;     # Omit subgroups that cannot contain an `n'-cycle.
    &#62;     max:= Filtered( max, m -&#62; IsTransitive( m, [ 1 .. n ] ) );
    &#62; 
    &#62;     # Compute the permutation characters.
    &#62;     cycle:= [];
    &#62;     cycle[ n-1 ]:= 1;
    &#62;     spos:= PositionProperty( ConjugacyClasses( CharacterTable( G ) ),
    &#62;                c -&#62; CycleStructurePerm( Representative( c ) ) = cycle );
    &#62;     prim:= List( max, m -&#62; TrivialCharacter( m )^G );
    &#62;     nonz:= PositionsProperty( prim, x -&#62; x[ spos ] &lt;&#62; 0 );
    &#62; 
    &#62;     # Compute the subgroup names and the multiplicities.
    &#62;     return rec( spos := spos,
    &#62;                 prim := prim{ nonz },
    &#62;                 grps := List( max{ nonz },
    &#62;                               m -&#62; TransitiveGroup( n,
    &#62;                                        TransitiveIdentification( m ) ) ),
    &#62;                 mult := List( prim{ nonz }, x -&#62; x[ spos ] ) );
    &#62; end;;

</pre>

<div class="p"><!----></div>
The sets <font face="helvetica"><i>M</i></font>/&#160;&#8764;&#160;(s) and the values &#963;(A<sub>n</sub>,s) are as follows.
For each degree in question, the first list shows names for representatives
of the conjugacy classes of maximal subgroups containing a fixed n-cycle,
and the second list shows the number of conjugates in each class.

<div class="p"><!----></div>

<pre>
    gap&#62; for n in [ 5, 7 .. 23 ] do
    &#62;      prim:= PrimitivesInfoForOddDegreeAlternatingGroup( n );
    &#62;      bound:= Maximum( ApproxP( prim.prim, prim.spos ) );
    &#62;      Print( n, ": ", prim.grps, ", ", prim.mult, ", ", bound, "\n" );
    &#62; od;
    5: [ D(5) = 5:2 ], [ 1 ], 1/3
    7: [ L(7) = L(3,2), L(7) = L(3,2) ], [ 1, 1 ], 2/5
    9: [ 1/2[S(3)^3]S(3), L(9):3=P|L(2,8) ], [ 1, 3 ], 9/35
    11: [ M(11), M(11) ], [ 1, 1 ], 2/105
    13: [ F_78(13)=13:6, L(13)=PSL(3,3), L(13)=PSL(3,3) ], [ 1, 2, 2 ], 4/1155
    15: [ 1/2[S(3)^5]S(5), 1/2[S(5)^3]S(3), L(15)=A_8(15)=PSL(4,2), 
      L(15)=A_8(15)=PSL(4,2) ], [ 1, 1, 1, 1 ], 29/273
    17: [ L(17):4=PYL(2,16), L(17):4=PYL(2,16) ], [ 1, 1 ], 2/135135
    19: [ F_171(19)=19:9 ], [ 1 ], 1/6098892800
    21: [ t21n150, t21n161, t21n91 ], [ 1, 1, 2 ], 29/285
    23: [ M(23), M(23) ], [ 1, 1 ], 2/130945815

</pre>

<div class="p"><!----></div>
In the above output,
a subgroup printed as <tt>1/2[S(</tt>n<sub>1</sub><tt>)^</tt>n<sub>2</sub><tt>]S(</tt>n<sub>2</sub><tt>)</tt>,
where n = n<sub>1</sub> n<sub>2</sub> holds, denotes the intersection of A<sub>n</sub> with the
wreath product

 S<sub>n<sub>1</sub></sub> &#8768; S<sub>n<sub>2</sub></sub>  &#8804; S<sub>n</sub>.
(Note that the <font face="helvetica">ATLAS</font> denotes the subgroup <tt>1/2[S(3)^3]S(3)</tt> of A<sub>9</sub>
as 3<sup>3</sup>:S<sub>4</sub>.)
The groups printed as <tt>P|L(2,8)</tt> and <tt>PYL(2,16)</tt> denote
<span class="roman">P</span>&#915;<span class="roman">L</span>(2,8) and <span class="roman">P</span>&#915;<span class="roman">L</span>(2,16), respectively.
And the three subgroups of A<sub>21</sub> have the structures

 (S<sub>3</sub> &#8768; S<sub>7</sub>) &#8745;A<sub>21</sub>,
 (S<sub>7</sub> &#8768; S<sub>3</sub>) &#8745;A<sub>21</sub>,
and <span class="roman">PGL</span>(3,4), respectively.

<div class="p"><!----></div>
Note that A<sub>9</sub> contains two conjugacy classes of maximal subgroups of
the type <span class="roman">P</span>&#915;<span class="roman">L</span>(2,8)  &#8773; L<sub>2</sub>(8):3, and that each 9-cycle in A<sub>9</sub>
is contained in exactly three <em>conjugate</em> subgroups of this type.
For n  &#8712; { 13, 15, 17 }, A<sub>n</sub> contains two conjugacy classes of
isomorphic maximal subgroups of linear type, and each n-cycle is contained
in subgroups from each class.
Finally, A<sub>21</sub> contains only one class of maximal subgroups of linear type.

<div class="p"><!----></div>
For the two groups A<sub>5</sub> and A<sub>7</sub>,
the values computed above are not sufficient.
See Section&nbsp;<a href="#A5">5.2</a> and&nbsp;<a href="#A7">5.4</a> for a further treatment.

<div class="p"><!----></div>
The above computations look like a brute-force approach,
but note that the computation of the maximal subgroups of alternating
and symmetric groups in <font face="helvetica">GAP</font> uses the classification of these
subgroups, and also the conjugacy classes of elements in alternating and
symmetric groups can be computed cheaply.

<div class="p"><!----></div>
Alternative (character-theoretic) computations
for n  &#8712; { 5, 7, 9, 11, 13 } were shown in Section&nbsp;<a href="#easyloop">4.3</a>.
(A hand calculation for the case n = 19 can be found in&nbsp;[<a href="#BW1" name="CITEBW1">BW75</a>].)

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;A<sub>5</sub></h3><a name="A5">
</a>

<div class="p"><!----></div>
We show that S = A<sub>5</sub> satisfies the following.

<ol type="1">
<br />(a)
    &#963;(S) = 1/3,
    and this value is attained exactly for &#963;(S,s)
    with s of order 5.
<br />(b)
    For s  &#8712; S of order 5,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one group of the type D<sub>10</sub>.
<br />(c)
    P(S) = 1/3,
    and this value is attained exactly for P(S,s)
    with s of order 5.
<br />(d)
    Each element in S together with one of
    (1,2)(3,4), (1,3)(2,4), (1,4)(2,3)
    generates a proper subgroup of S.
<br />(e)
    Both the spread and the uniform spread of S is exactly two
    (see&nbsp;[<a href="#BW1" name="CITEBW1">BW75</a>]),
    with s of order 5.</ol>

<div class="p"><!----></div>
Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<a href="#easyloop">4.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "A5" );;
    gap&#62; ProbGenInfoSimple( t );
    [ "A5", 1/3, 2, [ "5A" ], [ 1 ] ]

</pre>

<div class="p"><!----></div>
Statement&nbsp;(b) can be read off from the primitive permutation characters,
and the fact that the unique class of maximal subgroups that contain
elements of order 5 consists of groups of the structure D<sub>10</sub>,
see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;2].

<div class="p"><!----></div>

<pre>
    gap&#62; OrdersClassRepresentatives( t );
    [ 1, 2, 3, 5, 5 ]
    gap&#62; PrimitivePermutationCharacters( t );
    [ Character( CharacterTable( "A5" ), [ 5, 1, 2, 0, 0 ] ), 
      Character( CharacterTable( "A5" ), [ 6, 2, 0, 1, 1 ] ), 
      Character( CharacterTable( "A5" ), [ 10, 2, 1, 0, 0 ] ) ]

</pre>

<div class="p"><!----></div>
For statement&nbsp;(c), we compute that for all nonidentity elements s  &#8712; S
and involutions g  &#8712; S,
P(g,s)  &#8805; 1/3 holds,
with equality if and only if s has order 5.
We actually compute, for class representatives s,
the proportion of involutions g such that
&#9001;g, s &#9002; &#8800; S holds.

<div class="p"><!----></div>

<pre>
    gap&#62; g:= AlternatingGroup( 5 );;
    gap&#62; inv:= g.1^2 * g.2;
    (1,4)(2,5)
    gap&#62; cclreps:= List( ConjugacyClasses( g ), Representative );;
    gap&#62; SortParallel( List( cclreps, Order ), cclreps );
    gap&#62; List( cclreps, Order );
    [ 1, 2, 3, 5, 5 ]
    gap&#62; Size( ConjugacyClass( g, inv ) );
    15
    gap&#62; prop:= List( cclreps,
    &#62;                 r -&#62; RatioOfNongenerationTransPermGroup( g, inv, r ) );
    [ 1, 1, 3/5, 1/3, 1/3 ]
    gap&#62; Minimum( prop );
    1/3

</pre>

<div class="p"><!----></div>
Statement&nbsp;(d) follows by explicit computations.

<div class="p"><!----></div>

<pre>
    gap&#62; triple:= [ (1,2)(3,4), (1,3)(2,4), (1,4)(2,3) ];;
    gap&#62; CommonGeneratorWithGivenElements( g, cclreps, triple );
    fail

</pre>

<div class="p"><!----></div>
As for statement&nbsp;(e), we know from&nbsp;(a) that the uniform spread of S
is at least two, and from&nbsp;(d) that the spread is less than three.

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.3">
5.3</a>&nbsp;&nbsp;A<sub>6</sub></h3><a name="A6">
</a>

<div class="p"><!----></div>
We show that S = A<sub>6</sub> satisfies the following.

<ol type="1">
<br />(a)
    &#963;(S) = 2/3,
    and this value is attained exactly for &#963;(S,s)
    with s of order 5.
<br />(b)
    For s of order 5,
    <font face="helvetica"><i>M</i></font>(S,s) consists of two nonconjugate groups of the type A<sub>5</sub>.
<br />(c)
    P(S) = 5/9,
    and this value is attained exactly for P(S,s)
    with s of order 5.
<br />(d)
    Each element in S together with one of
    (1,2)(3,4), (1,3)(2,4), (1,4)(2,3)
    generates a proper subgroup of S.
<br />(e)
    Both the spread and the uniform spread of S is exactly two
    (see&nbsp;[<a href="#BW1" name="CITEBW1">BW75</a>]),
    with s of order 4.
<br />(f)
    For x, y  &#8712; S<sub>6</sub><sup>&times;</sup>, there is s  &#8712; S<sub>6</sub>
    such that S  &#8838; &#9001;x, s &#9002;&#8745;&#9001;y, s &#9002;.
    It is <em>not</em> possible to find s  &#8712; S with this property,
    or s in a prescribed conjugacy class of S<sub>6</sub>.
<br />(g)
    &#963;( <span class="roman">PGL</span>(2,9) ) = 1/6 and &#963;( M<sub>10</sub> ) = 1/9,
    with s of order 10 and 8, respectively.</ol>

<div class="p"><!----></div>
(Note that in this example, the optimal choice of s for P(S) cannot be
used to obtain the result on the exact spread.)

<div class="p"><!----></div>
Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<a href="#easyloop">4.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "A6" );;
    gap&#62; ProbGenInfoSimple( t );
    [ "A6", 2/3, 1, [ "5A" ], [ 2 ] ]

</pre>

<div class="p"><!----></div>
Statement&nbsp;(b) can be read off from the permutation characters,
and the fact that the two classes of maximal subgroups that contain
elements of order 5 consist of groups of the structure A<sub>5</sub>,
see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;4].

<div class="p"><!----></div>

<pre>
    gap&#62; OrdersClassRepresentatives( t );
    [ 1, 2, 3, 3, 4, 5, 5 ]
    gap&#62; prim:= PrimitivePermutationCharacters( t );
    [ Character( CharacterTable( "A6" ), [ 6, 2, 3, 0, 0, 1, 1 ] ), 
      Character( CharacterTable( "A6" ), [ 6, 2, 0, 3, 0, 1, 1 ] ), 
      Character( CharacterTable( "A6" ), [ 10, 2, 1, 1, 2, 0, 0 ] ), 
      Character( CharacterTable( "A6" ), [ 15, 3, 3, 0, 1, 0, 0 ] ), 
      Character( CharacterTable( "A6" ), [ 15, 3, 0, 3, 1, 0, 0 ] ) ]

</pre>

<div class="p"><!----></div>
For statement&nbsp;(c),
we first compute that for all nonidentity elements s  &#8712; S
and involutions g  &#8712; S,
P(g,s)  &#8805; 5/9 holds,
with equality if and only if s has order 5.
We actually compute, for class representatives s,
the proportion of involutions g such that
&#9001;g, s &#9002; &#8800; S holds.

<div class="p"><!----></div>

<pre>
    gap&#62; S:= AlternatingGroup( 6 );;
    gap&#62; inv:= (S.1*S.2)^2;
    (1,3)(2,5)
    gap&#62; cclreps:= List( ConjugacyClasses( S ), Representative );;
    gap&#62; SortParallel( List( cclreps, Order ), cclreps );
    gap&#62; List( cclreps, Order );
    [ 1, 2, 3, 3, 4, 5, 5 ]
    gap&#62; C:= ConjugacyClass( S, inv );;
    gap&#62; Size( C );
    45
    gap&#62; prop:= List( cclreps,
    &#62;                 r -&#62; RatioOfNongenerationTransPermGroup( S, inv, r ) );
    [ 1, 1, 1, 1, 29/45, 5/9, 5/9 ]
    gap&#62; Minimum( prop );
    5/9

</pre>

<div class="p"><!----></div>
Now statement&nbsp;(c) follows from the fact that for g  &#8712; S of order larger
than two, &#963;(S,g)  &#8804; 1/2  &lt;  5/9 holds.

<div class="p"><!----></div>

<pre>
    gap&#62; ApproxP( prim, 6 );
    [ 0, 2/3, 1/2, 1/2, 0, 1/3, 1/3 ]

</pre>

<div class="p"><!----></div>
Statement&nbsp;(d) follows by explicit computations.

<div class="p"><!----></div>

<pre>
    gap&#62; triple:= [ (1,2)(3,4), (1,3)(2,4), (1,4)(2,3) ];;
    gap&#62; CommonGeneratorWithGivenElements( S, cclreps, triple );
    fail

</pre>

<div class="p"><!----></div>
An alternative triple to that in statement&nbsp;(d) is the one given
in&nbsp;[<a href="#BW1" name="CITEBW1">BW75</a>].

<div class="p"><!----></div>

<pre>
    gap&#62; triple:= [ (1,3)(2,4), (1,5)(2,6), (3,6)(4,5) ];;
    gap&#62; CommonGeneratorWithGivenElements( S, cclreps, triple );
    fail

</pre>

<div class="p"><!----></div>
Of course we can also construct such a triple, as follows.

<div class="p"><!----></div>

<pre>
    gap&#62; TripleWithProperty( [ [ inv ], C, C ],
    &#62;        l -&#62; ForAll( S, elm -&#62;
    &#62;   ForAny( l, x -&#62; not IsGeneratorsOfTransPermGroup( S, [ elm, x ] ) ) ) );
    [ (1,3)(2,5), (1,3)(2,6), (1,3)(2,4) ]

</pre>

<div class="p"><!----></div>
For statement&nbsp;(e), we use the random approach described in
Section&nbsp;<a href="#groups">3.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; s:= (1,2,3,4)(5,6);;
    gap&#62; reps:= Filtered( cclreps, x -&#62; Order( x ) &#62; 1 );;
    gap&#62; ResetGlobalRandomNumberGenerators();
    gap&#62; for pair in UnorderedTuples( reps, 2 ) do
    &#62;      if RandomCheckUniformSpread( S, pair, s, 40 ) &lt;&#62; true then
    &#62;        Print( "#E  nongeneration!\n" );
    &#62;      fi;
    &#62;    od;

</pre>

<div class="p"><!----></div>
We get no output, so a suitable element of order 4 works in all cases.
Note that we cannot use an element of order 5,
because it fixes a point in the natural permutation representation,
and we may take x<sub>1</sub> = (1,2,3) and x<sub>2</sub> = (4,5,6).
With this argument, only elements of order 4 and double 3-cycles
are possible choices for s, and the latter are excluded by the fact
that an outer automorphism maps the class of double s-cycles in A<sub>6</sub>
to the class of 3-cycles.
So no element in A<sub>6</sub> of order different from 4 works.

<div class="p"><!----></div>
Next we show statement&nbsp;(f).
Already in A<sub>6</sub>.2<sub>1</sub> = S<sub>6</sub>, elements s of order 4 do in general not work
because they do not generate with transpositions.

<div class="p"><!----></div>

<pre>
    gap&#62; G:= SymmetricGroup( 6 );;
    gap&#62; RatioOfNongenerationTransPermGroup( G, s, (1,2) );
    1

</pre>

<div class="p"><!----></div>
Also, choosing s from a prescribed conjugacy class of S<sub>6</sub> (that is,
also s outside A<sub>6</sub> is allowed) with the property that
A<sub>6</sub>  &#8838; &#9001;x, s &#9002;&#8745;&#9001;y, s &#9002;
is not possible.
Note that only 6-cycles are possible for s if x and y are commuting
transpositions, and -applying the outer automorphism-
no 6-cycle works for two commuting fixed-point free involutions.
(The group is small enough for a brute force test.)

<div class="p"><!----></div>

<pre>
    gap&#62; goods:= Filtered( Elements( G ),
    &#62;      s -&#62; IsGeneratorsOfTransPermGroup( G, [ s, (1,2) ] ) and
    &#62;           IsGeneratorsOfTransPermGroup( G, [ s, (3,4) ] ) );;
    gap&#62; Collected( List( goods, CycleStructurePerm ) );
    [ [ [ ,,,, 1 ], 24 ] ]
    gap&#62; goods:= Filtered( Elements( G ),
    &#62;      s -&#62; IsGeneratorsOfTransPermGroup( G, [ s, (1,2)(3,4)(5,6) ] ) and
    &#62;           IsGeneratorsOfTransPermGroup( G, [ s, (1,3)(2,4)(5,6) ] ) );;
    gap&#62; Collected( List( goods, CycleStructurePerm ) );
    [ [ [ 1, 1 ], 24 ] ]

</pre>

<div class="p"><!----></div>
However, for each pair of nonidentity element x, y  &#8712; S<sub>6</sub>,
there is s  &#8712; S<sub>6</sub> such that
&#9001;x, s &#9002; and &#9001;y, s &#9002; both contain A<sub>6</sub>.
(If s works for the pair (x,y) then s<sup>g</sup> works for (x<sup>g</sup>,y<sup>g</sup>),
so it is sufficient to consider only orbit representatives (x,y) under
the conjugation action of G on pairs.
Thus we check conjugacy class representatives x and, for fixed x,
representatives of orbits of C<sub>G</sub>(x) on the classes y<sup>G</sup>,
i.&nbsp;e., representatives of C<sub>G</sub>(y)-C<sub>G</sub>(x)-double cosets in G.
Moreover, clearly we can restrict the checks to elements x, y of
prime order.)

<div class="p"><!----></div>

<pre>
    gap&#62; Sgens:= GeneratorsOfGroup( S );;
    gap&#62; primord:= Filtered( List( ConjugacyClasses( G ), Representative ),
    &#62;                        x -&#62; IsPrimeInt( Order( x ) ) );;
    gap&#62; for x in primord do
    &#62;      for y in primord do
    &#62;        for pair in DoubleCosetRepsAndSizes( G, Centralizer( G, y ),
    &#62;                        Centralizer( G, x ) ) do
    &#62;          if not ForAny( G, s -&#62; IsSubset( Group( x,s ), S ) and 
    &#62;                                 IsSubset( Group( y^pair[1], s ), S ) ) then
    &#62;            Error( [ x, y ] );
    &#62;          fi;
    &#62;        od;
    &#62;      od;
    &#62;    od;

</pre>

<div class="p"><!----></div>
In other words, the spread of S<sub>6</sub> is 2 but the uniform spread of S<sub>6</sub>
is not 2 but only 1.

<div class="p"><!----></div>
We cannot always find s  &#8712; A<sub>6</sub> with the required property:
If x is a transposition then any s with S  &#8838; &#9001;x, s &#9002;
must be a 5-cycle.

<div class="p"><!----></div>

<pre>
    gap&#62; filt:= Filtered( S, s -&#62; IsSubset( Group( (1,2), s ), S ) );;
    gap&#62; Collected( List( filt, Order ) );
    [ [ 5, 48 ] ]

</pre>

<div class="p"><!----></div>
Moreover, clearly such s fixes one of the moved points of x,
so we may prescribe a transposition y  &#8800; x that commutes with x,
it satisfies S  &#8836; eq&#9001;y, s &#9002;.

<div class="p"><!----></div>
For the other two automorphic extensions A<sub>6</sub>.2<sub>2</sub> = <span class="roman">PGL</span>(2,9)
and A<sub>6</sub>.2<sub>3</sub> = M<sub>10</sub>,
we compute the character-theoretic bounds &#963;(A<sub>6</sub>.2<sub>2</sub>) = 1/6
and &#963;(A<sub>6</sub>.2<sub>3</sub>) = 1/9,
which shows statement&nbsp;(g).

<div class="p"><!----></div>

<pre>
    gap&#62; ProbGenInfoSimple( CharacterTable( "A6.2_2" ) );
    [ "A6.2_2", 1/6, 5, [ "10A" ], [ 1 ] ]
    gap&#62; ProbGenInfoSimple( CharacterTable( "A6.2_3" ) );
    [ "A6.2_3", 1/9, 8, [ "8C" ], [ 1 ] ]

</pre>

<div class="p"><!----></div>
Note that &#963;<sup>&#8242;</sup>( <span class="roman">PGL</span>(2,9), s ) = 1/6,
with s of order 5,
and &#963;<sup>&#8242;</sup>( M<sub>10</sub>, s ) = 0 for any s  &#8712; A<sub>6</sub>
since M<sub>10</sub> is a non-split extension of A<sub>6</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "A6" );;
    gap&#62; t2:= CharacterTable( "A6.2_2" );;
    gap&#62; spos:= PositionsProperty( OrdersClassRepresentatives( t ), x -&#62; x = 5 );;
    gap&#62; ProbGenInfoAlmostSimple( t, t2, spos );
    [ "A6.2_2", 1/6, [ "5A", "5B" ], [ 1, 1 ] ]

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.4">
5.4</a>&nbsp;&nbsp;A<sub>7</sub></h3><a name="A7">
</a>

<div class="p"><!----></div>
We show that S = A<sub>7</sub> satisfies the following.

<ol type="1">
<br />(a)
    &#963;(S) = 2/5,
    and this value is attained exactly for &#963;(S,s)
    with s of order 7.
<br />(b)
    For s of order 7,
    <font face="helvetica"><i>M</i></font>(S,s) consists of two nonconjugate subgroups of the type L<sub>2</sub>(7).
<br />(c)
    P(S) = 2/5,
    and this value is attained exactly for P(S,s)
    with s of order 7.
<br />(d)
    The uniform spread of S is exactly three,
    with s of order 7.</ol>

<div class="p"><!----></div>
Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<a href="#easyloop">4.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "A7" );;
    gap&#62; ProbGenInfoSimple( t );
    [ "A7", 2/5, 2, [ "7A" ], [ 2 ] ]

</pre>

<div class="p"><!----></div>
Statement&nbsp;(b) can be read off from the permutation characters,
and the fact that the two classes of maximal subgroups that contain
elements of order 7 consist of groups of the structure L<sub>2</sub>(7),
see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;10].

<div class="p"><!----></div>

<pre>
    gap&#62; OrdersClassRepresentatives( t );
    [ 1, 2, 3, 3, 4, 5, 6, 7, 7 ]
    gap&#62; prim:= PrimitivePermutationCharacters( t );
    [ Character( CharacterTable( "A7" ), [ 7, 3, 4, 1, 1, 2, 0, 0, 0 ] ), 
      Character( CharacterTable( "A7" ), [ 15, 3, 0, 3, 1, 0, 0, 1, 1 ] ), 
      Character( CharacterTable( "A7" ), [ 15, 3, 0, 3, 1, 0, 0, 1, 1 ] ), 
      Character( CharacterTable( "A7" ), [ 21, 5, 6, 0, 1, 1, 2, 0, 0 ] ), 
      Character( CharacterTable( "A7" ), [ 35, 7, 5, 2, 1, 0, 1, 0, 0 ] ) ]

</pre>

<div class="p"><!----></div>
For statement&nbsp;(c), we compute that for all nonidentity elements s  &#8712; S
and involutions g  &#8712; S,
P(g,s)  &#8805; 2/5 holds,
with equality if and only if s has order 7.
We actually compute, for class representatives s,
the proportion of involutions g such that
&#9001;g, s &#9002; &#8800; S holds.

<div class="p"><!----></div>

<pre>
    gap&#62; g:= AlternatingGroup( 7 );;
    gap&#62; inv:= (g.1^3*g.2)^3;
    (2,6)(3,7)
    gap&#62; ccl:= List( ConjugacyClasses( g ), Representative );;
    gap&#62; SortParallel( List( ccl, Order ), ccl );
    gap&#62; List( ccl, Order );
    [ 1, 2, 3, 3, 4, 5, 6, 7, 7 ]
    gap&#62; Size( ConjugacyClass( g, inv ) );
    105
    gap&#62; prop:= List( ccl, r -&#62; RatioOfNongenerationTransPermGroup( g, inv, r ) );
    [ 1, 1, 1, 1, 89/105, 17/21, 19/35, 2/5, 2/5 ]
    gap&#62; Minimum( prop );
    2/5

</pre>

<div class="p"><!----></div>
For statement&nbsp;(d),
we use the random approach described in Section&nbsp;<a href="#groups">3.3</a>.
By the character-theoretic bounds, it suffices to consider triples
of elements in the classes <tt>2A</tt> or <tt>3B</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; OrdersClassRepresentatives( t );
    [ 1, 2, 3, 3, 4, 5, 6, 7, 7 ]
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 7 );;
    gap&#62; SizesCentralizers( t );
    [ 2520, 24, 36, 9, 4, 5, 12, 7, 7 ]
    gap&#62; ApproxP( prim, spos );
    [ 0, 2/5, 0, 2/5, 2/15, 0, 0, 2/15, 2/15 ]
    gap&#62; s:= (1,2,3,4,5,6,7);;
    gap&#62; 3B:= (1,2,3)(4,5,6);;
    gap&#62; C3B:= ConjugacyClass( g, 3B );;
    gap&#62; Size( C3B );
    280
    gap&#62; ResetGlobalRandomNumberGenerators();
    gap&#62; for triple in UnorderedTuples( [ inv, 3B ], 3 ) do
    &#62;      if RandomCheckUniformSpread( g, triple, s, 80 ) &lt;&#62; true then
    &#62;        Print( "#E  nongeneration!\n" );
    &#62;      fi;
    &#62;    od;

</pre>

<div class="p"><!----></div>
We get no output, so the uniform spread of S is at least three.

<div class="p"><!----></div>
Alternatively, we can use Lemma&nbsp;<a href="#existsgoodconjugate">2.1</a>;
this approach is technically more involved but faster.
We work with the diagonal product of the two degree 15 representations
of S,
which is constructed from the information stored in the <font face="helvetica">GAP</font> Library
of Tables of Marks.

<div class="p"><!----></div>

<pre>
    gap&#62; tom:= TableOfMarks( "A7" );;
    gap&#62; a7:= UnderlyingGroup( tom );;
    gap&#62; tommaxes:= MaximalSubgroupsTom( tom );
    [ [ 39, 38, 37, 36, 35 ], [ 7, 15, 15, 21, 35 ] ]
    gap&#62; index15:= List( tommaxes[1]{ [ 2, 3 ] },
    &#62;                    i -&#62; RepresentativeTom( tom, i ) );
    [ Group([ (1,3)(2,7), (1,5,7)(3,4,6) ]), 
      Group([ (1,4)(2,3), (2,4,6)(3,5,7) ]) ]
    gap&#62; deg15:= List( index15, s -&#62; RightTransversal( a7, s ) );;
    gap&#62; reps:= List( deg15, l -&#62; Action( a7, l, OnRight ) );
    [ Group([ (1,5,7)(2,9,10)(3,11,4)(6,12,8)(13,14,15), 
          (1,8,15,5,12)(2,13,11,3,10)(4,14,9,7,6) ]), 
      Group([ (1,2,3)(4,6,5)(7,8,9)(10,12,11)(13,15,14), 
          (1,12,3,13,10)(2,9,15,4,11)(5,6,14,7,8) ]) ]
    gap&#62; g:= DiagonalProductOfPermGroups( reps );;
    gap&#62; ResetGlobalRandomNumberGenerators();
    gap&#62; repeat s:= Random( g );
    &#62;    until Order( s ) = 7;
    gap&#62; NrMovedPoints( s );
    28
    gap&#62; mpg:= MovedPoints( g );;
    gap&#62; fixs:= Difference( mpg, MovedPoints( s ) );;
    gap&#62; orb_s:= Orbit( g, fixs, OnSets );;
    gap&#62; Length( orb_s );
    120
    gap&#62; SizesCentralizers( t );
    [ 2520, 24, 36, 9, 4, 5, 12, 7, 7 ]
    gap&#62; repeat 2a:= Random( g ); until Order( 2a ) = 2;
    gap&#62; repeat 3b:= Random( g );
    &#62;    until Order( 3b ) = 3 and Size( Centralizer( g, 3b ) ) = 9;
    gap&#62; orb2a:= Orbit( g, Difference( mpg, MovedPoints( 2a ) ), OnSets );;
    gap&#62; orb3b:= Orbit( g, Difference( mpg, MovedPoints( 3b ) ), OnSets );;
    gap&#62; orb2aor3b:= Union( orb2a, orb3b );;
    gap&#62; TripleWithProperty( [ [ orb2a[1], orb3b[1] ], orb2aor3b, orb2aor3b ],
    &#62;        l -&#62; ForAll( orb_s,
    &#62;                 f -&#62; not IsEmpty( Intersection( Union( l ), f ) ) ) );
    fail

</pre>

<div class="p"><!----></div>
It remains to show that for any choice of s  &#8712; S,
a quadruple of elements in S<sup>&times;</sup> exists such that s generates
a proper subgroup of S together with at least one of these elements.

<div class="p"><!----></div>
First we observe (without using <font face="helvetica">GAP</font>) that there is a pair of 3-cycles
whose fixed points cover the seven points of the natural permutation
representation.
This implies the statement for all elements s  &#8712; S
that fix a point in this representation.
So it remains to consider elements s of the orders six and seven.

<div class="p"><!----></div>
For the order seven element, the above setup and
Lemma&nbsp;<a href="#existsgoodconjugate">2.1</a> can be used.

<div class="p"><!----></div>

<pre>
    gap&#62; QuadrupleWithProperty( [ [ orb2a[1] ], orb2a, orb2a, orb2a ],
    &#62;        l -&#62; ForAll( orb_s,
    &#62;                 f -&#62; not IsEmpty( Intersection( Union( l ), f ) ) ) );
    [ [ 2, 11, 15, 19, 24, 29 ], [ 4, 9, 13, 21, 22, 28 ], 
      [ 3, 10, 14, 20, 23, 30 ], [ 1, 5, 7, 25, 26, 27 ] ]

</pre>

<div class="p"><!----></div>
For the order six element, we use the diagonal product of the
primitive permutation representations of the degrees 21 and 35.

<div class="p"><!----></div>

<pre>
    gap&#62; has6A:= List( tommaxes[1]{ [ 4, 5 ] },
    &#62;                  i -&#62; RepresentativeTom( tom, i ) );
    [ Group([ (1,2)(3,7), (2,6,5,4)(3,7) ]), 
      Group([ (2,3)(5,7), (1,2)(4,5,6,7), (2,3)(5,6) ]) ]
    gap&#62; trans:= List( has6A, s -&#62; RightTransversal( a7, s ) );;
    gap&#62; reps:= List( trans, l -&#62; Action( a7, l, OnRight ) );
    [ Group([ (1,16,12)(2,17,13)(3,18,11)(4,19,14)(15,20,21), 
          (1,4,7,9,10)(2,5,8,3,6)(11,12,15,14,13)(16,20,19,17,18) ]), 
      Group([ (2,16,6)(3,17,7)(4,18,8)(5,19,9)(10,20,26)(11,21,27)(12,22,28)(13,
            23,29)(14,24,30)(15,25,31), (1,2,3,4,5)(6,10,13,15,9)(7,11,14,8,
            12)(16,20,23,25,19)(17,21,24,18,22)(26,32,35,31,28)(27,33,29,34,30) 
         ]) ]
    gap&#62; g:= DiagonalProductOfPermGroups( reps );;
    gap&#62; repeat s:= Random( g );
    &#62;    until Order( s ) = 6;
    gap&#62; NrMovedPoints( s );
    53
    gap&#62; mpg:= MovedPoints( g );;
    gap&#62; fixs:= Difference( mpg, MovedPoints( s ) );;
    gap&#62; orb_s:= Orbit( g, fixs, OnSets );;
    gap&#62; Length( orb_s );
    105
    gap&#62; repeat 3a:= Random( g );
    &#62;    until Order( 3a ) = 3 and Size( Centralizer( g, 3a ) ) = 36;
    gap&#62; orb3a:= Orbit( g, Difference( mpg, MovedPoints( 3a ) ), OnSets );;
    gap&#62; Length( orb3a );
    35
    gap&#62; TripleWithProperty( [ [ orb3a[1] ], orb3a, orb3a ],
    &#62;        l -&#62; ForAll( orb_s,
    &#62;                 f -&#62; not IsEmpty( Intersection( Union( l ), f ) ) ) );
    [ [ 5, 7, 9, 17, 18, 19, 31, 32, 34, 40, 53 ], 
      [ 5, 7, 9, 11, 13, 14, 30, 41, 42, 44, 53 ], 
      [ 2, 3, 4, 5, 7, 9, 26, 47, 48, 50, 53 ] ]

</pre>

<div class="p"><!----></div>
So we have found not only a quadruple but even a triple of 3-cycles
that excludes candidates s of order six.

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.5">
5.5</a>&nbsp;&nbsp;L<sub>d</sub>(q)</h3><a name="SL">
</a>

<div class="p"><!----></div>
In the treatment of small dimensional linear groups S = <span class="roman">SL</span>(d,q),
[<a href="#BGK" name="CITEBGK">BGK08</a>] uses a Singer element s of order (q<sup>d</sup>&#8722;1)/(q&#8722;1).
(So the order of the corresponding element in
<span class="roman">PSL</span>(d,q) = (q<sup>d</sup>&#8722;1)/[(q&#8722;1) gcd(d,q&#8722;1)].)
By&nbsp;[<a href="#Be00" name="CITEBe00">Ber00</a>], <font face="helvetica"><i>M</i></font>(S,s) consists of extension field type subgroups,
except in the cases d = 2, q  &#8712; { 2, 5, 7, 9 }, and (d,q) = (3,4).
These subgroups have the structure <span class="roman">GL</span>(d/p,q<sup>p</sup>):&#945;<sub>q</sub> &#8745;S,
for prime divisors p of d,
where &#945;<sub>q</sub> denotes the Frobenius automorphism that acts on
matrices by raising each entry to the q-th power.
(If q is a prime then we have <span class="roman">GL</span>(d/p,q<sup>p</sup>):&#945;<sub>q</sub> = &#915;<span class="roman">L</span>(d/p,q<sup>p</sup>).)
Since s acts irreducibly,
it is contained in at most one conjugate of each class of
extension field type subgroups (cf.&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Lemma&nbsp;2.12]).

<div class="p"><!----></div>
First we write a <font face="helvetica">GAP</font> function <tt>RelativeSigmaL</tt> that takes
a positive integer d and a basis B of the field
extension of degree n over the field with q elements,
and returns the group <span class="roman">GL</span>(d,q<sup>n</sup>):&#945;<sub>q</sub>, as a subgroup of <span class="roman">GL</span>(dn,q).

<div class="p"><!----></div>

<pre>
    gap&#62; RelativeSigmaL:= function( d, B )
    &#62;     local n, F, q, glgens, diag, pi, frob, i;
    &#62; 
    &#62;     n:= Length( B );
    &#62;     F:= LeftActingDomain( UnderlyingLeftModule( B ) );
    &#62;     q:= Size( F );
    &#62; 
    &#62;     # Create the generating matrices inside the linear subgroup.
    &#62;     glgens:= List( GeneratorsOfGroup( SL( d, q^n ) ),
    &#62;                    m -&#62; BlownUpMat( B, m ) );
    &#62; 
    &#62;     # Create the matrix of a diagonal part that maps to determinant 1.
    &#62;     diag:= IdentityMat( d*n, F );
    &#62;     diag{ [ 1 .. n ] }{ [ 1 .. n ] }:= BlownUpMat( B, [ [ Z(q^n)^(q-1) ] ] );
    &#62;     Add( glgens, diag );
    &#62; 
    &#62;     # Create the matrix that realizes the Frobenius action,
    &#62;     # and adjust the determinant.
    &#62;     pi:= List( B, b -&#62; Coefficients( B, b^q ) );
    &#62;     frob:= NullMat( d*n, d*n, F );
    &#62;     for i in [ 0 .. d-1 ] do
    &#62;       frob{ [ 1 .. n ] + i*n }{ [ 1 .. n ] + i*n }:= pi;
    &#62;     od;
    &#62;     diag:= IdentityMat( d*n, F );
    &#62;     diag{ [ 1 .. n ] }{ [ 1 .. n ] }:= BlownUpMat( B, [ [ Z(q^n) ] ] );
    &#62;     diag:= diag^LogFFE( Inverse( Determinant( frob ) ), Determinant( diag ) );
    &#62; 
    &#62;     # Return the result.
    &#62;     return Group( Concatenation( glgens, [ diag * frob ] ) );
    &#62; end;;

</pre>

<div class="p"><!----></div>
The next function computes &#963;(<span class="roman">SL</span>(d,q),s),
by computing the sum of &#956;(g,S/(<span class="roman">GL</span>(d/p,q<sup>p</sup>):&#945;<sub>q</sub> &#8745;S)),
for prime divisors p of d, and taking the maximum over
g  &#8712; S<sup>&times;</sup>.
The computations take place in a permutation representation of <span class="roman">PSL</span>(d,q).

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; ApproxPForSL:= function( d, q )
    &#62;     local G, epi, PG, primes, maxes, names, ccl;
    &#62; 
    &#62;     # Check whether this is an admissible case (see [Be00]).
    &#62;     if ( d = 2 and q in [ 2, 5, 7, 9 ] ) or ( d = 3 and q = 4 ) then
    &#62;       return fail;
    &#62;     fi;
    &#62; 
    &#62;     # Create the group SL(d,q), and the map to PSL(d,q).
    &#62;     G:= SL( d, q );
    &#62;     epi:= ActionHomomorphism( G, NormedRowVectors( GF(q)^d ), OnLines );
    &#62;     PG:= ImagesSource( epi );
    &#62; 
    &#62;     # Create the subgroups corresponding to the prime divisors of `d'.
    &#62;     primes:= Set( Factors( d ) );
    &#62;     maxes:= List( primes, p -&#62; RelativeSigmaL( d/p,
    &#62;                                  Basis( AsField( GF(q), GF(q^p) ) ) ) );
    &#62;     names:= List( primes, p -&#62; Concatenation( "GL(", String( d/p ), ",",
    &#62;                                  String( q^p ), ").", String( p ) ) );
    &#62;     if 2 &lt; q then
    &#62;       names:= List( names, name -&#62; Concatenation( name, " cap G" ) );
    &#62;     fi;
    &#62; 
    &#62;     # Compute the conjugacy classes of prime order elements in the maxes.
    &#62;     # (In order to avoid computing all conjugacy classes of these subgroups,
    &#62;     # we work in Sylow subgroups.)
    &#62;     ccl:= List( List( maxes, x -&#62; ImagesSet( epi, x ) ),
    &#62;             M -&#62; ClassesOfPrimeOrder( M, Set( Factors( Size( M ) ) ),
    &#62;                                       TrivialSubgroup( M ) ) );
    &#62; 
    &#62;     return [ names, UpperBoundFixedPointRatios( PG, ccl, true )[1] ];
    &#62; end;;

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
We apply this function to the cases that are interesting
in&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Section&nbsp;5.12].

<div class="p"><!----></div>

<pre>
    gap&#62; pairs:= [ [ 3, 2 ], [ 3, 3 ], [ 4, 2 ], [ 4, 3 ], [ 4, 4 ],
    &#62;            [ 6, 2 ], [ 6, 3 ], [ 6, 4 ], [ 6, 5 ], [ 8, 2 ], [ 10, 2 ] ];;
    gap&#62; array:= [];;
    gap&#62; for pair in pairs do
    &#62;      d:= pair[1];  q:= pair[2];
    &#62;      approx:= ApproxPForSL( d, q );
    &#62;      Add( array, [ Concatenation( "SL(", String(d), ",", String(q), ")" ),
    &#62;                    (q^d-1)/(q-1),
    &#62;                    approx[1], approx[2] ] );
    &#62;    od;
    gap&#62; PrintFormattedArray( array );
       SL(3,2)    7                             [ "GL(1,8).3" ]             1/4
       SL(3,3)   13                      [ "GL(1,27).3 cap G" ]            1/24
       SL(4,2)   15                             [ "GL(2,4).2" ]            3/14
       SL(4,3)   40                       [ "GL(2,9).2 cap G" ]         53/1053
       SL(4,4)   85                      [ "GL(2,16).2 cap G" ]           1/108
       SL(6,2)   63                [ "GL(3,4).2", "GL(2,8).3" ]       365/55552
       SL(6,3)  364   [ "GL(3,9).2 cap G", "GL(2,27).3 cap G" ] 22843/123845436
       SL(6,4) 1365  [ "GL(3,16).2 cap G", "GL(2,64).3 cap G" ]         1/85932
       SL(6,5) 3906 [ "GL(3,25).2 cap G", "GL(2,125).3 cap G" ]        1/484220
       SL(8,2)  255                             [ "GL(4,4).2" ]          1/7874
      SL(10,2) 1023               [ "GL(5,4).2", "GL(2,32).5" ]        1/129794

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
The only missing case for&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>] is S = L<sub>3</sub>(4),
for which <font face="helvetica"><i>M</i></font>(S,s) consists of three groups of the type L<sub>3</sub>(2)
(see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;23]).
The group L<sub>3</sub>(4) has been considered already in Section&nbsp;<a href="#easyloop">4.3</a>,
where &#963;(S,s) = 1/5 has been proved.
Also the cases <span class="roman">SL</span>(3,3), <span class="roman">SL</span>(4,2)  &#8773; A<sub>8</sub>, and <span class="roman">SL</span>(4,3) have been
handled there.

<div class="p"><!----></div>
An alternative character-theoretic proof for S = L<sub>6</sub>(2) looks as follows.
In this case, the subgroups in <font face="helvetica"><i>M</i></font>(S,s) have the types
&#915;<span class="roman">L</span>(3,4)  &#8773; <span class="roman">GL</span>(3,4).2  &#8773; 3.L<sub>3</sub>(4).3.2<sub>2</sub>
and &#915;<span class="roman">L</span>(2,8)  &#8773; <span class="roman">GL</span>(2,8).3  &#8773; (7 &times;L<sub>2</sub>(8)).3.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "L6(2)" );;
    gap&#62; s1:= CharacterTable( "3.L3(4).3.2_2" );;
    gap&#62; s2:= CharacterTable( "(7xL2(8)).3" );;
    gap&#62; SigmaFromMaxes( t, "63A", [ s1, s2 ], [ 1, 1 ] );
    365/55552

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.6">
5.6</a>&nbsp;&nbsp;&#8727;&nbsp;L<sub>d</sub>(q) with prime d</h3>

<div class="p"><!----></div>
For S = <span class="roman">SL</span>(d,q) with <em>prime</em> dimension d,
and s  &#8712; S a Singer cycle,
we have <font face="helvetica"><i>M</i></font>(S,s) = { M },
where M = N<sub>S</sub>(&#9001;s &#9002;)  &#8773; &#915;<span class="roman">L</span>(1,q<sup>d</sup>) &#8745;S.
So

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 &#963;(g,s) = &#956;(g,S/M) = &#124;g<sup>S</sup> &#8745;M&#124;/&#124;g<sup>S</sup>&#124;  &lt;  &#124;M&#124;/&#124;g<sup>S</sup>&#124;  &#8804; (q<sup>d</sup>&#8722;1) &#183;d/&#124;g<sup>S</sup>&#124;</td></tr></table>
</td></tr></table>


holds for any g  &#8712; S \Z(S),
which implies
&#963;( S, s )  &lt;  max{ (q<sup>d</sup>&#8722;1) &#183;d/&#124;g<sup>S</sup>&#124;; g  &#8712; S \Z(S) }.
The right hand side of this inequality is returned by the following function.
In&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Lemma&nbsp;3.8],
the global upper bound 1/q<sup>d</sup> is derived for primes d  &#8805; 5.

<div class="p"><!----></div>

<pre>
    gap&#62; UpperBoundForSL:= function( d, q )
    &#62;     local G, Msize, ccl;
    &#62; 
    &#62;     if not IsPrimeInt( d ) then
    &#62;       Error( "&lt;d&#62; must be a prime" );
    &#62;     fi;
    &#62; 
    &#62;     G:= SL( d, q );
    &#62;     Msize:= (q^d-1) * d;
    &#62;     ccl:= Filtered( ConjugacyClasses( G ),
    &#62;                     c -&#62;     Msize mod Order( Representative( c ) ) = 0
    &#62;                          and Size( c ) &lt;&#62; 1 );
    &#62; 
    &#62;     return Msize / Minimum( List( ccl, Size ) );
    &#62; end;;

</pre>

<div class="p"><!----></div>
The interesting values are (d,q) with d  &#8712; { 5, 7, 11 } and
q  &#8712; { 2, 3, 4 }, and perhaps also (d,q)  &#8712; { (3,2), (3,3) }.
(Here we exclude <span class="roman">SL</span>(11,4) because writing down the conjugacy classes
of this group would exceed the permitted memory.)

<div class="p"><!----></div>

<pre>
    gap&#62; NrConjugacyClasses( SL(11,4) );
    1397660
    gap&#62; pairs:= [ [ 3, 2 ], [ 3, 3 ], [ 5, 2 ], [ 5, 3 ], [ 5, 4 ],
    &#62;              [ 7, 2 ], [ 7, 3 ], [ 7, 4 ],
    &#62;              [ 11, 2 ], [ 11, 3 ] ];;
    gap&#62; array:= [];;
    gap&#62; for pair in pairs do
    &#62;      d:= pair[1];  q:= pair[2];
    &#62;      approx:= UpperBoundForSL( d, q );
    &#62;      Add( array, [ Concatenation( "SL(", String(d), ",", String(q), ")" ),
    &#62;                    (q^d-1)/(q-1),
    &#62;                    approx ] );
    &#62;    od;
    gap&#62; PrintFormattedArray( array );
       SL(3,2)     7                                   7/8
       SL(3,3)    13                                   3/4
       SL(5,2)    31                              31/64512
       SL(5,3)   121                                 10/81
       SL(5,4)   341                                15/256
       SL(7,2)   127                             7/9142272
       SL(7,3)  1093                                14/729
       SL(7,4)  5461                               21/4096
      SL(11,2)  2047 2047/34112245508649716682268134604800
      SL(11,3) 88573                              22/59049

</pre>

<div class="p"><!----></div>
The exact values are clearly better than the above bounds.
We compute them for L<sub>5</sub>(2) and L<sub>7</sub>(2).
In the latter case, the class fusion of the 127:7 type subgroup M
is not uniquely determined by the character tables;
here we use the additional information that the elements of order 7 in M
have centralizer order 49 in L<sub>7</sub>(2).
(See Section&nbsp;<a href="#easyloop">4.3</a> for the examples with d = 3.)

<div class="p"><!----></div>

<pre>
    gap&#62; SigmaFromMaxes( CharacterTable( "L5(2)" ), "31A",
    &#62;        [ CharacterTable( "31:5" ) ], [ 1 ] );
    1/5376
    gap&#62; t:= CharacterTable( "L7(2)" );;
    gap&#62; s:= CharacterTable( "P:Q", [ 127, 7 ] );;
    gap&#62; pi:= PossiblePermutationCharacters( s, t );;
    gap&#62; Length( pi );
    2
    gap&#62; ord7:= PositionsProperty( OrdersClassRepresentatives( t ), x -&#62; x = 7 );
    [ 38, 45, 76, 77, 83 ]
    gap&#62; sizes:= SizesCentralizers( t ){ ord7 };
    [ 141120, 141120, 3528, 3528, 49 ]
    gap&#62; List( pi, x -&#62; x[83] );
    [ 42, 0 ]
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 127 );;
    gap&#62; Maximum( ApproxP( pi{ [ 1 ] }, spos ) );
    1/4388290560

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.7">
5.7</a>&nbsp;&nbsp;Automorphic Extensions of L<sub>d</sub>(q)</h3><a name="SLaut">
</a>

<div class="p"><!----></div>
For the following values of d and q,
automorphic extensions G of L<sub>d</sub>(q) had to be checked
for&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Section&nbsp;5.12].

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 (d,q)  &#8712; { (3,4), (6,2), (6,3), (6,4), (6,5), (10,2) }</td></tr></table>
</td></tr></table>


The first case has been treated in Section&nbsp;<a href="#easyloopaut">4.4</a>.
For the other cases, we compute &#963;<sup>&#8242;</sup>(G,s) below.

<div class="p"><!----></div>
In any case, the extension by a <em>graph</em> automorphism occurs,
which can be described by mapping each matrix in <span class="roman">SL</span>(d,q) to its inverse
transpose.
If q  &gt;  2, also extensions by <em>diagonal</em> automorphisms occur,
which are induced by conjugation with elements in <span class="roman">GL</span>(d,q).
If q is nonprime then also extensions by <em>field</em> automorphisms occur,
which can be described by powering the matrix entries by roots of q.
Finally, products (of prime order) of these three kinds of automorphisms
have to be considered.

<div class="p"><!----></div>
We start with the extension G of S = <span class="roman">SL</span>(d,q) by a graph automorphism.
G can be embedded into <span class="roman">GL</span>(2d,q) by representing the matrix A  &#8712; S
as a block diagonal matrix with diagonal blocks equal to A and A<sup>&#8722;tr</sup>,
and representing the graph automorphism by a permutation matrix that
interchanges the two blocks.
In order to construct the field extension type subgroups of G,
we have to choose the basis of the field extension in such a way that the
subgroup is normalized by the permutation matrix;
a sufficient condition is that the matrices of the <font size="+0">F</font><sub>q</sub>-linear mappings
induced by the basis elements are symmetric.

<div class="p"><!----></div>
(We do not give a function that computes a basis with this property from
the parameters d and q.
Instead, we only write down the bases that we will need.)

<div class="p"><!----></div>

<pre>
    gap&#62; SymmetricBasis:= function( q, n )
    &#62;     local vectors, B, issymmetric;
    &#62; 
    &#62;     if   q = 2 and n = 2 then
    &#62;       vectors:= [ Z(2)^0, Z(2^2) ];
    &#62;     elif q = 2 and n = 3 then
    &#62;       vectors:= [ Z(2)^0, Z(2^3), Z(2^3)^5 ];
    &#62;     elif q = 2 and n = 5 then
    &#62;       vectors:= [ Z(2)^0, Z(2^5), Z(2^5)^4, Z(2^5)^25, Z(2^5)^26 ];
    &#62;     elif q = 3 and n = 2 then
    &#62;       vectors:= [ Z(3)^0, Z(3^2) ];
    &#62;     elif q = 3 and n = 3 then
    &#62;       vectors:= [ Z(3)^0, Z(3^3)^2, Z(3^3)^7 ];
    &#62;     elif q = 4 and n = 2 then
    &#62;       vectors:= [ Z(2)^0, Z(2^4)^3 ];
    &#62;     elif q = 4 and n = 3 then
    &#62;       vectors:= [ Z(2)^0, Z(2^3), Z(2^3)^5 ];
    &#62;     elif q = 5 and n = 2 then
    &#62;       vectors:= [ Z(5)^0, Z(5^2)^2 ];
    &#62;     elif q = 5 and n = 3 then
    &#62;       vectors:= [ Z(5)^0, Z(5^3)^9, Z(5^3)^27 ];
    &#62;     else
    &#62;       Error( "sorry, no basis for &lt;q&#62; and &lt;n&#62; stored" );
    &#62;     fi;
    &#62; 
    &#62;     B:= Basis( AsField( GF(q), GF(q^n) ), vectors );
    &#62; 
    &#62;     # Check that the basis really has the required property.
    &#62;     issymmetric:= M -&#62; M = TransposedMat( M );
    &#62;     if not ForAll( B, b -&#62; issymmetric( BlownUpMat( B, [ [ b ] ] ) ) ) then
    &#62;       Error( "wrong basis!" );
    &#62;     fi;
    &#62; 
    &#62;     # Return the result.
    &#62;     return B;
    &#62; end;;

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
In later examples, we will need similar embeddings of matrices.
Therefore, we provide a more general function <tt>EmbeddedMatrix</tt>
that takes a field <tt>F</tt>, a matrix <tt>mat</tt>, and a function <tt>func</tt>,
and returns a block diagonal matrix over <tt>F</tt> whose diagonal blocks are
<tt>mat</tt> and <tt>func( mat )</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; BindGlobal( "EmbeddedMatrix", function( F, mat, func )
    &#62;   local d, result;
    &#62; 
    &#62;   d:= Length( mat );
    &#62;   result:= NullMat( 2*d, 2*d, F );
    &#62;   result{ [ 1 .. d ] }{ [ 1 .. d ] }:= mat;
    &#62;   result{ [ d+1 .. 2*d ] }{ [ d+1 .. 2*d ] }:= func( mat );
    &#62; 
    &#62;   return result;
    &#62; end );

</pre>

<div class="p"><!----></div>
The following function is similar to <tt>ApproxPForSL</tt>,
the differences are that the group G in question is not <span class="roman">SL</span>(d,q) but
the extension of this group by a graph automorphism,
and that &#963;<sup>&#8242;</sup>(G,s) is computed not &#963;(G,s).

<div class="p"><!----></div>

<pre>
    gap&#62; ApproxPForOuterClassesInExtensionOfSLByGraphAut:= function( d, q )
    &#62;     local embedG, swap, G, orb, epi, PG, Gprime, primes, maxes, ccl, names;
    &#62; 
    &#62;     # Check whether this is an admissible case (see [Be00],
    &#62;     # note that a graph automorphism exists only for `d &#62; 2').
    &#62;     if d = 2 or ( d = 3 and q = 4 ) then
    &#62;       return fail;
    &#62;     fi;
    &#62; 
    &#62;     # Provide a function that constructs a block diagonal matrix.
    &#62;     embedG:= mat -&#62; EmbeddedMatrix( GF( q ), mat,
    &#62;                                     M -&#62; TransposedMat( M^-1 ) );
    &#62; 
    &#62;     # Create the matrix that exchanges the two blocks.
    &#62;     swap:= NullMat( 2*d, 2*d, GF(q) );
    &#62;     swap{ [ 1 .. d ] }{ [ d+1 .. 2*d ] }:= IdentityMat( d, GF(q) );
    &#62;     swap{ [ d+1 .. 2*d ] }{ [ 1 .. d ] }:= IdentityMat( d, GF(q) );
    &#62; 
    &#62;     # Create the group SL(d,q).2, and the map to the projective group.
    &#62;     G:= ClosureGroupDefault( Group( List( GeneratorsOfGroup( SL( d, q ) ),
    &#62;                                           embedG ) ),
    &#62;                       swap );
    &#62;     orb:= Orbit( G, One( G )[1], OnLines );
    &#62;     epi:= ActionHomomorphism( G, orb, OnLines );
    &#62;     PG:= ImagesSource( epi );
    &#62;     Gprime:= DerivedSubgroup( PG );
    &#62; 
    &#62;     # Create the subgroups corresponding to the prime divisors of `d'.
    &#62;     primes:= Set( Factors( d ) );
    &#62;     maxes:= List( primes,
    &#62;               p -&#62; ClosureGroupDefault( Group( List( GeneratorsOfGroup(
    &#62;                          RelativeSigmaL( d/p, SymmetricBasis( q, p ) ) ),
    &#62;                          embedG ) ),
    &#62;                      swap ) );
    &#62; 
    &#62;     # Compute conjugacy classes of outer involutions in the maxes.
    &#62;     # (In order to avoid computing all conjugacy classes of these subgroups,
    &#62;     # we work in the Sylow $2$ subgroups.)
    &#62;     maxes:= List( maxes, M -&#62; ImagesSet( epi, M ) );
    &#62;     ccl:= List( maxes, M -&#62; ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );
    &#62;     names:= List( primes, p -&#62; Concatenation( "GL(", String( d/p ), ",",
    &#62;                                    String( q^p ), ").", String( p ) ) );
    &#62; 
    &#62;     return [ names, UpperBoundFixedPointRatios( PG, ccl, true )[1] ];
    &#62; end;;

</pre>

<div class="p"><!----></div>
And these are the results for the groups we are interested in
(and others).

<div class="p"><!----></div>

<pre>
    gap&#62; ApproxPForOuterClassesInExtensionOfSLByGraphAut( 4, 3 );
    [ [ "GL(2,9).2" ], 17/117 ]
    gap&#62; ApproxPForOuterClassesInExtensionOfSLByGraphAut( 4, 4 );
    [ [ "GL(2,16).2" ], 73/1008 ]
    gap&#62; ApproxPForOuterClassesInExtensionOfSLByGraphAut( 6, 2 );
    [ [ "GL(3,4).2", "GL(2,8).3" ], 41/1984 ]
    gap&#62; ApproxPForOuterClassesInExtensionOfSLByGraphAut( 6, 3 );
    [ [ "GL(3,9).2", "GL(2,27).3" ], 541/352836 ]
    gap&#62; ApproxPForOuterClassesInExtensionOfSLByGraphAut( 6, 4 );
    [ [ "GL(3,16).2", "GL(2,64).3" ], 3265/12570624 ]
    gap&#62; ApproxPForOuterClassesInExtensionOfSLByGraphAut( 6, 5 );
    [ [ "GL(3,25).2", "GL(2,125).3" ], 13001/195250000 ]
    gap&#62; ApproxPForOuterClassesInExtensionOfSLByGraphAut( 8, 2 );
    [ [ "GL(4,4).2" ], 367/1007872 ]
    gap&#62; ApproxPForOuterClassesInExtensionOfSLByGraphAut( 10, 2 );
    [ [ "GL(5,4).2", "GL(2,32).5" ], 609281/476346056704 ]

</pre>

<div class="p"><!----></div>
Now we consider diagonal automorphisms.
We modify the approach for <span class="roman">SL</span>(d,q) by constructing the field extension
type subgroups of <span class="roman">GL</span>(d,q) ...

<div class="p"><!----></div>

<pre>
    gap&#62; RelativeGammaL:= function( d, B )
    &#62;     local n, F, q, diag;
    &#62; 
    &#62;     n:= Length( B );
    &#62;     F:= LeftActingDomain( UnderlyingLeftModule( B ) );
    &#62;     q:= Size( F );
    &#62;     diag:= IdentityMat( d * n, F );
    &#62;     diag{[ 1 .. n ]}{[ 1 .. n ]}:= BlownUpMat( B, [ [ Z(q^n) ] ] );
    &#62;     return ClosureGroup( RelativeSigmaL( d, B ),  diag );
    &#62; end;;

</pre>

<div class="p"><!----></div>
... and counting the elements of prime order outside the simple group.

<div class="p"><!----></div>

<pre>
    gap&#62; ApproxPForOuterClassesInGL:= function( d, q )
    &#62;     local G, epi, PG, Gprime, primes, maxes, names;
    &#62; 
    &#62;     # Check whether this is an admissible case (see [Be00]).
    &#62;     if ( d = 2 and q in [ 2, 5, 7, 9 ] ) or ( d = 3 and q = 4 ) then
    &#62;       return fail;
    &#62;     fi;
    &#62; 
    &#62;     # Create the group GL(d,q), and the map to PGL(d,q).
    &#62;     G:= GL( d, q );
    &#62;     epi:= ActionHomomorphism( G, NormedRowVectors( GF(q)^d ), OnLines );
    &#62;     PG:= ImagesSource( epi );
    &#62;     Gprime:= ImagesSet( epi, SL( d, q ) );
    &#62; 
    &#62;     # Create the subgroups corresponding to the prime divisors of `d'.
    &#62;     primes:= Set( Factors( d ) );
    &#62;     maxes:= List( primes, p -&#62; RelativeGammaL( d/p,
    &#62;                                    Basis( AsField( GF(q), GF(q^p) ) ) ) );
    &#62;     maxes:= List( maxes, M -&#62; ImagesSet( epi, M ) );
    &#62;     names:= List( primes, p -&#62; Concatenation( "M(", String( d/p ), ",",
    &#62;                                    String( q^p ), ")" ) );
    &#62; 
    &#62;     return [ names,
    &#62;              UpperBoundFixedPointRatios( PG, List( maxes,
    &#62;                  M -&#62; ClassesOfPrimeOrder( M,
    &#62;                           Set( Factors( Index( PG, Gprime ) ) ), Gprime ) ),
    &#62;                  true )[1] ];
    &#62; end;;

</pre>

<div class="p"><!----></div>
Here are the required results.

<div class="p"><!----></div>

<pre>
    gap&#62; ApproxPForOuterClassesInGL( 6, 3 );
    [ [ "M(3,9)", "M(2,27)" ], 41/882090 ]
    gap&#62; ApproxPForOuterClassesInGL( 4, 3 );
    [ [ "M(2,9)" ], 0 ]
    gap&#62; ApproxPForOuterClassesInGL( 6, 4 );
    [ [ "M(3,16)", "M(2,64)" ], 1/87296 ]
    gap&#62; ApproxPForOuterClassesInGL( 6, 5 );
    [ [ "M(3,25)", "M(2,125)" ], 821563/756593750000 ]

</pre>

<div class="p"><!----></div>
(Note that the extension field type subgroup in <span class="roman">PGL</span>(4,3) = L<sub>4</sub>(3).2<sub>1</sub>
is a <em>non-split</em> extension of its intersection with L<sub>4</sub>(3),
hence the zero value.)

<div class="p"><!----></div>

<div class="p"><!----></div>
Concerning extensions by Frobenius automorphisms,
only the case (d,q) = (6,4) is interesting in&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>].
In fact, we would not need to compute anything for the extension G of
S = <span class="roman">SL</span>(6,4) by the Frobenius map that squares each matrix entry.
This is because <font face="helvetica"><i>M</i></font><sup>&#8242;</sup>(G,s) consists of the normalizers
of the two subgroups of the types <span class="roman">SL</span>(3,16) and <span class="roman">SL</span>(2,64),
and the former maximal subgroup is a <em>non-split</em> extension of its
intersection with S,
so only one maximal subgroup can contribute to &#963;<sup>&#8242;</sup>(G,s),
which is thus smaller than 1/2, by&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Prop.&nbsp;2.6].

<div class="p"><!----></div>
However, it is easy enough to compute the exact value of
&#963;<sup>&#8242;</sup>(G,s).
We work with the projective action of S on its natural module,
and compute the permutation induced by the Frobenius map as the
Frobenius action on the normed row vectors.

<div class="p"><!----></div>

<pre>
    gap&#62; matgrp:= SL(6,4);;
    gap&#62; dom:= NormedRowVectors( GF(4)^6 );;
    gap&#62; Gprime:= Action( matgrp, dom, OnLines );;
    gap&#62; pi:= PermList( List( dom, v -&#62; Position( dom, List( v, x -&#62; x^2 ) ) ) );;
    gap&#62; G:= ClosureGroup( Gprime, pi );;

</pre>

<div class="p"><!----></div>
Then we compute the maximal subgroups, the classes of outer involutions,
and the bound, similar to the situation with graph automorphisms.

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; maxes:= List( [ 2, 3 ], p -&#62; Normalizer( G,
    &#62;              Action( RelativeSigmaL( 6/p,
    &#62;                Basis( AsField( GF(4), GF(4^p) ) ) ), dom, OnLines ) ) );;
    gap&#62; ccl:= List( maxes, M -&#62; ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;
    gap&#62; List( ccl, Length );
    [ 0, 1 ]
    gap&#62; UpperBoundFixedPointRatios( G, ccl, true );
    [ 1/34467840, true ]

</pre>

<div class="p"><!----></div>
For (d,q) = (6,4),
we have to consider also the extension G of S = <span class="roman">SL</span>(6,4)
by the product &#945; of the Frobenius map and the graph automorphism.
We use the same approach as for the graph automorphism,
i.&nbsp;e., we embed <span class="roman">SL</span>(6,4) into a 12-dimensional group of 6 &times;6
block matrices,
where the second block is the image of the first block under &#945;,
and describe &#945; by the transposition of the two blocks.

<div class="p"><!----></div>
First we construct the projective actions of S and G on an orbit of
1-spaces.

<div class="p"><!----></div>

<pre>
    gap&#62; embedFG:= function( F, mat )
    &#62;      return EmbeddedMatrix( F, mat,
    &#62;                 M -&#62; List( TransposedMat( M^-1 ),
    &#62;                            row -&#62; List( row, x -&#62; x^2 ) ) );
    &#62;    end;;
    gap&#62; d:= 6;;  q:= 4;;
    gap&#62; alpha:= NullMat( 2*d, 2*d, GF(q) );;
    gap&#62; alpha{ [ 1 .. d ] }{ [ d+1 .. 2*d ] }:= IdentityMat( d, GF(q) );;
    gap&#62; alpha{ [ d+1 .. 2*d ] }{ [ 1 .. d ] }:= IdentityMat( d, GF(q) );;
    gap&#62; Gprime:= Group( List( GeneratorsOfGroup( SL(d,q) ),
    &#62;                          mat -&#62; embedFG( GF(q), mat ) ) );;
    gap&#62; G:= ClosureGroupDefault( Gprime, alpha );;
    gap&#62; orb:= Orbit( G, One( G )[1], OnLines );;
    gap&#62; G:= Action( G, orb, OnLines );;
    gap&#62; Gprime:= Action( Gprime, orb, OnLines );;

</pre>

<div class="p"><!----></div>
Next we construct the maximal subgroups, the classes of outer involutions,
and the bound.

<div class="p"><!----></div>

<pre>
    gap&#62; maxes:= List( Set( Factors( d ) ), p -&#62; Group( List( GeneratorsOfGroup(
    &#62;              RelativeSigmaL( d/p, Basis( AsField( GF(q), GF(q^p) ) ) ) ),
    &#62;                mat -&#62; embedFG( GF(q), mat ) ) ) );;
    gap&#62; maxes:= List( maxes, x -&#62; Action( x, orb, OnLines ) );;
    gap&#62; maxes:= List( maxes, x -&#62; Normalizer( G, x ) );;
    gap&#62; ccl:= List( maxes, M -&#62; ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;
    gap&#62; List( ccl, Length );
    [ 0, 1 ]
    gap&#62; UpperBoundFixedPointRatios( G, ccl, true );
    [ 1/10792960, true ]

</pre>

<div class="p"><!----></div>
The only missing cases are the extensions of <span class="roman">SL</span>(6,3) and <span class="roman">SL</span>(6,5)
by the involutory outer automorphism that acts as the product of a diagonal
and a graph automorphism.

<div class="p"><!----></div>
In the case S = <span class="roman">SL</span>(6,3), we can directly write down the extension G.

<div class="p"><!----></div>

<pre>
    gap&#62; d:= 6;;  q:= 3;;
    gap&#62; diag:= IdentityMat( d, GF(q) );;
    gap&#62; diag[1][1]:= Z(q);;
    gap&#62; embedDG:= mat -&#62; EmbeddedMatrix( GF(q), mat,
    &#62;                                     M -&#62; TransposedMat( M^-1 )^diag );;
    gap&#62; Gprime:= Group( List( GeneratorsOfGroup( SL(d,q) ), embedDG ) );;
    gap&#62; alpha:= NullMat( 2*d, 2*d, GF(q) );;
    gap&#62; alpha{ [ 1 .. d ] }{ [ d+1 .. 2*d ] }:= IdentityMat( d, GF(q) );;
    gap&#62; alpha{ [ d+1 .. 2*d ] }{ [ 1 .. d ] }:= IdentityMat( d, GF(q) );;
    gap&#62; G:= ClosureGroupDefault( Gprime, alpha );;

</pre>

<div class="p"><!----></div>
The maximal subgroups are constructed as the normalizers in G of the
extension field type subgroups in S.
We work with a permutation representation of G.

<div class="p"><!----></div>

<pre>
    gap&#62; maxes:= List( Set( Factors( d ) ), p -&#62; Group( List( GeneratorsOfGroup(
    &#62;              RelativeSigmaL( d/p, Basis( AsField( GF(q), GF(q^p) ) ) ) ),
    &#62;                embedDG ) ) );;
    gap&#62; orb:= Orbit( G, One( G )[1], OnLines );;
    gap&#62; G:= Action( G, orb, OnLines );;
    gap&#62; Gprime:= Action( Gprime, orb, OnLines );;
    gap&#62; maxes:= List( maxes, M -&#62; Normalizer( G, Action( M, orb, OnLines ) ) );;
    gap&#62; ccl:= List( maxes, M -&#62; ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;
    gap&#62; List( ccl, Length );
    [ 1, 1 ]
    gap&#62; UpperBoundFixedPointRatios( G, ccl, true );
    [ 25/352836, true ]

</pre>

<div class="p"><!----></div>
For S = <span class="roman">SL</span>(6,5), this approach does not work because we cannot
realize the diagonal involution by an involutory matrix.
Instead, we consider the extension of <span class="roman">GL</span>(6,5)  &#8773; 2.(2 &times;L<sub>6</sub>(5)).2
by the graph automorphism &#945;, which can be embedded into <span class="roman">GL</span>(12,5).

<div class="p"><!----></div>

<pre>
    gap&#62; d:= 6;;  q:= 5;;
    gap&#62; embedG:= mat -&#62; EmbeddedMatrix( GF(q),
    &#62;                                    mat, M -&#62; TransposedMat( M^-1 ) );;
    gap&#62; Gprime:= Group( List( GeneratorsOfGroup( SL(d,q) ), embedG ) );;
    gap&#62; maxes:= List( Set( Factors( d ) ), p -&#62; Group( List( GeneratorsOfGroup(
    &#62;              RelativeSigmaL( d/p, Basis( AsField( GF(q), GF(q^p) ) ) ) ),
    &#62;                embedG ) ) );;
    gap&#62; diag:= IdentityMat( d, GF(q) );;
    gap&#62; diag[1][1]:= Z(q);;
    gap&#62; diag:= embedG( diag );;
    gap&#62; alpha:= NullMat( 2*d, 2*d, GF(q) );;
    gap&#62; alpha{ [ 1 .. d ] }{ [ d+1 .. 2*d ] }:= IdentityMat( d, GF(q) );;
    gap&#62; alpha{ [ d+1 .. 2*d ] }{ [ 1 .. d ] }:= IdentityMat( d, GF(q) );;
    gap&#62; G:= ClosureGroupDefault( Gprime, alpha * diag );;

</pre>

<div class="p"><!----></div>
Now we switch to the permutation action of this group on the 1-dimensional
subspaces, thus factoring out the cyclic normal subgroup of order four.
In this action, the involutory diagonal automorphism is represented by an
involution, and we can proceed as above.

<div class="p"><!----></div>

<pre>
    gap&#62; orb:= Orbit( G, One( G )[1], OnLines );;
    gap&#62; Gprime:= Action( Gprime, orb, OnLines );;
    gap&#62; G:= Action( G, orb, OnLines );;
    gap&#62; maxes:= List( maxes, M -&#62; Action( M, orb, OnLines ) );;
    gap&#62; extmaxes:= List( maxes, M -&#62; Normalizer( G, M ) );;
    gap&#62; ccl:= List( extmaxes, M -&#62; ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;
    gap&#62; List( ccl, Length );
    [ 2, 1 ]
    gap&#62; UpperBoundFixedPointRatios( G, ccl, true );
    [ 3863/6052750000, true ]

</pre>

<div class="p"><!----></div>
In the same way, we can recheck the values for the extensions of <span class="roman">SL</span>(6,5)
by the diagonal or by the graph automorphism.

<div class="p"><!----></div>

<pre>
    gap&#62; diag:= Permutation( diag, orb, OnLines );;
    gap&#62; G:= ClosureGroupDefault( Gprime, diag );;
    gap&#62; extmaxes:= List( maxes, M -&#62; Normalizer( G, M ) );;
    gap&#62; ccl:= List( extmaxes, M -&#62; ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;
    gap&#62; List( ccl, Length );
    [ 3, 1 ]
    gap&#62; UpperBoundFixedPointRatios( G, ccl, true );
    [ 821563/756593750000, true ]
    gap&#62; alpha:= Permutation( alpha, orb, OnLines );;
    gap&#62; G:= ClosureGroupDefault( Gprime, alpha );;
    gap&#62; extmaxes:= List( maxes, M -&#62; Normalizer( G, M ) );;
    gap&#62; ccl:= List( extmaxes, M -&#62; ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;
    gap&#62; List( ccl, Length );
    [ 2, 2 ]
    gap&#62; UpperBoundFixedPointRatios( G, ccl, true );
    [ 13001/195250000, true ]

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.8">
5.8</a>&nbsp;&nbsp;L<sub>3</sub>(2)</h3><a name="L32">
</a>

<div class="p"><!----></div>
We show that S = L<sub>3</sub>(2) = <span class="roman">SL</span>(3,2) satisfies the following.

<ol type="1">
<br />(a)
    &#963;(S) = 1/4,
    and this value is attained exactly for &#963;(S,s)
    with s of order 7.
<br />(b)
    For s of order 7,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one group of the type 7:3.
<br />(c)
    P(S) = 1/4,
    and this value is attained exactly for P(S,s)
    with s of order 7.
<br />(d)
    The uniform spread of S is at exactly three,
    with s of order 7,
    and the spread of S is exactly four.
    (This had been left open in&nbsp;[<a href="#BW1" name="CITEBW1">BW75</a>].)</ol>

<div class="p"><!----></div>
(Note that in this example, the spread and the uniform spread differ.)

<div class="p"><!----></div>
Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<a href="#easyloop">4.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "L3(2)" );;
    gap&#62; ProbGenInfoSimple( t );
    [ "L3(2)", 1/4, 3, [ "7A" ], [ 1 ] ]

</pre>

<div class="p"><!----></div>
Statement&nbsp;(b) can be read off from the permutation characters,
and the fact that the unique class of maximal subgroups that contain
elements of order 7 consists of groups of the structure 7:3,
see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;3].

<div class="p"><!----></div>

<pre>
    gap&#62; OrdersClassRepresentatives( t );
    [ 1, 2, 3, 4, 7, 7 ]
    gap&#62; PrimitivePermutationCharacters( t );
    [ Character( CharacterTable( "L3(2)" ), [ 7, 3, 1, 1, 0, 0 ] ), 
      Character( CharacterTable( "L3(2)" ), [ 7, 3, 1, 1, 0, 0 ] ), 
      Character( CharacterTable( "L3(2)" ), [ 8, 0, 2, 0, 1, 1 ] ) ]

</pre>

<div class="p"><!----></div>
For the other statements, we will use the primitive permutation
representations on 7 and 8 points of S
(computed from the <font face="helvetica">GAP</font> Library of Tables of Marks),
and their diagonal products of the degrees 14 and 15.

<div class="p"><!----></div>

<pre>
    gap&#62; tom:= TableOfMarks( "L3(2)" );;
    gap&#62; g:= UnderlyingGroup( tom );
    Group([ (2,4)(5,7), (1,2,3)(4,5,6) ])
    gap&#62; mx:= MaximalSubgroupsTom( tom );
    [ [ 14, 13, 12 ], [ 7, 7, 8 ] ]
    gap&#62; maxes:= List( mx[1], i -&#62; RepresentativeTom( tom, i ) );;
    gap&#62; tr:= List( maxes, s -&#62; RightTransversal( g, s ) );;
    gap&#62; acts:= List( tr, x -&#62; Action( g, x, OnRight ) );;
    gap&#62; g7:= acts[1];
    Group([ (3,4)(6,7), (1,3,2)(4,6,5) ])
    gap&#62; g8:= acts[3];
    Group([ (1,6)(2,5)(3,8)(4,7), (1,7,3)(2,5,8) ])
    gap&#62; g14:= DiagonalProductOfPermGroups( acts{ [ 1, 2 ] } );
    Group([ (3,4)(6,7)(11,13)(12,14), (1,3,2)(4,6,5)(8,11,9)(10,12,13) ])
    gap&#62; g15:= DiagonalProductOfPermGroups( acts{ [ 2, 3 ] } );
    Group([ (4,6)(5,7)(8,13)(9,12)(10,15)(11,14), 
      (1,4,2)(3,5,6)(8,14,10)(9,12,15) ])

</pre>

<div class="p"><!----></div>
First we compute that for all nonidentity elements s  &#8712; S
and order three elements g  &#8712; S,
P(g,s)  &#8805; 1/4 holds,
with equality if and only if s has order 7;
this implies statement&nbsp;(c).
We actually compute, for class representatives s,
the proportion of order three elements g such that
&#9001;g, s &#9002; &#8800; S holds.

<div class="p"><!----></div>

<pre>
    gap&#62; ccl:= List( ConjugacyClasses( g7 ), Representative );;
    gap&#62; SortParallel( List( ccl, Order ), ccl );
    gap&#62; List( ccl, Order );
    [ 1, 2, 3, 4, 7, 7 ]
    gap&#62; Size( ConjugacyClass( g7, ccl[3] ) );
    56
    gap&#62; prop:= List( ccl,
    &#62;                 r -&#62; RatioOfNongenerationTransPermGroup( g7, ccl[3], r ) );
    [ 1, 5/7, 19/28, 2/7, 1/4, 1/4 ]
    gap&#62; Minimum( prop );
    1/4

</pre>

<div class="p"><!----></div>
Now we show that the uniform spread of S is less than four.
In any of the primitive permutation representations of degree seven,
we find three involutions whose sets of fixed points cover the
seven points.
The elements s of order different from 7 in S fix a point in this
representation, so each such s generates a proper subgroup of S
together with one of the three involutions.

<div class="p"><!----></div>

<pre>
    gap&#62; x:= g7.1;
    (3,4)(6,7)
    gap&#62; fix:= Difference( MovedPoints( g7 ), MovedPoints( x ) );
    [ 1, 2, 5 ]
    gap&#62; orb:= Orbit( g7, fix, OnSets );
    [ [ 1, 2, 5 ], [ 1, 3, 4 ], [ 2, 3, 6 ], [ 2, 4, 7 ], [ 1, 6, 7 ], 
      [ 3, 5, 7 ], [ 4, 5, 6 ] ]
    gap&#62; Union( orb{ [ 1, 2, 5 ] } ) = [ 1 .. 7 ];
    true

</pre>

<div class="p"><!----></div>
So we still have to exclude elements s of order 7.
In the primitive permutation representation of S on eight points,
we find four elements of order three whose sets of fixed points
cover the set of all points that are moved by S,
so with each element of order seven in S,
one of them generates an intransitive group.

<div class="p"><!----></div>

<pre>
    gap&#62; three:= g8.2;
    (1,7,3)(2,5,8)
    gap&#62; fix:= Difference( MovedPoints( g8 ), MovedPoints( three ) );
    [ 4, 6 ]
    gap&#62; orb:= Orbit( g8, fix, OnSets );;
    gap&#62; QuadrupleWithProperty( [ [ fix ], orb, orb, orb ],
    &#62;        list -&#62; Union( list ) = [ 1 .. 8 ] );
    [ [ 4, 6 ], [ 1, 7 ], [ 3, 8 ], [ 2, 5 ] ]

</pre>

<div class="p"><!----></div>
Together with statement&nbsp;(a), this proves that the uniform spread of S
is exactly three, with s of order seven.

<div class="p"><!----></div>
Each element of S fixes a point
in the permutation representation on 15 points.
So for proving that the spread of S is less than five,
it is sufficient to find a quintuple of elements whose sets of fixed points
cover all 15 points.
(From the permutation characters it is clear that four of these elements
must have order three, and the fifth must be an involution.)

<div class="p"><!----></div>

<pre>
    gap&#62; x:= g15.1;
    (4,6)(5,7)(8,13)(9,12)(10,15)(11,14)
    gap&#62; fixx:= Difference( MovedPoints( g15 ), MovedPoints( x ) );
    [ 1, 2, 3 ]
    gap&#62; orbx:= Orbit( g15, fixx, OnSets );
    [ [ 1, 2, 3 ], [ 1, 4, 5 ], [ 1, 6, 7 ], [ 2, 4, 6 ], [ 3, 4, 7 ], 
      [ 3, 5, 6 ], [ 2, 5, 7 ] ]
    gap&#62; y:= g15.2;
    (1,4,2)(3,5,6)(8,14,10)(9,12,15)
    gap&#62; fixy:= Difference( MovedPoints( g15 ), MovedPoints( y ) );
    [ 7, 11, 13 ]
    gap&#62; orby:= Orbit( g15, fixy, OnSets );;
    gap&#62; QuadrupleWithProperty( [ [ fixy ], orby, orby, orby ],
    &#62;        l -&#62; Difference( [ 1 .. 15 ], Union( l ) ) in orbx );
    [ [ 7, 11, 13 ], [ 5, 8, 14 ], [ 1, 10, 15 ], [ 3, 9, 12 ] ]

</pre>

<div class="p"><!----></div>
It remains to show that the spread of S is (at least) four.
By the consideration of permutation characters,
we know that we can find a suitable order seven element
for all quadruples in question
except perhaps quadruples of order three elements.
We show that for each such case, we can choose s of order four.
Since <font face="helvetica"><i>M</i></font>(S,s) consists of two subgroups of the type S<sub>4</sub>,
we work with the representation on 14 points.)

<div class="p"><!----></div>
First we compute s and the S-orbit of its fixed points,
and the S-orbit of the fixed points of an element x of order three.
Then we prove that for each quadruple of conjugates of x,
the union of their fixed points intersects the fixed points of
at least one conjugate of s trivially.

<div class="p"><!----></div>

<pre>
    gap&#62; ResetGlobalRandomNumberGenerators();
    gap&#62; repeat s:= Random( g14 );
    &#62;    until Order( s ) = 4;
    gap&#62; s;
    (2,3,5,4)(6,7)(8,9)(11,12,14,13)
    gap&#62; fixs:= Difference( MovedPoints( g14 ), MovedPoints( s ) );
    [ 1, 10 ]
    gap&#62; orbs:= Orbit( g14, fixs, OnSets );;
    gap&#62; Length( orbs );
    21
    gap&#62; three:= g14.2;
    (1,3,2)(4,6,5)(8,11,9)(10,12,13)
    gap&#62; fix:= Difference( MovedPoints( g14 ), MovedPoints( three ) );
    [ 7, 14 ]
    gap&#62; orb:= Orbit( g14, fix, OnSets );;
    gap&#62; Length( orb );
    28
    gap&#62; QuadrupleWithProperty( [ [ fix ], orb, orb, orb ],
    &#62;        l -&#62; ForAll( orbs, o -&#62; not IsEmpty( Intersection( o,
    &#62;                        Union( l ) ) ) ) );
    fail

</pre>

<div class="p"><!----></div>
By Lemma&nbsp;<a href="#existsgoodconjugate">2.1</a>, we are done.

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.9">
5.9</a>&nbsp;&nbsp;M<sub>11</sub></h3><a name="spreadM11">
</a>

<div class="p"><!----></div>
We show that S = M<sub>11</sub> satisfies the following.

<ol type="1">
<br />(a)
    &#963;(S) = 1/3,
    and this value is attained exactly for &#963;(S,s)
    with s of order 11.
<br />(b)
    For s of order 11,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one group of the type L<sub>2</sub>(11).
<br />(c)
    P(S) = 1/3,
    and this value is attained exactly for P(S,s)
    with s of order 11.
<br />(d)
    Both the uniform spread and the spread of S is exactly three,
    with s of order 11.</ol>

<div class="p"><!----></div>
Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<a href="#spor">4.1</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "M11" );;
    gap&#62; ProbGenInfoSimple( t );
    [ "M11", 1/3, 2, [ "11A" ], [ 1 ] ]

</pre>

<div class="p"><!----></div>
Statement&nbsp;(b) can be read off from the permutation characters,
and the fact that the unique class of maximal subgroups that contain
elements of order 11 consists of groups of the structure L<sub>2</sub>(11),
see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;18].

<div class="p"><!----></div>

<pre>
    gap&#62; OrdersClassRepresentatives( t );
    [ 1, 2, 3, 4, 5, 6, 8, 8, 11, 11 ]
    gap&#62; PrimitivePermutationCharacters( t );
    [ Character( CharacterTable( "M11" ), [ 11, 3, 2, 3, 1, 0, 1, 1, 0, 0 ] ),
      Character( CharacterTable( "M11" ), [ 12, 4, 3, 0, 2, 1, 0, 0, 1, 1 ] ),
      Character( CharacterTable( "M11" ), [ 55, 7, 1, 3, 0, 1, 1, 1, 0, 0 ] ),
      Character( CharacterTable( "M11" ), [ 66, 10, 3, 2, 1, 1, 0, 0, 0, 0 ] ),
      Character( CharacterTable( "M11" ), [ 165, 13, 3, 1, 0, 1, 1, 1, 0, 0 ] ) ]
    gap&#62; Maxes( t );
    [ "A6.2_3", "L2(11)", "3^2:Q8.2", "A5.2", "2.S4" ]

</pre>

<div class="p"><!----></div>
For the other statements, we will use the primitive permutation
representations of S on 11 and 12 points
(which are fetched from the <font face="helvetica">ATLAS</font> of Group Representations&nbsp;[<a href="#AGR" name="CITEAGR">WWT<sup>+</sup></a>]),
and their diagonal product.

<div class="p"><!----></div>

<pre>
    gap&#62; gens11:= OneAtlasGeneratingSet( "M11", NrMovedPoints, 11 );
    rec( charactername := "1a+10a",
      generators := [ (2,10)(4,11)(5,7)(8,9), (1,4,3,8)(2,5,6,9) ],
      groupname := "M11", id := "",
      identifier := [ "M11", [ "M11G1-p11B0.m1", "M11G1-p11B0.m2" ], 1, 11 ],
      isPrimitive := true, maxnr := 1, p := 11, rankAction := 2,
      repname := "M11G1-p11B0", repnr := 1, size := 7920, stabilizer := "A6.2_3",
      standardization := 1, transitivity := 4, type := "perm" )
    gap&#62; g11:= GroupWithGenerators( gens11.generators );;
    gap&#62; gens12:= OneAtlasGeneratingSet( "M11", NrMovedPoints, 12 );;
    gap&#62; g12:= GroupWithGenerators( gens12.generators );;
    gap&#62; g23:= DiagonalProductOfPermGroups( [ g11, g12 ] );
    Group([ (2,10)(4,11)(5,7)(8,9)(12,17)(13,20)(16,18)(19,21), 
      (1,4,3,8)(2,5,6,9)(12,17,18,15)(13,19)(14,20)(16,22,23,21) ])

</pre>

<div class="p"><!----></div>
First we compute that for all nonidentity elements s  &#8712; S
and involutions g  &#8712; S,
P(g,s)  &#8805; 1/3 holds,
with equality if and only if s has order 11;
this implies statement&nbsp;(c).
We actually compute, for class representatives s,
the proportion of involutions g such that
&#9001;g, s &#9002; &#8800; S holds.

<div class="p"><!----></div>

<pre>
    gap&#62; inv:= g11.1;
    (2,10)(4,11)(5,7)(8,9)
    gap&#62; ccl:= List( ConjugacyClasses( g11 ), Representative );;
    gap&#62; SortParallel( List( ccl, Order ), ccl );
    gap&#62; List( ccl, Order );
    [ 1, 2, 3, 4, 5, 6, 8, 8, 11, 11 ]
    gap&#62; Size( ConjugacyClass( g11, inv ) );
    165
    gap&#62; prop:= List( ccl,
    &#62;                 r -&#62; RatioOfNongenerationTransPermGroup( g11, inv, r ) );
    [ 1, 1, 1, 149/165, 25/33, 31/55, 23/55, 23/55, 1/3, 1/3 ]
    gap&#62; Minimum( prop );
    1/3

</pre>

<div class="p"><!----></div>
For the first part of statement&nbsp;(d),
we have to deal only with the case of triples of involutions.

<div class="p"><!----></div>
The 11-cycle s is contained in exactly one maximal subgroup
of S, of index 12.
By Corollary&nbsp;<a href="#existsgoodconjugate1">2.2</a>,
it is enough to show that in the primitive degree 12 representation of S,
the fixed points of no triple (x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>) of involutions in S
can cover all twelve points;
equivalenly (considering complements),
we show that there is no triple such that
the intersection of the sets of <em>moved</em> points is empty.

<div class="p"><!----></div>

<pre>
    gap&#62; inv:= g12.1;
    (1,6)(2,9)(5,7)(8,10)
    gap&#62; moved:= MovedPoints( inv );
    [ 1, 2, 5, 6, 7, 8, 9, 10 ]
    gap&#62; orb12:= Orbit( g12, moved, OnSets );;
    gap&#62; Length( orb12 );
    165
    gap&#62; TripleWithProperty( [ orb12{[1]}, orb12, orb12 ],
    &#62;        list -&#62; IsEmpty( Intersection( list ) ) );
    fail

</pre>

<div class="p"><!----></div>
This implies that the uniform spread of S is at least three.

<div class="p"><!----></div>
Now we show that there is a quadruple consisting of one
element of order three and three involutions whose fixed points cover
all points in the degree 23 representation constructed above;
since the permutation character of this representation is strictly positive,
this implies that S does not have spread four,
by Corollary&nbsp;<a href="#disprovespread">2.3</a>,
and we have proved statement&nbsp;(d).

<div class="p"><!----></div>

<pre>
    gap&#62; inv:= g23.1;
    (2,10)(4,11)(5,7)(8,9)(12,17)(13,20)(16,18)(19,21)
    gap&#62; moved:= MovedPoints( inv );
    [ 2, 4, 5, 7, 8, 9, 10, 11, 12, 13, 16, 17, 18, 19, 20, 21 ]
    gap&#62; orb23:= Orbit( g23, moved, OnSets );;
    gap&#62; three:= ( g23.1*g23.2^2 )^2;
    (2,6,10)(4,8,7)(5,9,11)(12,17,23)(15,18,16)(19,21,22)
    gap&#62; movedthree:= MovedPoints( three );;
    gap&#62; QuadrupleWithProperty( [ [ movedthree ], orb23, orb23, orb23 ],
    &#62;        list -&#62; IsEmpty( Intersection( list ) ) );
    [ [ 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 21, 22, 23 ], 
      [ 1, 3, 4, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 20, 21 ], 
      [ 1, 2, 3, 4, 5, 6, 7, 11, 12, 13, 14, 15, 18, 19, 20, 23 ], 
      [ 1, 2, 3, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 20, 22, 23 ] ]

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.10">
5.10</a>&nbsp;&nbsp;M<sub>12</sub></h3><a name="spreadM12">
</a>

<div class="p"><!----></div>
We show that S = M<sub>12</sub> satisfies the following.

<ol type="1">
<br />(a)
    &#963;(S) = 1/3,
    and this value is attained exactly for &#963;(S,s)
    with s of order 10.
<br />(b)
    For s  &#8712; S of order 10,
    <font face="helvetica"><i>M</i></font>(S,s) consists of two nonconjugate subgroups of the type A<sub>6</sub>.2<sup>2</sup>,
    and one group of the type 2 &times;S<sub>5</sub>.
<br />(c)
    P(S) = 31/99,
    and this value is attained exactly for P(S,s)
    with s of order 10.
<br />(d)
    The uniform spread of S is at least three,
    with s of order 10.
<br />(e)
    &#963;<sup>&#8242;</sup>(<span class="roman">Aut</span>(S), s) = 4/99.</ol>

<div class="p"><!----></div>
Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<a href="#spor">4.1</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "M12" );;
    gap&#62; ProbGenInfoSimple( t );
    [ "M12", 1/3, 2, [ "10A" ], [ 3 ] ]

</pre>

<div class="p"><!----></div>
Statement&nbsp;(b) can be read off from the permutation characters,
and the fact that the only classes of maximal subgroups that contain
elements of order 10 consist of groups of the structures
A<sub>6</sub>.2<sup>2</sup> (two classes) and 2 &times;S<sub>5</sub> (one class),
see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;33].

<div class="p"><!----></div>

<pre>
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 10 );
    13
    gap&#62; prim:= PrimitivePermutationCharacters( t );;
    gap&#62; List( prim, x -&#62; x{ [ 1, spos ] } );
    [ [ 12, 0 ], [ 12, 0 ], [ 66, 1 ], [ 66, 1 ], [ 144, 0 ], [ 220, 0 ], 
      [ 220, 0 ], [ 396, 1 ], [ 495, 0 ], [ 495, 0 ], [ 1320, 0 ] ]
    gap&#62; Maxes( t );
    [ "M11", "M12M2", "A6.2^2", "M12M4", "L2(11)", "3^2.2.S4", "M12M7", "2xS5", 
      "M8.S4", "4^2:D12", "A4xS3" ]

</pre>

<div class="p"><!----></div>
For statement&nbsp;(c) (which implies statement&nbsp;(d)),
we use the primitive permutation representation on 12 points.

<div class="p"><!----></div>

<pre>
    gap&#62; g:= MathieuGroup( 12 );
    Group([ (1,2,3,4,5,6,7,8,9,10,11), (3,7,11,8)(4,10,5,6), 
      (1,12)(2,11)(3,6)(4,8)(5,9)(7,10) ])

</pre>

<div class="p"><!----></div>
First we show that for s of order 10, P(S,s) = 31/99 holds.

<div class="p"><!----></div>

<pre>
    gap&#62; approx:= ApproxP( prim, spos );
    [ 0, 3/11, 1/3, 1/11, 1/132, 13/99, 13/99, 13/396, 1/132, 1/33, 1/33, 1/33, 
      13/396, 0, 0 ]
    gap&#62; 2B:= g.2^2;
    (3,11)(4,5)(6,10)(7,8)
    gap&#62; Size( ConjugacyClass( g, 2B ) );
    495
    gap&#62; ResetGlobalRandomNumberGenerators();
    gap&#62; repeat s:= Random( g );
    &#62;    until Order( s ) = 10;
    gap&#62; prop:= RatioOfNongenerationTransPermGroup( g, 2B, s );
    31/99
    gap&#62; Filtered( approx, x -&#62; x &#62;= prop );
    [ 1/3 ]

</pre>

<div class="p"><!----></div>
Next we show that for s of order different from 10,
P(g,s) is larger than 31/99 for suitable g  &#8712; S<sup>&times;</sup>.
Except for s in the class <tt>6A</tt> (which fixes no point in the degree 12
representation), it suffices to consider g in the class <tt>2B</tt>
(with four fixed points).

<div class="p"><!----></div>

<pre>
    gap&#62; x:= g.2^2;
    (3,11)(4,5)(6,10)(7,8)
    gap&#62; ccl:= List( ConjugacyClasses( g ), Representative );;
    gap&#62; SortParallel( List( ccl, Order ), ccl );
    gap&#62; prop:= List( ccl, r -&#62; RatioOfNongenerationTransPermGroup( g, x, r ) );
    [ 1, 1, 1, 1, 39/55, 1, 1, 29/33, 7/55, 43/55, 383/495, 383/495, 31/99, 5/9,
      5/9 ]
    gap&#62; bad:= Filtered( prop, x -&#62; x &lt; 31/99 );
    [ 7/55 ]
    gap&#62; pos:= Position( prop, bad[1] );;
    gap&#62; [ Order( ccl[ pos ] ), NrMovedPoints( ccl[ pos ] ) ];
    [ 6, 12 ]

</pre>

<div class="p"><!----></div>
In the remaining case, we choose g in the class <tt>2A</tt>
(which is fixed point free).

<div class="p"><!----></div>

<pre>
    gap&#62; x:= g.3;
    (1,12)(2,11)(3,6)(4,8)(5,9)(7,10)
    gap&#62; s:= ccl[ pos ];;
    gap&#62; prop:= RatioOfNongenerationTransPermGroup( g, x, s );
    17/33
    gap&#62; prop &#62; 31/99;
    true

</pre>

<div class="p"><!----></div>
Statement&nbsp;(e) has been shown already in Section&nbsp;<a href="#sporaut">4.2</a>.

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.11">
5.11</a>&nbsp;&nbsp;O<sub>7</sub>(3)</h3><a name="O73">
</a>

<div class="p"><!----></div>
We show that S = O<sub>7</sub>(3) satisfies the following.

<ol type="1">
<br />(a)
    &#963;(S) = 199/351,
    and this value is attained exactly for &#963;(S,s)
    with s of order 14.
<br />(b)
    For s  &#8712; S of order 14,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one group of the type
    2.U<sub>4</sub>(3).2<sub>2</sub> = &#8486;<sup>&#8722;</sup>(6,3).2
    and two nonconjugate groups of the type S<sub>9</sub>.
<br />(c)
    P(S) = 155/351,
    and this value is attained exactly for P(S,s)
    with s of order 14.
<br />(d)
    The uniform spread of S is at least three,
    with s of order 14.
<br />(e)
    &#963;<sup>&#8242;</sup>(<span class="roman">Aut</span>(S), s) = 1/3.</ol>

<div class="p"><!----></div>
Currently <font face="helvetica">GAP</font> provides neither the table of marks of S nor all
character tables of its maximal subgroups.
First we compute those primitive permutation characters of S that have
the degrees
351 (point stabilizer 2.U<sub>4</sub>(3).2<sub>2</sub>),
364 (point stabilizer 3<sup>5</sup>:U<sub>4</sub>(2).2),
378 (point stabilizer L<sub>4</sub>(3).2<sub>2</sub>),
1&nbsp;080 (point stabilizer G<sub>2</sub>(3), two classes),
1&nbsp;120 (point stabilizer 3<sup>3+3</sup>:L<sub>3</sub>(3)),
3&nbsp;159 (point stabilizer S<sub>6</sub>(2), two classes),
12&nbsp;636 (point stabilizer S<sub>9</sub>, two classes),
22&nbsp;113 (point stabilizer (2<sup>2</sup> &times;U<sub>4</sub>(2)).2,
which extends to D<sub>8</sub> &times;U<sub>4</sub>(2).2 in O<sub>7</sub>(3).2), and
28&nbsp;431 (point stabilizer 2<sup>6</sup>:A<sub>7</sub>).

<div class="p"><!----></div>
(So we ignore the primitive permutation characters of the degrees 3&nbsp;640,
265&nbsp;356, and 331&nbsp;695.
Note that the orders of the corresponding subgroups are not divisible by 7.)

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "O7(3)" );;
    gap&#62; someprim:= [];;
    gap&#62; pi:= PossiblePermutationCharacters(
    &#62;             CharacterTable( "2.U4(3).2_2" ), t );;  Length( pi );
    1
    gap&#62; Append( someprim, pi );
    gap&#62; pi:= PermChars( t, rec( torso:= [ 364 ] ) );;  Length( pi );
    1
    gap&#62; Append( someprim, pi );
    gap&#62; pi:= PossiblePermutationCharacters(
    &#62;             CharacterTable( "L4(3).2_2" ), t );;  Length( pi );
    1
    gap&#62; Append( someprim, pi );
    gap&#62; pi:= PossiblePermutationCharacters( CharacterTable( "G2(3)" ), t );
    [ Character( CharacterTable( "O7(3)" ), [ 1080, 0, 0, 24, 108, 0, 0, 0, 27, 
          18, 9, 0, 12, 4, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 3, 6, 0, 3, 
          2, 2, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 4, 0, 3, 0, 1, 1, 0, 0, 0, 0, 0, 
          0, 0 ] ), Character( CharacterTable( "O7(3)" ), 
        [ 1080, 0, 0, 24, 108, 0, 0, 27, 0, 18, 9, 0, 12, 4, 0, 0, 0, 0, 0, 0, 0, 
          0, 12, 0, 0, 0, 0, 3, 0, 0, 6, 3, 2, 2, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 
          0, 4, 3, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0 ] ) ]
    gap&#62; Append( someprim, pi );
    gap&#62; pi:= PermChars( t, rec( torso:= [ 1120 ] ) );;  Length( pi );
    1
    gap&#62; Append( someprim, pi );
    gap&#62; pi:= PossiblePermutationCharacters( CharacterTable( "S6(2)" ), t );
    [ Character( CharacterTable( "O7(3)" ), [ 3159, 567, 135, 39, 0, 81, 0, 0, 
          27, 27, 0, 15, 3, 3, 7, 4, 0, 27, 0, 0, 0, 0, 0, 9, 3, 0, 9, 0, 3, 9, 
          3, 0, 2, 1, 1, 0, 0, 0, 3, 0, 2, 0, 0, 0, 3, 0, 0, 3, 1, 0, 0, 0, 1, 0, 
          0, 0, 0, 0 ] ), Character( CharacterTable( "O7(3)" ), 
        [ 3159, 567, 135, 39, 0, 81, 0, 27, 0, 27, 0, 15, 3, 3, 7, 4, 0, 27, 0, 
          0, 0, 0, 0, 9, 3, 0, 9, 3, 0, 3, 9, 0, 2, 1, 1, 0, 0, 3, 0, 0, 2, 0, 0, 
          0, 3, 0, 3, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 ] ) ]
    gap&#62; Append( someprim, pi );
    gap&#62; pi:= PossiblePermutationCharacters( CharacterTable( "S9" ), t );
    [ Character( CharacterTable( "O7(3)" ), [ 12636, 1296, 216, 84, 0, 81, 0, 0, 
          108, 27, 0, 6, 0, 12, 10, 1, 0, 27, 0, 0, 0, 0, 0, 9, 3, 0, 9, 0, 12, 
          9, 3, 0, 1, 0, 2, 0, 0, 0, 3, 1, 1, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 1, 1, 
          0, 0, 0, 0, 1 ] ), Character( CharacterTable( "O7(3)" ), 
        [ 12636, 1296, 216, 84, 0, 81, 0, 108, 0, 27, 0, 6, 0, 12, 10, 1, 0, 27, 
          0, 0, 0, 0, 0, 9, 3, 0, 9, 12, 0, 3, 9, 0, 1, 0, 2, 0, 0, 3, 0, 1, 1, 
          0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1 ] ) ]
    gap&#62; Append( someprim, pi );
    gap&#62; t2:= CharacterTable( "O7(3).2" );;
    gap&#62; s2:= CharacterTable( "Dihedral", 8 ) * CharacterTable( "U4(2).2" );
    CharacterTable( "Dihedral(8)xU4(2).2" )
    gap&#62; pi:= PossiblePermutationCharacters( s2, t2 );;  Length( pi );
    1
    gap&#62; pi:= RestrictedClassFunctions( pi, t );;
    gap&#62; Append( someprim, pi );
    gap&#62; pi:= PossiblePermutationCharacters(
    &#62;             CharacterTable( "2^6:A7" ), t );;  Length( pi );
    1
    gap&#62; Append( someprim, pi );
    gap&#62; List( someprim, x -&#62; x[1] );
    [ 351, 364, 378, 1080, 1080, 1120, 3159, 3159, 12636, 12636, 22113, 28431 ]

</pre>

<div class="p"><!----></div>
Note that in the three cases where two possible permutation characters
were found, there are in fact two classes of subgroups that induce
different permutation characters.
For the subgroups of the types G<sub>2</sub>(3) and S<sub>6</sub>(2),
this is stated in&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;109],
and for the subgroups of the type S<sub>9</sub>,
this follows from the fact that each S<sub>9</sub> type subgroup in S contains
elements in exactly one of the classes <tt>3D</tt> or <tt>3E</tt>,
and these two classes are fused by the outer automorphism of S.

<div class="p"><!----></div>

<pre>
    gap&#62; cl:= PositionsProperty( AtlasClassNames( t ),
    &#62;                            x -&#62; x in [ "3D", "3E" ] );
    [ 8, 9 ]
    gap&#62; List( Filtered( someprim, x -&#62; x[1] = 12636 ), pi -&#62; pi{ cl } );
    [ [ 0, 108 ], [ 108, 0 ] ]
    gap&#62; GetFusionMap( t, t2 ){ cl };
    [ 8, 8 ]

</pre>

<div class="p"><!----></div>
Now we compute the lower bounds for &#963;( S, s<sup>&#8242;</sup> ) that are given
by the sublist <tt>someprim</tt> of the primitive permutation characters.

<div class="p"><!----></div>

<pre>
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 14 );
    52
    gap&#62; Maximum( ApproxP( someprim, spos ) );
    199/351

</pre>

<div class="p"><!----></div>
This shows that &#963;( S, s ) = 199/351 holds.
For statement&nbsp;(a),
we have to show that choosing s<sup>&#8242;</sup> from another class than <tt>14A</tt>
yields a larger value for &#963;( S, s<sup>&#8242;</sup> ).

<div class="p"><!----></div>

<pre>
    gap&#62; approx:= List( [ 1 .. NrConjugacyClasses( t ) ],
    &#62;       i -&#62; Maximum( ApproxP( someprim, i ) ) );;
    gap&#62; PositionsProperty( approx, x -&#62; x &lt;= 199/351 );
    [ 52 ]

</pre>

<div class="p"><!----></div>
Statement&nbsp;(b) can be read off from the permutation characters.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= PositionsProperty( someprim, x -&#62; x[ spos ] &lt;&#62; 0 );
    [ 1, 9, 10 ]
    gap&#62; List( someprim{ pos }, x -&#62; x{ [ 1, spos ] } );
    [ [ 351, 1 ], [ 12636, 1 ], [ 12636, 1 ] ]

</pre>

<div class="p"><!----></div>
For statement&nbsp;(c), we first compute P(g, s) for g in the class
<tt>2A</tt>, via explicit computations with the group.
For dealing with this case, we first construct a faithful permutation
representation of O<sub>7</sub>(3) from the natural matrix representation of
<span class="roman">SO</span>(7,3).

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; so73:= SpecialOrthogonalGroup( 7, 3 );;
    gap&#62; o73:= DerivedSubgroup( so73 );;
    gap&#62; orbs:= Orbits( o73, Elements( GF(3)^7 ) );;
    gap&#62; Set( List( orbs, Length ) );
    [ 1, 702, 728, 756 ]
    gap&#62; g:= Action( o73, First( orbs, x -&#62; Length( x ) = 702 ) );;
    gap&#62; Size( g ) = Size( t );
    true

</pre>

<div class="p"><!----></div>
A <tt>2A</tt> element g can be found as the 7-th power of any element
of order 14 in S.

<div class="p"><!----></div>

<pre>
    gap&#62; ResetGlobalRandomNumberGenerators();
    gap&#62; repeat s:= Random( g );
    &#62;    until Order( s ) = 14;
    gap&#62; 2A:= s^7;;
    gap&#62; bad:= RatioOfNongenerationTransPermGroup( g, 2A, s );
    155/351
    gap&#62; bad &#62; 1/3;
    true
    gap&#62; approx:= ApproxP( someprim, spos );;
    gap&#62; PositionsProperty( approx, x -&#62; x &#62;= 1/3 );
    [ 2 ]

</pre>

<div class="p"><!----></div>
This shows that P(g,s) = 155/351  &gt;  1/3.
Since &#963;( g, s )  &lt;  1/3 for all nonidentity g not in the class
<tt>2A</tt>, we have P( S, s ) = 155/351.
For statement&nbsp;(c), it remains to show that P( S, s<sup>&#8242;</sup> ) is larger
than 155/351 whenever s<sup>&#8242;</sup> is not of order 14.
First we compute P( g, s<sup>&#8242;</sup> ), for g in the class <tt>2A</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; consider:= RepresentativesMaximallyCyclicSubgroups( t );
    [ 18, 19, 25, 26, 27, 30, 31, 32, 34, 35, 38, 39, 41, 42, 43, 44, 45, 46, 47, 
      48, 49, 50, 52, 53, 54, 56, 57, 58 ]
    gap&#62; Length( consider );
    28
    gap&#62; consider:= ClassesPerhapsCorrespondingToTableColumns( g, t, consider );;
    gap&#62; Length( consider );
    31
    gap&#62; consider:= List( consider, Representative );;
    gap&#62; SortParallel( List( consider, Order ), consider );
    gap&#62; app2A:= List( consider, c -&#62;
    &#62;       RatioOfNongenerationTransPermGroup( g, 2A, c ) );
    [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 85/117, 1, 10/13, 10/13, 1, 1, 23/39, 23/39, 1,
      1, 1, 1, 1, 1/3, 1/3, 155/351, 67/117, 1, 1, 1, 1, 191/351 ]
    gap&#62; test:= PositionsProperty( app2A, x -&#62; x &lt;= 155/351 );
    [ 23, 24, 25 ]
    gap&#62; List( test, i -&#62; Order( consider[i] ) );
    [ 13, 13, 14 ]

</pre>

<div class="p"><!----></div>
We see that only for s<sup>&#8242;</sup> in one of the two (algebraically conjugate)
classes of element order 13,
P( S, s<sup>&#8242;</sup> ) has a chance to be smaller than 155/351.
This possibility is now excluded by counting elements in the class <tt>3A</tt>
that do not generate S together with s<sup>&#8242;</sup> of order 13.

<div class="p"><!----></div>

<pre>
    gap&#62; C3A:= First( ConjugacyClasses( g ),
    &#62;               c -&#62; Order( Representative( c ) ) = 3 and Size( c ) = 7280 );;
    gap&#62; repeat ss:= Random( g );
    &#62;    until Order( ss ) = 13;
    gap&#62; bad:= RatioOfNongenerationTransPermGroup( g, Representative( C3A ), ss );
    17/35
    gap&#62; bad &#62; 155/351;
    true

</pre>

<div class="p"><!----></div>
Now we show statement&nbsp;(d):
For each triple (x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>) of nonidentity elements in S,
there is an element s in the class <tt>14A</tt> such that
&#9001;x<sub>i</sub>, s &#9002; =  S holds for 1  &#8804; i  &#8804; 3.
We can read off from the character-theoretic data that
only those triples have to be checked for which at least two
elements are contained in the class <tt>2A</tt>,
and the third element lies in one of the classes
<tt>2A</tt>, <tt>2B</tt>, <tt>3B</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; approx:= ApproxP( someprim, spos );;
    gap&#62; max:= Maximum( approx{ [ 3 .. Length( approx ) ] } );
    59/351
    gap&#62; 155 + 2*59 &lt; 351;
    true
    gap&#62; third:= PositionsProperty( approx, x -&#62; 2 * 155/351 + x &#62;= 1 );
    [ 2, 3, 6 ]
    gap&#62; ClassNames( t ){ third };
    [ "2a", "2b", "3b" ]

</pre>

<div class="p"><!----></div>
We can find elements in the classes <tt>2B</tt> and <tt>3B</tt> as powers
of arbitrary elements of the orders 20 and 15, respectively.

<div class="p"><!----></div>

<pre>
    gap&#62; ord20:= PositionsProperty( OrdersClassRepresentatives( t ),
    &#62;                               x -&#62; x = 20 );
    [ 58 ]
    gap&#62; PowerMap( t, 10 ){ ord20 };
    [ 3 ]
    gap&#62; repeat x:= Random( g );
    &#62;    until Order( x ) = 20;
    gap&#62; 2B:= x^10;;
    gap&#62; C2B:= ConjugacyClass( g, 2B );;
    gap&#62; ord15:= PositionsProperty( OrdersClassRepresentatives( t ),
    &#62;                               x -&#62; x = 15 );
    [ 53 ]
    gap&#62; PowerMap( t, 10 ){ ord15 };
    [ 6 ]
    gap&#62; repeat x:= Random( g );
    &#62;    until Order( x ) = 15;
    gap&#62; 3B:= x^5;;
    gap&#62; C3B:= ConjugacyClass( g, 3B );;

</pre>

<div class="p"><!----></div>
The existence of s can be shown with the random approach
described in Section&nbsp;<a href="#groups">3.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; repeat s:= Random( g );
    &#62;    until Order( s ) = 14;
    gap&#62; RandomCheckUniformSpread( g, [ 2A, 2A, 2A ], s, 50 );
    true
    gap&#62; RandomCheckUniformSpread( g, [ 2B, 2A, 2A ], s, 50 );
    true
    gap&#62; RandomCheckUniformSpread( g, [ 3B, 2A, 2A ], s, 50 );
    true

</pre>

<div class="p"><!----></div>
Finally, we show statement&nbsp;(e).
Let G = <span class="roman">Aut</span>(S) = S.2.
By&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;109], <font face="helvetica"><i>M</i></font><sup>&#8242;</sup>(G,s) consists of the extension
of the 2.U<sub>4</sub>(3).2<sub>1</sub> type subgroup.
We compute the extension of the permutation character.

<div class="p"><!----></div>

<pre>
    gap&#62; prim:= someprim{ [ 1 ] };
    [ Character( CharacterTable( "O7(3)" ), [ 351, 127, 47, 15, 27, 45, 36, 0, 0, 
          9, 0, 15, 3, 3, 7, 6, 19, 19, 10, 11, 12, 8, 3, 5, 3, 6, 1, 0, 0, 3, 3, 
          0, 1, 1, 1, 6, 3, 0, 0, 2, 2, 0, 3, 0, 3, 3, 0, 0, 1, 0, 0, 1, 0, 4, 4, 
          1, 2, 0 ] ) ]
    gap&#62; spos:= Position( AtlasClassNames( t ), "14A" );;
    gap&#62; t2:= CharacterTable( "O7(3).2" );;
    gap&#62; map:= InverseMap( GetFusionMap( t, t2 ) );;
    gap&#62; torso:= List( prim, pi -&#62; CompositionMaps( pi, map ) );;
    gap&#62; ext:= List( torso, x -&#62; PermChars( t2, rec( torso:= x ) ) );
    [ [ Character( CharacterTable( "O7(3).2" ), [ 351, 127, 47, 15, 27, 45, 36, 
              0, 9, 0, 15, 3, 3, 7, 6, 19, 19, 10, 11, 12, 8, 3, 5, 3, 6, 1, 0, 
              3, 0, 1, 1, 1, 6, 3, 0, 2, 2, 0, 3, 0, 3, 3, 0, 1, 0, 0, 1, 0, 4, 
              1, 2, 0, 117, 37, 21, 45, 1, 13, 5, 1, 9, 9, 18, 15, 1, 7, 9, 6, 4, 
              0, 3, 0, 3, 3, 6, 2, 2, 9, 6, 1, 3, 1, 4, 1, 2, 1, 1, 0, 3, 1, 0, 
              0, 0, 0, 1, 1, 0, 0 ] ) ] ]
    gap&#62; approx:= ApproxP( Concatenation( ext ),
    &#62;        Position( AtlasClassNames( t2 ), "14A" ) );;
    gap&#62; Maximum( approx{ Difference(
    &#62;      PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),
    &#62;      ClassPositionsOfDerivedSubgroup( t2 ) ) } );
    1/3

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.12">
5.12</a>&nbsp;&nbsp;O<sub>8</sub><sup>+</sup>(2)</h3><a name="O8p2">
</a>

<div class="p"><!----></div>
We show that S = O<sub>8</sub><sup>+</sup>(2) = &#8486;<sup>+</sup>(8,2) satisfies the following.

<ol type="1">
<br />(a)
    &#963;(S) = 334/315,
    and this value is attained exactly for &#963;(S,s)
    with s of order 15.
<br />(b)
    For s  &#8712; S of order 15,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one group of the type S<sub>6</sub>(2),
    two conjugate groups of the type 2<sup>6</sup>:A<sub>8</sub>,
    two conjugate groups of the type A<sub>9</sub>,
    and one group of each of the types
    (3 &times;U<sub>4</sub>(2)):2 = (3 &times;&#8486;<sup>&#8722;</sup>(6,2)):2 and
    (A<sub>5</sub> &times;A<sub>5</sub>):2<sup>2</sup> = (&#8486;<sup>&#8722;</sup>(4,2) &times;&#8486;<sup>&#8722;</sup>(4,2)):2<sup>2</sup>.
<br />(c)
    P(S) = 29/42,
    and this value is attained exactly for P(S,s)
    with s of order 15.
<br />(d)
    Let x, y  &#8712; S such that x, y, x y lie in the unique involution class
    of length 1&nbsp;575 of S.
    (This is the class <tt>2A</tt>.)
    Then each element in S together with one of x, y, x y
    generates a proper subgroup of S.
<br />(e)
    Both the spread and the uniform spread of S is exactly two,
    with s of order 15.
<br />(f)
    For each choice of s  &#8712; S, there is an extension S.2 such that
    for any element g in the (outer) class <tt>2F</tt>,
    &#9001;s, g &#9002; does not contain S.
<br />(g)
    For an element s of order 15 in S,
    either S is the only maximal subgroup of S.2 that contains s,
    or the maximal subgroups of S.2 that contain s
    are S and the extensions of the subgroups listed in statement&nbsp;(b);
    these groups have the structures S<sub>6</sub>(2) &times;2, 2<sup>6</sup>:S<sub>8</sub> (twice),
    S<sub>9</sub> (twice), S<sub>3</sub> &times;U<sub>4</sub>(2).2, and

<br />(h)
    For s  &#8712; S of order 15 and arbitrary g  &#8712; S.3 \S,
    we have &#9001;s, g &#9002; =  S.3.
<br />(i)
    If x, y are nonidentity elements in <span class="roman">Aut</span>(S) then there is an
    element s of order 15 in S such that
    S  &#8838; &#9001;x, s &#9002;&#8745;&#9001;y, s &#9002;.</ol>

<div class="p"><!----></div>
Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<a href="#easyloop">4.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "O8+(2)" );;
    gap&#62; ProbGenInfoSimple( t );
    [ "O8+(2)", 334/315, 0, [ "15A", "15B", "15C" ], [ 7, 7, 7 ] ]

</pre>

<div class="p"><!----></div>
Statement&nbsp;(b) can be read off from the permutation characters,
and the fact that the only classes of maximal subgroups that contain
elements of order 15 consist of groups of the structures
as claimed, see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;85].

<div class="p"><!----></div>

<pre>
    gap&#62; prim:= PrimitivePermutationCharacters( t );;
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 15 );;
    gap&#62; List( Filtered( prim, x -&#62; x[ spos ] &lt;&#62; 0 ), l -&#62; l{ [ 1, spos ] } );
    [ [ 120, 1 ], [ 135, 2 ], [ 960, 2 ], [ 1120, 1 ], [ 12096, 1 ] ]

</pre>

<div class="p"><!----></div>
For the remaining statements,
we take a primitive permutation representation on 120 points,
and assume that the permutation character is <tt>1a+35a+84a</tt>.
(See&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;85], note that the three classes of maximal subgroups
of index 120 in S are conjugate under triality.)

<div class="p"><!----></div>

<pre>
    gap&#62; matgroup:= DerivedSubgroup( GeneralOrthogonalGroup( 1, 8, 2 ) );;
    gap&#62; points:= NormedRowVectors( GF(2)^8 );;
    gap&#62; orbs:= Orbits( matgroup, points );;
    gap&#62; List( orbs, Length );
    [ 135, 120 ]
    gap&#62; g:= Action( matgroup, orbs[2] );;
    gap&#62; Size( g );
    174182400
    gap&#62; pi:= Sum( Irr( t ){ [ 1, 3, 7 ] } );
    Character( CharacterTable( "O8+(2)" ), [ 120, 24, 32, 0, 0, 8, 36, 0, 0, 3, 
      6, 12, 4, 8, 0, 0, 0, 10, 0, 0, 12, 0, 0, 8, 0, 0, 3, 6, 0, 0, 2, 0, 0, 2, 
      1, 2, 2, 3, 0, 0, 2, 0, 0, 0, 0, 0, 3, 2, 0, 0, 1, 0, 0 ] )

</pre>

<div class="p"><!----></div>
In order to show statement&nbsp;(c),
we first observe that for s in the class <tt>15A</tt>
and g <em>not</em> in one of the classes <tt>2A</tt>, <tt>2B</tt>, <tt>3A</tt>,
&#963;(g,s)  &lt;  1/3 holds,
and for the exceptional three classes,
we have &#963;(g,s)  &gt;  1/2.

<div class="p"><!----></div>

<pre>
    gap&#62; approx:= ApproxP( prim, spos );;
    gap&#62; testpos:= PositionsProperty( approx, x -&#62; x &#62;= 1/3 );
    [ 2, 3, 7 ]
    gap&#62; AtlasClassNames( t ){ testpos };
    [ "2A", "2B", "3A" ]
    gap&#62; approx{ testpos };
    [ 254/315, 334/315, 1093/1120 ]
    gap&#62; ForAll( approx{ testpos }, x -&#62; x &#62; 1/2 );
    true

</pre>

<div class="p"><!----></div>
Now we compute the values P(g,s), for s in the class <tt>15A</tt>
and g in one of the classes <tt>2A</tt>, <tt>2B</tt>, <tt>3A</tt>.

<div class="p"><!----></div>
By our choice of the character of the permutation representation we use,
the class <tt>15A</tt> is determined as the unique class of element order 15
with one fixed point.
(Note that the three classes of element order 15 in S are conjugate
under triality.)
A <tt>2A</tt> element can be found as the fourth power of any element of order
8 in S,
a <tt>3A</tt> element can be found as the fifth power of a <tt>15A</tt> element,
and a <tt>2B</tt> element can be found as the sixth power of an element
of order 12, with 32 fixed points.

<div class="p"><!----></div>

<pre>
    gap&#62; ResetGlobalRandomNumberGenerators();
    gap&#62; repeat s:= Random( g );
    &#62;    until Order( s ) = 15 and NrMovedPoints( g ) = 1 + NrMovedPoints( s );
    gap&#62; 3A:= s^5;;
    gap&#62; repeat x:= Random( g ); until Order( x ) = 8;
    gap&#62; 2A:= x^4;;
    gap&#62; repeat x:= Random( g ); until Order( x ) = 12 and
    &#62;      NrMovedPoints( g ) = 32 + NrMovedPoints( x^6 );
    gap&#62; 2B:= x^6;;
    gap&#62; prop15A:= List( [ 2A, 2B, 3A ],
    &#62;                    x -&#62; RatioOfNongenerationTransPermGroup( g, x, s ) );
    [ 23/35, 29/42, 149/224 ]
    gap&#62; Maximum( prop15A );
    29/42

</pre>

<div class="p"><!----></div>
This means that for s in the class <tt>15A</tt>,
we have P( S, s ) = 29/42,
and the same holds for all s of order 15
since the three classes of element order 15 are conjugate under triality.
Now we show that for s of order different from 15,
the value P(g,s) is larger than 29/42,
for g in one of the classes <tt>2A</tt>, <tt>2B</tt>, <tt>3A</tt>,
or their images under triality.
This implies statement&nbsp;(c).

<div class="p"><!----></div>

<pre>
    gap&#62; test:= List( [ 2A, 2B, 3A ], x -&#62; ConjugacyClass( g, x ) );;
    gap&#62; ccl:= ConjugacyClasses( g );;
    gap&#62; consider:= Filtered( ccl, c -&#62; Size( c ) in List( test, Size ) );;
    gap&#62; Length( consider );
    7
    gap&#62; filt:= Filtered( ccl, c -&#62; ForAll( consider, cc -&#62;
    &#62;       RatioOfNongenerationTransPermGroup( g, Representative( cc ),
    &#62;           Representative( c ) ) &lt;= 29/42 ) );;
    gap&#62; Length( filt );
    3
    gap&#62; List( filt, c -&#62; Order( Representative( c ) ) );
    [ 15, 15, 15 ]

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
Now we show statement&nbsp;(d).
First we observe that all those Klein four groups in S whose involutions
lie in the class <tt>2A</tt> are conjugate in S.
Note that this is the unique class of length 1&nbsp;575 in S,
and also the unique class whose elements have 24 fixed points
in the degree 120 permutation representation.

<div class="p"><!----></div>
For that, we use the character table of S to read off that S contains
exactly 14&nbsp;175 such subgroups,
and we use the group to compute one such subgroup and its normalizer
of index 14&nbsp;175.

<div class="p"><!----></div>

<pre>
    gap&#62; SizesConjugacyClasses( t );
    [ 1, 1575, 3780, 3780, 3780, 56700, 2240, 2240, 2240, 89600, 268800, 37800,
      340200, 907200, 907200, 907200, 2721600, 580608, 580608, 580608, 100800,
      100800, 100800, 604800, 604800, 604800, 806400, 806400, 806400, 806400,
      2419200, 2419200, 2419200, 7257600, 24883200, 5443200, 5443200, 6451200,
      6451200, 6451200, 8709120, 8709120, 8709120, 1209600, 1209600, 1209600,
      4838400, 7257600, 7257600, 7257600, 11612160, 11612160, 11612160 ]
    gap&#62; NrPolyhedralSubgroups( t, 2, 2, 2 );
    rec( number := 14175, type := "V4" )
    gap&#62; repeat x:= Random( g );
    &#62;    until     Order( x ) mod 2 = 0
    &#62;          and NrMovedPoints( x^( Order(x)/2 ) ) = 120 - 24;
    gap&#62; x:= x^( Order(x)/2 );;
    gap&#62; repeat y:= x^Random( g );
    &#62;    until NrMovedPoints( x*y ) = 120 - 24;
    gap&#62; v4:= SubgroupNC( g, [ x, y ] );;
    gap&#62; n:= Normalizer( g, v4 );;
    gap&#62; Index( g, n );
    14175

</pre>

<div class="p"><!----></div>
We verify that the triple has the required property.

<div class="p"><!----></div>

<pre>
    gap&#62; maxorder:= RepresentativesMaximallyCyclicSubgroups( t );;
    gap&#62; maxorderreps:= List( ClassesPerhapsCorrespondingToTableColumns( g, t,
    &#62;        maxorder ), Representative );;
    gap&#62; Length( maxorderreps );
    28
    gap&#62; CommonGeneratorWithGivenElements( g, maxorderreps, [ x, y, x*y ] );
    fail

</pre>

<div class="p"><!----></div>
For the simple group S, it remains to show statement&nbsp;(e).
We want to show that for any choice of two nonidentity elements x, y
in S, there is an element s in the class <tt>15A</tt> such that
&#9001;s, x &#9002; =  &#9001;s, y &#9002; =  S holds.
Only x, y in the classes given by the list <tt>testpos</tt> must be considered,
by the estimates &#963;(g,s).

<div class="p"><!----></div>
We replace the values &#963;(g,s) by the exact values P(g,s),
for g in one of these three classes.
Each of the three classes is determined by its element order and its number
of fixed points.

<div class="p"><!----></div>

<pre>
    gap&#62; reps:= List( ccl, Representative );;
    gap&#62; bading:= List( testpos, i -&#62; Filtered( reps,
    &#62;        r -&#62; Order( r ) = OrdersClassRepresentatives( t )[i] and
    &#62;             NrMovedPoints( r ) = 120 - pi[i] ) );;
    gap&#62; List( bading, Length );
    [ 1, 1, 1 ]
    gap&#62; bading:= List( bading, x -&#62; x[1] );;

</pre>

<div class="p"><!----></div>
For each pair (C<sub>1</sub>, C<sub>2</sub>) of classes represented by this list,
we have to show that for any choice of elements x  &#8712; C<sub>1</sub>, y  &#8712; C<sub>2</sub>
there is s in the class <tt>15A</tt> such that
&#9001;s, x &#9002; =  &#9001;s, y &#9002; =  S holds.
This is done with the random approach that is described in
Section&nbsp;<a href="#groups">3.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; for pair in UnorderedTuples( bading, 2 ) do
    &#62;      test:= RandomCheckUniformSpread( g, pair, s, 80 );
    &#62;      if test &lt;&#62; true then
    &#62;        Error( test );
    &#62;      fi;
    &#62;    od;

</pre>

<div class="p"><!----></div>
We get no error message, so statement&nbsp;(e) holds.

<div class="p"><!----></div>

<div class="p"><!----></div>
Now we turn to the automorphic extensions of S.
First we compute a permutation representation of <span class="roman">SO</span><sup>+</sup>(8,2)  &#8773; S.2
and an element g in the class <tt>2F</tt>,
which is the unique conjugacy class of size 120 in S.2.

<div class="p"><!----></div>

<pre>
    gap&#62; matgrp:= SO(1,8,2);;
    gap&#62; g2:= Image( IsomorphismPermGroup( matgrp ) );;
    gap&#62; IsTransitive( g2, MovedPoints( g2 ) );
    true
    gap&#62; repeat x:= Random( g2 ); until Order( x ) = 14;
    gap&#62; 2F:= x^7;;
    gap&#62; Size( ConjugacyClass( g2, 2F ) );
    120

</pre>

<div class="p"><!----></div>
Only for s in six conjugacy classes of S,
there is a nonzero probability to have S.2 = &#9001;g, s &#9002;.

<div class="p"><!----></div>

<pre>
    gap&#62; der:= DerivedSubgroup( g2 );;
    gap&#62; cclreps:= List( ConjugacyClasses( der ), Representative );;
    gap&#62; nongen:= List( cclreps,
    &#62;               x -&#62; RatioOfNongenerationTransPermGroup( g2, 2F, x ) );;
    gap&#62; goodpos:= PositionsProperty( nongen, x -&#62; x &lt; 1 );;
    gap&#62; invariants:= List( goodpos, i -&#62; [ Order( cclreps[i] ),
    &#62;      Size( Centralizer( g2, cclreps[i] ) ), nongen[i] ] );;
    gap&#62; SortedList( invariants );
    [ [ 10, 20, 1/3 ], [ 10, 20, 1/3 ], [ 12, 24, 2/5 ], [ 12, 24, 2/5 ],
      [ 15, 15, 0 ], [ 15, 15, 0 ] ]

</pre>

<div class="p"><!----></div>
S contains three classes of element order 10, which are conjugate
in S.3.
For a fixed extension of the type S.2,
the element s can be chosen only in two of these three classes,
which means that there is another group of the type S.2
(more precisely, another subgroup of index three in S.S<sub>3</sub>)
in which this choice of s is not suitable
- note that the general aim is to find s  &#8712; S uniformly for all
automorphic extensions of S.
Analogous statements hold for the other possibilities for s,
so statement&nbsp;(f) follows.

<div class="p"><!----></div>
Statement&nbsp;(g) follows from the list of maximal subgroups
in&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;85].

<div class="p"><!----></div>
Statement&nbsp;(h) follows from the fact that S is the only maximal
subgroup of S.3 that contains elements of order 15,
according to the list of maximal subgroups in&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;85].
Alternatively, if we do not want to assume this information,
we can use explicit computations, as follows.
All we have to check is that any element in the classes <tt>3F</tt> and <tt>3G</tt>
generates S.3 together with a fixed element of order 15 in S.

<div class="p"><!----></div>
We compute a permutation representation of S.3 as the derived subgroup
of a subgroup of the type S.S<sub>3</sub> inside the sporadic simple Fischer group
Fi<sub>22</sub>;
these subgroups lie in the fourth class of maximal subgroups of Fi<sub>22</sub>,
see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;163].
An element in the class <tt>3F</tt> of S.3 can be found as a power of
an order 21 element,
and an element in the class <tt>3G</tt> can be found as the fourth power of
a <tt>12P</tt> element.

<div class="p"><!----></div>

<pre>
    gap&#62; aut:= Group( AtlasGenerators( "Fi22", 1, 4 ).generators );;
    gap&#62; Size( aut ) = 6 * Size( t );
    true
    gap&#62; g3:= DerivedSubgroup( aut );;
    gap&#62; orbs:= Orbits( g3, MovedPoints( g3 ) );;
    gap&#62; List( orbs, Length );
    [ 3150, 360 ]
    gap&#62; g3:= Action( g3, orbs[2] );;
    gap&#62; repeat s:= Random( g3 ); until Order( s ) = 15;
    gap&#62; repeat x:= Random( g3 ); until Order( x ) = 21;
    gap&#62; 3F:= x^7;;
    gap&#62; RatioOfNongenerationTransPermGroup( g3, 3F, s );
    0
    gap&#62; repeat x:= Random( g3 );
    &#62;    until Order( x ) = 12 and Size( Centralizer( g3, x^4 ) ) = 648;
    gap&#62; 3G:= x^4;;
    gap&#62; RatioOfNongenerationTransPermGroup( g3, 3G, s );
    0

</pre>

<div class="p"><!----></div>
Finally, consider statement&nbsp;(i).
It implies that&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Corollary&nbsp;1.5] holds
for &#8486;<sup>+</sup>(8,2), with s of order 15.
Note that by part&nbsp;(f),
s <em>cannot be chosen in a prescribed conjugacy class</em> of S
that is independent of the elements x, y.

<div class="p"><!----></div>
If x and y lie in S then statement&nbsp;(i) follows from part&nbsp;(e),
and by part&nbsp;(g), the case that x or y lie in S.3 \S
is also not a problem.
We now show that also x or y in S.2 \S is not a problem.
Here we have to deal with the cases that x and y lie in the same
subgroup of index 3 in <span class="roman">Aut</span>(S) or in different such subgroups.
Actually we show that for each index 3 subgroup H = S.2  &lt;  <span class="roman">Aut</span>(S),
we can choose s from two of the three classes of element order 15 in S
such that S is the only maximal subgroup of H that contains s,
and thus &#9001;x, s &#9002; contains H,
for any choice of x  &#8712; H \S.

<div class="p"><!----></div>
For that, we note that no novelty in S.2 contains elements of order 15,
so all maximal subgroups of S.2 that contain such elements -besides S-
have one of the indices 120, 135, 960, 1120, or 12096,
and point stabilizers of the types S<sub>6</sub>(2) &times;2, 2<sup>6</sup>:S<sub>8</sub>, S<sub>9</sub>,
S<sub>3</sub> &times;U<sub>4</sub>(2):2, or

 S<sub>5</sub> &#8768; 2.
We compute the corresponding permutation characters.

<div class="p"><!----></div>

<pre>
    gap&#62; t2:= CharacterTable( "O8+(2).2" );;
    gap&#62; s:= CharacterTable( "S6(2)" ) * CharacterTable( "Cyclic", 2 );;
    gap&#62; pi:= PossiblePermutationCharacters( s, t2 );;
    gap&#62; prim:= pi;;
    gap&#62; pi:= PermChars( t2, rec( torso:= [ 135 ] ) );;
    gap&#62; Append( prim, pi );
    gap&#62; pi:= PossiblePermutationCharacters( CharacterTable( "A9.2" ), t2 );;
    gap&#62; Append( prim, pi );
    gap&#62; s:= CharacterTable( "Dihedral(6)" ) * CharacterTable( "U4(2).2" );;
    gap&#62; pi:= PossiblePermutationCharacters( s, t2 );;
    gap&#62; Append( prim, pi );
    gap&#62; s:= CharacterTableWreathSymmetric( CharacterTable( "S5" ), 2 );;
    gap&#62; pi:= PossiblePermutationCharacters( s, t2 );;
    gap&#62; Append( prim, pi );
    gap&#62; Length( prim );
    5
    gap&#62; ord15:= PositionsProperty( OrdersClassRepresentatives( t2 ),
    &#62;                               x -&#62; x = 15 );
    [ 39, 40 ]
    gap&#62; List( prim, pi -&#62; pi{ ord15 } );
    [ [ 1, 0 ], [ 2, 0 ], [ 2, 0 ], [ 1, 0 ], [ 1, 0 ] ]
    gap&#62; List( ord15, i -&#62; Maximum( ApproxP( prim, i ) ) );
    [ 307/120, 0 ]

</pre>

<div class="p"><!----></div>
Here it is appropriate to clean the workspace again.

<div class="p"><!----></div>

<pre>
    gap&#62; CleanWorkspace();

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.13">
5.13</a>&nbsp;&nbsp;O<sub>8</sub><sup>+</sup>(3)</h3><a name="O8p3">
</a>

<div class="p"><!----></div>
We show that S = O<sub>8</sub><sup>+</sup>(3) satisfies the following.

<ol type="1">
<br />(a)
    &#963;(S) = 863/1820,
    and this value is attained exactly for &#963;(S,s)
    with s of order 20.
<br />(b)
    For s  &#8712; S of order 20,
    <font face="helvetica"><i>M</i></font>(S,s) consists of two nonconjugate groups of the type
    O<sub>7</sub>(3) = &#8486;(7,3),
    two conjugate subgroups of the type 3<sup>6</sup>:L<sub>4</sub>(3),
    two nonconjugate subgroups of the type (A<sub>4</sub> &times;U<sub>4</sub>(2)):2,
    and one subgroup of each of the types 2.U<sub>4</sub>(3).(2<sup>2</sup>)<sub>122</sub>
    and (A<sub>6</sub> &times;A<sub>6</sub>):2<sup>2</sup>.
<br />(c)
    P(S) = 194/455,
    and this value is attained exactly for P(S,s)
    with s of order 20.
<br />(d)
    The uniform spread of S is at least three,
    with s of order 20.
<br />(e)
    The preimage of s in the matrix group 2.S = &#8486;<sup>+</sup>(8,3)
    can be chosen of order 40,
    and then the maximal subgroups of 2.S containing s
    have the structures 2.O<sub>7</sub>(3), 3<sup>6</sup>:2.L<sub>4</sub>(3),
    4.U<sub>4</sub>(3).2<sup>2</sup> = <span class="roman">SU</span>(4,3).2<sup>2</sup>,
    2.(A<sub>4</sub> &times;U<sub>4</sub>(2)).2 = 2.(<span class="roman">PSp</span>(2,3) &#8855;<span class="roman">PSp</span>(4,3)).2, and
    2.(A<sub>6</sub> &times;A<sub>6</sub>):2<sup>2</sup> = 2.(&#8486;<sup>&#8722;</sup>(4,3) &times;&#8486;<sup>&#8722;</sup>(4,3)):2<sup>2</sup>,
    respectively.
<br />(f)
    For s  &#8712; S of order 20, we have
    P<sup>&#8242;</sup>(S.2<sub>1</sub>, s)  &#8712; { 83/567, 574/1215 },
    P<sup>&#8242;</sup>(S.2<sub>2</sub>, s)  &#8712; { 0, 1 }
    (depending on the choice of s), and
    &#963;<sup>&#8242;</sup>(S.3, s) = 0.

<div class="p"><!----></div>
    Furthermore, for any choice of s<sup>&#8242;</sup>  &#8712; S,
    we have &#963;<sup>&#8242;</sup>(S.2<sub>2</sub>, s<sup>&#8242;</sup>) = 1
    for some group S.2<sub>2</sub>.
    However, if it is allowed to choose s from an <span class="roman">Aut</span>(S)-class
    of elements of order 20 (and not from a fixed S-class)
    then we can achieve &#963;(g,s) = 0 for any given
    g  &#8712; S.2<sub>2</sub> \S.
<br />(g)
    The maximal subgroups of S.2<sub>1</sub> that contain an element of order 20
    are either
    S and the extensions of the subgroups listed in statement&nbsp;(b)
    or they are
    S and L<sub>4</sub>(3).2<sup>2</sup>, 3<sup>6</sup>:L<sub>4</sub>(3).2 (twice),
    2.U<sub>4</sub>(3).(2<sup>2</sup>)<sub>122</sub>.2, and
    (A<sub>6</sub> &times;A<sub>6</sub>):2<sup>2</sup>.2.

<div class="p"><!----></div>
    In the former case, the groups have the structures
    O<sub>7</sub>(3):2 (twice),
    3<sup>6</sup>:(L<sub>4</sub>(3) &times;2) (twice),
    S<sub>4</sub> &times;U<sub>4</sub>(2).2 (twice),
    2.U<sub>4</sub>(3).(2<sup>2</sup>)<sub>122</sub>.2, and
    (A<sub>6</sub> &times;A<sub>6</sub>):2<sup>2</sup> &times;2.</ol>

<div class="p"><!----></div>
Statement&nbsp;(a) follows from inspection of the primitive permutation
characters.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "O8+(3)" );;
    gap&#62; ProbGenInfoSimple( t );
    [ "O8+(3)", 863/1820, 2, [ "20A", "20B", "20C" ], [ 8, 8, 8 ] ]

</pre>

<div class="p"><!----></div>
Also statement&nbsp;(b) follows from the information provided by the
character table of S (cf.&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;140]).

<div class="p"><!----></div>

<pre>
    gap&#62; prim:= PrimitivePermutationCharacters( t );;
    gap&#62; ord:= OrdersClassRepresentatives( t );;
    gap&#62; spos:= Position( ord, 20 );;
    gap&#62; filt:= PositionsProperty( prim, x -&#62; x[ spos ] &lt;&#62; 0 );
    [ 1, 2, 7, 15, 18, 19, 24 ]
    gap&#62; Maxes( t ){ filt };
    [ "O7(3)", "O8+(3)M2", "3^6:L4(3)", "2.U4(3).(2^2)_{122}", "(A4xU4(2)):2", 
      "O8+(3)M19", "(A6xA6):2^2" ]
    gap&#62; prim{ filt }{ [ 1, spos ] };
    [ [ 1080, 1 ], [ 1080, 1 ], [ 1120, 2 ], [ 189540, 1 ], [ 7960680, 1 ], 
      [ 7960680, 1 ], [ 9552816, 1 ] ]

</pre>

<div class="p"><!----></div>
For statement&nbsp;(c), we first show that P(S,s) = 194/455 holds.
Since this value is larger than 1/3,
we have to inspect only those classes g<sup>S</sup> for which
&#963;(g,s)  &#8805; 1/3 holds,

<div class="p"><!----></div>

<pre>
    gap&#62; ord:= OrdersClassRepresentatives( t );;
    gap&#62; ord20:= PositionsProperty( ord, x -&#62; x = 20 );;
    gap&#62; cand:= [];;
    gap&#62; for i in ord20 do
    &#62;      approx:= ApproxP( prim, i );
    &#62;      Add( cand, PositionsProperty( approx, x -&#62; x &#62;= 1/3 ) );
    &#62;    od;
    gap&#62; cand;
    [ [ 2, 6, 7, 10 ], [ 3, 6, 8, 11 ], [ 4, 6, 9, 12 ] ]
    gap&#62; AtlasClassNames( t ){ cand[1] };
    [ "2A", "3A", "3B", "3E" ]

</pre>

<div class="p"><!----></div>
The three possibilities form one orbit under the outer automorphism group
of S.

<div class="p"><!----></div>

<pre>
    gap&#62; t3:= CharacterTable( "O8+(3).3" );;
    gap&#62; tfust3:= GetFusionMap( t, t3 );;
    gap&#62; List( cand, x -&#62; tfust3{ x } );
    [ [ 2, 4, 5, 6 ], [ 2, 4, 5, 6 ], [ 2, 4, 5, 6 ] ]

</pre>

<div class="p"><!----></div>
By symmetry, we may consider only the first possibility,
and assume that s is in the class <tt>20A</tt>.

<div class="p"><!----></div>
We work with a permutation representation of degree 1&nbsp;080,
and assume that the permutation character is <tt>1a+260a+819a</tt>.
(Note that all permutation characters of S of degree 1&nbsp;080
are conjugate under <span class="roman">Aut</span>(S).)

<div class="p"><!----></div>

<pre>
    gap&#62; g:= Action( SO(1,8,3), NormedRowVectors( GF(3)^8 ), OnLines );;
    gap&#62; Size( g );
    9904359628800
    gap&#62; g:= DerivedSubgroup( g );;  Size( g );
    4952179814400
    gap&#62; orbs:= Orbits( g, MovedPoints( g ) );;
    gap&#62; List( orbs, Length );
    [ 1080, 1080, 1120 ]
    gap&#62; g:= Action( g, orbs[1] );;
    gap&#62; PositionProperty( Irr( t ), chi -&#62; chi[1] = 819 );
    9
    gap&#62; permchar:= Sum( Irr( t ){ [ 1, 2, 9 ] } );
    Character( CharacterTable( "O8+(3)" ), [ 1080, 128, 0, 0, 24, 108, 135, 0, 0, 
      108, 0, 0, 27, 27, 0, 0, 18, 9, 12, 16, 0, 0, 4, 15, 0, 0, 20, 0, 0, 12, 
      11, 0, 0, 20, 0, 0, 15, 0, 0, 12, 0, 0, 2, 0, 0, 3, 3, 0, 0, 6, 6, 0, 0, 3, 
      2, 2, 2, 18, 0, 0, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 3, 0, 0, 12, 0, 0, 3, 
      0, 0, 0, 0, 0, 4, 3, 3, 0, 0, 1, 0, 0, 4, 0, 0, 1, 1, 2, 0, 0, 0, 0, 0, 3, 
      0, 0, 2, 0, 0, 5, 0, 0, 1, 0, 0 ] )

</pre>

<div class="p"><!----></div>
Now we show that for s in the class <tt>20A</tt> (which fixes one point),
the proportion of nongenerating elements g in one of the classes
<tt>2A</tt>, <tt>3A</tt>, <tt>3B</tt>, <tt>3E</tt> has the maximum 194/455,
which is attained exactly for <tt>3A</tt>.
(We find a <tt>2A</tt> element as a power of s,
a <tt>3A</tt> element as a power of any element of order 18,
a <tt>3B</tt> and a <tt>3E</tt> element as elements with 135 and 108
fixed points, respectively, which occur as powers of suitable
elements of order 15.)

<div class="p"><!----></div>

<pre>
    gap&#62; permchar{ ord20 };
    [ 1, 0, 0 ]
    gap&#62; AtlasClassNames( t )[ PowerMap( t, 10 )[ ord20[1] ] ];
    "2A"
    gap&#62; ord18:= PositionsProperty( ord, x -&#62; x = 18 );;
    gap&#62; Set( AtlasClassNames( t ){ PowerMap( t, 6 ){ ord18 } } );
    [ "3A" ]
    gap&#62; ord15:= PositionsProperty( ord, x -&#62; x = 15 );;
    gap&#62; PowerMap( t, 5 ){ ord15 };
    [ 7, 8, 9, 10, 11, 12 ]
    gap&#62; AtlasClassNames( t ){ [ 7 .. 12 ] };
    [ "3B", "3C", "3D", "3E", "3F", "3G" ]
    gap&#62; permchar{ [ 7 .. 12 ] };
    [ 135, 0, 0, 108, 0, 0 ]
    gap&#62; mp:= NrMovedPoints( g );;
    gap&#62; ResetGlobalRandomNumberGenerators();
    gap&#62; repeat 20A:= Random( g );
    &#62;    until Order( 20A ) = 20 and mp - NrMovedPoints( 20A ) = 1;
    gap&#62; 2A:= 20A^10;;
    gap&#62; repeat x:= Random( g ); until Order( x ) = 18;
    gap&#62; 3A:= x^6;;
    gap&#62; repeat x:= Random( g );
    &#62;    until Order( x ) = 15 and mp - NrMovedPoints( x^5 ) = 135;
    gap&#62; 3B:= x^5;;
    gap&#62; repeat x:= Random( g );
    &#62;    until Order( x ) = 15 and mp - NrMovedPoints( x^5 ) = 108;
    gap&#62; 3E:= x^5;;
    gap&#62; nongen:= List( [ 2A, 3A, 3B, 3E ],
    &#62;                   c -&#62; RatioOfNongenerationTransPermGroup( g, c, 20A ) );
    [ 3901/9477, 194/455, 451/1092, 451/1092 ]
    gap&#62; Maximum( nongen );
    194/455

</pre>

<div class="p"><!----></div>
Next we compute the values P(g,s), for g is in the class <tt>3A</tt>
and certain elements s.
It is enough to consider representatives s of maximally cyclic subgroups
in S, but here we can do better, as follows.
Since <tt>3A</tt> is the unique class of length 72&nbsp;800,
it is fixed under <span class="roman">Aut</span>(S),
so it is enough to consider one element s from each <span class="roman">Aut</span>(S)-orbit
on the classes of S.
We use the class fusion between the character tables of S and <span class="roman">Aut</span>(S)
for computing orbit representatives.

<div class="p"><!----></div>

<pre>
    gap&#62; maxorder:= RepresentativesMaximallyCyclicSubgroups( t );;
    gap&#62; Length( maxorder );
    57
    gap&#62; autt:= CharacterTable( "O8+(3).S4" );;
    gap&#62; fus:= PossibleClassFusions( t, autt );;
    gap&#62; orbreps:= Set( List( fus, map -&#62; Set( ProjectionMap( map ) ) ) );
    [ [ 1, 2, 5, 6, 7, 13, 17, 18, 19, 20, 23, 24, 27, 30, 31, 37, 43, 46, 50, 
          54, 55, 56, 57, 58, 64, 68, 72, 75, 78, 84, 85, 89, 95, 96, 97, 100, 
          106, 112 ] ]
    gap&#62; totest:= Intersection( maxorder, orbreps[1] );
    [ 43, 50, 54, 56, 57, 64, 68, 75, 78, 84, 85, 89, 95, 97, 100, 106, 112 ]
    gap&#62; Length( totest );
    17
    gap&#62; AtlasClassNames( t ){ totest };
    [ "6Q", "6X", "6B1", "8A", "8B", "9G", "9K", "12A", "12D", "12J", "12K", 
      "12O", "13A", "14A", "15A", "18A", "20A" ]

</pre>

<div class="p"><!----></div>
This means that we have to test one element of each of the element orders
13, 14, 15, and 18
(note that we know already a bound for elements of order 20),
plus certain elements of the orders 6, 8, 9, and 12
which can be identified by their centralizer orders and (for elements of
order 6 and 8) perhaps the centralizer orders of some powers.

<div class="p"><!----></div>

<pre>
    gap&#62; elementstotest:= [];;
    gap&#62; for elord in [ 13, 14, 15, 18 ] do
    &#62;      repeat s:= Random( g );
    &#62;      until Order( s ) = elord;
    &#62;      Add( elementstotest, s );
    &#62;    od;

</pre>

<div class="p"><!----></div>
The next elements to be tested are
in the classes <tt>6B1</tt> (centralizer order 162),
in one of <tt>9G</tt>-<tt>9J</tt> (centralizer order 729),
in one of <tt>9K</tt>-<tt>9N</tt> (centralizer order 81),
in one of <tt>12A</tt>-<tt>12C</tt> (centralizer order 1&nbsp;728),
in one of <tt>12D</tt>-<tt>12I</tt> (centralizer order 432),
in <tt>12J</tt> (centralizer order 192),
in one of <tt>12K</tt>-<tt>12N</tt> (centralizer order 108),
and in one of <tt>12O</tt>-<tt>12T</tt> (centralizer order 72).

<div class="p"><!----></div>

<pre>
    gap&#62; ordcent:= [ [ 6, 162 ], [ 9, 729 ], [ 9, 81 ], [ 12, 1728 ],
    &#62;                [ 12, 432 ], [ 12, 192 ], [ 12, 108 ], [ 12, 72 ] ];;
    gap&#62; cents:= SizesCentralizers( t );;
    gap&#62; for pair in ordcent do
    &#62;      Print( pair, ": ", AtlasClassNames( t ){
    &#62;          Filtered( [ 1 .. Length( ord ) ],
    &#62;                    i -&#62; ord[i] = pair[1] and cents[i] = pair[2] ) }, "\n" );
    &#62;      repeat s:= Random( g );
    &#62;      until Order( s ) = pair[1] and Size( Centralizer( g, s ) ) = pair[2];
    &#62;      Add( elementstotest, s );
    &#62;    od;
    [ 6, 162 ]: [ "6B1" ]
    [ 9, 729 ]: [ "9G", "9H", "9I", "9J" ]
    [ 9, 81 ]: [ "9K", "9L", "9M", "9N" ]
    [ 12, 1728 ]: [ "12A", "12B", "12C" ]
    [ 12, 432 ]: [ "12D", "12E", "12F", "12G", "12H", "12I" ]
    [ 12, 192 ]: [ "12J" ]
    [ 12, 108 ]: [ "12K", "12L", "12M", "12N" ]
    [ 12, 72 ]: [ "12O", "12P", "12Q", "12R", "12S", "12T" ]

</pre>

<div class="p"><!----></div>
The next elements to be tested are
in one of the classes <tt>6Q</tt>-<tt>6S</tt> (centralizer order 648).

<div class="p"><!----></div>

<pre>
    gap&#62; AtlasClassNames( t ){ Filtered( [ 1 .. Length( ord ) ],
    &#62;        i -&#62; cents[i] = 648 and cents[ PowerMap( t, 2 )[i] ] = 52488
    &#62;                            and cents[ PowerMap( t, 3 )[i] ] = 26127360 ) };
    [ "6Q", "6R", "6S" ]
    gap&#62; repeat s:= Random( g );
    &#62;    until Order( s ) = 6 and Size( Centralizer( g, s ) ) = 648
    &#62;      and Size( Centralizer( g, s^2 ) ) = 52488
    &#62;      and Size( Centralizer( g, s^3 ) ) = 26127360;
    gap&#62; Add( elementstotest, s );

</pre>

<div class="p"><!----></div>
The next elements to be tested are
in the class <tt>6X</tt>-<tt>6A1</tt> (centralizer order 648).

<div class="p"><!----></div>

<pre>
    gap&#62; AtlasClassNames( t ){ Filtered( [ 1 .. Length( ord ) ],
    &#62;        i -&#62; cents[i] = 648 and cents[ PowerMap( t, 2 )[i] ] = 52488
    &#62;                            and cents[ PowerMap( t, 3 )[i] ] = 331776 ) };
    [ "6X", "6Y", "6Z", "6A1" ]
    gap&#62; repeat s:= Random( g );
    &#62;    until Order( s ) = 6 and Size( Centralizer( g, s ) ) = 648
    &#62;      and Size( Centralizer( g, s^2 ) ) = 52488
    &#62;      and Size( Centralizer( g, s^3 ) ) = 331776;
    gap&#62; Add( elementstotest, s );

</pre>

<div class="p"><!----></div>
Finally, we add elements from the classes <tt>8A</tt> and <tt>8B</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; AtlasClassNames( t ){ Filtered( [ 1 .. Length( ord ) ],
    &#62;        i -&#62; ord[i] = 8 and cents[ PowerMap( t, 2 )[i] ] = 13824 ) };
    [ "8A" ]
    gap&#62; repeat s:= Random( g );
    &#62;    until Order( s ) = 8 and Size( Centralizer( g, s^2 ) ) = 13824;
    gap&#62; Add( elementstotest, s );
    gap&#62; AtlasClassNames( t ){ Filtered( [ 1 .. Length( ord ) ],
    &#62;        i -&#62; ord[i] = 8 and cents[ PowerMap( t, 2 )[i] ] = 1536 ) };
    [ "8B" ]
    gap&#62; repeat s:= Random( g );
    &#62;    until Order( s ) = 8 and Size( Centralizer( g, s^2 ) ) = 1536;
    gap&#62; Add( elementstotest, s );

</pre>

<div class="p"><!----></div>
Now we compute the ratios.
It turns out that from these candidates,
only elements s of the orders 14 and 15 satisfy P(g,s)  &lt;  194/455.

<div class="p"><!----></div>

<pre>
    gap&#62; nongen:= List( elementstotest,
    &#62;                   s -&#62; RatioOfNongenerationTransPermGroup( g, 3A, s ) );;
    gap&#62; smaller:= PositionsProperty( nongen, x -&#62; x &lt; 194/455 );
    [ 2, 3 ]
    gap&#62; nongen{ smaller };
    [ 127/325, 1453/3640 ]

</pre>

<div class="p"><!----></div>
So the only candidates for s that may be better than order 20 elements
are elements of order 14 or 15.
In order to exclude these two possibilities,
we compute P(g,s) for s in the class <tt>14A</tt>
and g = s<sup>7</sup> in the class <tt>2A</tt>,
and for s in the class <tt>15A</tt> and g in the class <tt>2A</tt>,
which yields values that are larger than 194/455.

<div class="p"><!----></div>

<pre>
    gap&#62; repeat s:= Random( g );
    &#62;    until Order( s ) = 14 and NrMovedPoints( s ) = 1078;
    gap&#62; 2A:= s^7;;
    gap&#62; nongen:= RatioOfNongenerationTransPermGroup( g, 2A, s );
    1573/3645
    gap&#62; nongen &#62; 194/455;
    true
    gap&#62; repeat s:= Random( g );
    &#62;    until Order( s ) = 15 and NrMovedPoints( s ) = 1080 - 3;
    gap&#62; nongen:= RatioOfNongenerationTransPermGroup( g, 2A, s );
    490/1053
    gap&#62; nongen &#62; 194/455;
    true

</pre>

<div class="p"><!----></div>
For statement&nbsp;(d), we show that for each triple of elements
in the union of the classes <tt>2A</tt>, <tt>3A</tt>, <tt>3B</tt>, <tt>3E</tt>
there is an element in the class <tt>20A</tt> that generates S
together with each element of the triple.

<div class="p"><!----></div>

<pre>
    gap&#62; for tup in UnorderedTuples( [ 2A, 3A, 3B, 3E ], 3 ) do
    &#62;      cl:= ShallowCopy( tup );
    &#62;      test:= RandomCheckUniformSpread( g, cl, 20A, 100 );
    &#62;      if test &lt;&#62; true then
    &#62;        Error( test );
    &#62;      fi;
    &#62;    od;

</pre>

<div class="p"><!----></div>
We get no error message, so statement&nbsp;(d) is true.

<div class="p"><!----></div>
For statement&nbsp;(e), first we show that 2.S = &#8486;<sup>+</sup>(8,3) contains
elements of order 40 but S does not.

<div class="p"><!----></div>

<pre>
    gap&#62; der:= DerivedSubgroup( SO(1,8,3) );;
    gap&#62; repeat x:= PseudoRandom( der ); until Order( x ) = 40;
    gap&#62; 40 in ord;
    false

</pre>

<div class="p"><!----></div>
Thus elements of order 40 must arise as preimages of order 20 elements
under the natural epimorphism from 2.S to S,
which means that we may choose an order 40 preimage [^s] of s.
Then <font face="helvetica"><i>M</i></font>(2.S, [^s]) consists of central extensions of the subgroups
listed in statement&nbsp;(b).
The perfect subgroups O<sub>7</sub>(3), L<sub>4</sub>(3), 2.U<sub>4</sub>(3), and U<sub>4</sub>(2)
of these groups must lift to their Schur double covers in 2.S because
otherwise the preimages would not contain elements of order 40.

<div class="p"><!----></div>
Next we consider the preimage of the subgroup U = (A<sub>4</sub> &times;U<sub>4</sub>(2)).2
of S.
We show that the preimages of the two direct factors A<sub>4</sub> and U<sub>4</sub>(2)
in U<sup>&#8242;</sup> = A<sub>4</sub> &times;U<sub>4</sub>(2) are Schur covers.
For A<sub>4</sub>, this follows from the fact that the preimage of U<sup>&#8242;</sup>
must contain elements of order 20,
and that U<sub>4</sub>(2) does not contain elements of order 10.

<div class="p"><!----></div>

<pre>
    gap&#62; u42:= CharacterTable( "U4(2)" );;
    gap&#62; Filtered( OrdersClassRepresentatives( u42 ), x -&#62; x mod 5 = 0 );
    [ 5 ]

</pre>

<div class="p"><!----></div>
In order to show that the U<sub>4</sub>(2) type subgroup of U<sup>&#8242;</sup> lifts to its
double cover in 2.S, we note that the class <tt>2B</tt> of U<sub>4</sub>(2) lifts
to a class of elements of order four in the double cover 2.U<sub>4</sub>(2),
and that the corresponding class of elements in U
is S-conjugate to the class of involutions in the direct factor A<sub>4</sub>
(which is the unique class of length three in U).

<div class="p"><!----></div>

<pre>
    gap&#62; u:= CharacterTable( Maxes( t )[18] );
    CharacterTable( "(A4xU4(2)):2" )
    gap&#62; 2u42:= CharacterTable( "2.U4(2)" );;
    gap&#62; OrdersClassRepresentatives( 2u42 )[4];
    4
    gap&#62; GetFusionMap( 2u42, u42 )[4];
    3
    gap&#62; OrdersClassRepresentatives( u42 )[3];
    2
    gap&#62; List( PossibleClassFusions( u42, u ), x -&#62; x[3] );
    [ 8 ]
    gap&#62; PositionsProperty( SizesConjugacyClasses( u ), x -&#62; x = 3 );
    [ 2 ]
    gap&#62; ForAll( PossibleClassFusions( u, t ), x -&#62; x[2] = x[8] );
    true

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
The last subgroup for which the structure of the preimage has to be shown
is U = (A<sub>6</sub> &times;A<sub>6</sub>):2<sup>2</sup>.
We claim that each of the A<sub>6</sub> type subgroups in the derived subgroup
U<sup>&#8242;</sup> = A<sub>6</sub> &times;A<sub>6</sub> lifts to its double cover in 2.S.
Since all elements of order 20 in U lie in U<sup>&#8242;</sup>,
at least one of the two direct factors must lift to its double cover,
in order to give rise to an order 40 element in U.
In fact both factors lift to the double cover
since the two direct factors are interchanged by conjugation in U;
the latter follows form tha fact that U has no normal subgroup
of type A<sub>6</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; u:= CharacterTable( Maxes( t )[24] );
    CharacterTable( "(A6xA6):2^2" )
    gap&#62; ClassPositionsOfDerivedSubgroup( u );
    [ 1 .. 22 ]
    gap&#62; PositionsProperty( OrdersClassRepresentatives( u ), x -&#62; x = 20 );
    [ 8 ]
    gap&#62; List( ClassPositionsOfNormalSubgroups( u ),
    &#62;          x -&#62; Sum( SizesConjugacyClasses( u ){ x } ) );
    [ 1, 129600, 259200, 259200, 259200, 518400 ]

</pre>

<div class="p"><!----></div>
So statement&nbsp;(e) holds.

<div class="p"><!----></div>
For statement&nbsp;(f), we have to consider the upward extensions S.2<sub>1</sub>,
S.2<sub>2</sub>, and S.3.

<div class="p"><!----></div>
First we look at S.2<sub>1</sub>, an extension by an outer automorphism that
acts as a double transposition in the outer automorphism group S<sub>4</sub>.
Note that the symmetry between the three classes of element oder 20 in S
is broken in S.2<sub>1</sub>,
two of these classes have square roots in S.2<sub>1</sub>, the third has not.

<div class="p"><!----></div>

<pre>
    gap&#62; t2:= CharacterTable( "O8+(3).2_1" );;
    gap&#62; ord20:= PositionsProperty( OrdersClassRepresentatives( t2 ),
    &#62;                x -&#62; x = 20 );;
    gap&#62; ord20:= Intersection( ord20, ClassPositionsOfDerivedSubgroup( t2 ) );
    [ 84, 85, 86 ]
    gap&#62; List( ord20, x -&#62; x in PowerMap( t2, 2 ) );
    [ false, true, true ]

</pre>

<div class="p"><!----></div>
Changing the viewpoint, we see that for each class of element order 20
in S,
there is a group of the type S.2<sub>1</sub> in which the elements in this class
do not have square roots,
and there are groups of this type in which these elements have square roots.
So we have to deal with two different cases,
and we do this by first collecting the permutation characters induced from
<b>all</b> maximal subgroups of S.2<sub>1</sub> (other than S) that contain
elements of order 20 in S,
and then considering s in each of these classes of S.

<div class="p"><!----></div>
We fix an embedding of S into S.2<sub>1</sub> in which the elements in the class
<tt>20A</tt> do not have square roots.
This situation is given for the stored class fusion between the tables
in the <font face="helvetica">GAP</font> Character Table Library.

<div class="p"><!----></div>

<pre>
    gap&#62; tfust2:= GetFusionMap( t, t2 );;
    gap&#62; tfust2{ PositionsProperty( OrdersClassRepresentatives( t ),
    &#62;                x -&#62; x = 20 ) };
    [ 84, 85, 86 ]

</pre>

<div class="p"><!----></div>
The six different actions of S on the cosets of O<sub>7</sub>(3) type subgroups
induce pairwise different permutation characters that form an orbit under
the action of <span class="roman">Aut</span>(S).
Four of these characters cannot extend to S.2<sub>1</sub>,
the other two extend to permutation characters of S.2<sub>1</sub> on the cosets of
O<sub>7</sub>(3).2 type subgroups;
these subgroups contain <tt>20A</tt> elements.

<div class="p"><!----></div>

<pre>
    gap&#62; primt2:= [];;
    gap&#62; poss:= PossiblePermutationCharacters( CharacterTable( "O7(3)" ), t );;
    gap&#62; invfus:= InverseMap( tfust2 );;
    gap&#62; List( poss, pi -&#62; ForAll( CompositionMaps( pi, invfus ), IsInt ) );
    [ false, false, false, false, true, true ]
    gap&#62; PossiblePermutationCharacters(
    &#62;        CharacterTable( "O7(3)" ) * CharacterTable( "Cyclic", 2 ), t2 );
    [  ]
    gap&#62; ext:= PossiblePermutationCharacters( CharacterTable( "O7(3).2" ), t2 );;
    gap&#62; List( ext, pi -&#62; pi{ ord20 } );
    [ [ 1, 0, 0 ], [ 1, 0, 0 ] ]
    gap&#62; Append( primt2, ext );

</pre>

<div class="p"><!----></div>
The novelties in S.2<sub>1</sub> that arise from O<sub>7</sub>(3) type subgroups of S
have the structure L<sub>4</sub>(3).2<sup>2</sup>.
These subgroups contain elements in the classes <tt>20B</tt> and <tt>20C</tt>
of S.

<div class="p"><!----></div>

<pre>
    gap&#62; ext:= PossiblePermutationCharacters( CharacterTable( "L4(3).2^2" ), t2 );;
    gap&#62; List( ext, pi -&#62; pi{ ord20 } );
    [ [ 0, 0, 1 ], [ 0, 1, 0 ] ]
    gap&#62; Append( primt2, ext );

</pre>

<div class="p"><!----></div>
Note that from the possible permutation characters of S.2<sub>1</sub> on the cosets
of L<sub>4</sub>(3):2 &times;2 type subgroups,
we see that such subgroups must contain <tt>20A</tt> elements,
i.&nbsp;e., all such subgroups of S.2<sub>1</sub> lie inside O<sub>7</sub>(3).2 type subgroups.
This means that the structure description of these novelties
in&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;140] is not correct.
The correct structure is L<sub>4</sub>(3).2<sup>2</sup>.)

<div class="p"><!----></div>

<pre>
    gap&#62; List( PossiblePermutationCharacters( CharacterTable( "L4(3).2_2" ) *
    &#62;              CharacterTable( "Cyclic", 2 ), t2 ), pi -&#62; pi{ ord20 } );
    [ [ 1, 0, 0 ] ]

</pre>

<div class="p"><!----></div>
All 3<sup>6</sup>:L<sub>4</sub>(3) type subgroups of S extend to S.2<sub>1</sub>.
We compute these permutation characters as the possible permutation characters
of the right degree.

<div class="p"><!----></div>

<pre>
    gap&#62; ext:= PermChars( t2, rec( torso:= [ 1120 ] ) );;
    gap&#62; List( ext, pi -&#62; pi{ ord20 } );
    [ [ 2, 0, 0 ], [ 0, 0, 2 ], [ 0, 2, 0 ] ]
    gap&#62; Append( primt2, ext );

</pre>

<div class="p"><!----></div>
Also all 2.U<sub>4</sub>(3).2<sup>2</sup> type subgroups of S extend to S.2<sub>1</sub>.
We compute the permutation characters as the extensions of the corresponding
permutation characters of S.

<div class="p"><!----></div>

<pre>
    gap&#62; filt:= Filtered( prim, x -&#62; x[1] = 189540 );;
    gap&#62; cand:= List( filt, x -&#62; CompositionMaps( x, invfus ) );;
    gap&#62; ext:= Concatenation( List( cand,
    &#62;              pi -&#62; PermChars( t2, rec( torso:= pi ) ) ) );;
    gap&#62; List( ext, x -&#62; x{ ord20 } );
    [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
    gap&#62; Append( primt2, ext );

</pre>

<div class="p"><!----></div>
The extensions of (A<sub>4</sub> &times;U<sub>4</sub>(2)):2 type subgroups of S to S.2<sub>1</sub>
have the type S<sub>4</sub> &times;U<sub>4</sub>(2):2, they contain <tt>20A</tt> elements.

<div class="p"><!----></div>

<pre>
    gap&#62; ext:= PossiblePermutationCharacters( CharacterTable( "Symmetric", 4 ) *
    &#62;              CharacterTable( "U4(2).2" ), t2 );;
    gap&#62; List( ext, x -&#62; x{ ord20 } );
    [ [ 1, 0, 0 ], [ 1, 0, 0 ] ]
    gap&#62; Append( primt2, ext );

</pre>

<div class="p"><!----></div>
All (A<sub>6</sub> &times;A<sub>6</sub>):2<sup>2</sup> type subgroups of S extend to S.2<sub>1</sub>.
We compute the permutation characters as the extensions of the corresponding
permutation characters of S.

<div class="p"><!----></div>

<pre>
    gap&#62; filt:= Filtered( prim, x -&#62; x[1] = 9552816 );;
    gap&#62; cand:= List( filt, x -&#62; CompositionMaps( x, InverseMap( tfust2 ) ));;
    gap&#62; ext:= Concatenation( List( cand,
    &#62;              pi -&#62; PermChars( t2, rec( torso:= pi ) ) ) );;
    gap&#62; List( ext, x -&#62; x{ ord20 } );
    [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
    gap&#62; Append( primt2, ext );

</pre>

<div class="p"><!----></div>
We have found all relevant permutation characters of S.2<sub>1</sub>.
This together with the list in&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;140] implies statement&nbsp;(g).

<div class="p"><!----></div>
Now we compute the bounds &#963;<sup>&#8242;</sup>(S.2<sub>1</sub>, s).

<div class="p"><!----></div>

<pre>
    gap&#62; Length( primt2 );
    15
    gap&#62; approx:= List( ord20, x -&#62; ApproxP( primt2, x ) );;
    gap&#62; outer:= Difference(
    &#62;      PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),
    &#62;      ClassPositionsOfDerivedSubgroup( t2 ) );;
    gap&#62; List( approx, l -&#62; Maximum( l{ outer } ) );
    [ 574/1215, 83/567, 83/567 ]

</pre>

<div class="p"><!----></div>
Next we look at S.2<sub>2</sub>, an extension by an outer automorphism that
acts as a transposition in the outer automorphism group S<sub>4</sub>.
Similar to the above situation,
the symmetry between the three classes of element oder 20 in S
is broken also in S.2<sub>2</sub>:
The first is a conjugacy class of S.2<sub>2</sub>,
the other two classes are fused in S.2<sub>2</sub>,

<div class="p"><!----></div>

<pre>
    gap&#62; t2:= CharacterTable( "O8+(3).2_2" );;
    gap&#62; ord20:= PositionsProperty( OrdersClassRepresentatives( t2 ),
    &#62;                x -&#62; x = 20 );;
    gap&#62; ord20:= Intersection( ord20, ClassPositionsOfDerivedSubgroup( t2 ) );
    [ 82, 83 ]
    gap&#62; tfust2:= GetFusionMap( t, t2 );;
    gap&#62; tfust2{ PositionsProperty( OrdersClassRepresentatives( t ),
    &#62;                x -&#62; x = 20 ) };
    [ 82, 83, 83 ]

</pre>

<div class="p"><!----></div>
Like in the case S.2<sub>1</sub>, we compute the permutation characters induced from
<b>all</b> maximal subgroups of S.2<sub>2</sub> (other than S) that contain
elements of order 20 in S.

<div class="p"><!----></div>
We fix the embedding of S into S.2<sub>2</sub> in which the class
<tt>20A</tt> of S is a class of S.2<sub>2</sub>.
This situation is given for the stored class fusion between the tables
in the <font face="helvetica">GAP</font> Character Table Library.

<div class="p"><!----></div>
Exactly two classes of O<sub>7</sub>(3) type subgroups in S extend to S.2<sub>2</sub>,
these groups contain <tt>20A</tt> elements.

<div class="p"><!----></div>

<pre>
    gap&#62; primt2:= [];;
    gap&#62; ext:= PermChars( t2, rec( torso:= [ 1080 ] ) );;
    gap&#62; List( ext, pi -&#62; pi{ ord20 } );
    [ [ 1, 0 ], [ 1, 0 ] ]
    gap&#62; Append( primt2, ext );

</pre>

<div class="p"><!----></div>
Only one class of 3<sup>6</sup>:L<sub>4</sub>(3) type subgroups extends to S.2<sub>2</sub>.
(Note that we need not consider the novelties of the type
3<sup>3+6</sup>:(L<sub>3</sub>(3) &times;2), because the order of these groups is not
divisible by 5.)

<div class="p"><!----></div>

<pre>
    gap&#62; ext:= PermChars( t2, rec( torso:= [ 1120 ] ) );;
    gap&#62; List( ext, pi -&#62; pi{ ord20 } );
    [ [ 2, 0 ] ]
    gap&#62; Append( primt2, ext );

</pre>

<div class="p"><!----></div>
Only one class of 2.U<sub>4</sub>(3).2<sup>2</sup> type subgroups of S extends to S.2<sub>2</sub>.
We compute the permutation character as the extension of the corresponding
permutation characters of S.

<div class="p"><!----></div>

<pre>
    gap&#62; filt:= Filtered( prim, x -&#62; x[1] = 189540 );;
    gap&#62; cand:= List( filt, x -&#62; CompositionMaps( x, InverseMap( tfust2 ) ));;
    gap&#62; ext:= Concatenation( List( cand,
    &#62;              pi -&#62; PermChars( t2, rec( torso:= pi ) ) ) );;
    gap&#62; List( ext, x -&#62; x{ ord20 } );
    [ [ 1, 0 ] ]
    gap&#62; Append( primt2, ext );

</pre>

<div class="p"><!----></div>
Two classes of (A<sub>4</sub> &times;U<sub>4</sub>(2)):2 type subgroups of S extend
to S.2<sub>2</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; filt:= Filtered( prim, x -&#62; x[1] = 7960680 );;
    gap&#62; cand:= List( filt, x -&#62; CompositionMaps( x, InverseMap( tfust2 ) ));;
    gap&#62; ext:= Concatenation( List( cand,
    &#62;              pi -&#62; PermChars( t2, rec( torso:= pi ) ) ) );;
    gap&#62; List( ext, x -&#62; x{ ord20 } );
    [ [ 1, 0 ], [ 1, 0 ] ]
    gap&#62; Append( primt2, ext );

</pre>

<div class="p"><!----></div>
Exactly one class of (A<sub>6</sub> &times;A<sub>6</sub>):2<sup>2</sup> type subgroups in S
extends to S.2<sub>2</sub>, and the extensions have the structure

 S<sub>6</sub> &#8768; 2.

<div class="p"><!----></div>

<pre>
    gap&#62; ext:= PossiblePermutationCharacters( CharacterTableWreathSymmetric(
    &#62;              CharacterTable( "S6" ), 2 ), t2 );;
    gap&#62; List( ext, x -&#62; x{ ord20 } );
    [ [ 1, 0 ] ]
    gap&#62; Append( primt2, ext );

</pre>

<div class="p"><!----></div>
We have found all relevant permutation characters of S.2<sub>2</sub>,
and compute the bounds &#963;<sup>&#8242;</sup>(S.2<sub>2</sub>, s).

<div class="p"><!----></div>

<pre>
    gap&#62; Length( primt2 );
    7
    gap&#62; approx:= List( ord20, x -&#62; ApproxP( primt2, x ) );;
    gap&#62; outer:= Difference(
    &#62;      PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),
    &#62;      ClassPositionsOfDerivedSubgroup( t2 ) );;
    gap&#62; List( approx, l -&#62; Maximum( l{ outer } ) );
    [ 14/9, 0 ]

</pre>

<div class="p"><!----></div>
This means that there is an extension of the type S.2<sub>2</sub> in which
s cannot be chosen such that the bound is less than 1/2.
More precisely, we have &#963;(g,s)  &#8805; 1/2 exactly for g in the
unique outer involution class of size 1&nbsp;080.

<div class="p"><!----></div>

<pre>
    gap&#62; approx:= ApproxP( primt2, ord20[1] );;
    gap&#62; bad:= Filtered( outer, i -&#62; approx[i] &#62;= 1/2 );
    [ 84 ]
    gap&#62; OrdersClassRepresentatives( t2 ){ bad };
    [ 2 ]
    gap&#62; SizesConjugacyClasses( t2 ){ bad };
    [ 1080 ]
    gap&#62; Number( SizesConjugacyClasses( t2 ), x -&#62; x = 1080 );
    1

</pre>

<div class="p"><!----></div>
So we compute the proportion of elements in this class that generate S.2<sub>2</sub>
together with an element s of order 20 in S.
(As above, we have to consider two conjugacy classes.)
For that, we first compute a permutation representation of S.2<sub>2</sub>,
using that S.2<sub>2</sub> is isomporphic to the two subgroups of index 2 in
<span class="roman">PGO</span><sup>+</sup>(8,3) = O<sub>8</sub><sup>+</sup>(3).2<sup>2</sup><sub>122</sub> that are different from
<span class="roman">PSO</span><sup>+</sup>(8,3) = O<sub>8</sub><sup>+</sup>(3).2<sub>1</sub>, cf.&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;140].

<div class="p"><!----></div>

<pre>
    gap&#62; go:= GO(1,8,3);;
    gap&#62; so:= SO(1,8,3);;
    gap&#62; outerelm:= First( GeneratorsOfGroup( go ), x -&#62; not x in so );;
    gap&#62; g2:= ClosureGroup( DerivedSubgroup( so ), outerelm );;
    gap&#62; Size( g2 );
    19808719257600
    gap&#62; dom:= NormedVectors( GF(3)^8 );;
    gap&#62; orbs:= Orbits( g2, dom, OnLines );;
    gap&#62; List( orbs, Length );
    [ 1080, 1080, 1120 ]
    gap&#62; act:= Action( g2, orbs[1], OnLines );;

</pre>

<div class="p"><!----></div>
An involution g can be found as a power of one of the given generators.

<div class="p"><!----></div>

<pre>
    gap&#62; Order( outerelm );
    26
    gap&#62; g:= Permutation( outerelm^13, orbs[1], OnLines );;
    gap&#62; Size( ConjugacyClass( act, g ) );
    1080

</pre>

<div class="p"><!----></div>
Now we find the candidates for the elements s,
and compute their ratios of nongeneration.

<div class="p"><!----></div>

<pre>
    gap&#62; ord20;
    [ 82, 83 ]
    gap&#62; SizesCentralizers( t2 ){ ord20 };
    [ 40, 20 ]
    gap&#62; der:= DerivedSubgroup( act );;
    gap&#62; repeat 20A:= Random( der );
    &#62;    until Order( 20A ) = 20 and Size( Centralizer( act, 20A ) ) = 40;
    gap&#62; RatioOfNongenerationTransPermGroup( act, g, 20A );
    1
    gap&#62; repeat 20BC:= Random( der );
    &#62;    until Order( 20BC ) = 20 and Size( Centralizer( act, 20BC ) ) = 20;
    gap&#62; RatioOfNongenerationTransPermGroup( act, g, 20BC );
    0

</pre>

<div class="p"><!----></div>
This means that for s in one S-class of elements of order 20,
we have P<sup>&#8242;</sup>(g, s) = 1,
and s in the other two S-classes of elements of order 20 generates
with any conjugate of g.

<div class="p"><!----></div>
Concerning S.2<sub>2</sub>, it remains to show that we cannot find a better element
than s.
For that, we first compute class representatives s<sup>&#8242;</sup>
in S, w.r.t.&nbsp;conjugacy in S.2<sub>2</sub>,
and then compute P<sup>&#8242;</sup>( s<sup>&#8242;</sup>, g ).
(It would be enough to check representatives of classes of maximal element
order, but computing all classes is easy enough.)

<div class="p"><!----></div>

<pre>
    gap&#62; ccl:= ConjugacyClasses( act );;
    gap&#62; der:= DerivedSubgroup( act );;
    gap&#62; reps:= Filtered( List( ccl, Representative ), x -&#62; x in der );;
    gap&#62; Length( reps );
    83
    gap&#62; ratios:= List( reps,
    &#62;                   s -&#62; RatioOfNongenerationTransPermGroup( act, g, s ) );;
    gap&#62; cand:= PositionsProperty( ratios, x -&#62; x &lt; 1 );;
    gap&#62; ratios:= ratios{ cand };;
    gap&#62; SortParallel( ratios, cand );
    gap&#62; ratios;
    [ 0, 1/10, 1/10, 16/135, 1/3, 1/3, 11/27, 7/15, 7/15 ]

</pre>

<div class="p"><!----></div>
For S.2<sub>2</sub>, it remains to show that there is no element s<sup>&#8242;</sup>  &#8712; S
such that P<sup>&#8242;</sup>( s<sup>&#8242;</sup><sup>x</sup>, g )  &lt;  1 holds for any
x  &#8712; <span class="roman">Aut</span>(S) and g  &#8712; S.2<sub>2</sub>.
So we are done when we can show that each class given by <tt>cand</tt>
is conjugate in S.3 to a class outside <tt>cand</tt>.
The classes can be identified by element orders and centralizer orders.

<div class="p"><!----></div>

<pre>
    gap&#62; invs:= List( cand,
    &#62;       x -&#62; [ Order( reps[x] ), Size( Centralizer( der, reps[x] ) ) ] );
    [ [ 20, 20 ], [ 18, 108 ], [ 18, 108 ], [ 14, 28 ], [ 15, 45 ], [ 15, 45 ], 
      [ 10, 40 ], [ 12, 72 ], [ 12, 72 ] ]

</pre>

<div class="p"><!----></div>
Namely, <tt>cand</tt> contains no full S.3-orbit of classes of the element orders
20, 18, 14, 15, and 10; also, <tt>cand</tt> does not contain full
S.3-orbits on the classes <tt>12O</tt>-<tt>12T</tt>.

<div class="p"><!----></div>
Finally, we deal with S.3.
The fact that no maximal subgroup of S containing an element of order 20
extends to S.3 follows either from the list of maximal subgroups of S
in&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;140]
or directly from the permutation characters.

<div class="p"><!----></div>

<pre>
    gap&#62; t3:= CharacterTable( "O8+(3).3" );;
    gap&#62; tfust3:= GetFusionMap( t, t3 );;
    gap&#62; inv:= InverseMap( tfust3 );;
    gap&#62; filt:= PositionsProperty( prim, x -&#62; x[ spos ] &lt;&#62; 0 );;
    gap&#62; ForAll( prim{ filt },
    &#62;            pi -&#62; ForAny( CompositionMaps( pi, inv ), IsList ) );
    true

</pre>

<div class="p"><!----></div>
So we have to consider only the classes of novelties in S.3,
but the order of none of these groups is divisible by 20
-again see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;140]).
This means that <b>any</b> element in S.3 \S together with an element
of order 20 in S generates S.3.
This is in fact stronger than statement&nbsp;(f),
which claims this property only for elements of prime order in
S.3 \S (and their roots);
note that S.3 \S contains elements of the orders 9 and 27.

<div class="p"><!----></div>

<pre>
    gap&#62; outer:= Difference( [ 1 .. NrConjugacyClasses( t3 ) ],
    &#62;                ClassPositionsOfDerivedSubgroup( t3 ) );
    [ 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 
      72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 
      91, 92, 93, 94 ]
    gap&#62; Set( OrdersClassRepresentatives( t3 ){ outer } );      
    [ 3, 6, 9, 12, 18, 21, 24, 27, 36, 39 ]

</pre>

<div class="p"><!----></div>
Before we turn to the next computations, we clean the workspace.

<div class="p"><!----></div>

<pre>
    gap&#62; CleanWorkspace();

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.14">
5.14</a>&nbsp;&nbsp;O<sup>+</sup><sub>8</sub>(4)</h3><a name="O8p4">
</a>

<div class="p"><!----></div>
We show that S = O<sup>+</sup><sub>8</sub>(4) = &#8486;<sup>+</sup>(8,4) satisfies the following.

<ol type="1">
<br />(a)
    For suitable s  &#8712; S of the type 2<sup>&#8722;</sup> &#8869;6<sup>&#8722;</sup>
    (i.&nbsp;e., s decomposes the natural 8-dimensional module for
    S into an orthogonal sum of two irreducible modules
    of the dimensions 2 and 6, respectively) and of order 65,
    <font face="helvetica"><i>M</i></font>(S,s) consists of exactly three pairwise nonconjugate subgroups
    of the type (5 &times;O<sup>&#8722;</sup><sub>6</sub>(4)).2 = (5 &times;&#8486;<sup>&#8722;</sup>(6,4)).2.
<br />(b)
    &#963;( S, s )  &#8804; 34&nbsp;817 / 1&nbsp;645&nbsp;056.
<br />(c)
    In the extensions S.2<sub>1</sub> and S.3 of S by graph automorphisms,
    there is at most one maximal subgroup besides S that contains s.
    For the extension S.2<sub>2</sub> of S by a field automorphism,
    we have &#963;<sup>&#8242;</sup>(S.2<sub>2</sub>, s) = 0.
    In the extension S.2<sub>3</sub> of S by the product of an involutory graph
    automorphism and a field automorphism,
    there is a unique maximal subgroup besides S that contains s.</ol>

<div class="p"><!----></div>
A safe source for determining <font face="helvetica"><i>M</i></font>(S,s) is&nbsp;[<a href="#Kle87" name="CITEKle87">Kle87</a>].
By inspection of the result matrix in this paper,
we get that the only maximal subgroups of S that contain elements
of order 65 occur in the rows 9-14 and 23-25;
they have the isomorphism types
S<sub>6</sub>(4) = <span class="roman">Sp</span>(6,4)  &#8773; O<sub>7</sub>(4) = &#8486;(7,4) and
(5 &times;O<sub>6</sub><sup>&#8722;</sup>(4)).2 = (5 &times;&#8486;<sup>&#8722;</sup>(6,4)).2, respectively,
and for each of these, there are three conjugacy classes of subgroups
in S, which are conjugate under the triality graph automorphism of S.

<div class="p"><!----></div>
We start with the natural matrix representation of S.
For convenience,
we compute an isomorphic permutation group on 5&nbsp;525 points.

<div class="p"><!----></div>

<pre>
    gap&#62; q:= 4;;  n:= 8;;
    gap&#62; G:= DerivedSubgroup( SO( 1, n, q ) );;
    gap&#62; points:= NormedRowVectors( GF(q)^n );;
    gap&#62; orbs:= Orbits( G, points, OnLines );;
    gap&#62; List( orbs, Length );
    [ 5525, 16320 ]
    gap&#62; hom:= ActionHomomorphism( G, orbs[1], OnLines );;
    gap&#62; G:= Image( hom );;

</pre>

<div class="p"><!----></div>
The group S contains exactly six conjugacy classes of (cyclic) subgroups
of order 65;
this follows from the fact that the centralizer of any Sylow 13 subgroup
in S has the structure 5 &times;5 &times;13.

<div class="p"><!----></div>

<pre>
    gap&#62; Collected( Factors( Size( G ) ) );
    [ [ 2, 24 ], [ 3, 5 ], [ 5, 4 ], [ 7, 1 ], [ 13, 1 ], [ 17, 2 ] ]
    gap&#62; ResetGlobalRandomNumberGenerators();
    gap&#62; repeat x:= Random( G );
    &#62;    until Order( x ) mod 13 = 0;
    gap&#62; x:= x^( Order( x ) / 13 );;
    gap&#62; c:= Centralizer( G, x );;
    gap&#62; IsAbelian( c );  AbelianInvariants( c );
    true
    [ 5, 5, 13 ]

</pre>

<div class="p"><!----></div>
The group S<sub>6</sub>(4) contains exactly one class of subgroups of order 65,
since the conjugacy classes of elements of order 65 in S<sub>6</sub>(4) are
algebraically conjugate.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "S6(4)" );;
    gap&#62; ord65:= PositionsProperty( OrdersClassRepresentatives( t ),
    &#62;                               x -&#62; x = 65 );
    [ 105, 106, 107, 108, 109, 110, 111, 112 ]
    gap&#62; ord65 = ClassOrbit( t, ord65[1] );
    true

</pre>

<div class="p"><!----></div>
Thus there are at least three classes of order 65 elements in S
that are <em>not</em> contained in S<sub>6</sub>(4) type subgroups of S.
So we choose such an element s,
and have to consider only overgroups of the type
(5 &times;&#8486;<sup>&#8722;</sup>(6,4)).2.

<div class="p"><!----></div>
The group &#8486;<sup>&#8722;</sup>(6,4)  &#8773; U<sub>4</sub>(4) contains exactly one class
of subgroups of order 65.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "U4(4)" );;
    gap&#62; ords:= OrdersClassRepresentatives( t );;
    gap&#62; ord65:= PositionsProperty( ords, x -&#62; x = 65 );;
    gap&#62; ord65 = ClassOrbit( t, ord65[1] );
    true

</pre>

<div class="p"><!----></div>
So 5 &times;&#8486;<sup>&#8722;</sup>(6,4) contains exactly six such classes.
Furthermore, subgroups in different classes are not S-conjugate.

<div class="p"><!----></div>

<pre>
    gap&#62; syl5:= SylowSubgroup( c, 5 );;
    gap&#62; elms:= Filtered( Elements( syl5 ), y -&#62; Order( y ) = 5 );;
    gap&#62; reps:= Set( List( elms, SmallestGeneratorPerm ) );;  Length( reps );
    6
    gap&#62; reps65:= List( reps, y -&#62; SubgroupNC( G, [ y * x ] ) );;
    gap&#62; pairs:= Filtered( UnorderedTuples( [ 1 .. 6 ], 2 ),
    &#62;                      p -&#62; p[1] &lt;&#62; p[2] );;
    gap&#62; ForAny( pairs, p -&#62; IsConjugate( G, reps65[ p[1] ], reps65[ p[2] ] ) );
    false

</pre>

<div class="p"><!----></div>
We consider only subgroups M  &#8804; S in the three S-classes of the type
(5 &times;&#8486;<sup>&#8722;</sup>(6,4)).2.

<div class="p"><!----></div>

<pre>
    gap&#62; cand:= List( reps, y -&#62; Normalizer( G, SubgroupNC( G, [ y ] ) ) );;
    gap&#62; cand:= Filtered( cand, y -&#62; Size( y ) = 10 * Size( t ) );;
    gap&#62; Length( cand );
    3

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
(Note that one of the members in <font face="helvetica"><i>M</i></font>(S,s) is the stabilizer in S of the
orthogonal decomposition 2<sup>&#8722;</sup> &#8869;6<sup>&#8722;</sup>,
the other two members are not reducible.)

<div class="p"><!----></div>
By the above, the classes of subgroups of order 65 in each such M
are in bijection with the corresponding classes in S.
Since N<sub>S</sub>(&#9001;g &#9002;)  &#8838; M holds
for any g  &#8712; M of order 65, also the conjugacy classes of
<em>elements</em> of order 65 in M are in bijection with those in S.

<div class="p"><!----></div>

<pre>
    gap&#62; norms:= List( reps65, y -&#62; Normalizer( G, y ) );;
    gap&#62; ForAll( norms, y -&#62; ForAll( cand, M -&#62; IsSubset( M, y ) ) );
    true

</pre>

<div class="p"><!----></div>
As a consequence, we have g<sup>S</sup> &#8745;M = g<sup>M</sup> and thus 1<sub>M</sub><sup>S</sup>(g) = 1.
This implies statement&nbsp;(a).

<div class="p"><!----></div>
In order to show statement&nbsp;(b),
we want to use the function <tt>UpperBoundFixedPointRatios</tt> introduced in
Section&nbsp;<a href="#groups">3.3</a>.
For that, we first compute the conjugacy classes of
the three class representatives M.
(Since the groups have elementary abelian Sylow 5 subgroups of the order
5<sup>4</sup>, computing all conjugacy classes appears to be faster than using
<tt>ClassesOfPrimeOrder</tt>.)
Then we compute an upper bounds for &#963;(S,s).

<div class="p"><!----></div>

<pre>
    gap&#62; syl5:= SylowSubgroup( cand[1], 5 );;
    gap&#62; Size( syl5 );  IsElementaryAbelian( syl5 );
    625
    true
    gap&#62; UpperBoundFixedPointRatios( G, List( cand, ConjugacyClasses ), false );
    [ 34817/1645056, false ]

</pre>

<div class="p"><!----></div>

   <b>Remark 1</b> <em>
<span class="roman">
Computing the exact value &#963;(S,s) in the above setup would require
to test the S-conjugacy of certain order 5 elements in M.
With the current <font face="helvetica">GAP</font> implementation,
some of the relevant tests need several hours of CPU time.

<div class="p"><!----></div>
An alternative approach would be to compute the permutation action of
S on the cosets of M, of degree 6&nbsp;580&nbsp;224,
and to count the fixed points of conjugacy class representatives
of prime order.
The currently available <font face="helvetica">GAP</font> library methods are not sufficient
for computing this in reasonable time.
"Ad-hoc code" for this special case works,
but it seemed to be not appropriate to include it here.</span>

<div class="p"><!----></div>
</em>In the proof of statement&nbsp;(c),
again we consult the result matrix in&nbsp;[<a href="#Kle87" name="CITEKle87">Kle87</a>].
For S.3,
the maximal subgroups are in the rows 4, 15, 22, 26, and 61.
Only row 26 yields subgroups that contain elements s of order 65,
they have the isomorphism type
(5 &times;<span class="roman">GU</span>(3,4)).2  &#8773; (5<sup>2</sup> &times;U<sub>3</sub>(4)).2.
Note that the conjugacy classes of the members in <font face="helvetica"><i>M</i></font>(S,s) are permuted
by the outer automorphism of order 3,
so none of the subgroups in <font face="helvetica"><i>M</i></font>(S,s) extends to S.3.
By&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Lemma&nbsp;2.4&nbsp;(2)], if there is a maximal subgroup of S.3
besides S that contains s then this subgroup is the normalizer in S.3
of the intersection of the three members of <font face="helvetica"><i>M</i></font>(S,s),
i.&nbsp;e., s is contained in at most one such subgroup.

<div class="p"><!----></div>
For S.2<sub>1</sub>,
only the rows 9 and 23 yield maximal subgroups containing elements of
order 65, and since we had chosen s in such a way
that row 9 was excluded already for the simple group,
only extensions of the elements in <font face="helvetica"><i>M</i></font>(S,s) can appear.
Exactly one of these three subgroups of S extends to S.2<sub>1</sub>,
so again we get just one maximal subgroup of S.2<sub>1</sub>, besides S,
that contains s.

<div class="p"><!----></div>
All subgroups in <font face="helvetica"><i>M</i></font>(S,s) extend to S.2<sub>2</sub>, see&nbsp;[<a href="#Kle87" name="CITEKle87">Kle87</a>].
We compute the extensions of the above subgroups M of S to S.2<sub>2</sub>,
by constructing the action of the field automorphism
in the permutation representation we used for S.
In other words, we compute the projective action of the Frobenius map.

<div class="p"><!----></div>

<pre>
    gap&#62; frob:= PermList( List( orbs[1], v -&#62; Position( orbs[1],
    &#62;              List( v, x -&#62; x^2 ) ) ) );;
    gap&#62; G2:= ClosureGroupDefault( G, frob );;
    gap&#62; cand2:= List( cand, M -&#62; Normalizer( G2, M ) );;
    gap&#62; ccl:= List( cand2,
    &#62;                M2 -&#62; PcConjugacyClassReps( SylowSubgroup( M2, 2 ) ) );;
    gap&#62; List( ccl, l -&#62; Number( l, x -&#62; Order( x ) = 2 and not x in G ) );
    [ 0, 0, 0 ]

</pre>

<div class="p"><!----></div>
So in each case, the extension of M to its normalizer in S.2<sub>2</sub>
is non-split.
This implies &#963;<sup>&#8242;</sup>(S.2<sub>2</sub>,s) = 0.

<div class="p"><!----></div>
Finally, in the extension of S by the product of a graph automorphism
and the field automorphism, exactly that member of <font face="helvetica"><i>M</i></font>(S,s) is invariant
that is invariant under the graph automorphism,
hence statement&nbsp;(c) holds.

<div class="p"><!----></div>
It is again time to clean the workspace.

<div class="p"><!----></div>

<pre>
    gap&#62; CleanWorkspace();

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.15">
5.15</a>&nbsp;&nbsp;&#8727;&nbsp;O<sub>9</sub>(3)</h3><a name="O93">
</a>

<div class="p"><!----></div>
The group S = O<sub>9</sub>(3) = &#8486;<sub>9</sub>(3) is the first member in the series
dealt with in&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Proposition&nbsp;5.7],
and serves as an example to illustrate this statement.

<div class="p"><!----></div>

<ol type="1">
<br />(a) 
    For s  &#8712; S of the type 1 &#8869;8<sup>&#8722;</sup>
    (i.&nbsp;e., s decomposes the natural 9-dimensional module for S
    into an orthogonal sum of two irreducible modules of the dimensions
    1 and 8, respectively) and of order (3<sup>4</sup> + 1)/2 = 41,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one group of the type O<sub>8</sub><sup>&#8722;</sup>(3).2<sub>1</sub> = <span class="roman">PGO</span><sup>&#8722;</sup>(8,3).
<br />(b)
    &#963;(S,s) = 1/3.
<br />(c)
    The uniform spread of S is at least three,
    with s of order 41.</ol>

<div class="p"><!----></div>
By&nbsp;[<a href="#MSW94" name="CITEMSW94">MSW94</a>], the only maximal subgroup of S that contains s
is the stabilizer M of the orthogonal decomposition.
The group 2 &times;O<sub>8</sub><sup>&#8722;</sup>(3).2<sub>1</sub> = <span class="roman">GO</span><sup>&#8722;</sup>(8,3) embeds naturally into
<span class="roman">SO</span>(9,3), its intersection with S is <span class="roman">PGO</span><sup>&#8722;</sup>(8,3).
This proves statement&nbsp;(a).

<div class="p"><!----></div>
The group M is the stabilizer of a 1-space, it has index 3&nbsp;240 in S.

<div class="p"><!----></div>

<pre>
    gap&#62; g:= SO( 9, 3 );;
    gap&#62; g:= DerivedSubgroup( g );;
    gap&#62; Size( g );
    65784756654489600
    gap&#62; orbs:= Orbits( g, NormedRowVectors( GF(3)^9 ), OnLines );;
    gap&#62; List( orbs, Length ) / 41;
    [ 3240/41, 81, 80 ]
    gap&#62; Size( SO( 9, 3 ) ) / Size( GO( -1, 8, 3 ) );
    3240

</pre>

<div class="p"><!----></div>
So we compute the unique transitive permutation character of S that has
degree 3&nbsp;240.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "O9(3)" );;
    gap&#62; pi:= PermChars( t, rec( torso:= [ 3240 ] ) );
    [ Character( CharacterTable( "O9(3)" ), [ 3240, 1080, 380, 132, 48, 324, 378,
          351, 0, 0, 54, 27, 54, 27, 0, 118, 0, 36, 46, 18, 12, 2, 8, 45, 0, 108,
          108, 135, 126, 0, 0, 56, 0, 0, 36, 47, 38, 27, 39, 36, 24, 12, 18, 18,
          15, 24, 2, 18, 15, 9, 0, 0, 0, 2, 0, 18, 11, 3, 9, 6, 6, 9, 6, 3, 6, 3,
          0, 6, 16, 0, 4, 6, 2, 45, 36, 0, 0, 0, 0, 0, 0, 0, 9, 9, 6, 3, 0, 0,
          15, 13, 0, 5, 7, 36, 0, 10, 0, 10, 19, 6, 15, 0, 0, 0, 0, 12, 3, 10, 0,
          3, 3, 7, 0, 6, 6, 2, 8, 0, 4, 0, 2, 0, 1, 3, 0, 0, 3, 0, 3, 2, 2, 3, 3,
          6, 2, 2, 9, 6, 3, 0, 0, 18, 9, 0, 0, 12, 0, 0, 8, 0, 6, 9, 5, 0, 0, 0,
          0, 0, 0, 0, 0, 3, 3, 3, 2, 1, 3, 3, 1, 0, 0, 4, 1, 0, 0, 1, 0, 3, 3, 1,
          1, 2, 2, 0, 0, 1, 3, 4, 0, 1, 2, 0, 0, 1, 0, 4, 1, 0, 0, 0, 0, 1, 0, 0,
          1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0 ] ) ]
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 41 );
    208
    gap&#62; approx:= ApproxP( pi, spos );;
    gap&#62; Maximum( approx );
    1/3
    gap&#62; PositionsProperty( approx, x -&#62; x = 1/3 );
    [ 2 ]
    gap&#62; SizesConjugacyClasses( t )[2];
    3321
    gap&#62; OrdersClassRepresentatives( t )[2];
    2

</pre>

<div class="p"><!----></div>
We see that P( S, s ) = &#963;( S, s ) = 1/3 holds,
and that &#963;( g, s ) attains this maximum only for g in one
class of involutions in S;
let us call this class <tt>2A</tt>.
(This class consists of the negatives of a class of <em>reflections</em>
in <span class="roman">GO</span>(9,3).)
This shows statement&nbsp;(b).

<div class="p"><!----></div>
In order to show that the uniform spread of S is at least three,
it suffices to show that for each triple of <tt>2A</tt> elements,
there is an element s of order 41 in S that generates S with each
element of the triple.

<div class="p"><!----></div>
We work with the primitive permutation representation of S on 3&nbsp;240
points.
In this representation, s fixes exactly one point,
and by statement&nbsp;(a),
s generates S with x  &#8712; S if and only if x moves this point.
Since the number of fixed points of each <tt>2A</tt> involution in S is
exactly one third of the moved points of S,
it suffices to show that we cannot choose three such involutions with
mutually disjoint fixed point sets.
And this is shown particularly easily because it will turn out that
already for any two different <tt>2A</tt> involutions,
the sets of fixed points of are never disjoint.

<div class="p"><!----></div>
First we compute a <tt>2A</tt> element, which is determined as an involution
with exactly 1&nbsp;080 fixed points.

<div class="p"><!----></div>

<pre>
    gap&#62; g:= Action( g, orbs[1], OnLines );;
    gap&#62; repeat
    &#62;      repeat x:= Random( g ); ord:= Order( x ); until ord mod 2 = 0;
    &#62;      y:= x^(ord/2);
    &#62; until NrMovedPoints( y ) = 3240 - 1080;

</pre>

<div class="p"><!----></div>
Next we compute the sets of fixed points of the elements in the class <tt>2A</tt>,
by forming the S-orbit of the set of fixed points of the chosen
<tt>2A</tt> element.

<div class="p"><!----></div>

<pre>
    gap&#62; fp:= Difference( MovedPoints( g ), MovedPoints( y ) );;
    gap&#62; orb:= Orbit( g, fp, OnSets );;

</pre>

<div class="p"><!----></div>
Finally, we show that for any pair of <tt>2A</tt> elements, their sets of
fixed points intersect nontrivially.
(Of course we can fix one of the two elements.)
This proves statement&nbsp;(c).

<div class="p"><!----></div>

<pre>
    gap&#62; ForAny( orb, l -&#62; IsEmpty( Intersection( l, fp ) ) );
    false

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.16">
5.16</a>&nbsp;&nbsp;O<sub>10</sub><sup>&#8722;</sup>(3)</h3><a name="O10m3">
</a>

<div class="p"><!----></div>
We show that the group S = O<sub>10</sub><sup>&#8722;</sup>(3) = <span class="roman">P</span>&#8486;<sup>&#8722;</sup>(10,3) satisfies the
following.

<ol type="1">
<br />(a)
    For s  &#8712; S irreducible of order (3<sup>5</sup> + 1)/4 = 61,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one subgroup of the type <span class="roman">SU</span>(5,3)  &#8773; U<sub>5</sub>(3).
<br />(b)
    &#963;(S,s) = 1/1&nbsp;066.</ol>

<div class="p"><!----></div>
By&nbsp;[<a href="#Be00" name="CITEBe00">Ber00</a>], the maximal subgroups of S containing s are of
extension field type,
and by&nbsp;[<a href="#KlL90" name="CITEKlL90">KL90</a>,Prop.&nbsp;4.3.18 and&nbsp;4.3.20], these groups have the structure
<span class="roman">SU</span>(5,3) = U<sub>5</sub>(3)
(which lift to 2 &times;U<sub>5</sub>(3)  &lt;  <span class="roman">GU</span>(5,3) in &#8486;<sup>&#8722;</sup>(10,3) = 2.S)
or &#8486;(5,9).2,
but the order of the latter group is not divisible by &#124;s&#124;.
Furthermore, by&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Lemma&nbsp;2.12&nbsp;(b)], s is contained in only one
member of the former class.

<div class="p"><!----></div>

<pre>
    gap&#62; Size( GO(5,9) ) / 61;
    6886425600/61

</pre>

<div class="p"><!----></div>
<em>(When the first version of these computations was written,
the character tables of both S and U<sub>5</sub>(3) were not
contained in the <font face="helvetica">GAP</font> Character Table Library,
so we worked with the groups.
Meanwhile the character tables are available,
thus we can show also a character theoretic solution.)</em>

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "O10-(3)" );  s:= CharacterTable( "U5(3)" );
    CharacterTable( "O10-(3)" )
    CharacterTable( "U5(3)" )
    gap&#62; SigmaFromMaxes( t, "61A", [ s ], [ 1 ] );
    1/1066

</pre>

<div class="p"><!----></div>
<em>(Now follow the computations with groups.)</em>

<div class="p"><!----></div>
The first step is the construction of the embedding of M = <span class="roman">SU</span>(5,3)
into the matrix group 2.S,
that is, we write the matrix generators of M as linear mappings on
the natural module for 2.S, and then conjugate them such that the
result matrices respect the bilinear form of 2.S.
For convenience, we choose a basis for the field extension
<font size="+0">F</font><sub>9</sub>/<font size="+0">F</font><sub>3</sub> such that the <font size="+0">F</font><sub>3</sub>-linear mapping given by the invariant
form of M is invariant under the <font size="+0">F</font><sub>3</sub>-linear mappings given by
the generators of M.

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; m:= SU(5,3);;
    gap&#62; so:= SO(-1,10,3);;
    gap&#62; omega:= DerivedSubgroup( so );;
    gap&#62; om:= InvariantBilinearForm( so ).matrix;;
    gap&#62; Display( om );
     . 1 . . . . . . . .
     1 . . . . . . . . .
     . . 1 . . . . . . .
     . . . 2 . . . . . .
     . . . . 2 . . . . .
     . . . . . 2 . . . .
     . . . . . . 2 . . .
     . . . . . . . 2 . .
     . . . . . . . . 2 .
     . . . . . . . . . 2
    gap&#62; b:= Basis( GF(9), [ Z(3)^0, Z(3^2)^2 ] );
    Basis( GF(3^2), [ Z(3)^0, Z(3^2)^2 ] )
    gap&#62; blow:= List( GeneratorsOfGroup( m ), x -&#62; BlownUpMat( b, x ) );;
    gap&#62; form:= BlownUpMat( b, InvariantSesquilinearForm( m ).matrix );;
    gap&#62; ForAll( blow, x -&#62; x * form * TransposedMat( x ) = form );
    true
    gap&#62; Display( form );
     . . . . . . . . 1 .
     . . . . . . . . . 1
     . . . . . . 1 . . .
     . . . . . . . 1 . .
     . . . . 1 . . . . .
     . . . . . 1 . . . .
     . . 1 . . . . . . .
     . . . 1 . . . . . .
     1 . . . . . . . . .
     . 1 . . . . . . . .

</pre>

<div class="p"><!----></div>
The matrix <tt>om</tt> of the invariant bilinear form of 2.S
is equivalent to the identity matrix I.
So we compute matrices <tt>T1</tt> and <tt>T2</tt>
that transform <tt>om</tt> and <tt>form</tt>, respectively, to &#177;I.

<div class="p"><!----></div>

<pre>
    gap&#62; T1:= IdentityMat( 10, GF(3) );;
    gap&#62; T1{[1..3]}{[1..3]}:= [[1,1,0],[1,-1,1],[1,-1,-1]]*Z(3)^0;;
    gap&#62; pi:= PermutationMat( (1,10)(3,8), 10, GF(3) );;
    gap&#62; tr:= NullMat( 10,10,GF(3) );;
    gap&#62; tr{[1, 2]}{[1, 2]}:= [[1,1],[1,-1]]*Z(3)^0;;
    gap&#62; tr{[3, 4]}{[3, 4]}:= [[1,1],[1,-1]]*Z(3)^0;;
    gap&#62; tr{[7, 8]}{[7, 8]}:= [[1,1],[1,-1]]*Z(3)^0;;
    gap&#62; tr{[9,10]}{[9,10]}:= [[1,1],[1,-1]]*Z(3)^0;;
    gap&#62; tr{[5, 6]}{[5, 6]}:= [[1,0],[0,1]]*Z(3)^0;;
    gap&#62; tr2:= IdentityMat( 10,GF(3) );;
    gap&#62; tr2{[1,3]}{[1,3]}:= [[-1,1],[1,1]]*Z(3)^0;;
    gap&#62; tr2{[7,9]}{[7,9]}:= [[-1,1],[1,1]]*Z(3)^0;;
    gap&#62; T2:= tr2 * tr * pi;;
    gap&#62; D:= T1^-1 * T2;;
    gap&#62; tblow:= List( blow, x -&#62; D * x * D^-1 );;
    gap&#62; IsSubset( omega, tblow );
    true

</pre>

<div class="p"><!----></div>
Now we switch to a permutation representation of S,
and use the embedding of M into 2.S to obtain the corresponding
subgroup of type M in S.
Then we compute an upper bound for max{ &#956;(g,S/M); g  &#8712; S<sup>&times;</sup> }.

<div class="p"><!----></div>

<pre>
    gap&#62; orbs:= Orbits( omega, NormedRowVectors( GF(3)^10 ), OnLines );;
    gap&#62; List( orbs, Length );
    [ 9882, 9882, 9760 ]
    gap&#62; permgrp:= Action( omega, orbs[3], OnLines );;
    gap&#62; M:= SubgroupNC( permgrp,
    &#62;            List( tblow, x -&#62; Permutation( x, orbs[3], OnLines ) ) );;
    gap&#62; ccl:= ClassesOfPrimeOrder( M, Set( Factors( Size( M ) ) ),
    &#62;                               TrivialSubgroup( M ) );;
    gap&#62; UpperBoundFixedPointRatios( permgrp, [ ccl ], false );
    [ 1/1066, true ]

</pre>

<div class="p"><!----></div>
The entry <tt>true</tt> in the second position of the result indicates
that in fact the <em>exact</em> value for the maximum of &#956;(g,S/M)
has been computed.
This implies statement&nbsp;(b).

<div class="p"><!----></div>
We clean the workspace.

<div class="p"><!----></div>

<pre>
    gap&#62; CleanWorkspace();

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.17">
5.17</a>&nbsp;&nbsp;O<sub>14</sub><sup>&#8722;</sup>(2)</h3><a name="O14m2">
</a>

<div class="p"><!----></div>
We show that the group S = O<sub>14</sub><sup>&#8722;</sup>(2) = &#8486;<sup>&#8722;</sup>(14,2) satisfies the
following.

<ol type="1">
<br />(a)
    For s  &#8712; S irreducible of order 2<sup>7</sup>+1 = 129,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one subgroup M of the type
    <span class="roman">GU</span>(7,2)  &#8773; 3 &times;U<sub>7</sub>(2).
<br />(b)
    &#963;(S,s) = 1/2&nbsp;015.</ol>

<div class="p"><!----></div>
By&nbsp;[<a href="#Be00" name="CITEBe00">Ber00</a>], any maximal subgroup of S containing s is of extension
field type, and by&nbsp;[<a href="#KlL90" name="CITEKlL90">KL90</a>,Table&nbsp;3.5.F, Prop.&nbsp;4.3.18],
these groups have the type <span class="roman">GU</span>(7,2),
and there is exactly one class of subgroups of this type.
Furthermore, by&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Lemma&nbsp;2.12&nbsp;(a)], s is contained in only one
member of this class.

<div class="p"><!----></div>
We embed U<sub>7</sub>(2) into S,
by first replacing each element in <font size="+0">F</font><sub>4</sub> by the 2 &times;2 matrix
of the induced <font size="+0">F</font><sub>2</sub>-linear mapping w.r.t.&nbsp;a suitable basis,
and then conjugating the images of the generators such that the invariant
quadratic form of S is respected.

<div class="p"><!----></div>

<pre>
    gap&#62; o:= SO(-1,14,2);;
    gap&#62; g:= SU(7,2);;
    gap&#62; b:= Basis( GF(4) );;
    gap&#62; blow:= List( GeneratorsOfGroup( g ), x -&#62; BlownUpMat( b, x ) );;
    gap&#62; form:= NullMat( 14, 14, GF(2) );;
    gap&#62; for i in [ 1 .. 14 ] do form[i][ 15-i ]:= Z(2); od;
    gap&#62; ForAll( blow, x -&#62; x * form * TransposedMat( x ) = form );
    true
    gap&#62; pi:= PermutationMat( (1,13)(3,11)(5,9), 14, GF(2) );;
    gap&#62; pi * form * TransposedMat( pi ) = InvariantBilinearForm( o ).matrix;
    true
    gap&#62; pi2:= PermutationMat( (7,3)(8,4), 14, GF(2) );;
    gap&#62; D:= pi2 * pi;;
    gap&#62; tblow:= List( blow, x -&#62; D * x * D^-1 );;
    gap&#62; IsSubset( o, tblow );
    true

</pre>

<div class="p"><!----></div>
Note that the central subgroup of order three in <span class="roman">GU</span>(7,2) consists of
scalar matrices.

<div class="p"><!----></div>

<pre>
    gap&#62; omega:= DerivedSubgroup( o );;
    gap&#62; IsSubset( omega, tblow );
    true
    gap&#62; z:= Z(4) * One( g );;
    gap&#62; tz:= D * BlownUpMat( b, z ) * D^-1;;
    gap&#62; tz in omega;
    true

</pre>

<div class="p"><!----></div>
Now we switch to a permutation representation of S,
and compute the conjugacy classes of prime element order in the subgroup M.
The latter is done in two steps, first class representatives of the
simple subgroup U<sub>7</sub>(2) of M are computed, and then they are multiplied
with the scalars in M.

<div class="p"><!----></div>

<pre>
    gap&#62; orbs:= Orbits( omega, NormedVectors( GF(2)^14 ), OnLines );;
    gap&#62; List( orbs, Length );
    [ 8127, 8256 ]
    gap&#62; omega:= Action( omega, orbs[1], OnLines );;
    gap&#62; gens:= List( GeneratorsOfGroup( g ),
    &#62;             x -&#62; Permutation( D * BlownUpMat( b, x ) * D^-1, orbs[1] ) );;
    gap&#62; g:= Group( gens );;
    gap&#62; ccl:= ClassesOfPrimeOrder( g, Set( Factors( Size( g ) ) ),
    &#62;                               TrivialSubgroup( g ) );;
    gap&#62; tz:= Permutation( tz, orbs[1] );;
    gap&#62; primereps:= List( ccl, Representative );;
    gap&#62; Add( primereps, () );
    gap&#62; reps:= Concatenation( List( primereps,
    &#62;               x -&#62; List( [ 0 .. 2 ], i -&#62; x * tz^i ) ) );;
    gap&#62; primereps:= Filtered( reps, x -&#62; IsPrimeInt( Order( x ) ) );;
    gap&#62; Length( primereps );
    48

</pre>

<div class="p"><!----></div>
Finally, we apply <tt>UpperBoundFixedPointRatios</tt> (see Section&nbsp;<a href="#groups">3.3</a>)
to compute an upper bound for &#956;(g,S/M), for g  &#8712; S<sup>&times;</sup>.

<div class="p"><!----></div>

<pre>
    gap&#62; M:= ClosureGroup( g, tz );;
    gap&#62; bccl:= List( primereps, x -&#62; ConjugacyClass( M, x ) );;
    gap&#62; UpperBoundFixedPointRatios( omega, [ bccl ], false );
    [ 1/2015, true ]

</pre>

<div class="p"><!----></div>
Although some of the classes of M in the list <tt>bccl</tt> may be S-conjugate,
the entry <tt>true</tt> in the second position of the result indicates
that in fact the <em>exact</em> value for the maximum of &#956;(g,S/M),
for g  &#8712; S<sup>&times;</sup>, has been computed.
This implies statement&nbsp;(b).

<div class="p"><!----></div>
We clean the workspace.

<div class="p"><!----></div>

<pre>
    gap&#62; CleanWorkspace();

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.18">
5.18</a>&nbsp;&nbsp;O<sub>12</sub><sup>+</sup>(3)</h3><a name="O12p3">
</a>

<div class="p"><!----></div>
We show that the group S = O<sub>12</sub><sup>+</sup>(3) = <span class="roman">P</span>&#8486;<sup>+</sup>(12,3) satisfies the
following.

<ol type="1">
<br />(a)
    S has a maximal subgroup M of the type N<sub>S</sub>(<span class="roman">P</span>&#8486;<sup>+</sup>(6,9)),
    which has the structure <span class="roman">P</span>&#8486;<sup>+</sup>(6,9).[4].
<br />(b)
    &#956;(g,S/M)  &#8804; 2/88&nbsp;209 holds for all g  &#8712; S<sup>&times;</sup>.</ol>

<div class="p"><!----></div>
(This result is used in the proof of&nbsp;[<a href="#BGK" name="CITEBGK">BGK08</a>,Proposition&nbsp;5.14],
where it is shown that for s  &#8712; S of order 205,
<font face="helvetica"><i>M</i></font>(S,s) consists of one reducible subgroup G<sub>8</sub>
and at most two extension field type subgroups
of the type N<sub>S</sub>(<span class="roman">P</span>&#8486;<sup>+</sup>(6,9)).
By&nbsp;[<a href="#GK" name="CITEGK">GK00</a>,Proposition&nbsp;3.16], &#956;(g,S/G<sub>8</sub>)  &#8804; 19/3<sup>5</sup> holds
for all g  &#8712; S<sup>&times;</sup>.
This implies
P(g,s)  &#8804; 19/3<sup>5</sup> + 2 &#183;2/88&nbsp;209 = 6&nbsp;901/88&nbsp;209  &lt;  1/3.)

<div class="p"><!----></div>
Statement&nbsp;(a) follows from&nbsp;[<a href="#KlL90" name="CITEKlL90">KL90</a>,Prop.&nbsp;4.3.14].

<div class="p"><!----></div>
For statement&nbsp;(b), we embed <span class="roman">GO</span><sup>+</sup>(6,9)  &#8773; &#8486;<sup>+</sup>(6,9).2<sup>2</sup>
into <span class="roman">SO</span><sup>+</sup>(12,3) = 2.S.2,
by replacing each element in <font size="+0">F</font><sub>9</sub> by the 2 &times;2 matrix of the
induced <font size="+0">F</font><sub>3</sub>-linear mapping w.r.t.&nbsp;a suitable basis (b<sub>1</sub>, b<sub>2</sub>).
We choose a basis with the property b<sub>1</sub> = 1 and b<sub>2</sub><sup>2</sup> = 1 + b<sub>2</sub>,
because then the image of a symmetric matrix is again symmetric
(so the image of the invariant form is an invariant form for the image
of the group),
and apply an appropriate transformation to the images of the generators.

<div class="p"><!----></div>

<pre>
    gap&#62; so:= SO(+1,12,3);;
    gap&#62; Display( InvariantBilinearForm( so ).matrix );
     . 1 . . . . . . . . . .
     1 . . . . . . . . . . .
     . . 1 . . . . . . . . .
     . . . 2 . . . . . . . .
     . . . . 2 . . . . . . .
     . . . . . 2 . . . . . .
     . . . . . . 2 . . . . .
     . . . . . . . 2 . . . .
     . . . . . . . . 2 . . .
     . . . . . . . . . 2 . .
     . . . . . . . . . . 2 .
     . . . . . . . . . . . 2
    gap&#62; g:= GO(+1,6,9);;
    gap&#62; Z(9)^2 = Z(3)^0 + Z(9);
    true
    gap&#62; b:= Basis( GF(9), [ Z(3)^0, Z(9) ] );
    Basis( GF(3^2), [ Z(3)^0, Z(3^2) ] )
    gap&#62; blow:= List( GeneratorsOfGroup( g ), x -&#62; BlownUpMat( b, x ) );;
    gap&#62; m:= BlownUpMat( b, InvariantBilinearForm( g ).matrix );;
    gap&#62; Display( m );
     . . 1 . . . . . . . . .
     . . . 1 . . . . . . . .
     1 . . . . . . . . . . .
     . 1 . . . . . . . . . .
     . . . . 2 . . . . . . .
     . . . . . 2 . . . . . .
     . . . . . . 2 . . . . .
     . . . . . . . 2 . . . .
     . . . . . . . . 2 . . .
     . . . . . . . . . 2 . .
     . . . . . . . . . . 2 .
     . . . . . . . . . . . 2
    gap&#62; pi:= PermutationMat( (2,3), 12, GF(3) );;
    gap&#62; tr:= IdentityMat( 12, GF(3) );;
    gap&#62; tr{[3,4]}{[3,4]}:= [[1,-1],[1,1]]*Z(3)^0;;
    gap&#62; D:= tr * pi;;
    gap&#62; D * m * TransposedMat( D ) = InvariantBilinearForm( so ).matrix;
    true
    gap&#62; tblow:= List( blow, x -&#62; D * x * D^-1 );;
    gap&#62; IsSubset( so, tblow );
    true

</pre>

<div class="p"><!----></div>
The image of <span class="roman">GO</span><sup>+</sup>(6,9) under the embedding into <span class="roman">SO</span><sup>+</sup>(12,3)
does not lie in &#8486;<sup>+</sup>(12,3) = 2.S,
so a factor of two is missing in <span class="roman">GO</span><sup>+</sup>(6,9) &#8745;2.S for getting
(the preimage 2.M of) the required maximal subgroup M of S.
Because of this, and also because currently it is time consuming
to compute the derived subgroup of <span class="roman">SO</span><sup>+</sup>(12,3),
we work with the upward extension <span class="roman">PSO</span><sup>+</sup>(12,3) = S.2.
Note that M extends to a maximal subgroup of S.2.

<div class="p"><!----></div>
First we factor out the centre of <span class="roman">SO</span><sup>+</sup>(12,3),
and switch to a permutation representation of S.2.

<div class="p"><!----></div>

<pre>
    gap&#62; orbs:= Orbits( so, NormedVectors( GF(3)^12 ), OnLines );;
    gap&#62; List( orbs, Length );
    [ 88452, 88452, 88816 ]
    gap&#62; act:= Action( so, orbs[1], OnLines );;
    gap&#62; SetSize( act, Size( so ) / 2 );

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
Next we rewrite the matrix generators for <span class="roman">GO</span><sup>+</sup>(6,9) accordingly,
and compute the normalizer in S.2 of the subgroup they generate;
this is the maximal subgroup M.2 we need.

<div class="p"><!----></div>

<pre>
    gap&#62; u:= SubgroupNC( act,
    &#62;            List( tblow, x -&#62; Permutation( x, orbs[1], OnLines ) ) );;
    gap&#62; n:= Normalizer( act, u );;
    gap&#62; Size( n ) / Size( u );
    2

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
Now we compute class representatives of prime order in M.2,
in a smaller faithful permutation representation,
and then the desired upper bound for &#956;(g, S/M).

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; norbs:= Orbits( n, MovedPoints( n ) );;
    gap&#62; List( norbs, Length );
    [ 58968, 29484 ]
    gap&#62; hom:= ActionHomomorphism( n, norbs[2] );;
    gap&#62; nact:= Image( hom );;
    gap&#62; Size( nact ) = Size( n );
    true
    gap&#62; ccl:= ClassesOfPrimeOrder( nact, Set( Factors( Size( nact ) ) ),
    &#62;                               TrivialSubgroup( nact ) );;
    gap&#62; Length( ccl );
    26
    gap&#62; preim:= List( ccl,
    &#62;        x -&#62; PreImagesRepresentative( hom, Representative( x ) ) );;
    gap&#62; pccl:= List( preim, x -&#62; ConjugacyClass( n, x ) );;
    gap&#62; for i in [ 1 .. Length( pccl ) ] do
    &#62;      SetSize( pccl[i], Size( ccl[i] ) );
    &#62;    od;
    gap&#62; UpperBoundFixedPointRatios( act, [ pccl ], false );
    [ 2/88209, true ]

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
Note that we have computed
max{ &#956;(g,S.2/M.2), g  &#8712; S.2<sup>&times;</sup> }  &#8805;  max{ &#956;(g,S.2/M.2), g  &#8712; S<sup>&times;</sup> } = max{ &#956;(g,S/M), g  &#8712; S<sup>&times;</sup> }.

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.19">
5.19</a>&nbsp;&nbsp;&#8727;&nbsp;S<sub>4</sub>(8)</h3><a name="S48">
</a>

<div class="p"><!----></div>
We show that the group S = S<sub>4</sub>(8) = <span class="roman">Sp</span>(4,8) satisfies the following.

<ol type="1">
<br />(a)
    For s  &#8712; S irreducible of order 65,
    <font face="helvetica"><i>M</i></font>(S,s) consists of two nonconjugate subgroups of the type
    S<sub>2</sub>(64).2 = <span class="roman">Sp</span>(2,64).2  &#8773; L<sub>2</sub>(64).2  &#8773; O<sub>4</sub><sup>&#8722;</sup>(8).2 = &#8486;<sup>&#8722;</sup>(4,8).2.
<br />(b)
    &#963;(S,s) = 8/63.</ol>

<div class="p"><!----></div>
By&nbsp;[<a href="#Be00" name="CITEBe00">Ber00</a>], the only maximal subgroups of S that contain s
are O<sub>4</sub><sup>&#8722;</sup>(8).2 = <span class="roman">SO</span><sup>&#8722;</sup>(4,8) or of extension field type.
By&nbsp;[<a href="#KlL90" name="CITEKlL90">KL90</a>,Prop.&nbsp;4.3.10, 4.8.6], there is one class of each of these
subgroups (which happen to be isomorphic).

<div class="p"><!----></div>
These classes of subgroups induce different permutation characters.
One argument to see this is that the involutions in the outer half
of extension field type subgroup S<sub>2</sub>(64).2  &lt;  S<sub>4</sub>(8) have
a two-dimensional fixed space,
whereas the outer involutions in <span class="roman">SO</span><sup>&#8722;</sup>(4,8) have a three-dimensional
fixed space.

<div class="p"><!----></div>
The former statement can be seen by using a normal basis of the field
extension <font size="+0">F</font><sub>64</sub>/<font size="+0">F</font><sub>8</sub>, such that the action of the Frobenius
automorphism (which yields a suitable outer involution) is just a
double transposition on the basis vectors of the natural module for S.

<div class="p"><!----></div>

<pre>
    gap&#62; sp:= SP(4,8);;
    gap&#62; Display( InvariantBilinearForm( sp ).matrix );
     . . . 1
     . . 1 .
     . 1 . .
     1 . . .
    gap&#62; z:= Z(64);;
    gap&#62; f:= AsField( GF(8), GF(64) );;
    gap&#62; repeat
    &#62;      b:= Basis( f, [ z, z^8 ] );
    &#62;      z:= z * Z(64);
    &#62; until b &lt;&#62; fail;
    gap&#62; sub:= SP(2,64);;
    gap&#62; Display( InvariantBilinearForm( sub ).matrix );
     . 1
     1 .
    gap&#62; ext:= Group( List( GeneratorsOfGroup( sub ),
    &#62;                       x -&#62; BlownUpMat( b, x ) ) );;
    gap&#62; tr:= PermutationMat( (3,4), 4, GF(2) );;
    gap&#62; conj:= ConjugateGroup( ext, tr );;
    gap&#62; IsSubset( sp, conj );
    true
    gap&#62; inv:= [[0,1,0,0],[1,0,0,0],[0,0,0,1],[0,0,1,0]] * Z(2);;
    gap&#62; inv in sp;
    true
    gap&#62; inv in conj;
    false
    gap&#62; Length( NullspaceMat( inv - inv^0 ) );
    2

</pre>

<div class="p"><!----></div>
The latter statement can be shown by looking at an outer involution in
<span class="roman">SO</span><sup>&#8722;</sup>(4,8).

<div class="p"><!----></div>

<pre>
    gap&#62; so:= SO(-1,4,8);;
    gap&#62; der:= DerivedSubgroup( so );;
    gap&#62; x:= First( GeneratorsOfGroup( so ), x -&#62; not x in der );;
    gap&#62; x:= x^( Order(x)/2 );;
    gap&#62; Length( NullspaceMat( x - x^0 ) );
    3

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
The character table of L<sub>2</sub>(64).2 is currently not available in the
<font face="helvetica">GAP</font> Character Table Library, so we compute the possible permutation
characters with a combinatorial approach,
and show statement&nbsp;(a).

<div class="p"><!----></div>

<pre>
    gap&#62; CharacterTable( "L2(64).2" );
    fail
    gap&#62; t:= CharacterTable( "S4(8)" );;
    gap&#62; degree:= Size( t ) / ( 2 * Size( SL(2,64) ) );;
    gap&#62; pi:= PermChars( t, rec( torso:= [ degree ] ) );
    [ Character( CharacterTable( "S4(8)" ), [ 2016, 0, 256, 32, 0, 36, 0, 8, 1, 
          0, 4, 0, 0, 0, 28, 28, 28, 0, 0, 0, 0, 0, 0, 36, 36, 36, 0, 0, 0, 0, 0, 
          0, 1, 1, 1, 0, 0, 0, 4, 4, 4, 0, 0, 0, 4, 4, 4, 0, 0, 0, 1, 1, 1, 0, 0, 
          0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
          1, 1, 1, 1 ] ), Character( CharacterTable( "S4(8)" ), 
        [ 2016, 256, 0, 32, 36, 0, 0, 8, 1, 4, 0, 28, 28, 28, 0, 0, 0, 0, 0, 0, 
          36, 36, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 4, 4, 4, 0, 0, 0, 4, 4, 
          4, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 
          0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ) ]
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 65 );;
    gap&#62; List( pi, x -&#62; x[ spos ] );
    [ 1, 1 ]

</pre>

<div class="p"><!----></div>
Now we compute &#963;(S,s), which yields statement&nbsp;(b).

<div class="p"><!----></div>

<pre>
    gap&#62; Maximum( ApproxP( pi, spos ) );
    8/63

</pre>

<div class="p"><!----></div>
We clean the workspace.

<div class="p"><!----></div>

<pre>
    gap&#62; CleanWorkspace();

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.20">
5.20</a>&nbsp;&nbsp;S<sub>6</sub>(2)</h3><a name="S62">
</a>

<div class="p"><!----></div>
We show that the group S = S<sub>6</sub>(2) = <span class="roman">Sp</span>(6,2) satisfies the following.

<ol type="1">
<br />(a)
    &#963;(S) = 4/7,
    and this value is attained exactly for &#963;(S,s)
    with s of order 9.
<br />(b)
    For s  &#8712; S of order 9,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one subgroup of the type
    U<sub>4</sub>(2).2 = &#8486;<sup>&#8722;</sup>(6,2).2 and three conjugate subgroups
    of the type L<sub>2</sub>(8).3 = <span class="roman">Sp</span>(2,8).3.
<br />(c)
    For s  &#8712; S of order 9,
    and g  &#8712; S<sup>&times;</sup>,
    we have P(g,s)  &lt;  1/3, except if g is in one of the classes
    <tt>2A</tt> (the transvection class) or <tt>3A</tt>.
<br />(d)
    For s  &#8712; S of order 15,
    and g  &#8712; S<sup>&times;</sup>,
    we have P(g,s)  &lt;  1/3, except if g is in one of the classes
    <tt>2A</tt> or <tt>2B</tt>.
<br />(e)
    P(S) = 11/21,
    and this value is attained exactly for P(S,s)
    with s of order 15.
<br />(f)
    For all s<sup>&#8242;</sup>  &#8712; S,
    we have P(g,s<sup>&#8242;</sup>)  &gt;  1/3 for g in at least two classes.
<br />(g)
    The uniform spread of S is at least two,
    with s of order 9.
</ol>

<div class="p"><!----></div>
(Note that in this example, the optimal choice of s w.r.t. &#963;(S,s)
is not optimal w.r.t. P(S,s).)

<div class="p"><!----></div>
Statement&nbsp;(a) follows from the inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<a href="#easyloop">4.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "S6(2)" );;
    gap&#62; ProbGenInfoSimple( t );
    [ "S6(2)", 4/7, 1, [ "9A" ], [ 4 ] ]

</pre>

<div class="p"><!----></div>
Also statement&nbsp;(b) follows from the information provided by the
character table of S (cf.&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;46]).

<div class="p"><!----></div>

<pre>
    gap&#62; prim:= PrimitivePermutationCharacters( t );;
    gap&#62; ord:= OrdersClassRepresentatives( t );;
    gap&#62; spos:= Position( ord, 9 );;
    gap&#62; filt:= PositionsProperty( prim, x -&#62; x[ spos ] &lt;&#62; 0 );
    [ 1, 8 ]
    gap&#62; Maxes( t ){ filt };
    [ "U4(2).2", "L2(8).3" ]
    gap&#62; List( prim{ filt }, x -&#62; x[ spos ] );
    [ 1, 3 ]

</pre>

<div class="p"><!----></div>
Now we consider statement&nbsp;(c).
For s of order 9 and g in one of the classes <tt>2A</tt>, <tt>3A</tt>,
we observe that P(g,s) = &#963;(g,s) holds.
This is because exactly one maximal subgroup of S
contains both s and g.
For all other elements g, we have even &#963;(g,s)  &lt;  1/3.

<div class="p"><!----></div>

<pre>
    gap&#62; prim:= PrimitivePermutationCharacters( t );;
    gap&#62; spos9:= Position( ord, 9 );;
    gap&#62; approx9:= ApproxP( prim, spos9 );;
    gap&#62; filt9:= PositionsProperty( approx9, x -&#62; x &#62;= 1/3 );
    [ 2, 6 ]
    gap&#62; AtlasClassNames( t ){ filt9 };
    [ "2A", "3A" ]
    gap&#62; approx9{ filt9 };
    [ 4/7, 5/14 ]
    gap&#62; List( Filtered( prim, x -&#62; x[ spos9 ] &lt;&#62; 0 ), x -&#62; x{ filt9 } );
    [ [ 16, 10 ], [ 0, 0 ] ]

</pre>

<div class="p"><!----></div>
Similarly, statement&nbsp;(d) follows.
For s of order 15 and g in one of the classes <tt>2A</tt>, <tt>2B</tt>,
already the degree 36 permutation character yields P(g,s)  &#8805; 1/3.
And for all other elements g, again we have &#963;(g,s)  &lt;  1/3.

<div class="p"><!----></div>

<pre>
    gap&#62; spos15:= Position( ord, 15 );;
    gap&#62; approx15:= ApproxP( prim, spos15 );;
    gap&#62; filt15:= PositionsProperty( approx15, x -&#62; x &#62;= 1/3 );
    [ 2, 3 ]
    gap&#62; PositionsProperty( ApproxP( prim{ [ 2 ] }, spos15 ), x -&#62; x &#62;= 1/3 );
    [ 2, 3 ]
    gap&#62; AtlasClassNames( t ){ filt15 };
    [ "2A", "2B" ]
    gap&#62; approx15{ filt15 };
    [ 46/63, 8/21 ]

</pre>

<div class="p"><!----></div>
For the remaining statements, we use explicit computations with S,
in the transitive degree 63 permutation representation.
We start with a function that computes a transvection in S<sub>d</sub>(2);
note that the invariant bilinear form used for symplectic groups in <font face="helvetica">GAP</font>
is described by a matrix with nonzero entries exactly in the positions
(i,d+1&#8722;i), for 1  &#8804; i  &#8804; d.

<div class="p"><!----></div>

<pre>
    gap&#62; transvection:= function( d )
    &#62;     local mat;
    &#62;     mat:= IdentityMat( d, Z(2) );
    &#62;     mat{ [ 1, d ] }{ [ 1, d ] }:= [ [ 0, 1 ], [ 1, 0 ] ] * Z(2);
    &#62;     return mat;
    &#62; end;;

</pre>

<div class="p"><!----></div>
First we compute, for statement&nbsp;(d), the exact values P(g,s) for g
in one of the classes <tt>2A</tt> or <tt>2B</tt>, and s of order 15.
Note that the classes <tt>2A</tt>, <tt>2B</tt> are the unique classes of the
lengths 63 and 315, respectively.

<div class="p"><!----></div>

<pre>
    gap&#62; PositionsProperty( SizesConjugacyClasses( t ), x -&#62; x in [ 63, 315 ] );
    [ 2, 3 ]
    gap&#62; d:= 6;;
    gap&#62; matgrp:= Sp(d,2);;
    gap&#62; hom:= ActionHomomorphism( matgrp, NormedRowVectors( GF(2)^d ) );;
    gap&#62; g:= Image( hom, matgrp );;
    gap&#62; ResetGlobalRandomNumberGenerators();
    gap&#62; repeat s15:= Random( g );
    &#62;    until Order( s15 ) = 15;
    gap&#62; 2A:= Image( hom, transvection( d ) );;
    gap&#62; Size( ConjugacyClass( g, 2A ) );
    63
    gap&#62; IsTransitive( g, MovedPoints( g ) );
    true
    gap&#62; RatioOfNongenerationTransPermGroup( g, 2A, s15 );
    11/21
    gap&#62; repeat 12C:= Random( g );
    &#62;    until Order( 12C ) = 12 and Size( Centralizer( g, 12C ) ) = 12;
    gap&#62; 2B:= 12C^6;;
    gap&#62; Size( ConjugacyClass( g, 2B ) );
    315
    gap&#62; RatioOfNongenerationTransPermGroup( g, 2B, s15 );
    8/21

</pre>

<div class="p"><!----></div>
For statement&nbsp;(e), we compute P(g, s<sup>&#8242;</sup>),
for a transvection g and class representatives s<sup>&#8242;</sup> of S.
It turns out that the minimum is 11/21,
and it is attained for exactly one s<sup>&#8242;</sup>;
by the above, this element has order 15.

<div class="p"><!----></div>

<pre>
    gap&#62; ccl:= ConjugacyClasses( g );;
    gap&#62; reps:= List( ccl, Representative );;
    gap&#62; nongen2A:= List( reps,
    &#62;        x -&#62; RatioOfNongenerationTransPermGroup( g, 2A, x ) );;
    gap&#62; min:= Minimum( nongen2A );
    11/21
    gap&#62; Number( nongen2A, x -&#62; x = min );
    1

</pre>

<div class="p"><!----></div>
For statement&nbsp;(f), we show that for any choice of s<sup>&#8242;</sup>,
at least two of the values P(g,s<sup>&#8242;</sup>),
with g in the classes <tt>2A</tt>, <tt>2B</tt>, or <tt>3A</tt>,
are larger than 1/3.

<div class="p"><!----></div>

<pre>
    gap&#62; nongen2B:= List( reps,
    &#62;        x -&#62; RatioOfNongenerationTransPermGroup( g, 2B, x ) );;
    gap&#62; 3A:= s15^5;;
    gap&#62; nongen3A:= List( reps,
    &#62;        x -&#62; RatioOfNongenerationTransPermGroup( g, 3A, x ) );;
    gap&#62; bad:= List( [ 1 .. NrConjugacyClasses( t ) ],
    &#62;                i -&#62; Number( [ nongen2A, nongen2B, nongen3A ],
    &#62;                             x -&#62; x[i] &#62; 1/3 ) );;
    gap&#62; Minimum( bad );
    2

</pre>

<div class="p"><!----></div>
Finally, for statement&nbsp;(g), we have to consider only the case that the
two elements x, y are transvections.

<div class="p"><!----></div>

<pre>
    gap&#62; PositionsProperty( approx9, x -&#62; x + approx9[2] &#62;= 1 );
    [ 2 ]

</pre>

<div class="p"><!----></div>
We use the random approach described in Section&nbsp;<a href="#groups">3.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; repeat s9:= Random( g );
    &#62;    until Order( s9 ) = 9;
    gap&#62; RandomCheckUniformSpread( g, [ 2A, 2A ], s9, 20 );
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.21">
5.21</a>&nbsp;&nbsp;S<sub>8</sub>(2)</h3><a name="S82">
</a>

<div class="p"><!----></div>
We show that the group S = S<sub>8</sub>(2) satisfies the following.

<ol type="1">
<br />(a)
    For s  &#8712; S of order 17,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one subgroup of each of the types
    O<sub>8</sub><sup>&#8722;</sup>(2).2 = &#8486;<sup>&#8722;</sup>(8,2).2, S<sub>4</sub>(4).2 = <span class="roman">Sp</span>(4,4).2,
    and L<sub>2</sub>(17) = <span class="roman">PSL</span>(2,17).
<br />(b)
    For s  &#8712; S of order 17,
    and g  &#8712; S<sup>&times;</sup>,
    we have P(g,s)  &lt;  1/3, except if g is a transvection.
<br />(c)
    The uniform spread of S is at least two,
    with s of order 17.</ol>

<div class="p"><!----></div>
Statement&nbsp;(a) follows from the list of maximal subgroups of S
in&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;123],
and the fact that 1<sub>H</sub><sup>S</sup>(s) = 1 holds for each H  &#8712; <font face="helvetica"><i>M</i></font>(S,s).
Note that 17 divides the indices of the maximal subgroups of the types
O<sub>8</sub><sup>+</sup>(2).2 and 2<sup>7</sup> : S<sub>6</sub>(2) in S,
and obviously 17 does not divide the orders of the remaining maximal
subgroups.

<div class="p"><!----></div>
The permutation characters induced from the first two subgroups
are uniquely determined by the ordinary character tables.
The permutation character induced from the last subgroup is
uniquely determined if one considers also the corresponding Brauer tables;
the correct class fusion is stored in the <font face="helvetica">GAP</font> Character Table Library,
see&nbsp;[<a href="#AmbigFus" name="CITEAmbigFus">Brea</a>].

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "S8(2)" );;
    gap&#62; pi1:= PossiblePermutationCharacters( CharacterTable( "O8-(2).2" ), t );;
    gap&#62; pi2:= PossiblePermutationCharacters( CharacterTable( "S4(4).2" ), t );;
    gap&#62; pi3:= [ TrivialCharacter( CharacterTable( "L2(17)" ) )^t ];;
    gap&#62; prim:= Concatenation( pi1, pi2, pi3 );;
    gap&#62; Length( prim );
    3
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 17 );;
    gap&#62; List( prim, x -&#62; x[ spos ] );
    [ 1, 1, 1 ]

</pre>

<div class="p"><!----></div>
For statement&nbsp;(b),
we observe that &#963;(g,s)  &lt;  1/3 if g is not a transvection,
and that P(g,s) = &#963;(g,s) for transvections g
because exactly one of the three permutation characters is nonzero
on both s and the class of transvections.

<div class="p"><!----></div>

<pre>
    gap&#62; approx:= ApproxP( prim, spos );;
    gap&#62; PositionsProperty( approx, x -&#62; x &#62;= 1/3 );
    [ 2 ]
    gap&#62; Number( prim, pi -&#62; pi[2] &lt;&#62; 0 and pi[ spos ] &lt;&#62; 0 );
    1
    gap&#62; approx[2];
    8/15

</pre>

<div class="p"><!----></div>
In statement&nbsp;(c), we have to consider only the case that the
two elements x, y are transvections.

<div class="p"><!----></div>

<pre>
    gap&#62; PositionsProperty( approx, x -&#62; x + approx[2] &#62;= 1 );
    [ 2 ]

</pre>

<div class="p"><!----></div>
We use the random approach described in Section&nbsp;<a href="#groups">3.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; d:= 8;;
    gap&#62; matgrp:= Sp(d,2);;
    gap&#62; hom:= ActionHomomorphism( matgrp, NormedRowVectors( GF(2)^d ) );;
    gap&#62; x:= Image( hom, transvection( d ) );;
    gap&#62; g:= Image( hom, matgrp );;
    gap&#62; C:= ConjugacyClass( g, x );;  Size( C );
    255
    gap&#62; ResetGlobalRandomNumberGenerators();
    gap&#62; repeat s:= Random( g );
    &#62;    until Order( s ) = 17;
    gap&#62; RandomCheckUniformSpread( g, [ x, x ], s, 20 );
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.22">
5.22</a>&nbsp;&nbsp;&#8727;&nbsp;S<sub>10</sub>(2)</h3><a name="S102">
</a>

<div class="p"><!----></div>
We show that the group S = S<sub>10</sub>(2) satisfies the following.

<ol type="1">
<br />(a)
    For s  &#8712; S of order 33,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one subgroup of each of the types
    &#8486;<sup>&#8722;</sup>(10,2).2 and L<sub>2</sub>(32).5 = <span class="roman">Sp</span>(2,32).5.
<br />(b)
    For s  &#8712; S of order 33,
    and g  &#8712; S<sup>&times;</sup>,
    we have P(g,s)  &lt;  1/3, except if g is a transvection.
<br />(c)
    The uniform spread of S is at least two,
    with s of order 33.</ol>

<div class="p"><!----></div>
By&nbsp;[<a href="#Be00" name="CITEBe00">Ber00</a>], the only maximal subgroups of S that contain s
have the types stated in&nbsp;(a),
and by&nbsp;[<a href="#KlL90" name="CITEKlL90">KL90</a>,Prop.&nbsp;4.3.10 and 4.8.6], there is exactly one class
of each of these subgroups.

<div class="p"><!----></div>
We compute the values &#963;( g, s ), for all g  &#8712; S<sup>&times;</sup>.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "S10(2)" );;
    gap&#62; pi1:= PossiblePermutationCharacters( CharacterTable( "O10-(2).2" ), t );;
    gap&#62; pi2:= PossiblePermutationCharacters( CharacterTable( "L2(32).5" ), t );;
    gap&#62; prim:= Concatenation( pi1, pi2 );;  Length( prim );
    2
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 33 );;
    gap&#62; approx:= ApproxP( prim, spos );;

</pre>

<div class="p"><!----></div>
For statement&nbsp;(b),
we observe that &#963;(g,s)  &lt;  1/3 if g is not a transvection,
and that P(g,s) = &#963;(g,s) for transvections g
because exactly one of the two permutation characters is nonzero
on both s and the class of transvections.

<div class="p"><!----></div>

<pre>
    gap&#62; PositionsProperty( approx, x -&#62; x &#62;= 1/3 );
    [ 2 ]
    gap&#62; Number( prim, pi -&#62; pi[2] &lt;&#62; 0 and pi[ spos ] &lt;&#62; 0 );
    1
    gap&#62; approx[2];
    16/31

</pre>

<div class="p"><!----></div>
In statement&nbsp;(c), we have to consider only the case that the
two elements x, y are transvections.
We use the random approach described in Section&nbsp;<a href="#groups">3.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; d:= 10;;
    gap&#62; matgrp:= Sp(d,2);;
    gap&#62; hom:= ActionHomomorphism( matgrp, NormedRowVectors( GF(2)^d ) );;
    gap&#62; x:= Image( hom, transvection( d ) );;
    gap&#62; g:= Image( hom, matgrp );;
    gap&#62; C:= ConjugacyClass( g, x );;  Size( C );
    1023
    gap&#62; ResetGlobalRandomNumberGenerators();
    gap&#62; repeat s:= Random( g );
    &#62;    until Order( s ) = 33;
    gap&#62; RandomCheckUniformSpread( g, [ x, x ], s, 20 );
    true

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.23">
5.23</a>&nbsp;&nbsp;U<sub>4</sub>(2)</h3><a name="U42">
</a>

<div class="p"><!----></div>
We show that S = U<sub>4</sub>(2) = <span class="roman">SU</span>(4,2)  &#8773; S<sub>4</sub>(3) = <span class="roman">PSp</span>(4,3)
satisfies the following.

<ol type="1">
<br />(a)
    &#963;(S) = 21/40,
    and this value is attained exactly for &#963;(S,s)
    with s of order 12.
<br />(b)
    For s  &#8712; S of order 9,
    <font face="helvetica"><i>M</i></font>(S,s) consists of two groups,
    of the types 3<sup>1+2</sup><sub>+</sub> :2A<sub>4</sub> = <span class="roman">GU</span>(3,2) and 3<sup>3</sup> :S<sub>4</sub>,
    respectively.
<br />(c)
    P(S) = 2/5,
    and this value is attained exactly for P(S,s)
    with s of order 9.
<br />(d)
    The uniform spread of S is at least three,
    with s of order 9.
<br />(e)
    &#963;<sup>&#8242;</sup>(<span class="roman">Aut</span>(S),s) = 7/20.</ol>

<div class="p"><!----></div>

<div class="p"><!----></div>
(Note that in this example, the optimal choice of s w.r.t. &#963;(S,s)
is not optimal w.r.t. P(S,s).)

<div class="p"><!----></div>
Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<a href="#easyloop">4.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "U4(2)" );;
    gap&#62; ProbGenInfoSimple( t );
    [ "U4(2)", 21/40, 1, [ "12A" ], [ 2 ] ]

</pre>

<div class="p"><!----></div>
Statement&nbsp;(b) can be read off from the permutation characters,
and the fact that the only classes of maximal subgroups that contain
elements of order 9 consist of groups of the structures
3<sup>1+2</sup><sub>+</sub>:2A<sub>4</sub> and 3<sup>3</sup>:S<sub>4</sub>,
see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;26].

<div class="p"><!----></div>

<pre>
    gap&#62; OrdersClassRepresentatives( t );
    [ 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 6, 6, 6, 6, 6, 6, 9, 9, 12, 12 ]
    gap&#62; prim:= PrimitivePermutationCharacters( t );
    [ Character( CharacterTable( "U4(2)" ), [ 27, 3, 7, 0, 0, 9, 0, 3, 1, 2, 0, 
          0, 3, 3, 0, 1, 0, 0, 0, 0 ] ), Character( CharacterTable( "U4(2)" ), 
        [ 36, 12, 8, 0, 0, 6, 3, 0, 2, 1, 0, 0, 0, 0, 3, 2, 0, 0, 0, 0 ] ), 
      Character( CharacterTable( "U4(2)" ), [ 40, 8, 0, 13, 13, 4, 4, 4, 0, 0, 5, 
          5, 2, 2, 2, 0, 1, 1, 1, 1 ] ), Character( CharacterTable( "U4(2)" ), 
        [ 40, 16, 4, 4, 4, 1, 7, 0, 2, 0, 4, 4, 1, 1, 1, 1, 1, 1, 0, 0 ] ), 
      Character( CharacterTable( "U4(2)" ), [ 45, 13, 5, 9, 9, 6, 3, 1, 1, 0, 1, 
          1, 4, 4, 1, 2, 0, 0, 1, 1 ] ) ]

</pre>

<div class="p"><!----></div>
For statement&nbsp;(c),
we use a primitive permutation representation on 40 points
that occurs in the natural action of <span class="roman">SU</span>(4,2).

<div class="p"><!----></div>

<pre>
    gap&#62; g:= SU(4,2);;
    gap&#62; orbs:= Orbits( g, NormedRowVectors( GF(4)^4 ), OnLines );;
    gap&#62; List( orbs, Length );
    [ 45, 40 ]
    gap&#62; g:= Action( g, orbs[2], OnLines );;

</pre>

<div class="p"><!----></div>
First we show that for s of order 9, P(S,s) = 2/5 holds.
For that, we have to consider only P(g,s),
with g in one of the classes <tt>2A</tt> (of length 45)
and <tt>3A</tt> (of length 40);
since the class <tt>3B</tt> contains the inverses of the elements in
the class <tt>3A</tt>, we need not test it.

<div class="p"><!----></div>

<pre>
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 9 );
    17
    gap&#62; approx:= ApproxP( prim, spos );
    [ 0, 3/5, 1/10, 17/40, 17/40, 1/8, 11/40, 1/10, 1/20, 0, 9/40, 9/40, 3/40, 
      3/40, 3/40, 1/40, 1/20, 1/20, 1/40, 1/40 ]
    gap&#62; badpos:= PositionsProperty( approx, x -&#62; x &#62;= 2/5 );
    [ 2, 4, 5 ]
    gap&#62; PowerMap( t, 2 )[4];
    5
    gap&#62; OrdersClassRepresentatives( t );
    [ 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 6, 6, 6, 6, 6, 6, 9, 9, 12, 12 ]
    gap&#62; SizesConjugacyClasses( t );
    [ 1, 45, 270, 40, 40, 240, 480, 540, 3240, 5184, 360, 360, 720, 720, 1440, 
      2160, 2880, 2880, 2160, 2160 ]

</pre>

<div class="p"><!----></div>
A representative g of a class of length 40 can be found as the third
power of any order 9 element.

<div class="p"><!----></div>

<pre>
    gap&#62; PowerMap( t, 3 )[ spos ];
    4
    gap&#62; ResetGlobalRandomNumberGenerators();
    gap&#62; repeat s:= Random( g );
    &#62;    until Order( s ) = 9;
    gap&#62; Size( ConjugacyClass( g, s^3 ) );
    40
    gap&#62; prop:= RatioOfNongenerationTransPermGroup( g, s^3, s );
    13/40

</pre>

<div class="p"><!----></div>
Next we examine g in the class <tt>2A</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; repeat x:= Random( g ); until Order( x ) = 12;
    gap&#62; Size( ConjugacyClass( g, x^6 ) );
    45
    gap&#62; prop:= RatioOfNongenerationTransPermGroup( g, x^6, s );
    2/5

</pre>

<div class="p"><!----></div>
Finally, we compute that for s of order different from 9
and g in the class <tt>2A</tt>, P(g,s) is larger than 2/5.

<div class="p"><!----></div>

<pre>
    gap&#62; ccl:= List( ConjugacyClasses( g ), Representative );;
    gap&#62; SortParallel( List( ccl, Order ), ccl );
    gap&#62; List( ccl, Order );
    [ 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 6, 6, 6, 6, 6, 6, 9, 9, 12, 12 ]
    gap&#62; prop:= List( ccl, r -&#62; RatioOfNongenerationTransPermGroup( g, x^6, r ) );
    [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 5/9, 1, 1, 1, 1, 1, 1, 2/5, 2/5, 7/15, 7/15 ]
    gap&#62; Minimum( prop );
    2/5

</pre>

<div class="p"><!----></div>
In order to show statement&nbsp;(d),
we have to consider triples (x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>)
with x<sub>i</sub> of prime order and &#8721;<sub>i=1</sub><sup>3</sup> P(x<sub>i</sub>,s)  &#8805; 1.
This means that it suffices to check x in the class <tt>2A</tt>,
y in <tt>2</tt><tt>A</tt> &#8746;<tt>3</tt><tt>A</tt>,
and z in <tt>2</tt><tt>A</tt> &#8746;<tt>3</tt><tt>A</tt> &#8746;<tt>3</tt><tt>D</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; approx[2]:= 2/5;;
    gap&#62; approx[4]:= 13/40;;
    gap&#62; primeord:= PositionsProperty( OrdersClassRepresentatives( t ),
    &#62;                                  IsPrimeInt );
    [ 2, 3, 4, 5, 6, 7, 10 ]
    gap&#62; RemoveSet( primeord, 5 );
    gap&#62; primeord;
    [ 2, 3, 4, 6, 7, 10 ]
    gap&#62; approx{ primeord };
    [ 2/5, 1/10, 13/40, 1/8, 11/40, 0 ]
    gap&#62; AtlasClassNames( t ){ primeord };
    [ "2A", "2B", "3A", "3C", "3D", "5A" ]
    gap&#62; triples:= Filtered( UnorderedTuples( primeord, 3 ),
    &#62;                  t -&#62; Sum( approx{ t } ) &#62;= 1 );
    [ [ 2, 2, 2 ], [ 2, 2, 4 ], [ 2, 2, 7 ], [ 2, 4, 4 ], [ 2, 4, 7 ] ]

</pre>

<div class="p"><!----></div>
We use the random approach described in Section&nbsp;<a href="#groups">3.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; repeat 6E:= Random( g );
    &#62;    until Order( 6E ) = 6 and Size( Centralizer( g, 6E ) ) = 18;
    gap&#62; 2A:= 6E^3;;
    gap&#62; 3A:= s^3;;
    gap&#62; 3D:= 6E^2;;
    gap&#62; RandomCheckUniformSpread( g, [ 2A, 2A, 2A ], s, 50 );
    true
    gap&#62; RandomCheckUniformSpread( g, [ 2A, 2A, 3A ], s, 50 );
    true
    gap&#62; RandomCheckUniformSpread( g, [ 3D, 2A, 2A ], s, 50 );
    true
    gap&#62; RandomCheckUniformSpread( g, [ 2A, 3A, 3A ], s, 50 );
    true
    gap&#62; RandomCheckUniformSpread( g, [ 3D, 3A, 2A ], s, 50 );
    true

</pre>

<div class="p"><!----></div>
Statement&nbsp;(e) can be proved using <tt>ProbGenInfoAlmostSimple</tt>,
cf. Section&nbsp;<a href="#easyloopaut">4.4</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "U4(2)" );;
    gap&#62; t2:= CharacterTable( "U4(2).2" );;
    gap&#62; spos:= PositionsProperty( OrdersClassRepresentatives( t ), x -&#62; x = 9 );;
    gap&#62; ProbGenInfoAlmostSimple( t, t2, spos );
    [ "U4(2).2", 7/20, [ "9AB" ], [ 2 ] ]

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.24">
5.24</a>&nbsp;&nbsp;U<sub>4</sub>(3)</h3><a name="U43">
</a>

<div class="p"><!----></div>
We show that S = U<sub>4</sub>(3) = <span class="roman">PSU</span>(4,3) satisfies the following.

<ol type="1">
<br />(a)
    &#963;(S) = 53/153,
    and this value is attained exactly for &#963;(S,s)
    with s of order 7.
<br />(b)
    For s  &#8712; S of order 7,
    <font face="helvetica"><i>M</i></font>(S,s) consists of two nonconjugate groups of the type L<sub>3</sub>(4),
    one group of the type U<sub>3</sub>(3), and four pairwise nonconjugate
    groups of the type A<sub>7</sub>.
<br />(c)
    P(S) = 43/135,
    and this value is attained exactly for P(S,s)
    with s of order 7.
<br />(d)
    The uniform spread of S is at least three,
    with s of order 7.
<br />(e)
    The preimage of s in the matrix group <span class="roman">SU</span>(4,3)  &#8773; 4.U<sub>4</sub>(3)
    has order 28,
    the preimages of the groups in <font face="helvetica"><i>M</i></font>(S,s) have the structures
    4<sub>2</sub>.L<sub>3</sub>(4), 4 &times;U<sub>3</sub>(3)  &#8773; <span class="roman">GU</span>(3,3), and 4.A<sub>7</sub>
    (the latter being a central product of a cyclic group of order four
    and 2.A<sub>7</sub>).
<br />(f)
    P<sup>&#8242;</sup>(S.2<sub>1</sub>,s) = 13/27,
    &#963;<sup>&#8242;</sup>(S.2<sub>2</sub>) = 1/3,
    and &#963;<sup>&#8242;</sup>(S.2<sub>3</sub>) = 31/162,
    with s of order 7 in each case.</ol>

<div class="p"><!----></div>
Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<a href="#easyloop">4.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "U4(3)" );;
    gap&#62; ProbGenInfoSimple( t );
    [ "U4(3)", 53/135, 2, [ "7A" ], [ 7 ] ]

</pre>

<div class="p"><!----></div>
Statement&nbsp;(b) can be read off from the permutation characters,
and the fact that the only classes of maximal subgroups that contain
elements of order 7 consist of groups of the structures
as claimed,
see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;52].

<div class="p"><!----></div>

<pre>
    gap&#62; prim:= PrimitivePermutationCharacters( t );;
    gap&#62; spos:= Position( OrdersClassRepresentatives( t ), 7 );
    13
    gap&#62; List( Filtered( prim, x -&#62; x[ spos ] &lt;&#62; 0 ), l -&#62; l{ [ 1, spos ] } );
    [ [ 162, 1 ], [ 162, 1 ], [ 540, 1 ], [ 1296, 1 ], [ 1296, 1 ], [ 1296, 1 ], 
      [ 1296, 1 ] ]

</pre>

<div class="p"><!----></div>
In order to show statement&nbsp;(c) (which then implies statement&nbsp;(d)),
we use a permutation representation on 112 points.
It corresponds to an orbit of one-dimensional subspaces in the
natural module of &#8486;<sup>&#8722;</sup>(6,3)  &#8773; S.

<div class="p"><!----></div>

<pre>
    gap&#62; matgrp:= DerivedSubgroup( SO( -1, 6, 3 ) );;
    gap&#62; orbs:= Orbits( matgrp, NormedRowVectors( GF(3)^6 ), OnLines );;
    gap&#62; List( orbs, Length );
    [ 126, 126, 112 ]
    gap&#62; G:= Action( matgrp, orbs[3], OnLines );;

</pre>

<div class="p"><!----></div>
It is sufficient to compute P(g,s), for involutions g  &#8712; S.

<div class="p"><!----></div>

<pre>
    gap&#62; approx:= ApproxP( prim, spos );
    [ 0, 53/135, 1/10, 1/24, 1/24, 7/45, 4/45, 1/27, 1/36, 1/90, 1/216, 1/216, 
      7/405, 7/405, 1/270, 0, 0, 0, 0, 1/270 ]
    gap&#62; Filtered( approx, x -&#62; x &#62;= 43/135 );
    [ 53/135 ]
    gap&#62; OrdersClassRepresentatives( t );
    [ 1, 2, 3, 3, 3, 3, 4, 4, 5, 6, 6, 6, 7, 7, 8, 9, 9, 9, 9, 12 ]
    gap&#62; ResetGlobalRandomNumberGenerators();
    gap&#62; repeat g:= Random( G ); until Order(g) = 2;
    gap&#62; repeat s:= Random( G );
    &#62;    until Order(s) = 7;
    gap&#62; bad:= RatioOfNongenerationTransPermGroup( G, g, s );
    43/135
    gap&#62; bad &lt; 1/3;
    true

</pre>

<div class="p"><!----></div>
Statement&nbsp;(e) can be shown easily with character-theoretic methods,
as follows.
Since <span class="roman">SU</span>(4,3) is a Schur cover of S and the groups in <font face="helvetica"><i>M</i></font>(S,s)
are simple, only very few possibilities have to be checked.
The Schur multiplier of U<sub>3</sub>(3) is trivial (see, e.&nbsp;g., [<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;14]),
so the preimage in <span class="roman">SU</span>(4,3) is a direct product of U<sub>3</sub>(3) and the
centre of <span class="roman">SU</span>(4,3).
Neither L<sub>3</sub>(4) nor its double cover 2.L<sub>3</sub>(4) can be a subgroup of
<span class="roman">SU</span>(4,3), so the preimage of L<sub>3</sub>(4) must be a Schur cover of L<sub>3</sub>(4),
i.&nbsp;e., it must have either the type 4<sub>1</sub>.L<sub>3</sub>(4) or 4<sub>2</sub>.L<sub>3</sub>(4)
(see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;23]);
only the type 4<sub>2</sub>.L<sub>3</sub>(4) turns out to be possible.

<div class="p"><!----></div>

<pre>
    gap&#62; 4t:= CharacterTable( "4.U4(3)" );;
    gap&#62; Length( PossibleClassFusions( CharacterTable( "L3(4)" ), 4t ) );
    0
    gap&#62; Length( PossibleClassFusions( CharacterTable( "2.L3(4)" ), 4t ) );
    0
    gap&#62; Length( PossibleClassFusions( CharacterTable( "4_1.L3(4)" ), 4t ) );
    0
    gap&#62; Length( PossibleClassFusions( CharacterTable( "4_2.L3(4)" ), 4t ) );
    4

</pre>

<div class="p"><!----></div>
As for the preimage of the A<sub>7</sub> type subgroups,
we first observe that the double cover of A<sub>7</sub> cannot be a subgroup of the
double cover of S,
so the preimage of A<sub>7</sub> in the double cover of U<sub>4</sub>(3) is a direct product
2 &times;A<sub>7</sub>.
The group <span class="roman">SU</span>(4,3) does not contain A<sub>7</sub> type subgroups,
thus the A<sub>7</sub> type subgroups in 2.U<sub>4</sub>(3) lift to double covers of A<sub>7</sub>
in <span class="roman">SU</span>(4,3).
This proves the claimed structure.

<div class="p"><!----></div>

<pre>
    gap&#62; 2t:= CharacterTable( "2.U4(3)" );;
    gap&#62; Length( PossibleClassFusions( CharacterTable( "2.A7" ), 2t ) );
    0
    gap&#62; Length( PossibleClassFusions( CharacterTable( "A7" ), 4t ) );
    0

</pre>

<div class="p"><!----></div>
For statement&nbsp;(f), we consider automorphic extensions of S.
The bound for S.2<sub>3</sub> has been computed in Section&nbsp;<a href="#easyloopaut">4.4</a>.
That for S.2<sub>2</sub> can be computed form the fact that the classes of
maximal subgroups of S.2<sub>2</sub> containing s of order 7 are
S, one class of U<sub>3</sub>(3).2 type subgroups, and two classes of S<sub>7</sub> type
subgroups which induce the same permutation character
(see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;52]).

<div class="p"><!----></div>

<pre>
    gap&#62; t2:= CharacterTable( "U4(3).2_2" );;
    gap&#62; pi1:= PossiblePermutationCharacters( CharacterTable( "U3(3).2" ), t2 );
    [ Character( CharacterTable( "U4(3).2_2" ), [ 540, 12, 54, 0, 0, 9, 8, 0, 0, 
          6, 0, 0, 1, 2, 0, 0, 0, 2, 0, 24, 4, 0, 0, 0, 0, 0, 0, 3, 2, 0, 4, 0, 
          0, 0 ] ) ]
    gap&#62; pi2:= PossiblePermutationCharacters( CharacterTable( "A7.2" ), t2 );
    [ Character( CharacterTable( "U4(3).2_2" ), [ 1296, 48, 0, 27, 0, 9, 0, 4, 1, 
          0, 3, 0, 1, 0, 0, 0, 0, 0, 216, 24, 0, 4, 0, 0, 0, 9, 0, 3, 0, 1, 0, 1, 
          0, 0 ] ) ]
    gap&#62; prim:= Concatenation( pi1, pi2, pi2 );;
    gap&#62; outer:= Difference(
    &#62;      PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),
    &#62;      ClassPositionsOfDerivedSubgroup( t2 ) );;
    gap&#62; spos:= Position( OrdersClassRepresentatives( t2 ), 7 );;
    gap&#62; Maximum( ApproxP( prim, spos ){ outer } );
    1/3

</pre>

<div class="p"><!----></div>
Finally, Section&nbsp;<a href="#easyloopaut">4.4</a> shows that the character tables are
not sufficient for what we need, so we compute the exact proportion of
nongeneration for U<sub>4</sub>(3).2<sub>1</sub>  &#8773; <span class="roman">SO</span><sup>&#8722;</sup>(6,3).

<div class="p"><!----></div>

<pre>
    gap&#62; matgrp:= SO( -1, 6, 3 );
    SO(-1,6,3)
    gap&#62; orbs:= Orbits( matgrp, NormedRowVectors( GF(3)^6 ), OnLines );;
    gap&#62; List( orbs, Length );
    [ 126, 126, 112 ]
    gap&#62; G:= Action( matgrp, orbs[3], OnLines );;
    gap&#62; repeat s:= Random( G );
    &#62;    until Order( s ) = 7;
    gap&#62; repeat
    &#62;      repeat 2B:= Random( G ); until Order( 2B ) mod 2 = 0;
    &#62;      2B:= 2B^( Order( 2B ) / 2 );
    &#62;      c:= Centralizer( G, 2B );
    &#62;    until Size( c ) = 12096;
    gap&#62; RatioOfNongenerationTransPermGroup( G, 2B, s );
    13/27
    gap&#62; repeat
    &#62;      repeat 2C:= Random( G ); until Order( 2C ) mod 2 = 0;
    &#62;      2C:= 2C^( Order( 2C ) / 2 );
    &#62;      c:= Centralizer( G, 2C );
    &#62;    until Size( c ) = 1440;
    gap&#62; RatioOfNongenerationTransPermGroup( G, 2C, s );
    0

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.25">
5.25</a>&nbsp;&nbsp;U<sub>6</sub>(3)</h3><a name="U63">
</a>

<div class="p"><!----></div>
We show that S = U<sub>6</sub>(3) = <span class="roman">PSU</span>(6,3) satisfies the following.

<ol type="1">
<br />(a)
    For s  &#8712; S of the type 1 &#8869;5
    (i.&nbsp;e., the preimage of s in 2.S = <span class="roman">SU</span>(6,3) decomposes the natural
    6-dimensional module for 2.S into an orthogonal sum of two
    irreducible modules of the dimensions 1 and 5, respectively)
    and of order (3<sup>5</sup> + 1)/2 = 122,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one group of the type 2 &times;U<sub>5</sub>(3),
    which lifts to a subgroup of the type 4 &times;U<sub>5</sub>(3) = <span class="roman">GU</span>(5,3)
    in 2.S.
    (The preimage of s in 2.S has order 3<sup>5</sup> + 1 = 244.)
<br />(b)
    &#963;(S,s) = 353/3&nbsp;159.</ol>

<div class="p"><!----></div>
By&nbsp;[<a href="#MSW94" name="CITEMSW94">MSW94</a>], the only maximal subgroup of S that contains s
is the stabilizer H  &#8773; 2 &times;U<sub>5</sub>(3) of the orthogonal decomposition.
This proves statement&nbsp;(a).

<div class="p"><!----></div>
The character table of S is currently not available in the <font face="helvetica">GAP</font>
Character Table Library.
We consider the permutation action of S on the orbit of the stabilized
1-space.
So M can be taken as a point stabilizer in this action.

<div class="p"><!----></div>

<pre>
    gap&#62; CharacterTable( "U6(3)" );
    fail
    gap&#62; g:= SU(6,3);;
    gap&#62; orbs:= Orbits( g, NormedRowVectors( GF(9)^6 ), OnLines );;
    gap&#62; List( orbs, Length );
    [ 22204, 44226 ]
    gap&#62; repeat x:= PseudoRandom( g ); until Order( x ) = 244;
    gap&#62; List( orbs, o -&#62; Number( o, v -&#62; OnLines( v, x ) = v ) );
    [ 0, 1 ]
    gap&#62; g:= Action( g, orbs[2], OnLines );;
    gap&#62; M:= Stabilizer( g, 1 );;

</pre>

<div class="p"><!----></div>
Then we compute a list of elements in M that covers the conjugacy classes
of prime element order, from which the numbers of fixed points
and thus max{ &#956;( S/M, g ); g  &#8712; M<sup>&times;</sup> } = &#963;( S, s )
can be derived.
This way we avoid completely to check the S-conjugacy
of elements (class representatives of Sylow subgroups in M).

<div class="p"><!----></div>

<pre>
    gap&#62; elms:= [];;
    gap&#62; for p in Set( Factors( Size( M ) ) ) do
    &#62;      syl:= SylowSubgroup( M, p );
    &#62;      Append( elms, Filtered( PcConjugacyClassReps( syl ),
    &#62;                              r -&#62; Order( r ) = p ) );
    &#62;    od;
    gap&#62; 1 - Minimum( List( elms, NrMovedPoints ) ) / Length( orbs[2] );
    353/3159

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.26">
5.26</a>&nbsp;&nbsp;U<sub>8</sub>(2)</h3><a name="U82">
</a>

<div class="p"><!----></div>
We show that S = U<sub>8</sub>(2) = <span class="roman">SU</span>(8,2) satisfies the following.

<ol type="1">
<br />(a)
    For s  &#8712; S of the type 1 &#8869;7
    (i.&nbsp;e., s decomposes the natural 8-dimensional module for
    S into an orthogonal sum of two irreducible modules
    of the dimensions 1 and 7, respectively) and of order
    2<sup>7</sup> + 1 = 129,
    <font face="helvetica"><i>M</i></font>(S,s) consists of one group of the type 3 &times;U<sub>7</sub>(2) = <span class="roman">GU</span>(7,2).
<br />(b)
    &#963;(S,s) = 2&nbsp;753/10&nbsp;880.</ol>

<div class="p"><!----></div>
By&nbsp;[<a href="#MSW94" name="CITEMSW94">MSW94</a>], the only maximal subgroup of S that contains s
is the stabilizer M  &#8773; <span class="roman">GU</span>(7,2) of the orthogonal decomposition.
This proves statement&nbsp;(a).

<div class="p"><!----></div>
The character table of S is currently not available in the <font face="helvetica">GAP</font>
Character Table Library.
We proceed exactly as in Section&nbsp;<a href="#U63">5.25</a> in order to prove statement&nbsp;(b).

<div class="p"><!----></div>

<pre>
    gap&#62; CharacterTable( "U8(2)" );
    fail
    gap&#62; g:= SU(8,2);;
    gap&#62; orbs:= Orbits( g, NormedRowVectors( GF(4)^8 ), OnLines );;
    gap&#62; List( orbs, Length );
    [ 10965, 10880 ]
    gap&#62; repeat x:= PseudoRandom( g ); until Order( x ) = 129;
    gap&#62; List( orbs, o -&#62; Number( o, v -&#62; OnLines( v, x ) = v ) );
    [ 0, 1 ]
    gap&#62; g:= Action( g, orbs[2], OnLines );;
    gap&#62; M:= Stabilizer( g, 1 );;
    gap&#62; elms:= [];;
    gap&#62; for p in Set( Factors( Size( M ) ) ) do
    &#62;      syl:= SylowSubgroup( M, p );
    &#62;      Append( elms, Filtered( PcConjugacyClassReps( syl ),
    &#62;                              r -&#62; Order( r ) = p ) );
    &#62;    od;
    gap&#62; Length( elms );
    611
    gap&#62; 1 - Minimum( List( elms, NrMovedPoints ) ) / Length( orbs[2] );
    2753/10880

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>


<div class="p"><!----></div>

<h2>References</h2>

<dl compact="compact">
 <dt><a href="#CITEBe00" name="Be00">[Ber00]</a></dt><dd>
'A.&nbsp;Bereczky, <em>Maximal overgroups of Singer elements in classical
  groups</em>, J. Algebra <b>234</b> (2000), no.&nbsp;1, 187-206.
  MR 1799483 (2002a:20049)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEBGK" name="BGK">[BGK08]</a></dt><dd>
T.&nbsp;Breuer, R.&nbsp;M. Guralnick, and W.&nbsp;M. Kantor, <em>Probabilistic generation of
  finite simple groups, II</em>, J. Algebra <b>320</b> (2008), no.&nbsp;2,
  443-494. MR 2422303 (2010e:20096)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEBP98copy" name="BP98copy">[BP98]</a></dt><dd>
T.&nbsp;Breuer and G.&nbsp;Pfeiffer, <em>Finding possible permutation characters</em>, J.
  Symbolic Comput. <b>26</b> (1998), no.&nbsp;3, 343-354. MR 1633876
  (99e:20005)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEAmbigFus" name="AmbigFus">[Brea]</a></dt><dd>
T.&nbsp;Breuer, <em>Ambiguous class fusions in the <font face="helvetica">GAP</font> character table
  library</em>, <a href="http://www.math.rwth-aachen.de/~Thomas.Breuer/ctbllib/doc/ambigfus.pdf"><tt>http://www.math.rwth-aachen.de/</tt>
<tt><tt>~</tt>Thomas.Breuer/</tt>
<tt>ctbllib/</tt><tt>doc/</tt>
<tt>ambigfus.pdf</tt></a>.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEAuto" name="Auto">[Breb]</a></dt><dd>
<br /><table align="left" border="0"><tr><td width="50">
<hr />
</td></tr></table><!--hbox-->
 , <em>Using table automorphisms for constructing character tables in
  <font face="helvetica">GAP</font></em>, <a href="http://www.math.rwth-aachen.de/~Thomas.Breuer/ctbllib/doc/ctblcons.pdf"><tt>http://www.math.rwth-aachen.de/</tt>
<tt><tt>~</tt>Thomas.Breuer/</tt>
<tt>ctbllib/</tt><tt>doc/</tt>
<tt>ctblcons.pdf</tt></a>.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITECTblLib1.2" name="CTblLib1.2">[Bre12]</a></dt><dd>
<br /><table align="left" border="0"><tr><td width="50">
<hr />
</td></tr></table><!--hbox-->
 , <em>The <font face="helvetica">GAP</font> Character Table Library, Version 1.2</em>,
  <a href="http://www.math.rwth-aachen.de/~Thomas.Breuer/ctbllib"><tt>http://www.math.rwth-aachen.de/</tt>
<tt><tt>~</tt>Thomas.Breuer/</tt>
<tt>ctbllib</tt></a>, Mar 2012, <font face="helvetica">GAP</font> package.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEBW1" name="BW1">[BW75]</a></dt><dd>
J.&nbsp;L. Brenner and J.&nbsp;Wiegold, <em>Two-generator groups. I</em>, Michigan Math.
  J. <b>22</b> (1975), 53-64. MR 0372033 (51 #8250)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITECCN85" name="CCN85">[CCN<sup>+</sup>85]</a></dt><dd>
J.&nbsp;H. Conway, R.&nbsp;T. Curtis, S.&nbsp;P. Norton, R.&nbsp;A. Parker, and R.&nbsp;A. Wilson,
  <em>Atlas of finite groups</em>, Oxford University Press, Eynsham, 1985,
  Maximal subgroups and ordinary characters for simple groups, With
  computational assistance from J. G. Thackray. MR 827219 (88g:20025)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEGAP" name="GAP">[GAP12]</a></dt><dd>
<em><font face="helvetica">GAP</font> - Groups, Algorithms, and Programming,
  Version 4.5.0</em>, <a href="http://www.gap-system.org"><tt>http://www.gap-system.org</tt></a>, Apr 2012.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEGK" name="GK">[GK00]</a></dt><dd>
R.&nbsp;M. Guralnick and W.&nbsp;M. Kantor, <em>Probabilistic generation of finite
  simple groups</em>, J. Algebra <b>234</b> (2000), no.&nbsp;2, 743-792,
  Special issue in honor of Helmut Wielandt. MR 1800754 (2002f:20038)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEGM01" name="GM01">[GM01]</a></dt><dd>
S.&nbsp;Ganief and J.&nbsp;Moori, <em>On the spread of the sporadic simple groups</em>,
  Comm. Algebra <b>29</b> (2001), no.&nbsp;8, 3239-3255. MR 1849484
  (2002i:20025)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEGPPS" name="GPPS">[GPPS99]</a></dt><dd>
R.&nbsp;Guralnick, T.&nbsp;Penttila, C.&nbsp;E. Praeger, and J.&nbsp;Saxl, <em>Linear groups with
  orders having certain large prime divisors</em>, Proc. London Math. Soc.
  <b>78</b> (1999), no.&nbsp;1, 167-214. MR 1658168 (99m:20113)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEHulpkeTG" name="HulpkeTG">[Hul05]</a></dt><dd>
A.&nbsp;Hulpke, <em>Constructing transitive permutation groups</em>, J. Symbolic
  Comput. <b>39</b> (2005), no.&nbsp;1, 1-30. MR 2168238
  (2006e:20004)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEHW04" name="HW04">[HW04]</a></dt><dd>
P.&nbsp;E. Holmes and R.&nbsp;A. Wilson, <em><span class="roman">PSL</span><sub>2</sub>(59) is a subgroup of the
  Monster</em>, J. London Math. Soc. <b>69</b> (2004), no.&nbsp;1,
  141-152. MR 2025332 (2004k:20035)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEKlL90" name="KlL90">[KL90]</a></dt><dd>
P.&nbsp;Kleidman and M.&nbsp;Liebeck, <em>The subgroup structure of the finite
  classical groups</em>, London Mathematical Society Lecture Note Series, vol. 129,
  Cambridge University Press, Cambridge, 1990. MR 1057341 (91g:20001)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEKle87" name="Kle87">[Kle87]</a></dt><dd>
P.&nbsp;B. Kleidman, <em>The maximal subgroups of the finite 8-dimensional
  orthogonal groups P&#8486;<sup>+</sup><sub>8</sub>(q) and of their automorphism groups</em>, J.
  Algebra <b>110</b> (1987), no.&nbsp;1, 173-242. MR 904187
  (88i:20070)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEMSW94" name="MSW94">[MSW94]</a></dt><dd>
G.&nbsp;Malle, J.&nbsp;Saxl, and T.&nbsp;Weigel, <em>Generation of classical groups</em>, Geom.
  Dedicata <b>49</b> (1994), no.&nbsp;1, 85-116. MR 1261575
  (95c:20068)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEWil99" name="Wil99">[Wil99]</a></dt><dd>
R.&nbsp;A. Wilson, <em>The maximal subgroups of the Baby Monster. I</em>, J.
  Algebra <b>211</b> (1999), no.&nbsp;1, 1-14. MR 1656568
  (2000b:20016)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEAtlasRep" name="AtlasRep">[WPN<sup>+</sup>11]</a></dt><dd>
R.&nbsp;A. Wilson, R.&nbsp;A. Parker, S.&nbsp;Nickerson, J.&nbsp;N. Bray, and T.&nbsp;Breuer,
  <em>AtlasRep, a <font face="helvetica">GAP</font> Interface to the Atlas of Group
  Representations, Version 1.5</em>, <a href="http://www.math.rwth-aachen.de/~Thomas.Breuer/atlasrep"><tt>http://www.math.rwth-aachen.de/</tt>
<tt><tt>~</tt>Thomas.Breuer/</tt>
<tt>atlasrep</tt></a>, Jul 2011, Refereed <font face="helvetica">GAP</font> package.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEAGR" name="AGR">[WWT<sup>+</sup>]</a></dt><dd>
R.&nbsp;A. Wilson, P.&nbsp;Walsh, J.&nbsp;Tripp, I.&nbsp;Suleiman, R.&nbsp;A. Parker, S.&nbsp;P. Norton,
  S.&nbsp;Nickerson, S.&nbsp;Linton, J.&nbsp;Bray, and R.&nbsp;Abbott, <em>ATLAS of Finite Group
  Representations</em>, <a href="http://brauer.maths.qmul.ac.uk/Atlas/"><tt>http://brauer.maths.qmul.ac.uk/</tt>
<tt>Atlas/</tt></a>.</dd>
</dl>


<div class="p"><!----></div>

<div class="p"><!----></div>

<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 3.59.<br />On  5 May 2012, 09:07.</small>
</html>
