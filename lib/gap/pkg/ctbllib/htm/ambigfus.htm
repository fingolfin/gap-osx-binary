<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.59">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 

              
<title> Ambiguous Class Fusions in the GAP Character Table Library</title>
 
<h1 align="center">Ambiguous Class Fusions in the GAP Character Table Library </h1>
  <body bgcolor="FFFFFF"> 

<div class="p"><!----></div>

<h3 align="center"> T<font size="-2">HOMAS</font> B<font size="-2">REUER</font> <br />
<i>Lehrstuhl D f&#252;r Mathematik</i> <br />
<i>RWTH, 52056 Aachen, Germany</i> </h3>

<div class="p"><!----></div>

<h3 align="center">January 11th, 2004 </h3>

<div class="p"><!----></div>


<div class="p"><!----></div>

This is a collection of examples showing how class fusions between character
tables can be determined using the <font face="helvetica">GAP</font> system&nbsp;[<a href="#GAP4" name="CITEGAP4">GAP04</a>].
In each of these examples, the fusion is <em>ambiguous</em> in the sense that
the character tables do not determine it up to table automorphisms.
Our strategy is to compute first all possibilities with the <font face="helvetica">GAP</font> function
<tt>PossibleClassFusions</tt>, and then to use either other character tables or
information about the groups for excluding some of these candidates until
only one (orbit under table automorphisms) remains.

<div class="p"><!----></div>
The purpose of this writeup is twofold.
On the one hand, the computations are documented this way.
On the other hand, the <font face="helvetica">GAP</font> code shown for the examples can be used as
test input for automatic checking of the data and the functions used;
therefore, each example ends with a comparison of the result with the
fusion that is actually stored in
the <font face="helvetica">GAP</font> Character Table Library&nbsp;[<a href="#CTblLib1.2" name="CITECTblLib1.2">Bre12</a>].

<div class="p"><!----></div>



<div class="p"><!----></div>

<h1>Contents </h1><a href="#tth_sEc1"
>1&nbsp; Some <font face="helvetica">GAP</font> Utilities</a><br />
<a href="#tth_sEc2"
>2&nbsp; Fusions Determined by Factorization through Intermediate Subgroups</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.1"
>2.1&nbsp; Co<sub>3</sub>N5 &#8594; Co<sub>3</sub> (September 2002)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.2"
>2.2&nbsp; 31:15 &#8594; B (March 2003)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.3"
>2.3&nbsp; SuzN3 &#8594; Suz (September 2002)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4"
>2.4&nbsp; F<sub>3+</sub>N5 &#8594; F<sub>3+</sub> (March 2002)</a><br />
<a href="#tth_sEc3"
>3&nbsp; Fusions Determined Using Commutative Diagrams Involving Smaller Subgroups</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.1"
>3.1&nbsp; BN7 &#8594; B (March 2002)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2"
>3.2&nbsp; (A<sub>4</sub> &times;O<sub>8</sub><sup>+</sup>(2).3).2 &#8594; Fi<sub>24</sub><sup>&#8242;</sup> (November 2002)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.3"
>3.3&nbsp; A<sub>6</sub> &times;L<sub>2</sub>(8).3 &#8594; Fi<sub>24</sub><sup>&#8242;</sup> (November 2002)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4"
>3.4&nbsp; (3<sup>2</sup>:D<sub>8</sub> &times;U<sub>4</sub>(3).2<sup>2</sup>).2 &#8594; B (June 2007)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.5"
>3.5&nbsp; 7<sup>1+4</sup>:(3 &times;2.S<sub>7</sub>) &#8594; M (May 2009)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.6"
>3.6&nbsp; 3<sup>7</sup>.O<sub>7</sub>(3):2 &#8594; Fi<sub>24</sub> (November 2010)</a><br />
<a href="#tth_sEc4"
>4&nbsp; Fusions Determined Using Commutative Diagrams Involving Factor Groups</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1"
>4.1&nbsp; 3.A<sub>7</sub> &#8594; 3.Suz (December 2010)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2"
>4.2&nbsp; S<sub>6</sub> &#8594; U<sub>4</sub>(2) (September 2011)</a><br />
<a href="#tth_sEc5"
>5&nbsp; Fusions Determined Using Commutative Diagrams Involving Automorphic Extensions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1"
>5.1&nbsp; U<sub>3</sub>(8).3<sub>1</sub> &#8594; <sup>2</sup>E<sub>6</sub>(2) (December 2010)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2"
>5.2&nbsp; L<sub>3</sub>(4).2<sub>1</sub> &#8594; U<sub>6</sub>(2) (December 2010)</a><br />
<a href="#tth_sEc6"
>6&nbsp; Conditions Imposed by Brauer Tables</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1"
>6.1&nbsp; L<sub>2</sub>(16).4 &#8594; J<sub>3</sub>.2 (January&nbsp;2004)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2"
>6.2&nbsp; L<sub>2</sub>(17) &#8594; S<sub>8</sub>(2) (July 2004)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.3"
>6.3&nbsp; L<sub>2</sub>(19) &#8594; J<sub>3</sub> (April 2003)</a><br />
<a href="#tth_sEc7"
>7&nbsp; Fusions Determined by Information about the Groups</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.1"
>7.1&nbsp; U<sub>3</sub>(3).2 &#8594; Fi<sub>24</sub><sup>&#8242;</sup> (November 2002)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.2"
>7.2&nbsp; L<sub>2</sub>(13).2 &#8594; Fi<sub>24</sub><sup>&#8242;</sup> (September 2002)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.3"
>7.3&nbsp; M<sub>11</sub> &#8594; B (April 2009)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.4"
>7.4&nbsp; L<sub>2</sub>(11):2 &#8594; B (April 2009)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.5"
>7.5&nbsp; L<sub>3</sub>(3) &#8594; B (April 2009)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.6"
>7.6&nbsp; L<sub>2</sub>(17).2 &#8594; B (March 2004)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.7"
>7.7&nbsp; L<sub>2</sub>(49).2<sub>3</sub> &#8594; B (June 2006)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.8"
>7.8&nbsp; 2<sup>3</sup>.L<sub>3</sub>(2) &#8594; G<sub>2</sub>(5) (January&nbsp;2004)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.9"
>7.9&nbsp; 5<sup>1+4</sup>.2<sup>1+4</sup>.A<sub>5</sub>.4 &#8594; B (April 2009)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.10"
>7.10&nbsp; The fusion from the character table of 7<sup>2</sup>:2L<sub>2</sub>(7).2 into the table of marks (January&nbsp;2004)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.11"
>7.11&nbsp; 3 &times;U<sub>4</sub>(2) &#8594; 3<sub>1</sub>.U<sub>4</sub>(3) (March 2010)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.12"
>7.12&nbsp; 2.3<sup>4</sup>.2<sup>3</sup>.S<sub>4</sub> &#8594; 2.A12 (September 2011)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.13"
>7.13&nbsp; 127:7 &#8594; L<sub>7</sub>(2) (January 2012)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.14"
>7.14&nbsp; L<sub>2</sub>(59) &#8594; M (May 2009)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.15"
>7.15&nbsp; L<sub>2</sub>(71) &#8594; M (May 2009)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.16"
>7.16&nbsp; L<sub>2</sub>(41) &#8594; M (April 2012)</a><br />



<div class="p"><!----></div>

<div class="p"><!----></div>
The examples use the <font face="helvetica">GAP</font> Character Table Library,
so we first load this package.

<div class="p"><!----></div>

<pre>
    gap&#62; LoadPackage( "ctbllib" );
    true

</pre>

<div class="p"><!----></div>

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Some <font face="helvetica">GAP</font> Utilities</h2>

<div class="p"><!----></div>
The function <tt>SetOfComposedClassFusions</tt> takes two list of class fusions,
where the first list consists of fusions between the character tables of
the groups H and G, say,
and the second list consists of class fusions between the character tables
of the groups U and H, say;
the return value is the set of compositions of each map in the first list
with each map in the second list (via <tt>CompositionMaps</tt>).

<div class="p"><!----></div>
Note that the returned list may be a proper subset of the set of
all possible class fusions between U and G,
which can be computed with <tt>PossibleClassFusions</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; SetOfComposedClassFusions:= function( hfusg, ufush )
    &#62;     local result, map1, map2;
    &#62;     result:= [];;
    &#62;     for map2 in hfusg do
    &#62;       for map1 in ufush do
    &#62;         AddSet( result, CompositionMaps( map2, map1 ) );
    &#62;       od;
    &#62;     od;
    &#62;     return result;
    &#62; end;;

</pre>

<div class="p"><!----></div>

 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Fusions Determined by Factorization through Intermediate Subgroups</h2>

<div class="p"><!----></div>
This situation clearly occurs only for nonmaximal subgroups.
Interesting examples are Sylow normalizers.

<div class="p"><!----></div>

     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Co<sub>3</sub>N5 &#8594; Co<sub>3</sub> (September 2002)</h3>

<div class="p"><!----></div>
Let H be the Sylow 5 normalizer in the sporadic simple group Co<sub>3</sub>.
The class fusion of H into Co<sub>3</sub> is not uniquely determined by the
character tables of the two groups.

<div class="p"><!----></div>

<pre>
    gap&#62; co3:= CharacterTable( "Co3" );
    CharacterTable( "Co3" )
    gap&#62; h:= CharacterTable( "Co3N5" );
    CharacterTable( "5^(1+2):(24:2)" )
    gap&#62; hfusco3:= PossibleClassFusions( h, co3 );;
    gap&#62; Length( RepresentativesFusions( h, hfusco3, co3 ) );
    2

</pre>

<div class="p"><!----></div>
As H is not maximal in Co<sub>3</sub>, we look at those maximal subgroups of Co<sub>3</sub>
whose order is divisible by that of H.

<div class="p"><!----></div>

<pre>
    gap&#62; mx:= Maxes( co3 );
    [ "McL.2", "HS", "U4(3).(2^2)_{133}", "M23", "3^5:(2xm11)", "2.S6(2)", 
      "U3(5).3.2", "3^1+4:4s6", "2^4.a8", "L3(4).D12", "2xm12", 
      "2^2.(2^7.3^2).s3", "s3xpsl(2,8).3", "a4xs5" ]
    gap&#62; maxes:= List( mx, CharacterTable );;
    gap&#62; filt:= Filtered( maxes, x -&#62; Size( x ) mod Size( h ) = 0 );
    [ CharacterTable( "McL.2" ), CharacterTable( "HS" ), 
      CharacterTable( "U3(5).3.2" ) ]

</pre>

<div class="p"><!----></div>
According to the  A<font size="-2">TLAS</font> (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,pp.&nbsp;34 and&nbsp;100]),
H occurs as the Sylow 5 normalizer in U<sub>3</sub>(5).3.2 and in McL.2;
however, H is not a subgroup of HS,
since otherwise H would be contained in subgroups of type U<sub>3</sub>(5).2
(see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;80]), but the only possible subgroups
in these groups are too small (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;34]).

<div class="p"><!----></div>
We compute the possible class fusions from H into McL.2
and from McL.2 to Co<sub>3</sub>, and then form the compositions of these maps.

<div class="p"><!----></div>

<pre>
    gap&#62; max:= filt[1];;
    gap&#62; hfusmax:= PossibleClassFusions( h, max );;
    gap&#62; maxfusco3:= PossibleClassFusions( max, co3 );;
    gap&#62; comp:= SetOfComposedClassFusions( maxfusco3, hfusmax );;
    gap&#62; Length( comp );
    2
    gap&#62; reps:= RepresentativesFusions( h, comp, co3 );
    [ [ 1, 2, 3, 4, 8, 8, 7, 9, 10, 11, 17, 17, 19, 19, 22, 23, 27, 27, 30, 33, 
          34, 40, 40, 40, 40, 42 ] ]

</pre>

<div class="p"><!----></div>
So factoring through a maximal subgroup of type McL.2
determines the fusion from H to Co<sub>3</sub> uniquely up to table automorphisms.

<div class="p"><!----></div>
Alternatively, we can use the group U<sub>3</sub>(5).3.2 as intermediate
subgroup, which leads to the same result.

<div class="p"><!----></div>

<pre>
    gap&#62; max:= filt[3];;
    gap&#62; hfusmax:= PossibleClassFusions( h, max );;
    gap&#62; maxfusco3:= PossibleClassFusions( max, co3 );;
    gap&#62; comp:= SetOfComposedClassFusions( maxfusco3, hfusmax );;
    gap&#62; reps2:= RepresentativesFusions( h, comp, co3 );;
    gap&#62; reps2 = reps;
    true

</pre>

<div class="p"><!----></div>
Finally, we compare the result with the map that is stored on the library
table of H.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( h, co3 ) in reps;
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;31:15 &#8594; B (March 2003)</h3>

<div class="p"><!----></div>
The Sylow 31 normalizer H in the sporadic simple group B
has the structure 31:15.

<div class="p"><!----></div>

<pre>
    gap&#62; b:= CharacterTable( "B" );;
    gap&#62; h:= CharacterTable( "31:15" );;
    gap&#62; hfusb:= PossibleClassFusions( h, b );;
    gap&#62; Length( RepresentativesFusions( h, hfusb, b ) );
    2

</pre>

<div class="p"><!----></div>
We determine the correct fusion using the fact that
H is contained in a (maximal) subgroup of type Th in B.

<div class="p"><!----></div>

<pre>
    gap&#62; th:= CharacterTable( "Th" );;
    gap&#62; hfusth:= PossibleClassFusions( h, th );;
    gap&#62; thfusb:= PossibleClassFusions( th, b );;
    gap&#62; comp:= SetOfComposedClassFusions( thfusb, hfusth );;
    gap&#62; Length( comp );
    2
    gap&#62; reps:= RepresentativesFusions( h, comp, b );
    [ [ 1, 145, 146, 82, 82, 19, 82, 7, 19, 82, 82, 19, 7, 82, 19, 82, 82 ] ]
    gap&#62; GetFusionMap( h, b ) in reps;
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc2.3">
2.3</a>&nbsp;&nbsp;SuzN3 &#8594; Suz (September 2002)</h3>

<div class="p"><!----></div>
The class fusion from the Sylow 3 normalizer into the sporadic simple group
Suz is not uniquely determined by the character tables of these groups.

<div class="p"><!----></div>

<pre>
    gap&#62; h:= CharacterTable( "SuzN3" );
    CharacterTable( "3^5:(3^2:SD16)" )
    gap&#62; suz:= CharacterTable( "Suz" );
    CharacterTable( "Suz" )
    gap&#62; hfussuz:= PossibleClassFusions( h, suz );;
    gap&#62; Length( RepresentativesFusions( h, hfussuz, suz ) );
    2

</pre>

<div class="p"><!----></div>
Since H is not maximal in Suz, we try to factorize the fusion through
a suitable maximal subgroup.

<div class="p"><!----></div>

<pre>
    gap&#62; maxes:= List( Maxes( suz ), CharacterTable );;
    gap&#62; filt:= Filtered( maxes, x -&#62; Size( x ) mod Size( h ) = 0 );
    [ CharacterTable( "3_2.U4(3).2_3'" ), CharacterTable( "3^5:M11" ), 
      CharacterTable( "3^2+4:2(2^2xa4)2" ) ]

</pre>

<div class="p"><!----></div>
The group 3<sub>2</sub>.U<sub>4</sub>(3).2<sub>3</sub><sup>&#8242;</sup> does not admit a fusion from H.

<div class="p"><!----></div>

<pre>
    gap&#62; PossibleClassFusions( h, filt[1] );
    [  ]

</pre>

<div class="p"><!----></div>
Definitely 3<sup>5</sup>:M<sub>11</sub> contains a group isomorphic with H,
because the Sylow 3 normalizer in M<sub>11</sub> has the structure 3<sup>2</sup>:SD<sub>16</sub>;
using 3<sup>2+4</sup>:2(2<sup>2</sup> &times;A<sub>4</sub>)2 would lead to the same result as
we get below.
We compute the compositions of possible class fusions.

<div class="p"><!----></div>

<pre>
    gap&#62; max:= filt[2];;
    gap&#62; hfusmax:= PossibleClassFusions( h, max );;
    gap&#62; maxfussuz:= PossibleClassFusions( max, suz );;
    gap&#62; comp:= SetOfComposedClassFusions( maxfussuz, hfusmax );;
    gap&#62; repr:= RepresentativesFusions( h, comp, suz );
    [ [ 1, 2, 2, 4, 5, 4, 5, 5, 5, 5, 5, 6, 9, 9, 14, 15, 13, 16, 16, 14, 15, 13, 
          13, 13, 16, 15, 14, 16, 16, 16, 21, 21, 23, 22, 29, 29, 29, 38, 39 ] ]

</pre>

<div class="p"><!----></div>
So the factorization determines the fusion map up to table automorphisms.
We check that this map is equal to the stored one.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( h, suz ) in repr;
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc2.4">
2.4</a>&nbsp;&nbsp;F<sub>3+</sub>N5 &#8594; F<sub>3+</sub> (March 2002)</h3>

<div class="p"><!----></div>
The class fusion from the table of the Sylow 5 normalizer H in the
sporadic simple group F<sub>3+</sub> into F<sub>3+</sub> is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; f3p:= CharacterTable( "F3+" );;
    gap&#62; h:= CharacterTable( "F3+N5" );;
    gap&#62; hfusf3p:= PossibleClassFusions( h, f3p );;
    gap&#62; Length( RepresentativesFusions( h, hfusf3p, f3p ) );
    2

</pre>

<div class="p"><!----></div>
H is not maximal in F<sub>3+</sub>,
so we look for tables of maximal subgroups that can contain H.

<div class="p"><!----></div>

<pre>
    gap&#62; maxes:= List( Maxes( f3p ), CharacterTable );;
    gap&#62; filt:= Filtered( maxes, x -&#62; Size( x ) mod Size( h ) = 0 );
    [ CharacterTable( "Fi23" ), CharacterTable( "2.Fi22.2" ), 
      CharacterTable( "(3xO8+(3):3):2" ), CharacterTable( "O10-(2)" ), 
      CharacterTable( "(A4xO8+(2).3).2" ), CharacterTable( "He.2" ), 
      CharacterTable( "F3+M14" ), CharacterTable( "(A5xA9):2" ) ]
    gap&#62; possfus:= List( filt, x -&#62; PossibleClassFusions( h, x ) );
    [ [  ], [  ], [  ], [  ], 
      [ [ 1, 69, 110, 12, 80, 121, 4, 72, 113, 11, 11, 79, 79, 120, 120, 3, 71, 
              11, 79, 23, 91, 112, 120, 132, 29, 32, 97, 100, 37, 37, 105, 105, 
              139, 140, 145, 146, 155, 155, 156, 156, 44, 44, 167, 167, 48, 48, 
              171, 171, 57, 57, 180, 180, 66, 66, 189, 189 ], 
          [ 1, 69, 110, 12, 80, 121, 4, 72, 113, 11, 11, 79, 79, 120, 120, 3, 71, 
              11, 79, 23, 91, 112, 120, 132, 29, 32, 97, 100, 37, 37, 105, 105, 
              140, 139, 146, 145, 156, 156, 155, 155, 44, 44, 167, 167, 48, 48, 
              171, 171, 57, 57, 180, 180, 66, 66, 189, 189 ] ], [  ], [  ], [  ] ]

</pre>

<div class="p"><!----></div>
We see that from the eight possible classes of maximal subgroups in F<sub>3+</sub>
that might contain H, only the group of type (A<sub>4</sub> &times;O<sub>8</sub><sup>+</sup>(2).3).2
admits a class fusion from H.
Hence we can compute the compositions of the possible fusions from H into
this group with the possible fusions from this group into F<sub>3+</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; max:= filt[5];
    CharacterTable( "(A4xO8+(2).3).2" )
    gap&#62; hfusmax:= possfus[5];;
    gap&#62; maxfusf3p:= PossibleClassFusions( max, f3p );;
    gap&#62; comp:= SetOfComposedClassFusions( maxfusf3p, hfusmax );;
    gap&#62; Length( comp );
    2
    gap&#62; repr:= RepresentativesFusions( h, comp, f3p );
    [ [ 1, 2, 4, 12, 35, 54, 3, 3, 16, 9, 9, 11, 11, 40, 40, 2, 3, 9, 11, 35, 36, 
          13, 40, 90, 7, 22, 19, 20, 43, 43, 50, 50, 8, 8, 23, 23, 46, 46, 47, 
          47, 10, 10, 9, 9, 10, 10, 11, 11, 26, 26, 28, 28, 67, 67, 68, 68 ] ]

</pre>

<div class="p"><!----></div>
Finally, we check whether the map stored in the table library is correct.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( h, f3p ) in repr;
    true

</pre>

<div class="p"><!----></div>
Note that we did <b>not</b> determine the class fusion from the maximal subgroup
(A<sub>4</sub> &times;O<sub>8</sub><sup>+</sup>(2).3).2 into F<sub>3+</sub> up to table automorphisms
(see Section&nbsp;<a href="#A4xO8p2d32fusf3p">3.2</a> for this problem),
since also the ambiguous result was enough for computing the fusion from
H into F<sub>3+</sub>.

<div class="p"><!----></div>

 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Fusions Determined Using Commutative Diagrams Involving Smaller
Subgroups</h2>

<div class="p"><!----></div>
  <table><tr><td width="75%"> 
In each of the following examples, the class fusion of a (not necessarily
maximal) subgroup M of a group G into G is determined
by considering a proper subgroup U of M
whose class fusion into G can be computed, perhaps using another subgroup
S of G that also contains U.

<div class="p"><!----></div>
  </td><td width="25%"> 

<div class="p"><!----></div>

<center> <img src="ambigfus1.png" alt="ambigfus1.png" />

</center>

<div class="p"><!----></div>
  </td></tr></table> 

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;BN7 &#8594; B (March 2002)</h3><a name="BN7">
</a>

<div class="p"><!----></div>
Let H be a Sylow 7 normalizer in the sporadic simple group B.
The class fusion of H into B is not uniquely determined by the
character tables of the two groups.

<div class="p"><!----></div>

<pre>
    gap&#62; b:= CharacterTable( "B" );
    CharacterTable( "B" )
    gap&#62; h:= CharacterTable( "BN7" );
    CharacterTable( "BN7" )
    gap&#62; hfusb:= PossibleClassFusions( h, b );;
    gap&#62; Length( RepresentativesFusions( h, hfusb, b ) );
    2

</pre>

<div class="p"><!----></div>
Let us consider a maximal subgroup of the type Th in B
(cf.&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;217]).
By&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;177],
the Sylow 7 normalizers in Th are maximal subgroups of Th
and have the structure 7<sup>2</sup>:(3 &times;2S<sub>4</sub>).
Let U be such a subgroup.

<div class="p"><!----></div>
Note that the only maximal subgroups of Th whose order is divisible by
the order of a Sylow 7 subgroup of B have the types <sup>3</sup>D<sub>4</sub>(2).3
and 7<sup>2</sup>:(3 &times;2S<sub>4</sub>),
and the Sylow 7 normalizers in the former groups have the structure
7<sup>2</sup>:(3 &times;2A<sub>4</sub>), cf.&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;89].

<div class="p"><!----></div>

<pre>
    gap&#62; Number( Factors( Size( b ) ), x -&#62; x = 7 );
    2
    gap&#62; th:= CharacterTable( "Th" );
    CharacterTable( "Th" )
    gap&#62; Filtered( Maxes( th ), x -&#62; Size( CharacterTable( x ) ) mod 7^2 = 0 );
    [ "3D4(2).3", "7^2:(3x2S4)" ]

</pre>

<div class="p"><!----></div>
The class fusion of U into B via Th is uniquely determined by the
character tables of these groups.

<div class="p"><!----></div>

<pre>
    gap&#62; thn7:= CharacterTable( "ThN7" );
    CharacterTable( "7^2:(3x2S4)" )
    gap&#62; comp:= SetOfComposedClassFusions( PossibleClassFusions( th, b ),
    &#62;               PossibleClassFusions( thn7, th ) );
    [ [ 1, 31, 7, 7, 5, 28, 28, 17, 72, 72, 6, 6, 7, 28, 27, 27, 109, 109, 17, 
          45, 45, 72, 72, 127, 127, 127, 127 ] ]

</pre>

<div class="p"><!----></div>
The condition that the class fusion of U into B factors through H
determines the class fusion of H into B up to table automorphisms.

<div class="p"><!----></div>

<pre>
    gap&#62; thn7fush:= PossibleClassFusions( thn7, h );;
    gap&#62; filt:= Filtered( hfusb, x -&#62;
    &#62;               ForAny( thn7fush, y -&#62; CompositionMaps( x, y ) in comp ) );;
    gap&#62; Length( RepresentativesFusions( h, filt, b ) );
    1

</pre>

<div class="p"><!----></div>
Finally, we compare the result with the map that is stored on the library
table of H.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( h, b ) in filt;
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;(A<sub>4</sub> &times;O<sub>8</sub><sup>+</sup>(2).3).2 &#8594; Fi<sub>24</sub><sup>&#8242;</sup>
(November 2002)</h3><a name="A4xO8p2d32fusf3p">
</a>

<div class="p"><!----></div>
The class fusion of the maximal subgroup M  &#8773; (A<sub>4</sub> &times;O<sub>8</sub><sup>+</sup>(2).3).2
of G = Fi<sub>24</sub><sup>&#8242;</sup> is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; m:= CharacterTable( "(A4xO8+(2).3).2" );;
    gap&#62; t:= CharacterTable( "F3+" );;
    gap&#62; mfust:= PossibleClassFusions( m, t );;
    gap&#62; repr:= RepresentativesFusions( m, mfust, t );;
    gap&#62; Length( repr );
    2

</pre>

<div class="p"><!----></div>
We first observe that the elements of order three in the normal subgroup
of type A<sub>4</sub> in M lie in the class <tt>3A</tt> of Fi<sub>24</sub><sup>&#8242;</sup>.

<div class="p"><!----></div>

<pre>
    gap&#62; a4inm:= Filtered( ClassPositionsOfNormalSubgroups( m ),
    &#62;                      n -&#62; Sum( SizesConjugacyClasses( m ){ n } ) = 12 );
    [ [ 1, 69, 110 ] ]
    gap&#62; OrdersClassRepresentatives( m ){ a4inm[1] };
    [ 1, 2, 3 ]
    gap&#62; List( repr, map -&#62; map[110] );
    [ 4, 4 ]
    gap&#62; OrdersClassRepresentatives( t ){ [ 1 .. 4 ] };
    [ 1, 2, 2, 3 ]

</pre>

<div class="p"><!----></div>
Let us take one such element g, say.
Its normalizer S in G has the structure (3 &times;O<sub>8</sub><sup>+</sup>(3).3).2;
this group is maximal in G, and its character table is available in <font face="helvetica">GAP</font>.

<div class="p"><!----></div>

<pre>
    gap&#62; s:= CharacterTable( "F3+N3A" );
    CharacterTable( "(3xO8+(3):3):2" )

</pre>

<div class="p"><!----></div>
The intersection N<sub>M</sub>(g) = S &#8745;M contains a subgroup U of the type
3 &times;O<sub>8</sub><sup>+</sup>(2).3,
and in the following we compute the class fusions of U into S and M,
and then utilize the fact that only those class fusions from M into G
are possible whose composition with the class fusion from U into M
equals a composition of class fusions from U into S
and from S into G.

<div class="p"><!----></div>

<pre>
    gap&#62; u:= CharacterTable( "Cyclic", 3 ) * CharacterTable( "O8+(2).3" );
    CharacterTable( "C3xO8+(2).3" )
    gap&#62; ufuss:= PossibleClassFusions( u, s );;
    gap&#62; ufusm:= PossibleClassFusions( u, m );;
    gap&#62; sfust:= PossibleClassFusions( s, t );;
    gap&#62; comp:= SetOfComposedClassFusions( sfust, ufuss );;
    gap&#62; Length( comp );
    6
    gap&#62; filt:= Filtered( mfust,
    &#62;     x -&#62; ForAny( ufusm, map -&#62; CompositionMaps( x, map ) in comp ) );;
    gap&#62; repr:= RepresentativesFusions( m, filt, t );;
    gap&#62; Length( repr );
    1
    gap&#62; GetFusionMap( m, t ) in repr;
    true

</pre>

<div class="p"><!----></div>
So the class fusion from M into G is determined up to table automorphisms
by the commutative diagram.

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.3">
3.3</a>&nbsp;&nbsp;A<sub>6</sub> &times;L<sub>2</sub>(8).3 &#8594; Fi<sub>24</sub><sup>&#8242;</sup>
(November 2002)</h3>

<div class="p"><!----></div>
The class fusion of the maximal subgroup M  &#8773; A<sub>6</sub> &times;L<sub>2</sub>(8).3
of G = Fi<sub>24</sub><sup>&#8242;</sup> is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; m:= CharacterTable( "A6xL2(8):3" );;
    gap&#62; t:= CharacterTable( "F3+" );;
    gap&#62; mfust:= PossibleClassFusions( m, t );;
    gap&#62; Length( RepresentativesFusions( m, mfust, t ) );
    2

</pre>

<div class="p"><!----></div>
We will use the fact that the direct factor of the type A<sub>6</sub> in M
contains elements in the class <tt>3A</tt> of G.
This fact can be shown as follows.

<div class="p"><!----></div>

<pre>
    gap&#62; dppos:= ClassPositionsOfDirectProductDecompositions( m );
    [ [ [ 1, 12 .. 67 ], [ 1 .. 11 ] ] ]
    gap&#62; List( dppos[1], l -&#62; Sum( SizesConjugacyClasses( t ){ l } ) );
    [ 17733424133316996808705, 4545066196775803392 ]
    gap&#62; List( dppos[1], l -&#62; Sum( SizesConjugacyClasses( m ){ l } ) );
    [ 360, 1512 ]
    gap&#62; 3Apos:= Position( OrdersClassRepresentatives( t ), 3 );
    4
    gap&#62; 3Ainm:= List( mfust, map -&#62; Position( map, 3Apos ) );
    [ 23, 23, 23, 23, 34, 34, 34, 34 ]
    gap&#62; ForAll( 3Ainm, x -&#62; x in dppos[1][1] );
    true

</pre>

<div class="p"><!----></div>
Since the normalizer of an element of order three in A<sub>6</sub> has the form
3<sup>2</sup>:2,
such a <tt>3A</tt> element in M contains a subgroup U of the structure
3<sup>2</sup>:2 &times;L<sub>2</sub>(8).3 which is contained in the <tt>3A</tt> normalizer S in G,
which has the structure (3 &times;O<sub>8</sub><sup>+</sup>(3).3).2.

<div class="p"><!----></div>
(Note that all classes in the 3<sup>2</sup>:2 type group are rational,
and its character table is available in the <font face="helvetica">GAP</font> Character Table Library
with the identifier <tt>"3^2:2"</tt>.)

<div class="p"><!----></div>

<pre>
    gap&#62; u:= CharacterTable( "3^2:2" ) * CharacterTable( "L2(8).3" );
    CharacterTable( "3^2:2xL2(8).3" )
    gap&#62; s:= CharacterTable( "F3+N3A" );
    CharacterTable( "(3xO8+(3):3):2" )
    gap&#62; ufuss:= PossibleClassFusions( u, s );;
    gap&#62; comp:= SetOfComposedClassFusions( sfust, ufuss );;
    gap&#62; ufusm:= PossibleClassFusions( u, m );;
    gap&#62; filt:= Filtered( mfust,
    &#62;               map -&#62; ForAny( ufusm,
    &#62;                          map2 -&#62; CompositionMaps( map, map2 ) in comp ) );;
    gap&#62; repr:= RepresentativesFusions( m, filt, t );;
    gap&#62; Length( repr );
    1
    gap&#62; GetFusionMap( m, t ) in repr;
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.4">
3.4</a>&nbsp;&nbsp;(3<sup>2</sup>:D<sub>8</sub> &times;U<sub>4</sub>(3).2<sup>2</sup>).2 &#8594; B (June 2007)</h3><a name="BM14">
</a>

<div class="p"><!----></div>
Let G be a maximal subgroup of the type (3<sup>2</sup>:D<sub>8</sub> &times;U<sub>4</sub>(3).2<sup>2</sup>).2
in the sporadic simple group B, cf.&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;217].
Computing the class fusion of G into B just from the character tables
of the two groups takes extremely long.
So we use additional information.

<div class="p"><!----></div>
According to&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;217],
G is the normalizer in B of an elementary abelian group
&#9001;x, y &#9002; of order 9, with x, y in the class <tt>3A</tt> of B,
and N = N<sub>B</sub>(&#9001;x &#9002;) has the structure S<sub>3</sub> &times;Fi<sub>22</sub>.2.
The intersection G &#8745;N has the structure
S<sub>3</sub> &times;S<sub>3</sub> &times;U<sub>4</sub>(3).2<sup>2</sup>,
which is the direct product of S<sub>3</sub> and the normalizer in Fi<sub>22</sub>.2
of a <tt>3A</tt> element of Fi<sub>22</sub>.2, see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;163].
Thus we may use that the class fusions from G &#8745;N into B
through G or N coincide.

<div class="p"><!----></div>
The class fusion from N into B is uniquely determined by the character
tables.

<div class="p"><!----></div>

<pre>
    gap&#62; b:= CharacterTable( "B" );;
    gap&#62; n:= CharacterTable( "BN3A" );
    CharacterTable( "S3xFi22.2" )
    gap&#62; nfusb:= PossibleClassFusions( n, b );;
    gap&#62; Length( nfusb );
    1
    gap&#62; nfusb:= nfusb[1];;

</pre>

<div class="p"><!----></div>
The computation of the class fusion from G &#8745;N into N is sped up
by computing first the class fusion modulo the direct factor S<sub>3</sub>,
and then lifting these fusion maps.

<div class="p"><!----></div>

<pre>
    gap&#62; fi222:= CharacterTable( "Fi22.2" );;
    gap&#62; fi222n3a:= CharacterTable( "S3xU4(3).(2^2)_{122}" );;
    gap&#62; s3:= CharacterTable( "S3" );;
    gap&#62; inter:= s3 * fi222n3a;;
    gap&#62; intermods3fusnmods3:= PossibleClassFusions( fi222n3a, fi222 );;
    gap&#62; Length( intermods3fusnmods3 );
    2
    gap&#62; Length( RepresentativesFusions( fi222n3a, intermods3fusnmods3, fi222 ) );
    1

</pre>

<div class="p"><!----></div>
We get two equivalent possibilities,
and need to consider only one of them.
For lifting it to a map between G &#8745;N and N,
the safe way is to use the fusion map between the two factors for computing
an approximation.
(Additionally, we could interpret the known maps as fusions between two
subgroups, and use this for improving the approximation,
but in this case the speedup is not worth the effort.)

<div class="p"><!----></div>

<pre>
    gap&#62; interfusn:= CompositionMaps( InverseMap( GetFusionMap( n, fi222 ) ),
    &#62;        CompositionMaps( intermods3fusnmods3[1],
    &#62;            GetFusionMap( inter, fi222n3a ) ) );;
    gap&#62; interfusn:= PossibleClassFusions( inter, n,
    &#62;        rec( fusionmap:= interfusn, quick:= true ) );;
    gap&#62; Length( interfusn );
    1

</pre>

<div class="p"><!----></div>
The lift is unique.
Since we lift a class fusion to direct products,
we could also "extend" the fusion directly.
But note that this would assume the ordering of classes in character tables
of direct products.
This alternative would work as follows.

<div class="p"><!----></div>

<pre>
    gap&#62; nccl:= NrConjugacyClasses( fi222 );;
    gap&#62; interfusn[1] = Concatenation( List( [ 0 .. 2 ],
    &#62;                       i -&#62; intermods3fusnmods3[1] + i * nccl ) );
    true

</pre>

<div class="p"><!----></div>
Next we compute the class fusions from G &#8745;N to G.
We get two equivalent solutions.

<div class="p"><!----></div>

<pre>
    gap&#62; tblg:= CharacterTable( "BM14" );
    CharacterTable( "(3^2:D8xU4(3).2^2).2" )
    gap&#62; interfusg:= PossibleClassFusions( inter, tblg );;
    gap&#62; Length( interfusg );
    2
    gap&#62; Length( RepresentativesFusions( inter, interfusg, tblg ) );
    1

</pre>

<div class="p"><!----></div>
The approximation of the class fusion from G to B is computed
by composing the known maps.
Because we have chosen one of the two possible maps from G &#8745;N to N,
here we consider the two possibilities.
 From these approximations, we compute the possible class fusions.

<div class="p"><!----></div>

<pre>
    gap&#62; interfusb:= CompositionMaps( nfusb, interfusn[1] );;
    gap&#62; approx:= List( interfusg,
    &#62;        map -&#62; CompositionMaps( interfusb, InverseMap( map ) ) );;
    gap&#62; gfusb:= Set( Concatenation( List( approx,
    &#62;                     map -&#62; PossibleClassFusions( tblg, b,
    &#62;                                rec( fusionmap:= map ) ) ) ) );;
    gap&#62; Length( gfusb );
    4
    gap&#62; Length( RepresentativesFusions( tblg, gfusb, b ) );
    1

</pre>

<div class="p"><!----></div>
Finally, we compare the result with the class fusion that is stored
on the library table.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( tblg, b ) in gfusb;
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.5">
3.5</a>&nbsp;&nbsp;7<sup>1+4</sup>:(3 &times;2.S<sub>7</sub>) &#8594; M (May 2009)</h3><a name="MM24">
</a>

<div class="p"><!----></div>
The class fusion of the maximal subgroup U of type
7<sup>1+4</sup>:(3 &times;2.S<sub>7</sub>) of the Monster group M into M is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; tblu:= CharacterTable( "7^(1+4):(3x2.S7)" );;
    gap&#62; m:= CharacterTable( "M" );;
    gap&#62; ufusm:= PossibleClassFusions( tblu, m );;
    gap&#62; Length( RepresentativesFusions( tblu, ufusm, m ) );
    2

</pre>

<div class="p"><!----></div>
The subgroup U contains a Sylow 7-subgroup of M,
and the only maximal subgroups of M with this property are the class of U
and another class of subgroups, of the type 7<sup>2+1+2</sup>:GL<sub>2</sub>(7).
Moreover, it turns out that the Sylow 7 normalizers in the subgroups
in both classes have the same order, hence they are the Sylow 7
normalizers in M.

<div class="p"><!----></div>
For that, we use representations from the  A<font size="-2">TLAS</font> of Group
Representations&nbsp;[<a href="#AGR" name="CITEAGR">WWT<sup>+</sup></a>], and access these representations
via the <font face="helvetica">GAP</font> package <font face="helvetica">AtlasRep</font> ([<a href="#AtlasRep" name="CITEAtlasRep">WPN<sup>+</sup>11</a>]).

<div class="p"><!----></div>

<pre>
    gap&#62; LoadPackage( "atlasrep" );
    true
    gap&#62; g1:= AtlasGroup( "7^(2+1+2):GL2(7)" );;
    gap&#62; s1:= SylowSubgroup( g1, 7 );;
    gap&#62; n1:= Normalizer( g1, s1 );;
    gap&#62; g2:= AtlasGroup( "7^(1+4):(3x2.S7)" );;
    gap&#62; s2:= SylowSubgroup( g2, 7 );;
    gap&#62; n2:= Normalizer( g2, s2 );;
    gap&#62; Size( n1 ) = Size( n2 );
    true
    gap&#62; ( Size( m ) / Size( s1 ) ) mod 7 &lt;&#62; 0;
    true

</pre>

<div class="p"><!----></div>
So let N be a Sylow 7 normalizer in U, and choose a subgroup S of
the type 7<sup>2+1+2</sup>:GL<sub>2</sub>(7) that contains N.

<div class="p"><!----></div>
We compute the character table of N.
Computing the possible class fusions of N into M directly
yields two possibilities,
but the class fusion of N into M via S is uniquely determined by the
character tables.

<div class="p"><!----></div>

<pre>
    gap&#62; tbln:= CharacterTable( Image( IsomorphismPcGroup( n1 ) ) );;
    gap&#62; tbls:= CharacterTable( "7^(2+1+2):GL2(7)" );;
    gap&#62; nfusm:= PossibleClassFusions( tbln, m );;
    gap&#62; Length( RepresentativesFusions( tbln, nfusm, m ) );
    2
    gap&#62; nfuss:= PossibleClassFusions( tbln, tbls );;
    gap&#62; sfusm:= PossibleClassFusions( tbls, m );;
    gap&#62; nfusm:= SetOfComposedClassFusions( sfusm, nfuss );;
    gap&#62; Length( nfusm );
    1

</pre>

<div class="p"><!----></div>
Now we use the condition that the class fusions from N into M factors
through U.
This determines the class fusion of U into M up to table automorphisms.

<div class="p"><!----></div>

<pre>
    gap&#62; nfusu:= PossibleClassFusions( tbln, tblu );;
    gap&#62; ufusm:= Filtered( ufusm, map2 -&#62; ForAny( nfusu, 
    &#62;        map1 -&#62; CompositionMaps( map2, map1 ) in nfusm ) );;
    gap&#62; Length( RepresentativesFusions( tblu, ufusm, m ) );
    1

</pre>

<div class="p"><!----></div>
Let C be the centralizer in U of the normal subgroup of order 7;
note that C is the <tt>7B</tt> centralizer on M.
We can use the information about the class fusion of U into M
for determining the class fusion of C into M.
The class fusion of C into M is not determined by the character tables,
but the class fusion of C into U is determined up to table automorphisms,
so the same holds for the class fusion of C into M.

<div class="p"><!----></div>

<pre>
    gap&#62; tblc:= CharacterTable( "MC7B" );                             
    CharacterTable( "7^1+4.2A7" )
    gap&#62; cfusm:= PossibleClassFusions( tblc, m );;             
    gap&#62; Length( RepresentativesFusions( tblc, cfusm, m ) );
    2
    gap&#62; cfusu:= PossibleClassFusions( tblc, tblu );;
    gap&#62; cfusm:= SetOfComposedClassFusions( ufusm, cfusu );;
    gap&#62; Length( RepresentativesFusions( tblc, cfusm, m ) );
    1

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.6">
3.6</a>&nbsp;&nbsp;3<sup>7</sup>.O<sub>7</sub>(3):2 &#8594; Fi<sub>24</sub>
(November 2010)</h3>

<div class="p"><!----></div>
The class fusion of the maximal subgroup M  &#8773; 3<sup>7</sup>.O<sub>7</sub>(3):2
of G = Fi<sub>24</sub> = F<sub>3+</sub>.2 is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; m:= CharacterTable( "3^7.O7(3):2" );;
    gap&#62; t:= CharacterTable( "F3+.2" );;
    gap&#62; mfust:= PossibleClassFusions( m, t );;
    gap&#62; Length( RepresentativesFusions( m, mfust, t ) );
    2

</pre>

<div class="p"><!----></div>
We will use the fact that the elementary abelian normal subgroup of order
3<sup>7</sup> in M contains an element x, say, in the class <tt>3A</tt> of G.
This fact can be shown as follows.

<div class="p"><!----></div>

<pre>
    gap&#62; nsg:= ClassPositionsOfNormalSubgroups( m );
    [ [ 1 ], [ 1 .. 4 ], [ 1 .. 158 ], [ 1 .. 291 ] ]
    gap&#62; Sum( SizesConjugacyClasses( m ){ nsg[2] } );
    2187
    gap&#62; 3^7;
    2187
    gap&#62; rest:= Set( List( mfust, map -&#62; map{ nsg[2] } ) );
    [ [ 1, 4, 5, 6 ] ]
    gap&#62; List( rest, l -&#62; ClassNames( t, "Atlas" ){ l } );
    [ [ "1A", "3A", "3B", "3C" ] ]

</pre>

<div class="p"><!----></div>
The normalizer S of &#9001;x &#9002; in G has the form
S<sub>3</sub> &times;O<sub>8</sub><sup>+</sup>(3):S<sub>3</sub>,
and the order of U = S &#8745;M = N<sub>M</sub>( &#9001;x &#9002;)
is 53059069440, so U has index 3360 in S.

<div class="p"><!----></div>

<pre>
    gap&#62; s:= CharacterTable( "F3+.2N3A" );
    CharacterTable( "S3xO8+(3):S3" )
    gap&#62; PowerMap( m, 2 )[4];
    4
    gap&#62; size_u:= 2 * SizesCentralizers( m )[ 2 ];
    53059069440
    gap&#62; Size( s ) / size_u;
    3360

</pre>

<div class="p"><!----></div>
Using the list of maximal subgroups of O<sub>8</sub><sup>+</sup>(3),
we see that only the maximal subgroups of the type 3<sup>6</sup>:L<sub>4</sub>(3)
have index dividing 3360 in O<sub>8</sub><sup>+</sup>(3).
(There are three classes of such subgroups.)
This implies that U contains a subgroup of the type
S<sub>3</sub> &times;3<sup>6</sup>:L<sub>4</sub>(3).

<div class="p"><!----></div>

<pre>
    gap&#62; o8p3:= CharacterTable( "O8+(3)" );;
    gap&#62; mx:= List( Maxes( o8p3 ), CharacterTable );;
    gap&#62; filt:= Filtered( mx, x -&#62; 3360 mod Index( o8p3, x ) = 0 );
    [ CharacterTable( "3^6:L4(3)" ), CharacterTable( "O8+(3)M8" ), 
      CharacterTable( "O8+(3)M9" ) ]
    gap&#62; List( filt, x -&#62; Index( o8p3, x ) );
    [ 1120, 1120, 1120 ]

</pre>

<div class="p"><!----></div>
We compute the possible class fusions from U into M and S in two
steps, because this is faster.
First the possible class fusions from U<sup>&#8242;&#8242;</sup>  &#8773; 3<sup>6</sup>:L<sub>4</sub>(3)
into M and S are computed, and then these fusions are used to derive
approximations for the fusions from U into M and S.

<div class="p"><!----></div>

<pre>
    gap&#62; uu:= filt[1];;
    gap&#62; u:= CharacterTable( "Symmetric", 3 ) * uu;
    CharacterTable( "Sym(3)x3^6:L4(3)" )
    gap&#62; uufusm:= PossibleClassFusions( uu, m );;
    gap&#62; Length( uufusm );
    8
    gap&#62; approx:= List( uufusm, map -&#62; CompositionMaps( map,
    &#62;                   InverseMap( GetFusionMap( uu, u ) ) ) );;
    gap&#62; ufusm:= Concatenation( List( approx, map -&#62;
    &#62;        PossibleClassFusions( u, m, rec( fusionmap:= map ) ) ) );;
    gap&#62; Length( ufusm );
    8
    gap&#62; uufuss:= PossibleClassFusions( uu, s );;
    gap&#62; Length( uufuss );
    8
    gap&#62; approx:= List( uufuss, map -&#62; CompositionMaps( map,
    &#62;              InverseMap( GetFusionMap( uu, u ) ) ) );;
    gap&#62; ufuss:= Concatenation( List( approx, map -&#62;
    &#62;   PossibleClassFusions( u, s, rec( fusionmap:= map ) ) ) );;
    gap&#62; Length( ufuss );
    8

</pre>

<div class="p"><!----></div>
Now we compute the possible class fusions from S into G,
and the compositions of these maps with the possible class fusions
from U into S.

<div class="p"><!----></div>

<pre>
    gap&#62; sfust:= PossibleClassFusions( s, t );;
    gap&#62; comp:= SetOfComposedClassFusions( sfust, ufuss );;
    gap&#62; Length( comp );
    8

</pre>

<div class="p"><!----></div>
It turns out that only one orbit of the possible class fusions from M to
G is compatible with these possible class fusions from U to G.

<div class="p"><!----></div>

<pre>
    gap&#62; filt:= Filtered( mfust, map2 -&#62; ForAny( ufusm, map1 -&#62;
    &#62;        CompositionMaps( map2, map1 ) in comp ) );;
    gap&#62; Length( filt );
    4
    gap&#62; Length( RepresentativesFusions( m, filt, t ) );
    1

</pre>

<div class="p"><!----></div>
The class fusion stored in the <font face="helvetica">GAP</font> Character Table Library is one of them.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( m, t ) in filt;
    true

</pre>

<div class="p"><!----></div>

 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Fusions Determined Using Commutative Diagrams Involving Factor
Groups</h2>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;3.A<sub>7</sub> &#8594; 3.Suz (December 2010)</h3>

<div class="p"><!----></div>
The maximal subgroups of type A<sub>7</sub> in the sporadic simple Suzuki group Suz
lift to groups of the type 3.A<sub>7</sub> in 3.Suz.
This can be seen from the fact that 3.Suz does not admit a class fusion
from A<sub>7</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "Suz" );;
    gap&#62; 3t:= CharacterTable( "3.Suz" );;
    gap&#62; s:= CharacterTable( "A7" );;
    gap&#62; 3s:= CharacterTable( "3.A7" );;
    gap&#62; PossibleClassFusions( s, 3t );
    [  ]

</pre>

<div class="p"><!----></div>
The class fusion of 3.A<sub>7</sub> into 3.Suz is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; 3sfus3t:= PossibleClassFusions( 3s, 3t );;
    gap&#62; Length( 3sfus3t );
    6
    gap&#62; RepresentativesFusions( 3s, 3sfus3t, 3t );
    [ [ 1, 2, 3, 7, 8, 9, 16, 16, 26, 27, 28, 32, 33, 34, 47, 47, 47, 48, 49, 50, 
          48, 49, 50 ], 
      [ 1, 11, 12, 4, 36, 37, 13, 16, 23, 82, 83, 32, 100, 101, 44, 38, 41, 48, 
          112, 116, 48, 115, 113 ] ]
    gap&#62; ClassPositionsOfCentre( 3t );
    [ 1, 2, 3 ]

</pre>

<div class="p"><!----></div>
We see that the possible fusions in the second orbit avoid the centre of
3.Suz.
Since the preimages in 3.Suz of the A<sub>7</sub> type subgroups of Suz
contain the centre of 3.Suz, we know that the class fusion of these
preimages belong to the first orbit.
This can be formalized by checking the commutativity of the diagram
of fusions between 3.A<sub>7</sub>, 3.Suz, and their factors A<sub>7</sub> and Suz.

<div class="p"><!----></div>

<pre>
    gap&#62; sfust:= PossibleClassFusions( s, t );;
    gap&#62; Length( sfust );
    1
    gap&#62; filt:= Filtered( 3sfus3t, map -&#62; CompositionMaps( GetFusionMap( 3t, t ),
    &#62;                                         map )
    &#62;               = CompositionMaps( sfust[1], GetFusionMap( 3s, s ) ) );
    [ [ 1, 2, 3, 7, 8, 9, 16, 16, 26, 27, 28, 32, 33, 34, 47, 47, 47, 48, 49, 50, 
          48, 49, 50 ], 
      [ 1, 3, 2, 7, 9, 8, 16, 16, 26, 28, 27, 32, 34, 33, 47, 47, 47, 48, 50, 49, 
          48, 50, 49 ] ]

</pre>

<div class="p"><!----></div>
So the class fusion of maximal 3.A<sub>7</sub> type subgroups of 3.Suz is
determined up to table automorphisms.
One of these fusions is stored on the table of 3.A<sub>7</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; RepresentativesFusions( 3s, filt, 3t );
    [ [ 1, 2, 3, 7, 8, 9, 16, 16, 26, 27, 28, 32, 33, 34, 47, 47, 47, 48, 49, 50, 
          48, 49, 50 ] ]
    gap&#62; GetFusionMap( 3s, 3t ) in filt;
    true

</pre>

<div class="p"><!----></div>
Also the class fusions in the other orbit belong to subgroups of type
3.A<sub>7</sub> in 3.Suz.
Note that Suz contains maximal subgroups of the type
3<sub>2</sub>.U<sub>4</sub>(3).2<sub>3</sub><sup>&#8242;</sup> (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;131]),
and the A<sub>7</sub> type subgroups of U<sub>4</sub>(3) (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;52])
lift to groups of the type 3.A<sub>7</sub> in 3<sub>2</sub>.U<sub>4</sub>(3) because
3<sub>2</sub>.U<sub>4</sub>(3) does not admit a class fusion from A<sub>7</sub>.
The preimages in 3.Suz of the 3.A<sub>7</sub> tape subgroups of Suz
have the structure 3 &times;3.A<sub>7</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; u:= CharacterTable( "3_2.U4(3)" );;
    gap&#62; PossibleClassFusions( s, u );
    [  ]
    gap&#62; Length( PossibleClassFusions( 3s, u ) );
    8

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;S<sub>6</sub> &#8594; U<sub>4</sub>(2) (September 2011)</h3>

<div class="p"><!----></div>
The simple group G = U<sub>4</sub>(2) contains a maximal subgroup U of type S<sub>6</sub>.
The class fusion from U to G is unique up to table automorphisms.

<div class="p"><!----></div>

<pre>
    gap&#62; s:= CharacterTable( "S6" );
    CharacterTable( "A6.2_1" )
    gap&#62; t:= CharacterTable( "U4(2)" );
    CharacterTable( "U4(2)" )
    gap&#62; sfust:= PossibleClassFusions( s, t );
    [ [ 1, 3, 6, 7, 9, 10, 3, 2, 9, 16, 15 ], 
      [ 1, 3, 7, 6, 9, 10, 2, 3, 9, 15, 16 ] ]
    gap&#62; Length( RepresentativesFusions( s, sfust, t ) );
    1

</pre>

<div class="p"><!----></div>
In the double cover 2.G of G, U lifts to the double cover 2.U of U
(which is unique up to isomorphism).
Also the class fusion from 2.U to 2.G is unique up to table automorphisms.

<div class="p"><!----></div>

<pre>
    gap&#62; 2t:= CharacterTable( "2.U4(2)" );
    CharacterTable( "2.U4(2)" )
    gap&#62; 2s:= CharacterTable( "2.A6.2_1" );
    CharacterTable( "2.A6.2_1" )
    gap&#62; 2sfus2t:= PossibleClassFusions( 2s, 2t );
    [ [ 1, 2, 4, 11, 12, 9, 10, 15, 16, 17, 3, 4, 15, 24, 25, 26, 26 ], 
      [ 1, 2, 4, 11, 12, 9, 10, 15, 16, 17, 3, 4, 15, 25, 24, 26, 26 ] ]
    gap&#62; Length( RepresentativesFusions( 2s, 2sfus2t, 2t ) );
    1

</pre>

<div class="p"><!----></div>
However, the two possible fusions from 2.U to 2.G are lifts of the
same class fusion from U to G.

<div class="p"><!----></div>

<pre>
    gap&#62; 2sfuss:= GetFusionMap( 2s, s );
    [ 1, 1, 2, 3, 3, 4, 4, 5, 6, 6, 7, 8, 9, 10, 10, 11, 11 ]
    gap&#62; 2tfust:= GetFusionMap( 2t, t );;
    gap&#62; induced:= Set( List( 2sfus2t, x -&#62; CompositionMaps( 2tfust,
    &#62;      CompositionMaps( x, InverseMap( 2sfuss ) ) ) ) );
    [ [ 1, 3, 7, 6, 9, 10, 2, 3, 9, 15, 16 ] ]

</pre>

<div class="p"><!----></div>
The point is that the outer automorphism of S<sub>6</sub> that makes the two
fusions from U to G equivalent does not lift to 2.U,
and that we have silently assumed a fixed factor fusion from 2.U to U.
Note that composing this factor fusion with the automorphism of U
would also yield a factor fusion, and w.&nbsp;r.&nbsp;t.&nbsp;the commutative diagram
involving this factor fusion, the other possible class fusion from U to
G is induced by the possible fusions from 2.U to 2.G.

<div class="p"><!----></div>

<pre>
    gap&#62; auts:= AutomorphismsOfTable( s );
    Group([ (3,4)(7,8)(10,11) ])
    gap&#62; other:= OnTuples( 2sfuss, GeneratorsOfGroup( auts )[1] );
    [ 1, 1, 2, 4, 4, 3, 3, 5, 6, 6, 8, 7, 9, 11, 11, 10, 10 ]
    gap&#62; Set( List( 2sfus2t, x -&#62; CompositionMaps( 2tfust,
    &#62;      CompositionMaps( x, InverseMap( other ) ) ) ) );
    [ [ 1, 3, 6, 7, 9, 10, 3, 2, 9, 16, 15 ] ]

</pre>

<div class="p"><!----></div>
The library table of U stores the class fusion to G that is compatible
with the stored factor fusion from 2.U to U.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( s, t ) in induced;
    true

</pre>

<div class="p"><!----></div>

 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Fusions Determined Using Commutative Diagrams Involving
Automorphic Extensions</h2>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;U<sub>3</sub>(8).3<sub>1</sub> &#8594; <sup>2</sup>E<sub>6</sub>(2) (December 2010)</h3><a name="u383to2e62">
</a>

<div class="p"><!----></div>
According to the  A<font size="-2">TLAS</font> (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;191]),
the group G = <sup>2</sup>E<sub>6</sub>(2) contains a maximal subgroup U of the type
U<sub>3</sub>(8).3<sub>1</sub>.
The class fusion of U into G is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; s:= CharacterTable( "U3(8).3_1" );;
    gap&#62; t:= CharacterTable( "2E6(2)" );;
    gap&#62; sfust:= PossibleClassFusions( s, t );;
    gap&#62; Length( sfust );
    24
    gap&#62; Length( RepresentativesFusions( s, sfust, t ) );
    2

</pre>

<div class="p"><!----></div>
In the automorphic extension G.2 = <sup>2</sup>E<sub>6</sub>(2).2 of G,
the subgroup U extends to a group U.2 of the type U<sub>3</sub>(8).6
(again, see &nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;191]).
The class fusion of U.2 into G.2 is unique up to table automorphisms.

<div class="p"><!----></div>

<pre>
    gap&#62; s2:= CharacterTable( "U3(8).6" );;
    gap&#62; t2:= CharacterTable( "2E6(2).2" );;
    gap&#62; s2fust2:= PossibleClassFusions( s2, t2 );;
    gap&#62; Length( s2fust2 );
    2
    gap&#62; Length( RepresentativesFusions( s2, s2fust2, t2 ) );
    1

</pre>

<div class="p"><!----></div>
Only half of the possible class fusions from U into G are compatible
with the embeddings of U into G.2 via U.2 and G,
and the compatible maps form one orbit under table automorphisms.

<div class="p"><!----></div>

<pre>
    gap&#62; sfuss2:= PossibleClassFusions( s, s2 );;
    gap&#62; comp:= SetOfComposedClassFusions( s2fust2, sfuss2 );;
    gap&#62; tfust2:= PossibleClassFusions( t, t2 );;
    gap&#62; filt:= Filtered( sfust, map -&#62; ForAny( tfust2,
    &#62;               map2 -&#62; CompositionMaps( map2, map ) in comp ) );;
    gap&#62; Length( filt );
    12
    gap&#62; Length( RepresentativesFusions( s, filt, t ) );
    1

</pre>

<div class="p"><!----></div>
Let us see which classes of U and G are involved in the
disambiguation of the class fusion.
The "good" fusion candidates differ from the excluded ones on the
classes at the positions 31 to 36:
Under all possible class fusions, two pairs of classes are mapped to
the classes 81 and 82 of G;
from these classes, the excluded maps fuse classes at odd positions
with classes at even positions, whereas the "good" class fusions
do not have this property.

<div class="p"><!----></div>

<pre>
    gap&#62; Set( List( filt, x -&#62; x{ [ 31 .. 36 ] } ) );
    [ [ 74, 74, 81, 82, 81, 82 ], [ 74, 74, 82, 81, 82, 81 ], 
      [ 81, 82, 74, 74, 81, 82 ], [ 81, 82, 81, 82, 74, 74 ], 
      [ 82, 81, 74, 74, 82, 81 ], [ 82, 81, 82, 81, 74, 74 ] ]
    gap&#62; Set( List( Difference( sfust, filt ), x -&#62; x{ [ 31 .. 36 ] } ) );
    [ [ 74, 74, 81, 82, 82, 81 ], [ 74, 74, 82, 81, 81, 82 ], 
      [ 81, 82, 74, 74, 82, 81 ], [ 81, 82, 82, 81, 74, 74 ], 
      [ 82, 81, 74, 74, 81, 82 ], [ 82, 81, 81, 82, 74, 74 ] ]

</pre>

<div class="p"><!----></div>
None of the possible class fusions from U to U.2 fuses classes
at odd positions in the interval from 31 to 36 with classes at
even positions.

<div class="p"><!----></div>

<pre>
    gap&#62; Set( List( sfuss2, x -&#62; x{ [ 31 .. 36 ] } ) );
    [ [ 28, 29, 30, 31, 30, 31 ], [ 29, 28, 31, 30, 31, 30 ], 
      [ 30, 31, 28, 29, 30, 31 ], [ 30, 31, 30, 31, 28, 29 ], 
      [ 31, 30, 29, 28, 31, 30 ], [ 31, 30, 31, 30, 29, 28 ] ]

</pre>

<div class="p"><!----></div>
This suffices to exclude the "bad" fusion candidates
because no further fusion of the relevant classes of G happens in G.2.

<div class="p"><!----></div>

<pre>
    gap&#62; List( tfust2, x -&#62; x{ [ 74, 81, 82 ] } );
    [ [ 65, 70, 71 ], [ 65, 70, 71 ], [ 65, 71, 70 ], [ 65, 71, 70 ], 
      [ 65, 70, 71 ], [ 65, 70, 71 ], [ 65, 71, 70 ], [ 65, 71, 70 ], 
      [ 65, 70, 71 ], [ 65, 70, 71 ], [ 65, 71, 70 ], [ 65, 71, 70 ] ]

</pre>

<div class="p"><!----></div>
(The same holds for the fusion of the relevant classes of U.2 in G.2.)

<div class="p"><!----></div>

<pre>
    gap&#62; List( s2fust2, x -&#62; x{ [ 28 .. 31 ] } );
    [ [ 65, 65, 70, 71 ], [ 65, 65, 71, 70 ] ]

</pre>

<div class="p"><!----></div>
Finally, we check that a correct map is stored on the library table.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( s, t ) in filt;
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;L<sub>3</sub>(4).2<sub>1</sub> &#8594; U<sub>6</sub>(2) (December 2010)</h3>

<div class="p"><!----></div>
According to the  A<font size="-2">TLAS</font> (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;115]),
the group G = U<sub>6</sub>(2) contains a maximal subgroup U of the type
L<sub>3</sub>(4).2<sub>1</sub>.
The class fusion of U into G is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; s:= CharacterTable( "L3(4).2_1" );;
    gap&#62; t:= CharacterTable( "U6(2)" );;
    gap&#62; sfust:= PossibleClassFusions( s, t );;
    gap&#62; Length( sfust );
    27
    gap&#62; Length( RepresentativesFusions( s, sfust, t ) );
    3

</pre>

<div class="p"><!----></div>
In the automorphic extension G.3 = U<sub>6</sub>(2).3 of G,
the subgroup U extends to a group U.3 of the type L<sub>3</sub>(4).6
(again, see &nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;115]).
The class fusion of U.3 into G.3 is unique up to table automorphisms.

<div class="p"><!----></div>

<pre>
    gap&#62; s3:= CharacterTable( "L3(4).6" );;
    gap&#62; t3:= CharacterTable( "U6(2).3" );;
    gap&#62; s3fust3:= PossibleClassFusions( s3, t3 );;
    gap&#62; Length( s3fust3 );
    2
    gap&#62; Length( RepresentativesFusions( s3, s3fust3, t3 ) );
    1

</pre>

<div class="p"><!----></div>
Here the argument used in Section&nbsp;<a href="#u383to2e62">5.1</a> does not work,
because all possible class fusions from U into G are compatible
with the embeddings of U into G.3 via U.3 and G.

<div class="p"><!----></div>

<pre>
    gap&#62; sfuss3:= PossibleClassFusions( s, s3 );;
    gap&#62; comp:= SetOfComposedClassFusions( s3fust3, sfuss3 );;
    gap&#62; tfust3:= PossibleClassFusions( t, t3 );;
    gap&#62; sfust = Filtered( sfust, map -&#62; ForAny( tfust3,
    &#62;                map2 -&#62; CompositionMaps( map2, map ) in comp ) );
    true

</pre>

<div class="p"><!----></div>
Consider the elements of order four in U.
There are three such classes inside U<sup>&#8242;</sup>  &#8773; L<sub>3</sub>(4),
which fuse to one class of U.3.

<div class="p"><!----></div>

<pre>
    gap&#62; OrdersClassRepresentatives( s );
    [ 1, 2, 3, 4, 4, 4, 5, 7, 2, 4, 6, 8, 8, 8 ]
    gap&#62; sfuss3;
    [ [ 1, 2, 3, 4, 4, 4, 5, 6, 7, 8, 9, 10, 10, 10 ] ]

</pre>

<div class="p"><!----></div>
These classes of U fuse into some of the classes 10 to 12 of G.
In G.3, these three classes fuse into one class.

<div class="p"><!----></div>

<pre>
    gap&#62; Set( List( sfust, map -&#62; map{ [ 4 .. 6 ] } ) );
    [ [ 10, 10, 10 ], [ 10, 10, 11 ], [ 10, 10, 12 ], [ 10, 11, 10 ], 
      [ 10, 11, 11 ], [ 10, 11, 12 ], [ 10, 12, 10 ], [ 10, 12, 11 ], 
      [ 10, 12, 12 ], [ 11, 10, 10 ], [ 11, 10, 11 ], [ 11, 10, 12 ], 
      [ 11, 11, 10 ], [ 11, 11, 11 ], [ 11, 11, 12 ], [ 11, 12, 10 ], 
      [ 11, 12, 11 ], [ 11, 12, 12 ], [ 12, 10, 10 ], [ 12, 10, 11 ], 
      [ 12, 10, 12 ], [ 12, 11, 10 ], [ 12, 11, 11 ], [ 12, 11, 12 ], 
      [ 12, 12, 10 ], [ 12, 12, 11 ], [ 12, 12, 12 ] ]
    gap&#62; Set( List( tfust3, map -&#62; map{ [ 10 .. 12 ] } ) );
    [ [ 10, 10, 10 ] ]

</pre>

<div class="p"><!----></div>
This means that the automorphism &#945; of G that is induced by
the action of G.3 permutes the classes 10 to 12 of G transitively.
The fact that U extends to U.3 in G.3 means that U is invariant
under &#945;.
This implies that U contains either no elements from the classes
10 to 12 or elements from all of these classes.
The possible class fusions from U to G satisfying this condition
form one orbit under table automprhisms.

<div class="p"><!----></div>

<pre>
    gap&#62; Filtered( sfust, map -&#62; Intersection( map, [ 10 .. 12 ] ) = [] );
    [  ]
    gap&#62; filt:= Filtered( sfust, map -&#62; IsSubset( map, [ 10 .. 12 ] ) );
    [ [ 1, 3, 7, 10, 11, 12, 15, 24, 4, 14, 23, 26, 27, 28 ], 
      [ 1, 3, 7, 10, 12, 11, 15, 24, 4, 14, 23, 26, 28, 27 ], 
      [ 1, 3, 7, 11, 10, 12, 15, 24, 4, 14, 23, 27, 26, 28 ], 
      [ 1, 3, 7, 11, 12, 10, 15, 24, 4, 14, 23, 27, 28, 26 ], 
      [ 1, 3, 7, 12, 10, 11, 15, 24, 4, 14, 23, 28, 26, 27 ], 
      [ 1, 3, 7, 12, 11, 10, 15, 24, 4, 14, 23, 28, 27, 26 ] ]
    gap&#62; Length( RepresentativesFusions( s, filt, t ) );
    1

</pre>

<div class="p"><!----></div>
Finally, we check that a correct map is stored on the library table.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( s, t ) in filt;
    true

</pre>

<div class="p"><!----></div>

 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;Conditions Imposed by Brauer Tables</h2>

<div class="p"><!----></div>
The examples in this section show that symmetries can be broken as soon as
the class fusions between two ordinary tables shall be compatible with
the corresponding Brauer character tables.
More precisely, we assume that the class fusion from each Brauer table
to its ordinary table is already fixed;
choosing these fusions consistently can be a nontrivial task,
solving so-called "generality problems" may require the construction
of certain modules, similar to the arguments used in&nbsp;<a href="#generality">6.3</a> below.

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;L<sub>2</sub>(16).4 &#8594; J<sub>3</sub>.2 (January&nbsp;2004)</h3>

<div class="p"><!----></div>
It can happen that Brauer tables decide ambiguities of class fusions between
the corresponding ordinary tables.
An easy example is the class fusion of L<sub>2</sub>(16).4 into J<sub>3</sub>.2.
The ordinary tables admit four possible class fusions,
of which two are essentially different.

<div class="p"><!----></div>

<pre>
    gap&#62; s:= CharacterTable( "L2(16).4" );;
    gap&#62; t:= CharacterTable( "J3.2" );;
    gap&#62; fus:= PossibleClassFusions( s, t );
    [ [ 1, 2, 3, 6, 14, 15, 16, 2, 5, 7, 12, 5, 5, 8, 8, 13, 13 ],
      [ 1, 2, 3, 6, 14, 15, 16, 2, 5, 7, 12, 19, 19, 22, 22, 23, 23 ],
      [ 1, 2, 3, 6, 14, 16, 15, 2, 5, 7, 12, 5, 5, 8, 8, 13, 13 ],
      [ 1, 2, 3, 6, 14, 16, 15, 2, 5, 7, 12, 19, 19, 22, 22, 23, 23 ] ]
    gap&#62; RepresentativesFusions( s, fus, t );
    [ [ 1, 2, 3, 6, 14, 15, 16, 2, 5, 7, 12, 5, 5, 8, 8, 13, 13 ], 
      [ 1, 2, 3, 6, 14, 15, 16, 2, 5, 7, 12, 19, 19, 22, 22, 23, 23 ] ]

</pre>

<div class="p"><!----></div>
Using Brauer tables, we will see that just one fusion is admissible.

<div class="p"><!----></div>
We can exclude two possible fusions by the fact that their images all
lie inside the normal subgroup J<sub>3</sub>, but J<sub>3</sub> does not contain a subgroup
of type L<sub>2</sub>(16).4; so still one orbit of length two remains.

<div class="p"><!----></div>

<pre>
    gap&#62; j3:= CharacterTable( "J3" );;
    gap&#62; PossibleClassFusions( s, j3 );
    [  ]
    gap&#62; GetFusionMap( j3, t );
    [ 1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11, 12, 12, 13, 14, 14, 15, 16, 17, 17 ]
    gap&#62; filt:= Filtered( fus,
    &#62;          x -&#62; not IsSubset( ClassPositionsOfDerivedSubgroup( t ), x ) );
    [ [ 1, 2, 3, 6, 14, 15, 16, 2, 5, 7, 12, 19, 19, 22, 22, 23, 23 ], 
      [ 1, 2, 3, 6, 14, 16, 15, 2, 5, 7, 12, 19, 19, 22, 22, 23, 23 ] ]

</pre>

<div class="p"><!----></div>
Now the remaining wrong fusion is excluded by the fact that the table
automorphism of J<sub>3</sub>.2 that swaps the two classes of element order 17
-which swaps two of the possible class fusions-
does not live in the 2-modular table.

<div class="p"><!----></div>

<pre>
    gap&#62; smod2:= s mod 2;;
    gap&#62; tmod2:= t mod 2;;
    gap&#62; admissible:= [];;
    gap&#62; for map in filt do
    &#62;      modmap:= CompositionMaps( InverseMap( GetFusionMap( tmod2, t ) ),
    &#62;                   CompositionMaps( map, GetFusionMap( smod2, s ) ) );
    &#62;      if not fail in Decomposition( Irr( smod2 ),
    &#62;            List( Irr( tmod2 ), chi -&#62; chi{ modmap } ), "nonnegative" ) then
    &#62;        AddSet( admissible, map );
    &#62;      fi;
    &#62;    od;
    gap&#62; admissible;
    [ [ 1, 2, 3, 6, 14, 16, 15, 2, 5, 7, 12, 19, 19, 22, 22, 23, 23 ] ]

</pre>

<div class="p"><!----></div>
The test of all available Brauer tables is implemented in the function
<tt>CTblLib.Test.Decompositions</tt> of the <font face="helvetica">GAP</font> Character Table Library
([<a href="#CTblLib1.2" name="CITECTblLib1.2">Bre12</a>]).

<div class="p"><!----></div>

<pre>
    gap&#62; CTblLib.Test.Decompositions( s, fus, t ) = admissible;
    true

</pre>

<div class="p"><!----></div>
We see that p-modular tables alone determine the class fusion uniquely;
in fact the primes 2 and 3 suffice for that.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( s, t ) in admissible;
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;L<sub>2</sub>(17) &#8594; S<sub>8</sub>(2) (July 2004)</h3>

<div class="p"><!----></div>
The class fusion of the maximal subgroup M  &#8773; L<sub>2</sub>(17)
of G = S<sub>8</sub>(2) is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; m:= CharacterTable( "L2(17)" );;
    gap&#62; t:= CharacterTable( "S8(2)" );;
    gap&#62; mfust:= PossibleClassFusions( m, t );;
    gap&#62; Length( RepresentativesFusions( m, mfust, t ) );
    4

</pre>

<div class="p"><!----></div>
The Brauer tables for M and G determine the class fusion up to
table automorphisms.

<div class="p"><!----></div>

<pre>
    gap&#62; filt:= CTblLib.Test.Decompositions( m, mfust, t );;
    gap&#62; repr:= RepresentativesFusions( m, filt, t );;
    gap&#62; Length( repr );
    1
    gap&#62; GetFusionMap( m, t ) in repr;
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;L<sub>2</sub>(19) &#8594; J<sub>3</sub> (April 2003)</h3><a name="generality">
</a>

<div class="p"><!----></div>
It can happen that Brauer tables impose conditions such that ambiguities
arise which are not visible if one considers only ordinary tables.

<div class="p"><!----></div>
The class fusion between the ordinary character tables of L<sub>2</sub>(19) and J<sub>3</sub>
is unique up to table automorphisms.

<div class="p"><!----></div>

<pre>
    gap&#62; s:= CharacterTable( "L2(19)" );;
    gap&#62; t:= CharacterTable( "J3" );;
    gap&#62; sfust:= PossibleClassFusions( s, t );
    [ [ 1, 2, 4, 6, 7, 10, 11, 12, 13, 14, 20, 21 ],
      [ 1, 2, 4, 6, 7, 10, 11, 12, 13, 14, 21, 20 ],
      [ 1, 2, 4, 6, 7, 11, 12, 10, 13, 14, 20, 21 ],
      [ 1, 2, 4, 6, 7, 11, 12, 10, 13, 14, 21, 20 ],
      [ 1, 2, 4, 6, 7, 12, 10, 11, 13, 14, 20, 21 ],
      [ 1, 2, 4, 6, 7, 12, 10, 11, 13, 14, 21, 20 ],
      [ 1, 2, 4, 7, 6, 10, 11, 12, 14, 13, 20, 21 ],
      [ 1, 2, 4, 7, 6, 10, 11, 12, 14, 13, 21, 20 ],
      [ 1, 2, 4, 7, 6, 11, 12, 10, 14, 13, 20, 21 ],
      [ 1, 2, 4, 7, 6, 11, 12, 10, 14, 13, 21, 20 ],
      [ 1, 2, 4, 7, 6, 12, 10, 11, 14, 13, 20, 21 ],
      [ 1, 2, 4, 7, 6, 12, 10, 11, 14, 13, 21, 20 ] ]
    gap&#62; fusreps:= RepresentativesFusions( s, sfust, t );
    [ [ 1, 2, 4, 6, 7, 10, 11, 12, 13, 14, 20, 21 ] ]

</pre>

<div class="p"><!----></div>
The Galois automorphism that permutes the three classes of element order 9
in the tables of (L<sub>2</sub>(19) and) J<sub>3</sub> does not live in characteristic 19.
For example, the unique irreducible Brauer character of degree 110
in the 19-modular table of J<sub>3</sub> is &#981;<sub>3</sub>,
and the value of this character on the class <tt>9A</tt> is <tt>-1+2y9+&amp;4</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; tmod19:= t mod 19;
    BrauerTable( "J3", 19 )
    gap&#62; deg110:= Filtered( Irr( tmod19 ), phi -&#62; phi[1] = 110 );
    [ Character( BrauerTable( "J3", 19 ), [ 110, -2, 5, 2, 2, 0, 0, 1, 0, 
          -2*E(9)^2+E(9)^3-E(9)^4-E(9)^5+E(9)^6-2*E(9)^7, 
          E(9)^2+E(9)^3-E(9)^4-E(9)^5+E(9)^6+E(9)^7, 
          E(9)^2+E(9)^3+2*E(9)^4+2*E(9)^5+E(9)^6+E(9)^7, -2, -2, -1, 0, 0, 
          E(17)+E(17)^2+E(17)^4+E(17)^8+E(17)^9+E(17)^13+E(17)^15+E(17)^16, 
          E(17)^3+E(17)^5+E(17)^6+E(17)^7+E(17)^10+E(17)^11+E(17)^12+E(17)^14 ] ) 
     ]
    gap&#62; 9A:= Position( OrdersClassRepresentatives( tmod19 ), 9 );
    10
    gap&#62; deg110[1][ 9A ];
    -2*E(9)^2+E(9)^3-E(9)^4-E(9)^5+E(9)^6-2*E(9)^7
    gap&#62; AtlasIrrationality( "-1+2y9+&amp;4" ) = deg110[1][ 9A ];
    true

</pre>

<div class="p"><!----></div>
It turns out that four of the twelve possible class fusions are not compatible
with the 19-modular tables.

<div class="p"><!----></div>

<pre>
    gap&#62; smod19:= s mod 19;
    BrauerTable( "L2(19)", 19 )
    gap&#62; compatible:= [];;
    gap&#62; for map in sfust do
    &#62;      comp:= CompositionMaps( InverseMap( GetFusionMap( tmod19, t ) ),
    &#62;      CompositionMaps( map, GetFusionMap( smod19, s ) ) );
    &#62;      rest:= List( Irr( tmod19 ), phi -&#62; phi{ comp } );
    &#62;      if not fail in Decomposition( Irr( smod19 ), rest, "nonnegative" ) then
    &#62;        Add( compatible, map );
    &#62;      fi;
    &#62;    od;
    gap&#62; compatible;
    [ [ 1, 2, 4, 6, 7, 11, 12, 10, 13, 14, 20, 21 ],
      [ 1, 2, 4, 6, 7, 11, 12, 10, 13, 14, 21, 20 ],
      [ 1, 2, 4, 6, 7, 12, 10, 11, 13, 14, 20, 21 ],
      [ 1, 2, 4, 6, 7, 12, 10, 11, 13, 14, 21, 20 ],
      [ 1, 2, 4, 7, 6, 11, 12, 10, 14, 13, 20, 21 ],
      [ 1, 2, 4, 7, 6, 11, 12, 10, 14, 13, 21, 20 ],
      [ 1, 2, 4, 7, 6, 12, 10, 11, 14, 13, 20, 21 ],
      [ 1, 2, 4, 7, 6, 12, 10, 11, 14, 13, 21, 20 ] ]

</pre>

<div class="p"><!----></div>
Moreover, the subgroups of those table automorphisms of the ordinary tables
that leave the set of compatible fusions invariant make two orbits on this
set.
Indeed, the two orbits belong to essentially different decompositions of the
restriction of &#981;<sub>3</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; reps:= RepresentativesFusions( s, compatible, t );
    [ [ 1, 2, 4, 6, 7, 11, 12, 10, 13, 14, 20, 21 ],
      [ 1, 2, 4, 6, 7, 12, 10, 11, 13, 14, 20, 21 ] ]
    gap&#62; compatiblemod19:= List( reps, map -&#62; CompositionMaps(
    &#62;        InverseMap( GetFusionMap( tmod19, t ) ),
    &#62;        CompositionMaps( map, GetFusionMap( smod19, s ) ) ) );
    [ [ 1, 2, 4, 6, 7, 11, 12, 10, 13, 14 ], 
      [ 1, 2, 4, 6, 7, 12, 10, 11, 13, 14 ] ]
    gap&#62; rest:= List( compatiblemod19, map -&#62; Irr( tmod19 )[3]{ map } );;
    gap&#62; dec:= Decomposition( Irr( smod19 ), rest, "nonnegative" );
    [ [ 0, 0, 1, 2, 1, 2, 2, 1, 0, 1 ], [ 0, 2, 0, 2, 0, 1, 2, 0, 2, 1 ] ]
    gap&#62; List( Irr( smod19 ), phi -&#62; phi[1] );
    [ 1, 3, 5, 7, 9, 11, 13, 15, 17, 19 ]

</pre>

<div class="p"><!----></div>
In order to decide which class fusion is correct,
we take the matrix representation of J<sub>3</sub> that affords &#981;<sub>3</sub>,
restrict it to L<sub>2</sub>(19), which is the second maximal subgroup of J<sub>3</sub>,
and compute the composition factors.
For that, we use a representation from the  A<font size="-2">TLAS</font> of Group
Representations&nbsp;[<a href="#AGR" name="CITEAGR">WWT<sup>+</sup></a>], and access it via the <font face="helvetica">GAP</font> package
<font face="helvetica">AtlasRep</font> ([<a href="#AtlasRep" name="CITEAtlasRep">WPN<sup>+</sup>11</a>]).

<div class="p"><!----></div>

<pre>
    gap&#62; LoadPackage( "atlasrep" );
    true
    gap&#62; prog:= AtlasStraightLineProgram( "J3", "maxes", 2 );
    rec( groupname := "J3", identifier := [ "J3", "J3G1-max2W1", 1 ], 
      program := &lt;straight line program&#62;, size := 3420, standardization := 1, 
      subgroupname := "L2(19)" )
    gap&#62; gens:= OneAtlasGeneratingSet( "J3", Characteristic, 19, Dimension, 110 );
    rec( dim := 110, 
      generators := [ &lt; immutable compressed matrix 110x110 over GF(19) &#62;, 
          &lt; immutable compressed matrix 110x110 over GF(19) &#62; ], 
      groupname := "J3", id := "", 
      identifier := [ "J3", [ "J3G1-f19r110B0.m1", "J3G1-f19r110B0.m2" ], 1, 19 ],
      repname := "J3G1-f19r110B0", repnr := 35, ring := GF(19), size := 50232960, 
      standardization := 1, type := "matff" )
    gap&#62; restgens:= ResultOfStraightLineProgram( prog.program, gens.generators );
    [ &lt; immutable compressed matrix 110x110 over GF(19) &#62;,
      &lt; immutable compressed matrix 110x110 over GF(19) &#62; ]
    gap&#62; module:= GModuleByMats( restgens, GF( 19 ) );;
    gap&#62; facts:= SMTX.CollectedFactors( module );;
    gap&#62; Length( facts );
    7
    gap&#62; List( facts, x -&#62; x[1].dimension );
    [ 5, 7, 9, 11, 13, 15, 19 ]
    gap&#62; List( facts, x -&#62; x[2] );
    [ 1, 2, 1, 2, 2, 1, 1 ]

</pre>

<div class="p"><!----></div>
This means that there are seven pairwise nonisomorphic composition factors,
the smallest one of dimension five.
In other words, the first of the two maps is the correct one.
Let us check whether this map equals the one that is stored on the library
table.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( s, t ) = reps[1];
    true

</pre>

<div class="p"><!----></div>

 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;Fusions Determined by Information about the Groups</h2>

<div class="p"><!----></div>
In the examples in this section, character theoretic arguments do not suffice
for determining the class fusions.
So we use computations with the groups in question or information about
these groups beyond the character table,
and perhaps additionally character theoretic arguments.

<div class="p"><!----></div>
The group representations are taken from the  A<font size="-2">TLAS</font> of Group
Representations&nbsp;[<a href="#AGR" name="CITEAGR">WWT<sup>+</sup></a>] and are accessed via the <font face="helvetica">GAP</font> package
<font face="helvetica">AtlasRep</font> ([<a href="#AtlasRep" name="CITEAtlasRep">WPN<sup>+</sup>11</a>]).

<div class="p"><!----></div>

<pre>
    gap&#62; LoadPackage( "atlasrep" );
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;U<sub>3</sub>(3).2 &#8594; Fi<sub>24</sub><sup>&#8242;</sup> (November 2002)</h3>

<div class="p"><!----></div>
The group G = Fi<sub>24</sub><sup>&#8242;</sup> contains a maximal subgroup H of type
U<sub>3</sub>(3).2.  From the character tables of G and H, one gets a lot of
essentially different possibilities (and additionally this takes quite some
time).
We use the description of H as the normalizer in G of a U<sub>3</sub>(3) type
subgroup containing elements in the classes <tt>2B</tt>, <tt>3D</tt>, <tt>3E</tt>, <tt>4C</tt>, <tt>4C</tt>,
<tt>6J</tt>, <tt>7B</tt>, <tt>8C</tt>, and <tt>12M</tt> (see&nbsp;[<a href="#BN95" name="CITEBN95">BN95</a>]).

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "F3+" );
    CharacterTable( "F3+" )
    gap&#62; s:= CharacterTable( "U3(3).2" );
    CharacterTable( "U3(3).2" )
    gap&#62; tnames:= ClassNames( t, "ATLAS" );
    [ "1A", "2A", "2B", "3A", "3B", "3C", "3D", "3E", "4A", "4B", "4C", "5A", 
      "6A", "6B", "6C", "6D", "6E", "6F", "6G", "6H", "6I", "6J", "6K", "7A", 
      "7B", "8A", "8B", "8C", "9A", "9B", "9C", "9D", "9E", "9F", "10A", "10B", 
      "11A", "12A", "12B", "12C", "12D", "12E", "12F", "12G", "12H", "12I", 
      "12J", "12K", "12L", "12M", "13A", "14A", "14B", "15A", "15B", "15C", 
      "16A", "17A", "18A", "18B", "18C", "18D", "18E", "18F", "18G", "18H", 
      "20A", "20B", "21A", "21B", "21C", "21D", "22A", "23A", "23B", "24A", 
      "24B", "24C", "24D", "24E", "24F", "24G", "26A", "27A", "27B", "27C", 
      "28A", "29A", "29B", "30A", "30B", "33A", "33B", "35A", "36A", "36B", 
      "36C", "36D", "39A", "39B", "39C", "39D", "42A", "42B", "42C", "45A", 
      "45B", "60A" ]
    gap&#62; OrdersClassRepresentatives( s );
    [ 1, 2, 3, 3, 4, 4, 6, 7, 8, 12, 2, 4, 6, 8, 12, 12 ]
    gap&#62; sfust:= List( [ "1A", "2B", "3D", "3E", "4C", "4C", "6J", "7B", "8C",
    &#62;                    "12M" ], x -&#62; Position( tnames, x ) );
    [ 1, 3, 7, 8, 11, 11, 22, 25, 28, 50 ]
    gap&#62; sfust:= PossibleClassFusions( s, t, rec( fusionmap:= sfust ) );
    [ [ 1, 3, 7, 8, 11, 11, 22, 25, 28, 50, 3, 9, 23, 28, 43, 43 ], 
      [ 1, 3, 7, 8, 11, 11, 22, 25, 28, 50, 3, 11, 23, 28, 50, 50 ] ]
    gap&#62; OrdersClassRepresentatives( s );
    [ 1, 2, 3, 3, 4, 4, 6, 7, 8, 12, 2, 4, 6, 8, 12, 12 ]

</pre>

<div class="p"><!----></div>
So we still have two possibilities, which differ on the outer classes of
element order 4 and 12.

<div class="p"><!----></div>
Our idea is to take a subgroup U of H that contains such elements,
and to compute the possible class fusions of U into G, via the
factorization through a suitable maximal subgroup M of G.

<div class="p"><!----></div>
We take U = N<sub>H</sub>(&#9001;g &#9002;) where g is an element in the first
class of order three elements of H;
this is a maximal subgroup of H, of order 216.

<div class="p"><!----></div>

<pre>
    gap&#62; Maxes( s );
    [ "U3(3)", "3^(1+2):SD16", "L3(2).2", "2^(1+4).S3", "4^2:D12" ]
    gap&#62; SizesCentralizers( s );
    [ 12096, 192, 216, 18, 96, 32, 24, 7, 8, 12, 48, 48, 6, 8, 12, 12 ]
    gap&#62; u:= CharacterTable( Maxes( s )[2] );;
    gap&#62; ufuss:= GetFusionMap( u, s );
    [ 1, 2, 11, 3, 4, 5, 12, 7, 13, 9, 9, 15, 16, 10 ]

</pre>

<div class="p"><!----></div>
Candidates for M are those subgroups of G that contain elements
in the class <tt>3D</tt> of G whose centralizer is the full <tt>3D</tt> centralizer
in G.

<div class="p"><!----></div>

<pre>
    gap&#62; 3Dcentralizer:= SizesCentralizers( t )[7];
    153055008
    gap&#62; cand:= [];;                                                               
    gap&#62; for name in Maxes( t ) do
    &#62;      m:= CharacterTable( name );
    &#62;      mfust:= GetFusionMap( m, t );        
    &#62;      if ForAny( [ 1 .. Length( mfust ) ],                    
    &#62;          i -&#62; mfust[i] = 7 and SizesCentralizers( m )[i] = 3Dcentralizer )   
    &#62;      then
    &#62;        Add( cand, m );
    &#62;      fi;
    &#62;    od;
    gap&#62; cand;
    [ CharacterTable( "3^7.O7(3)" ), CharacterTable( "3^2.3^4.3^8.(A5x2A4).2" ) ]

</pre>

<div class="p"><!----></div>
For these two groups M, we show that the possible class fusions from U
to G via M factorize through H only if the second possible class fusion
from H to G is chosen.

<div class="p"><!----></div>

<pre>
    gap&#62; possufust:= List( sfust, x -&#62; CompositionMaps( x, ufuss ) );
    [ [ 1, 3, 3, 7, 8, 11, 9, 22, 23, 28, 28, 43, 43, 50 ], 
      [ 1, 3, 3, 7, 8, 11, 11, 22, 23, 28, 28, 50, 50, 50 ] ]
    gap&#62; m:= cand[1];;
    gap&#62; ufusm:= PossibleClassFusions( u, m );;
    gap&#62; Length( ufusm );
    242
    gap&#62; comp:= List( ufusm, x -&#62; CompositionMaps( GetFusionMap( m, t ), x ) );;
    gap&#62; Intersection( possufust, comp );
    [ [ 1, 3, 3, 7, 8, 11, 11, 22, 23, 28, 28, 50, 50, 50 ] ]
    gap&#62; m:= cand[2];;
    gap&#62; ufusm:= PossibleClassFusions( u, m );;
    gap&#62; Length( ufusm );                        
    256
    gap&#62; comp:= List( ufusm, x -&#62; CompositionMaps( GetFusionMap( m, t ), x ) );;   
    gap&#62; Intersection( possufust, comp );
    [ [ 1, 3, 3, 7, 8, 11, 11, 22, 23, 28, 28, 50, 50, 50 ] ]

</pre>

<div class="p"><!----></div>
Finally, we check that the correct fusion is stored in the <font face="helvetica">GAP</font> Character
Table Library.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( s, t ) = sfust[2];
    true

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;L<sub>2</sub>(13).2 &#8594; Fi<sub>24</sub><sup>&#8242;</sup> (September 2002)</h3>

<div class="p"><!----></div>
The class fusion of maximal subgroups U of type L<sub>2</sub>(13).2
in G = Fi<sub>24</sub><sup>&#8242;</sup> is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "F3+" );;
    gap&#62; u:= CharacterTable( "L2(13).2" );;
    gap&#62; fus:= PossibleClassFusions( u, t );;
    gap&#62; repr:= RepresentativesFusions( u, fus, t );;
    gap&#62; Length( repr );
    3

</pre>

<div class="p"><!----></div>
In&nbsp;[<a href="#LW91" name="CITELW91">LW91</a>,p.&nbsp;155], it is stated that U<sup>&#8242;</sup> contains elements
in the classes <tt>2B</tt>, <tt>3D</tt>, and <tt>7B</tt> of G.
(Note that the two conjugacy classes of groups isomorphic to U have
the same class fusion because the outer automorphism of G fixes
the relevant classes.)

<div class="p"><!----></div>

<pre>
    gap&#62; filt:= Filtered( repr, x -&#62; t.2b in x and t.3d in x and t.7b in x );
    [ [ 1, 3, 7, 22, 25, 25, 25, 51, 3, 9, 43, 43, 53, 53, 53 ], 
      [ 1, 3, 7, 22, 25, 25, 25, 51, 3, 11, 50, 50, 53, 53, 53 ] ]
    gap&#62; ClassNames( t ){ [ 43, 50 ] };
    [ "12f", "12m" ]

</pre>

<div class="p"><!----></div>
So we have to decide whether U contains elements in the class <tt>12F</tt> or
in <tt>12M</tt> of G.

<div class="p"><!----></div>
The order 12 elements in question lie inside subgroups of type 13 : 12
in U.
These subgroups are clearly contained in the Sylow 13 normalizers of G,
which are contained in maximal subgroups of type (3<sup>2</sup>:2 &times;G<sub>2</sub>(3)).2
in G;
the class fusion of the latter groups is unique up to table automorphisms.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= Position( OrdersClassRepresentatives( t ), 13 );
    51
    gap&#62; SizesCentralizers( t )[ pos ];
    234
    gap&#62; ClassOrbit( t, pos );
    [ 51 ]
    gap&#62; cand:= [];;                                                         
    gap&#62; for name in Maxes( t ) do
    &#62;      m:= CharacterTable( name );
    &#62;      pos:= Position( OrdersClassRepresentatives( m ), 13 );
    &#62;      if pos &lt;&#62; fail and                                             
    &#62;         SizesCentralizers( m )[ pos ] = 234                         
    &#62;         and ClassOrbit( m, pos ) = [ pos ] then
    &#62;        Add( cand, m );
    &#62;      fi;
    &#62;    od;
    gap&#62; cand;
    [ CharacterTable( "(3^2:2xG2(3)).2" ) ]
    gap&#62; s:= cand[1];;
    gap&#62; sfust:= PossibleClassFusions( s, t );;

</pre>

<div class="p"><!----></div>
As no 13:12 type subgroup is contained in the derived subgroup of
(3<sup>2</sup>:2 &times;G<sub>2</sub>(3)).2, we look at the elements of order 12 in the
outer half.

<div class="p"><!----></div>

<pre>
    gap&#62; der:= ClassPositionsOfDerivedSubgroup( s );;
    gap&#62; outer:= Difference( [ 1 .. NrConjugacyClasses( s ) ], der );;
    gap&#62; sfust:= PossibleClassFusions( s, t );;
    gap&#62; imgs:= Set( Flat( List( sfust, x -&#62; x{ outer } ) ) );
    [ 2, 3, 10, 11, 15, 17, 18, 19, 21, 22, 26, 44, 45, 49, 50, 52, 62, 83, 87, 
      98 ]
    gap&#62; t.12f in imgs;
    false
    gap&#62; t.12m in imgs;
    true

</pre>

<div class="p"><!----></div>
So L<sub>2</sub>(13).2 \L<sub>2</sub>(13) does not contain <tt>12F</tt> elements of G,
i.&nbsp;e., we have determined the class fusion of U in G.

<div class="p"><!----></div>
Finally, we check whether the correct fusion is stored in the
<font face="helvetica">GAP</font> Character Table Library.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( u, t ) = filt[2];
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;M<sub>11</sub> &#8594; B (April 2009)</h3><a name="M11fusB">
</a>

<div class="p"><!----></div>
The sporadic simple group B contains a maximal subgroup M of the type
M<sub>11</sub> whose class fusion is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; b:= CharacterTable( "B" );;
    gap&#62; m11:= CharacterTable( "M11" );;
    gap&#62; m11fusb:= PossibleClassFusions( m11, b );;
    gap&#62; Length( m11fusb );
    31
    gap&#62; CompositionMaps( ClassNames( b, "ATLAS" ), Parametrized( m11fusb ) );
    [ "1A", [ "2B", "2D" ], [ "3A", "3B" ], [ "4B", "4E", "4G", "4H", "4J" ], 
      [ "5A", "5B" ], [ "6C", "6E", "6H", "6I", "6J" ], 
      [ "8B", "8E", "8G", "8J", "8K", "8L", "8M", "8N" ], 
      [ "8B", "8E", "8G", "8J", "8K", "8L", "8M", "8N" ], "11A", "11A" ]

</pre>

<div class="p"><!----></div>
According to&nbsp;[<a href="#Wil93a" name="CITEWil93a">Wil93a</a>,Thm.&nbsp;12.1], M contains no <tt>5A</tt> elements of B.
By the proof of&nbsp;[<a href="#Wil99" name="CITEWil99">Wil99</a>,Prop.&nbsp;4.1],
the involutions in any S<sub>5</sub> type subgroup U of M
lie in the class <tt>2C</tt> or <tt>2D</tt> of B,
and since the possible class fusions of M computed above
admit only involutions in the class <tt>2B</tt> or <tt>2D</tt>,
all involutions of U lie in the class <tt>2D</tt>.
Again by the proof of&nbsp;[<a href="#Wil99" name="CITEWil99">Wil99</a>,Prop.&nbsp;4.1], U is contained in a maximal
subgroup of type Th in B.

<div class="p"><!----></div>
Now we use the embedding of U into B via M and Th for determining
the class fusion of M into B.
The class fusion of the embedding of U via Th is uniquely determined.

<div class="p"><!----></div>

<pre>
    gap&#62; th:= CharacterTable( "Th" );;
    gap&#62; s5:= CharacterTable( "S5" );;
    gap&#62; s5fusth:= PossibleClassFusions( s5, th );
    [ [ 1, 2, 4, 8, 2, 7, 11 ] ]
    gap&#62; thfusb:= PossibleClassFusions( th, b );;
    gap&#62; s5fusb:= Set( List( thfusb, x -&#62; CompositionMaps( x, s5fusth[1] ) ) );
    [ [ 1, 5, 7, 19, 5, 17, 29 ] ]

</pre>

<div class="p"><!----></div>
Also the class fusion of U into M is unique,
and this determines the class fusion of M into B.

<div class="p"><!----></div>

<pre>
    gap&#62; s5fusm11:= PossibleClassFusions( s5, m11 );
    [ [ 1, 2, 3, 5, 2, 4, 6 ] ]
    gap&#62; m11fusb:= Filtered( m11fusb,
    &#62;                  map -&#62; CompositionMaps( map, s5fusm11[1] ) = s5fusb[1] );
    [ [ 1, 5, 7, 17, 19, 29, 45, 45, 54, 54 ] ]
    gap&#62; CompositionMaps( ClassNames( b, "ATLAS" ), m11fusb[1] );
    [ "1A", "2D", "3B", "4J", "5B", "6J", "8N", "8N", "11A", "11A" ]

</pre>

<div class="p"><!----></div>
(Using the information that the M<sub>10</sub> type subgroups of M are also
contained in Th type subgroups would not have helped us,
since these subgroups do not contain elements of order 6,
and two possibilities would have remained.)

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.4">
7.4</a>&nbsp;&nbsp;L<sub>2</sub>(11):2 &#8594; B (April 2009)</h3>

<div class="p"><!----></div>
The sporadic simple group B contains a maximal subgroup L of the type
L<sub>2</sub>(11):2 whose class fusion is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; b:= CharacterTable( "B" );;
    gap&#62; l:= CharacterTable( "L2(11).2" );;
    gap&#62; lfusb:= PossibleClassFusions( l, b );;
    gap&#62; Length( lfusb );
    16
    gap&#62; CompositionMaps( ClassNames( b, "ATLAS" ), Parametrized( lfusb ) );
    [ "1A", [ "2B", "2D" ], [ "3A", "3B" ], [ "5A", "5B" ], [ "5A", "5B" ], 
      [ "6C", "6H", "6I", "6J" ], "11A", [ "2C", "2D" ], 
      [ "4D", "4E", "4F", "4G", "4H", "4J" ], [ "10C", "10E", "10F" ], 
      [ "10C", "10E", "10F" ], 
      [ "12E", "12F", "12H", "12I", "12J", "12L", "12N", "12P", "12Q", "12R", 
          "12S" ], 
      [ "12E", "12F", "12H", "12I", "12J", "12L", "12N", "12P", "12Q", "12R", 
          "12S" ] ]

</pre>

<div class="p"><!----></div>
According to&nbsp;[<a href="#Wil93a" name="CITEWil93a">Wil93a</a>,Thm.&nbsp;12.1], L contains no <tt>5A</tt> elements of B.
By the proof of&nbsp;[<a href="#Wil99" name="CITEWil99">Wil99</a>,Prop.&nbsp;4.1], B contains exactly one class of
L<sub>2</sub>(11) type subgroups with this property.
Hence the subgroup U of index two in L is contained in a maximal subgroup
M of type M<sub>11</sub> in B,
whose class fusion was determined in Section&nbsp;<a href="#M11fusB">7.3</a>.

<div class="p"><!----></div>
In the same way as we proceeded in Section&nbsp;<a href="#M11fusB">7.3</a>,
we use the embedding of U into B via L and M for determining
the class fusion of L into B.

<div class="p"><!----></div>

<pre>
    gap&#62; m:= CharacterTable( "M11" );;
    gap&#62; u:= CharacterTable( "L2(11)" );;
    gap&#62; ufusm:= PossibleClassFusions( u, m );;
    gap&#62; mfusb:= GetFusionMap( m, b );;
    gap&#62; ufusb:= Set( List( ufusm, x -&#62; CompositionMaps( mfusb, x ) ) );
    [ [ 1, 5, 7, 19, 19, 29, 54, 54 ] ]
    gap&#62; ufusl:= PossibleClassFusions( u, l );
    [ [ 1, 2, 3, 4, 5, 6, 7, 7 ], [ 1, 2, 3, 5, 4, 6, 7, 7 ] ]
    gap&#62; lfusb:= Filtered( lfusb, 
    &#62;              map2 -&#62; ForAny( ufusl, 
    &#62;                        map1 -&#62; CompositionMaps( map2, map1 ) in ufusb ) );
    [ [ 1, 5, 7, 19, 19, 29, 54, 5, 15, 53, 53, 73, 73 ] ]

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.5">
7.5</a>&nbsp;&nbsp;L<sub>3</sub>(3) &#8594; B (April 2009)</h3>

<div class="p"><!----></div>
The sporadic simple group B contains a maximal subgroup T of the type
L<sub>3</sub>(3) whose class fusion is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; b:= CharacterTable( "B" );;
    gap&#62; t:= CharacterTable( "L3(3)" );;
    gap&#62; tfusb:= PossibleClassFusions( t, b );;
    gap&#62; Length( tfusb );
    36

</pre>

<div class="p"><!----></div>
According to&nbsp;[<a href="#Wil99" name="CITEWil99">Wil99</a>,Section&nbsp;9], T contains a subgroup U of the type
3<sup>2</sup>:2S<sub>4</sub> that is contained also in a maximal subgroup M of the type
3<sup>2</sup>.3<sup>3</sup>.3<sup>6</sup>.(S<sub>4</sub> &times;2S<sub>4</sub>).
So we throw away the possible fusions from T to B that are not compatible
with the compositions of the embeddings of U into B via T and M.

<div class="p"><!----></div>

<pre>
    gap&#62; m:= CharacterTable( "3^2.3^3.3^6.(S4x2S4)" );;
    gap&#62; g:= PSL(3,3);;
    gap&#62; mx:= MaximalSubgroupClassReps( g );;
    gap&#62; u:= First( mx, x -&#62; Size( x ) = 432 );;
    gap&#62; u:= CharacterTable( u );;
    gap&#62; ufusm:= PossibleClassFusions( u, m );;
    gap&#62; ufust:= PossibleClassFusions( u, t );;
    gap&#62; mfusb:= GetFusionMap( m, b );;
    gap&#62; ufusb:= Set( List( ufusm, map -&#62; CompositionMaps( mfusb, map ) ) );;
    gap&#62; tfusb:= Filtered( tfusb, map -&#62; ForAny( ufust,
    &#62;        map2 -&#62; CompositionMaps( map, map2 ) in ufusb ) );;
    gap&#62; tfusb;
    [ [ 1, 5, 6, 7, 12, 27, 41, 41, 75, 75, 75, 75 ], 
      [ 1, 5, 7, 6, 12, 28, 41, 41, 75, 75, 75, 75 ], 
      [ 1, 5, 7, 7, 12, 28, 41, 41, 75, 75, 75, 75 ], 
      [ 1, 5, 7, 7, 12, 29, 41, 41, 75, 75, 75, 75 ], 
      [ 1, 5, 7, 7, 17, 29, 45, 45, 75, 75, 75, 75 ] ]

</pre>

<div class="p"><!----></div>
Now we use that T does not contain <tt>4E</tt> elements of B
(again see&nbsp;[<a href="#Wil99" name="CITEWil99">Wil99</a>,Section&nbsp;9]).
Thus the last of the five candidates is the correct class fusion.

<div class="p"><!----></div>

<pre>
    gap&#62; ClassNames( b, "ATLAS" ){ [ 12, 17 ] };
    [ "4E", "4J" ]

</pre>

<div class="p"><!----></div>
We check that this map is stored on the library table.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( t, b ) = tfusb[5];
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.6">
7.6</a>&nbsp;&nbsp;L<sub>2</sub>(17).2 &#8594; B (March 2004)</h3>

<div class="p"><!----></div>
The sporadic simple group B contains a maximal subgroup U of the type
L<sub>2</sub>(17).2 whose class fusion is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; b:= CharacterTable( "B" );;
    gap&#62; u:= CharacterTable( "L2(17).2" );;
    gap&#62; ufusb:= PossibleClassFusions( u, b );
    [ [ 1, 5, 7, 15, 42, 42, 47, 47, 47, 91, 4, 30, 89, 89, 89, 89, 97, 97, 97 ], 
      [ 1, 5, 7, 15, 44, 44, 46, 46, 46, 91, 5, 29, 90, 90, 90, 90, 96, 96, 96 ], 
      [ 1, 5, 7, 15, 44, 44, 47, 47, 47, 91, 5, 29, 90, 90, 90, 90, 95, 95, 95 ] ]

</pre>

<div class="p"><!----></div>
According to&nbsp;[<a href="#Wil99" name="CITEWil99">Wil99</a>,Prop.&nbsp;11.1], U contains elements in the classes
<tt>8M</tt> and <tt>9A</tt> of B.
This determines the fusion map.

<div class="p"><!----></div>

<pre>
    gap&#62; names:= ClassNames( b, "ATLAS" );;
    gap&#62; pos:= List( [ "8M", "9A" ], x -&#62; Position( names, x ) );
    [ 44, 46 ]
    gap&#62; ufusb:= Filtered( ufusb, map -&#62; IsSubset( map, pos ) );
    [ [ 1, 5, 7, 15, 44, 44, 46, 46, 46, 91, 5, 29, 90, 90, 90, 90, 96, 96, 96 ] ]

</pre>

<div class="p"><!----></div>
We check that this map is stored on the library table.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( u, b ) = ufusb[1];
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.7">
7.7</a>&nbsp;&nbsp;L<sub>2</sub>(49).2<sub>3</sub> &#8594; B (June 2006)</h3>

<div class="p"><!----></div>
The sporadic simple group B contains a class of maximal subgroups
of the type L<sub>2</sub>(49).2<sub>3</sub> (a non-split extension of L<sub>2</sub>(49),
see&nbsp;[<a href="#Wilson93" name="CITEWilson93">Wil93b</a>,Theorem&nbsp;2]).
Let U be such a subgroup.
The class fusion of U in B is not determined by the character tables
of U and B.

<div class="p"><!----></div>

<pre>
    gap&#62; u:= CharacterTable( "L2(49).2_3" );;
    gap&#62; b:= CharacterTable( "B" );;
    gap&#62; ufusb:= PossibleClassFusions( u, b );;
    gap&#62; Length( RepresentativesFusions( u, ufusb, b ) );
    2
    gap&#62; ufusb;
    [ [ 1, 5, 7, 15, 19, 28, 31, 42, 42, 71, 125, 125, 128, 128, 128, 128, 128, 
          15, 71, 71, 89, 89, 89, 89 ], 
      [ 1, 5, 7, 15, 19, 28, 31, 42, 42, 71, 125, 125, 128, 128, 128, 128, 128, 
          17, 72, 72, 89, 89, 89, 89 ] ]

</pre>

<div class="p"><!----></div>
We show that the fusion is determined by the embeddings of the Sylow 7
normalizer N, say, of U into U
and into the Sylow 7 normalizer of B.
(Note that the fusion of the latter group into B has been determined
in Section&nbsp;<a href="#BN7">3.1</a>.)

<div class="p"><!----></div>
For that, we compute the character table of N from a representation of U.
Note that U is a non-split extension of the simple group L<sub>2</sub>(49) by
the product of a diagonal automorphism and a field automorphism.
In&nbsp;[<a href="#Wilson93" name="CITEWilson93">Wil93b</a>], the structure of N is described as
7<sup>2</sup>:(3 &times;Q<sub>16</sub>).

<div class="p"><!----></div>

<pre>
    gap&#62; g:= SL( 2, 49 );;
    gap&#62; gens:= GeneratorsOfGroup( g );;
    gap&#62; f:= GF(49);;
    gap&#62; mats:= List( gens, x -&#62; IdentityMat( 4, f ) );;
    gap&#62; for i in [ 1 .. Length( gens ) ] do
    &#62;      mats[i]{ [ 1, 2 ] }{ [ 1, 2 ] }:= gens[i];
    &#62;      mats[i]{ [ 3, 4 ] }{ [ 3, 4 ] }:= List( gens[i],
    &#62;                                              x -&#62; List( x, y -&#62; y^7 ) );
    &#62;    od;
    gap&#62; fieldaut:= PermutationMat( (1,3)(2,4), 4, f );;
    gap&#62; diagaut:= IdentityMat( 4, f );;
    gap&#62; diagaut[1][1]:= Z(49);;
    gap&#62; diagaut[3][3]:= Z(49)^7;;
    gap&#62; g:= Group( Concatenation( mats, [ fieldaut * diagaut ] ) );;
    gap&#62; v:= [ 1, 0, 0, 0 ] * Z(7)^0;;
    gap&#62; orb:= Orbit( g, v, OnLines );;
    gap&#62; act:= Action( g, orb, OnLines );;
    gap&#62; n:= Normalizer( act, SylowSubgroup( act, 7 ) );;
    gap&#62; ntbl:= CharacterTable( n );;

</pre>

<div class="p"><!----></div>
Now we compute the possible class fusions of N into B, via the Sylow 7
normalizer in B.

<div class="p"><!----></div>

<pre>
    gap&#62; bn7:= CharacterTable( "BN7" );;
    gap&#62; nfusbn7:= PossibleClassFusions( ntbl, bn7 );;
    gap&#62; Length( RepresentativesFusions( ntbl, nfusbn7, bn7 ) );
    3
    gap&#62; nfusb:= SetOfComposedClassFusions( PossibleClassFusions( bn7, b ),
    &#62;                                       nfusbn7 );;
    gap&#62; Length( RepresentativesFusions( ntbl, nfusb, b ) );
    5

</pre>

<div class="p"><!----></div>
Although there are several possibilities, this information is enough to
exclude one of the possible fusions of U into B.

<div class="p"><!----></div>

<pre>
    gap&#62; nfusu:= PossibleClassFusions( ntbl, u );;
    gap&#62; Length( nfusu );
    4
    gap&#62; filt:= Filtered( ufusb,
    &#62;              x -&#62; ForAny( nfusu, y -&#62; CompositionMaps( x, y ) in nfusb ) );
    [ [ 1, 5, 7, 15, 19, 28, 31, 42, 42, 71, 125, 125, 128, 128, 128, 128, 128, 
          17, 72, 72, 89, 89, 89, 89 ] ]
    gap&#62; ClassNames( b, "ATLAS" ){ filt[1] };
    [ "1A", "2D", "3B", "4H", "5B", "6I", "7A", "8K", "8K", "12Q", "24L", "24L", 
      "25A", "25A", "25A", "25A", "25A", "4J", "12R", "12R", "16G", "16G", "16G", 
      "16G" ]

</pre>

<div class="p"><!----></div>
So the class fusion of U into B can be described by the property that
the elements of order four inside and outside the simple subgroup L<sub>2</sub>(49)
are not conjugate in B.

<div class="p"><!----></div>
We check that the correct map is stored on the library table.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( u, b ) in filt;
    true

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
Let us confirm that the two groups of the types L<sub>2</sub>(49).2<sub>1</sub> and
L<sub>2</sub>(49).2<sub>2</sub> cannot occur as subgroups of B.
First we show that L<sub>2</sub>(49).2<sub>1</sub> is isomorphic with <span class="roman">PGL</span>(2,49),
an extension of L<sub>2</sub>(49) by a diagonal automorphism,
and L<sub>2</sub>(49).2<sub>2</sub> is an extension by a field automorphism.

<div class="p"><!----></div>

<pre>
    gap&#62; NrConjugacyClasses( u );  NrConjugacyClasses( act );
    24
    24
    gap&#62; u:= CharacterTable( "L2(49).2_1" );;
    gap&#62; g:= Group( Concatenation( mats, [ diagaut ] ) );;
    gap&#62; orb:= Orbit( g, v, OnLines );;
    gap&#62; act:= Action( g, orb, OnLines );;
    gap&#62; Size(act );
    117600
    gap&#62; NrConjugacyClasses( u );  NrConjugacyClasses( act );
    51
    51
    gap&#62; u:= CharacterTable( "L2(49).2_2" );;
    gap&#62; g:= Group( Concatenation( mats, [ fieldaut ] ) );;
    gap&#62; orb:= Orbit( g, v, OnLines );;
    gap&#62; act:= Action( g, orb, OnLines );;
    gap&#62; NrConjugacyClasses( u );  NrConjugacyClasses( act );
    27
    27

</pre>

<div class="p"><!----></div>
The group L<sub>2</sub>(49).2<sub>1</sub> can be excluded because no class fusion into B
is possible.

<div class="p"><!----></div>

<pre>
    gap&#62; PossibleClassFusions( CharacterTable( "L2(49).2_1" ), b );
    [  ]

</pre>

<div class="p"><!----></div>
For L<sub>2</sub>(49).2<sub>2</sub>, it is not that easy.
We would get several possible class fusions into B.
However, the Sylow 7 normalizer of L<sub>2</sub>(49).2<sub>2</sub> does not admit
a class fusion into the Sylow 7 normalizer of B.

<div class="p"><!----></div>

<pre>
    gap&#62; n:= Normalizer( act, SylowSubgroup( act, 7 ) );;
    gap&#62; Length( PossibleClassFusions( CharacterTable( n ), bn7 ) );
    0

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.8">
7.8</a>&nbsp;&nbsp;2<sup>3</sup>.L<sub>3</sub>(2) &#8594; G<sub>2</sub>(5) (January&nbsp;2004)</h3>

<div class="p"><!----></div>
The Chevalley group G = G<sub>2</sub>(5) contains a maximal subgroup U of the type
2<sup>3</sup>.L<sub>3</sub>(2) whose class fusion is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "G2(5)" );;
    gap&#62; s:= CharacterTable( "2^3.L3(2)" );;
    gap&#62; sfust:= PossibleClassFusions( s, t );;
    gap&#62; RepresentativesFusions( s, sfust, t );
    [ [ 1, 2, 2, 5, 6, 4, 13, 16, 17, 15, 15 ], 
      [ 1, 2, 2, 5, 6, 4, 14, 16, 17, 15, 15 ] ]
    gap&#62; OrdersClassRepresentatives( s );
    [ 1, 2, 2, 4, 4, 3, 6, 8, 8, 7, 7 ]

</pre>

<div class="p"><!----></div>
So the question is whether U contains elements in the class <tt>6B</tt> or <tt>6C</tt>
of G (position 13 or 14 in the  A<font size="-2">TLAS</font> table).
We use a permutation representation of G, restrict it to U,
and compute the centralizer in G of a suitable element of order 6 in U.

<div class="p"><!----></div>

<pre>
    gap&#62; g:= AtlasGroup( "G2(5)" );;
    gap&#62; u:= AtlasSubgroup( "G2(5)", 7 );;
    gap&#62; Size( u );
    1344
    gap&#62; repeat
    &#62;      x:= Random( u );
    &#62;    until Order( x ) = 6;
    gap&#62; siz:= Size( Centralizer( g, x ) );
    36
    gap&#62; Filtered( [ 1 .. NrConjugacyClasses( t ) ],
    &#62;              i -&#62; SizesCentralizers( t )[i] = siz );
    [ 14 ]

</pre>

<div class="p"><!----></div>
So U contains <tt>6C</tt> elements in G<sub>2</sub>(5).

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( s, t ) in Filtered( sfust, map -&#62; 14 in map );  
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.9">
7.9</a>&nbsp;&nbsp;5<sup>1+4</sup>.2<sup>1+4</sup>.A<sub>5</sub>.4 &#8594; B (April 2009)</h3>

<div class="p"><!----></div>
The sporadic simple group B contains a maximal subgroup M of the type
5<sup>1+4</sup>.2<sup>1+4</sup>.A<sub>5</sub>.4 whose class fusion is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; b:= CharacterTable( "B" );;
    gap&#62; m:= CharacterTable( "5^(1+4).2^(1+4).A5.4" );;
    gap&#62; mfusb:= PossibleClassFusions( m, b );;
    gap&#62; Length( mfusb );
    4
    gap&#62; repres:= RepresentativesFusions( m, mfusb, b );; 
    gap&#62; Length( repres );
    2

</pre>

<div class="p"><!----></div>
The restriction of the unique irreducible character of degree 4&nbsp;371
distinguishes the two possibilities,

<div class="p"><!----></div>

<pre>
    gap&#62; char:= Filtered( Irr( b ), x -&#62; x[1] = 4371 );;
    gap&#62; Length( char );
    1
    gap&#62; rest:= List( repres, map -&#62; char[1]{ map } );;
    gap&#62; scprs:= MatScalarProducts( m, Irr( m ), rest );;
    gap&#62; constit:= List( scprs,
    &#62;                x -&#62; Filtered( [1 .. Length(x) ], i -&#62; x[i] &lt;&#62; 0 ) );
    [ [ 2, 27, 60, 63, 73, 74, 75, 79, 82 ], 
      [ 2, 27, 60, 63, 70, 72, 75, 79, 84 ] ]
    gap&#62; List( constit, x -&#62; List( Irr( m ){ x }, Degree ) );
    [ [ 1, 6, 384, 480, 400, 400, 500, 1000, 1200 ], 
      [ 1, 6, 384, 480, 100, 300, 500, 1000, 1600 ] ]

</pre>

<div class="p"><!----></div>
The database&nbsp;[<a href="#AGR" name="CITEAGR">WWT<sup>+</sup></a>] contains the 3-modular reduction of the
irreducible representation of degree 4&nbsp;371
and also a straight line program for restricting this representation
to M.
We access these data via the <font face="helvetica">GAP</font> package <font face="helvetica">AtlasRep</font>
(see&nbsp;[<a href="#AtlasRep" name="CITEAtlasRep">WPN<sup>+</sup>11</a>]), and compute the composition factors of the
natural module of this restriction.

<div class="p"><!----></div>

<pre>
    gap&#62; g:= AtlasSubgroup( "B", Dimension, 4371, Ring, GF(3), 21 );;
    gap&#62; module:= GModuleByMats( GeneratorsOfGroup( g ), GF(3) );;
    gap&#62; dec:= MTX.CompositionFactors( module );;
    gap&#62; SortedList( List( dec, x -&#62; x.dimension ) );
    [ 1, 6, 100, 384, 400, 400, 400, 480, 1000, 1200 ]

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
We see that exactly one ordinary constituent does not stay irreducible
upon restriction to characteristic 3.
Thus the first of the two possible class fusions is the correct one.

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.10">
7.10</a>&nbsp;&nbsp;The fusion from the character table of 7<sup>2</sup>:2L<sub>2</sub>(7).2
into the table of marks (January&nbsp;2004)</h3>

<div class="p"><!----></div>
It can happen that the class fusion from the ordinary character table of a
group G into the table of marks of G is not unique up to table
automorphisms of the character table of G.

<div class="p"><!----></div>
As an example, consider G = 7<sup>2</sup>:2L<sub>2</sub>(7).2, a maximal subgroup in the
sporadic simple group He.

<div class="p"><!----></div>
G contains four classes of cyclic subgroups of order 7.
One contains the elements in the normal subgroup of type 7<sup>2</sup>,
and the other three are preimages of the order 7 elements in the
factor group L<sub>2</sub>(7).
The conjugacy classes of nonidentity elements in the latter three classes
split into two Galois conjugates each, which are permuted cyclicly by the
table automorphisms of the character table of G,
but on which the stabilizer of one class acts trivially.
This means that determining one of the three classes determines also the
other two.

<div class="p"><!----></div>

<pre>
    gap&#62; tbl:= CharacterTable( "7^2:2psl(2,7)" );
    CharacterTable( "7^2:2psl(2,7)" )
    gap&#62; tom:= TableOfMarks( tbl );
    TableOfMarks( "7^2:2L2(7)" )
    gap&#62; fus:= PossibleFusionsCharTableTom( tbl, tom );
    [ [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 8, 10, 9, 16, 7, 10, 9, 8, 16 ], 
      [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 9, 8, 10, 16, 7, 8, 10, 9, 16 ], 
      [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 10, 9, 8, 16, 7, 9, 8, 10, 16 ], 
      [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 8, 9, 10, 16, 7, 9, 10, 8, 16 ], 
      [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 10, 8, 9, 16, 7, 8, 9, 10, 16 ], 
      [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 9, 10, 8, 16, 7, 10, 8, 9, 16 ] ]
    gap&#62; reps:= RepresentativesFusions( tbl, fus, Group(()) );        
    [ [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 8, 9, 10, 16, 7, 9, 10, 8, 16 ], 
      [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 8, 10, 9, 16, 7, 10, 9, 8, 16 ] ]
    gap&#62; AutomorphismsOfTable( tbl );
    Group([ (9,14)(10,17)(11,15)(12,16)(13,18), (7,8), (10,11,12)(15,16,17) ])
    gap&#62; OrdersClassRepresentatives( tbl );
    [ 1, 7, 2, 4, 3, 6, 8, 8, 7, 7, 7, 7, 14, 7, 7, 7, 7, 14 ]
    gap&#62; perms1:= PermCharsTom( reps[1], tom );;
    gap&#62; perms2:= PermCharsTom( reps[2], tom );;
    gap&#62; perms1 = perms2;      
    false
    gap&#62; Set( perms1 ) = Set( perms2 );
    true

</pre>

<div class="p"><!----></div>
The table of marks of G does not distinguish the three classes
of cyclic subgroups,
there are permutations of rows and columns that act as an S<sub>3</sub> on them.

<div class="p"><!----></div>
Note that an S<sub>3</sub> acts on the classes in question in the <b>rational</b>
character table.
So it is due to the irrationalities in the character table that it
contains more information.

<div class="p"><!----></div>

<pre>
    gap&#62; Display( tbl );
    7^2:2psl(2,7)
    
          2  4  .  4  3  1  1  3  3   1   .   .   .   1   1   .   .   .   1
          3  1  .  1  .  1  1  .  .   .   .   .   .   .   .   .   .   .   .
          7  3  3  1  .  .  .  .  .   2   2   2   2   1   2   2   2   2   1
    
            1a 7a 2a 4a 3a 6a 8a 8b  7b  7c  7d  7e 14a  7f  7g  7h  7i 14b
         2P 1a 7a 1a 2a 3a 3a 4a 4a  7b  7c  7d  7e  7b  7f  7g  7h  7i  7f
         3P 1a 7a 2a 4a 1a 2a 8b 8a  7f  7i  7g  7h 14b  7b  7d  7e  7c 14a
         5P 1a 7a 2a 4a 3a 6a 8b 8a  7f  7i  7g  7h 14b  7b  7d  7e  7c 14a
         7P 1a 1a 2a 4a 3a 6a 8a 8b  1a  1a  1a  1a  2a  1a  1a  1a  1a  2a
        11P 1a 7a 2a 4a 3a 6a 8b 8a  7b  7c  7d  7e 14a  7f  7g  7h  7i 14b
        13P 1a 7a 2a 4a 3a 6a 8b 8a  7f  7i  7g  7h 14b  7b  7d  7e  7c 14a
    
    X.1      1  1  1  1  1  1  1  1   1   1   1   1   1   1   1   1   1   1
    X.2      3  3  3 -1  .  .  1  1   B   B   B   B   B  /B  /B  /B  /B  /B
    X.3      3  3  3 -1  .  .  1  1  /B  /B  /B  /B  /B   B   B   B   B   B
    X.4      6  6  6  2  .  .  .  .  -1  -1  -1  -1  -1  -1  -1  -1  -1  -1
    X.5      7  7  7 -1  1  1 -1 -1   .   .   .   .   .   .   .   .   .   .
    X.6      8  8  8  . -1 -1  .  .   1   1   1   1   1   1   1   1   1   1
    X.7      4  4 -4  .  1 -1  .  .  -B  -B  -B  -B   B -/B -/B -/B -/B  /B
    X.8      4  4 -4  .  1 -1  .  . -/B -/B -/B -/B  /B  -B  -B  -B  -B   B
    X.9      6  6 -6  .  .  .  A -A  -1  -1  -1  -1   1  -1  -1  -1  -1   1
    X.10     6  6 -6  .  .  . -A  A  -1  -1  -1  -1   1  -1  -1  -1  -1   1
    X.11     8  8 -8  . -1  1  .  .   1   1   1   1  -1   1   1   1   1  -1
    X.12    48 -1  .  .  .  .  .  .   6  -1  -1  -1   .   6  -1  -1  -1   .
    X.13    48 -1  .  .  .  .  .  .   C  -1  /C  /D   .  /C   C   D  -1   .
    X.14    48 -1  .  .  .  .  .  .   C  /C  /D  -1   .  /C   D  -1   C   .
    X.15    48 -1  .  .  .  .  .  .  /C   D  -1   C   .   C  -1  /C  /D   .
    X.16    48 -1  .  .  .  .  .  .   C  /D  -1  /C   .  /C  -1   C   D   .
    X.17    48 -1  .  .  .  .  .  .  /C   C   D  -1   .   C  /D  -1  /C   .
    X.18    48 -1  .  .  .  .  .  .  /C  -1   C   D   .   C  /C  /D  -1   .
    
    A = E(8)-E(8)^3
      = Sqrt(2) = r2
    B = E(7)+E(7)^2+E(7)^4
      = (-1+Sqrt(-7))/2 = b7
    C = 2*E(7)+2*E(7)^2+2*E(7)^4
      = -1+Sqrt(-7) = 2b7
    D = -3*E(7)-3*E(7)^2-2*E(7)^3-3*E(7)^4-2*E(7)^5-2*E(7)^6
      = (5-Sqrt(-7))/2 = 2-b7
    gap&#62; mat:= MatTom( tom );;
    gap&#62; mataut:= MatrixAutomorphisms( mat );;
    gap&#62; Print( mataut, "\n" );
    Group( [ (11,12)(23,24)(27,28)(46,47)(53,54)(56,57), 
      ( 9,10)(20,21)(31,32)(38,39), ( 8, 9)(20,22)(31,33)(38,40) ] )
    gap&#62; RepresentativesFusions( Group( () ), reps, mataut );
    [ [ 1, 6, 2, 4, 3, 5, 13, 13, 7, 8, 9, 10, 16, 7, 9, 10, 8, 16 ] ]

</pre>

<div class="p"><!----></div>
We could say that thus the fusion is unique up to table automorphisms
and automorphisms of the table of marks.
But since a group is associated with the table of marks,
we compute the character table from the group,
and decide which class fusion is correct.

<div class="p"><!----></div>

<pre>
    gap&#62; g:= UnderlyingGroup( tom );;
    gap&#62; tg:= CharacterTable( g );;
    gap&#62; tgfustom:= FusionCharTableTom( tg, tom );;
    gap&#62; trans:= TransformingPermutationsCharacterTables( tg, tbl );;
    gap&#62; tblfustom:= Permuted( tgfustom, trans.columns );;
    gap&#62; orbits:= List( reps, map -&#62; OrbitFusions( AutomorphismsOfTable( tbl ),
    &#62;                                              map, Group( () ) ) );;
    gap&#62; PositionProperty( orbits, orb -&#62; tblfustom in orb );
    2
    gap&#62; PositionProperty( orbits, orb -&#62; FusionToTom( tbl ).map in orb );
    2

</pre>

<div class="p"><!----></div>
So we see that the second one of the possibilities above is the right one.

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.11">
7.11</a>&nbsp;&nbsp;3 &times;U<sub>4</sub>(2) &#8594; 3<sub>1</sub>.U<sub>4</sub>(3) (March 2010)</h3>

<div class="p"><!----></div>
According to the  A<font size="-2">TLAS</font> (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;52]),
the simple group U<sub>4</sub>(3) contains two classes of maximal subgroups
of the type U<sub>4</sub>(2).
The class fusion of U<sub>4</sub>(2) into U<sub>4</sub>(3) is unique up to table
automorphisms.

<div class="p"><!----></div>

<pre>
    gap&#62; u42:= CharacterTable( "U4(2)" );;
    gap&#62; u43:= CharacterTable( "U4(3)" );;
    gap&#62; u42fusu43:= PossibleClassFusions( u42, u43 );;
    gap&#62; Length( u42fusu43 );
    4
    gap&#62; Length( RepresentativesFusions( u42, u42fusu43, u43 ) );
    1

</pre>

<div class="p"><!----></div>
More precisely, take the outer automorphism group of U<sub>4</sub>(3),
which is a dihedral group of order eight,
and consider the subgroup generated by its central involution
(this automorphism is denoted by 2<sub>1</sub> in the  A<font size="-2">TLAS</font>)
and another involution called 2<sub>3</sub> in the  A<font size="-2">TLAS</font>.
This subgroup is a Klein four group that induces a permutation group
on the classes of U<sub>4</sub>(3) and thus acts on the four possible class
fusions of U<sub>4</sub>(2) into U<sub>4</sub>(3).
In fact, this action is transitive.

<div class="p"><!----></div>
The automorphism 2<sub>1</sub> swaps each pair of mutually inverse classes
of order nine,
that is, <tt>9A</tt> is swapped with <tt>9B</tt> and <tt>9C</tt> is swapped with <tt>9D</tt>.
All U<sub>4</sub>(2) type subgroups of U<sub>4</sub>(3) are invariant under this
automorphism, they extend to subgroups of the type U<sub>4</sub>(2).2 in
U<sub>4</sub>(3).2<sub>1</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; u43_21:= CharacterTable( "U4(3).2_1" );;
    gap&#62; fus1:= GetFusionMap( u43, u43_21 );
    [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16, 17, 17, 18 ]
    gap&#62; act1:= Filtered( InverseMap( fus1 ), IsList );
    [ [ 16, 17 ], [ 18, 19 ] ]
    gap&#62; CompositionMaps( ClassNames( u43, "Atlas" ), act1 );
    [ [ "9A", "9B" ], [ "9C", "9D" ] ]

</pre>

<div class="p"><!----></div>
The automorphism 2<sub>3</sub> swaps <tt>6B</tt> with <tt>6C</tt>, <tt>9A</tt> with <tt>9C</tt>,
and <tt>9B</tt> with <tt>9D</tt>.
The two classes of U<sub>4</sub>(2) type subgroups of U<sub>4</sub>(3) are swapped
by this automorphism.

<div class="p"><!----></div>

<pre>
    gap&#62; u43_23:= CharacterTable( "U4(3).2_3" );;
    gap&#62; fus3:= GetFusionMap( u43, u43_23 );
    [ 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 10, 11, 11, 12, 13, 14, 13, 14, 15 ]
    gap&#62; act3:= Filtered( InverseMap( fus3 ), IsList );
    [ [ 4, 5 ], [ 11, 12 ], [ 13, 14 ], [ 16, 18 ], [ 17, 19 ] ]
    gap&#62; CompositionMaps( ClassNames( u43, "Atlas" ), act3 );
    [ [ "3B", "3C" ], [ "6B", "6C" ], [ "7A", "7B" ], [ "9A", "9C" ], 
      [ "9B", "9D" ] ]

</pre>

<div class="p"><!----></div>
The  A<font size="-2">TLAS</font> states that the permutation character induced by the
first class of U<sub>4</sub>(2) type subgroups is <tt>1a+35a+90a</tt>,
which means that the subgroups in this class contain <tt>9A</tt> and <tt>9B</tt> elements.
Then the permutation character induced by the second class
of U<sub>4</sub>(2) type subgroups is <tt>1a+35b+90a</tt>,
and the subgroups in this class contain <tt>9C</tt> and <tt>9D</tt> elements.

<div class="p"><!----></div>
So we choose appropriate fusions for the two classes of maximal
U<sub>4</sub>(2) type subgroups.

<div class="p"><!----></div>

<pre>
    gap&#62; firstfus:= First( u42fusu43, x -&#62; IsSubset( x, [ 16, 17 ] ) );
    [ 1, 2, 2, 3, 3, 5, 4, 7, 8, 9, 10, 10, 12, 12, 11, 12, 16, 17, 20, 20 ]
    gap&#62; secondfus:= First( u42fusu43, x -&#62; IsSubset( x, [ 18, 19 ] ) );
    [ 1, 2, 2, 3, 3, 4, 5, 7, 8, 9, 10, 10, 11, 11, 12, 11, 18, 19, 20, 20 ]

</pre>

<div class="p"><!----></div>
Let us now consider the central extension 3<sub>1</sub>.U<sub>4</sub>(3).
Since the Schur multiplier of U<sub>4</sub>(2) has order two,
the U<sub>4</sub>(2) type subgroups of U<sub>4</sub>(3) lift to groups of the structure
3 &times;U<sub>4</sub>(2) in 3<sub>1</sub>.U<sub>4</sub>(3).
There are eight possible class fusions from 3 &times;U<sub>4</sub>(2) to 3<sub>1</sub>.U<sub>4</sub>(3),
in two orbits of length four under the action of table automorphisms.

<div class="p"><!----></div>

<pre>
    gap&#62; 3u42:= CharacterTable( "Cyclic", 3 ) * u42;
    CharacterTable( "C3xU4(2)" )
    gap&#62; 3u43:= CharacterTable( "3_1.U4(3)" );
    CharacterTable( "3_1.U4(3)" )
    gap&#62; 3u42fus3u43:= PossibleClassFusions( 3u42, 3u43 );;
    gap&#62; Length( 3u42fus3u43 );
    8
    gap&#62; Length( RepresentativesFusions( 3u42, 3u42fus3u43, 3u43 ) );
    2

</pre>

<div class="p"><!----></div>
More precisely, each of the four fusions from U<sub>4</sub>(2) to U<sub>4</sub>(3) has
exactly two lifts.
The four lifts of those fusions from U<sub>4</sub>(2) to U<sub>4</sub>(3) with
<tt>9A</tt> and <tt>9B</tt> in their image form one orbit under the action of
table automorphisms.
The other orbit consists of the lifts of those fusions with
<tt>9C</tt> and <tt>9D</tt> in their image.

<div class="p"><!----></div>

<pre>
    gap&#62; inducedmaps:= List( 3u42fus3u43, map -&#62; CompositionMaps(
    &#62;        GetFusionMap( 3u43, u43 ), CompositionMaps( map,
    &#62;        InverseMap( GetFusionMap( 3u42, u42 ) ) ) ) );;
    gap&#62; List( inducedmaps, map -&#62; Position( u42fusu43, map ) );
    [ 1, 1, 2, 2, 4, 4, 3, 3 ]

</pre>

<div class="p"><!----></div>
This solves the ambiguity:
Fusions from each of the two orbits occur,
and we can assign them to the two classes of subgroups
by the choice of the fusions from U<sub>4</sub>(2) to U<sub>4</sub>(3).

<div class="p"><!----></div>
The reason for the asymmetry is that the automorphism 2<sub>3</sub> of U<sub>4</sub>(3)
does not lift to 3<sub>1</sub>.U<sub>4</sub>(3).
Note that each of the classes <tt>9A</tt>, <tt>9B</tt> of U<sub>4</sub>(3) has three preimages
in 3<sub>1</sub>.U<sub>4</sub>(3),
whereas each of the classes <tt>9C</tt>, <tt>9D</tt> has only one preimage.

<div class="p"><!----></div>
In fact the two classes of 3 &times;U<sub>4</sub>(2) type subgroups of 3<sub>1</sub>.U<sub>4</sub>(3)
behave differently.
For example,
inducing the irreducible characters of a 3 &times;U<sub>4</sub>(2) type subgroup
in the first class of maximal subgroups of 3<sub>1</sub>.U<sub>4</sub>(3)
yields no irreducible character, whereas the two irreducible characters
of degree 630 are obtained by inducing the irreducible characters
of a subgroup in the second class.

<div class="p"><!----></div>

<pre>
    gap&#62; rep:= RepresentativesFusions( 3u42, 3u42fus3u43, 3u43 );
    [ [ 1, 4, 4, 7, 7, 10, 13, 15, 18, 21, 24, 24, 27, 27, 30, 27, 48, 49, 50, 
          50, 2, 5, 5, 8, 8, 11, 13, 16, 19, 22, 25, 25, 28, 28, 31, 28, 48, 49, 
          51, 51, 3, 6, 6, 9, 9, 12, 13, 17, 20, 23, 26, 26, 29, 29, 32, 29, 48, 
          49, 52, 52 ], 
      [ 1, 4, 4, 8, 9, 13, 10, 15, 18, 21, 25, 26, 31, 32, 27, 30, 46, 44, 51, 
          52, 2, 5, 5, 9, 7, 13, 11, 16, 19, 22, 26, 24, 32, 30, 28, 31, 47, 42, 
          52, 50, 3, 6, 6, 7, 8, 13, 12, 17, 20, 23, 24, 25, 30, 31, 29, 32, 45, 
          43, 50, 51 ] ]
    gap&#62; irr:= Irr( 3u42 );;
    gap&#62; ind:= InducedClassFunctionsByFusionMap( 3u42, 3u43, irr, rep[1] );;
    gap&#62; Intersection( ind, Irr( 3u43 ) );
    [ Character( CharacterTable( "3_1.U4(3)" ), [ 630, 630*E(3)^2, 630*E(3), 6, 
          6*E(3)^2, 6*E(3), 9, 9*E(3)^2, 9*E(3), -9, -9*E(3)^2, -9*E(3), 0, 0, 2, 
          2*E(3)^2, 2*E(3), -2, -2*E(3)^2, -2*E(3), 0, 0, 0, -3, -3*E(3)^2, 
          -3*E(3), 3, 3*E(3)^2, 3*E(3), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
          0, 0, 0, 0, 0, 0, -1, -E(3)^2, -E(3) ] ), 
      Character( CharacterTable( "3_1.U4(3)" ), [ 630, 630*E(3), 630*E(3)^2, 6, 
          6*E(3), 6*E(3)^2, 9, 9*E(3), 9*E(3)^2, -9, -9*E(3), -9*E(3)^2, 0, 0, 2, 
          2*E(3), 2*E(3)^2, -2, -2*E(3), -2*E(3)^2, 0, 0, 0, -3, -3*E(3), 
          -3*E(3)^2, 3, 3*E(3), 3*E(3)^2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
          0, 0, 0, 0, 0, 0, 0, -1, -E(3), -E(3)^2 ] ) ]
    gap&#62; ind:= InducedClassFunctionsByFusionMap( 3u42, 3u43, irr, rep[2] );;
    gap&#62; Intersection( ind, Irr( 3u43 ) );
    [  ]

</pre>

<div class="p"><!----></div>
For 6<sub>1</sub>.U<sub>4</sub>(3) and 12<sub>1</sub>.U<sub>4</sub>(3), one gets the same phenomenon:
We have two orbits of class fusions,
one corresponding to each of the two classes of subgroups
of the type 3 &times;4 Y 2.U<sub>4</sub>(2).
We get 10 irreducible induced characters from
a subgroup in the second class (four faithful ones,
four with kernel of order two, and the two abovementioned
degree 630 characters with kernel of order four)
and no irreducible character from a subgroup in the first class.

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.12">
7.12</a>&nbsp;&nbsp;2.3<sup>4</sup>.2<sup>3</sup>.S<sub>4</sub> &#8594; 2.A12 (September 2011)</h3>

<div class="p"><!----></div>
The double cover G of the alternating group A<sub>12</sub> contains a maximal
subgroup M of the type 2.3<sup>4</sup>.2<sup>3</sup>.S<sub>4</sub> whose class fusion is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; 2a12:= CharacterTable( "2.A12" );;
    gap&#62; mtbl:= CharacterTable( "2.3^4.2^3.S4" );;
    gap&#62; mtblfus2a12:= PossibleClassFusions( mtbl, 2a12 );;
    gap&#62; Length( mtblfus2a12 );
    32
    gap&#62; repres:= RepresentativesFusions( mtbl, mtblfus2a12, 2a12 );; 
    gap&#62; Length( repres );
    2

</pre>

<div class="p"><!----></div>
We decide the question which of the essentially different two
possible class fusion is the right one,
by explicitly constructing M as a subgroup of G.

<div class="p"><!----></div>
For that, let &#960; denote the natural epimorphism from G to A<sub>12</sub>,
and note that &#960;(M) can be described as the intersection of a
S<sub>3</sub> &#8472;S<sub>4</sub> type subgroup of S<sub>12</sub> with A<sub>12</sub>.
Further note that the generators for G and A<sub>12</sub> provided by&nbsp;[<a href="#AGR" name="CITEAGR">WWT<sup>+</sup></a>]
are compatible in the sense that &#960; can be defined by mapping the
generators of G to those of A<sub>12</sub>.

<div class="p"><!----></div>
We need &#960; only for computing one preimage of each given element.
Therefore, we represent &#960; implicitly by two epimorphisms from a
free group to G and A<sub>12</sub>, respectively,
in order to avoid that <font face="helvetica">GAP</font>precomputes a lot of unnecessary information
for G.
This way,
computing a preimage of an element of A<sub>12</sub> under &#960; is cheap.
However, computing the preimage of a subgroup of A<sub>12</sub> would be very
expensive.
So we construct the subgroup of G that is generated by preimages of
a set of generators of &#960;(M); later we see that this subgroup is in fact
equal to M.

<div class="p"><!----></div>

<pre>
    gap&#62; g:= AtlasGroup( "A12" );
    Group([ (1,2,3), (2,3,4,5,6,7,8,9,10,11,12) ])
    gap&#62; 2g:= AtlasGroup( "2.A12" );
    &lt;matrix group of size 479001600 with 2 generators&#62;
    gap&#62; f:= FreeGroup( 2 );;
    gap&#62; pi1:= GroupHomomorphismByImagesNC( f, 2g, GeneratorsOfGroup( f ),
    &#62;              GeneratorsOfGroup( 2g ) );;
    gap&#62; pi2:= GroupHomomorphismByImagesNC( f, g, GeneratorsOfGroup( f ),
    &#62;              GeneratorsOfGroup( g ) );;
    gap&#62; w:= WreathProduct( SymmetricGroup( 3 ), SymmetricGroup(4) );
    &lt;permutation group of size 31104 with 10 generators&#62;
    gap&#62; NrMovedPoints( w );
    12
    gap&#62; s:= Intersection( w, g );  Size( s );
    &lt;permutation group with 8 generators&#62;
    15552
    gap&#62; m:= SubgroupNC( 2g, List( SmallGeneratingSet( s ),
    &#62;            x -&#62; ImagesRepresentative( pi1,
    &#62;                   PreImagesRepresentative( pi2, x ) ) ) );;

</pre>

<div class="p"><!----></div>
Now we compute the character table of M,
using a faithful permutation representation of M.

<div class="p"><!----></div>

<pre>
    gap&#62; iso:= IsomorphismPermGroup( m );;
    gap&#62; t:= CharacterTable( Image( iso ) );;
    gap&#62; Size( t );
    31104
    gap&#62; trans:= TransformingPermutationsCharacterTables( mtbl, t );;
    gap&#62; IsRecord( trans );
    true

</pre>

<div class="p"><!----></div>
Now let us see where the two fusion candidates differ.

<div class="p"><!----></div>

<pre>
    gap&#62; para:= Parametrized( repres );
    [ 1, 2, 6, 10, 8, 12, 7, 11, 9, 13, 5, 5, 17, 17, 17, 17, 3, 4, 24, 22, 27, 
      25, 12, 10, 13, 11, 28, 29, 35, 37, 39, 36, 38, 40, 5, 23, 28, 29, 26, 14, 
      14, 16, 16, 33, 34, [ 33, 34 ], [ 33, 34 ], 49, 49, 48, 48 ]
    gap&#62; PositionsProperty( para, IsList );
    [ 46, 47 ]
    gap&#62; List( repres, map -&#62; map{ [ 44 .. 47 ] } );
    [ [ 33, 34, 33, 34 ], [ 33, 34, 34, 33 ] ]

</pre>

<div class="p"><!----></div>
So the question is whether the elements in class 44 are conjugate in G
to the elements in class 46 or in class 47.
In order to answer this question, we compute preimages of the relevant
class representatives in the matrix group M.

<div class="p"><!----></div>

<pre>
    gap&#62; positions:= OnTuples( [ 44 .. 47 ], trans.columns );;
    gap&#62; classreps:= List( ConjugacyClasses( t ){ positions },
    &#62;        c -&#62; PreImagesRepresentative( iso, Representative( c ) ) );;
    gap&#62; List( classreps, TraceMat );
    [ Z(3)^0, Z(3), Z(3), Z(3)^0 ]

</pre>

<div class="p"><!----></div>
We are lucky, already the traces of the elements allow us to decide which
pairs of elements are G-conjugate; there is no need for an explicit
(and expensive) conjugacy test in the matrix group G.

<div class="p"><!----></div>
Finally, we check whether the stored fusion is correct.

<div class="p"><!----></div>

<pre>
    gap&#62; good:= First( repres,
    &#62;                  map -&#62; map{ [ 44 .. 47 ] } = [ 33, 34, 34, 33 ] );;
    gap&#62; GetFusionMap( mtbl, 2a12 ) = good;
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.13">
7.13</a>&nbsp;&nbsp;127:7 &#8594; L<sub>7</sub>(2) (January 2012)</h3>

<div class="p"><!----></div>
The simple group G = L<sub>7</sub>(2) contains a maximal subgroup M of the type
127:7 (the normalizer of an extension field type subgroup GL(1,2<sup>7</sup>))
whose class fusion is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "L7(2)" );;
    gap&#62; s:= CharacterTable( "127:7" );;
    gap&#62; fus:= PossibleClassFusions( s, t );;
    gap&#62; repr:= RepresentativesFusions( s, fus, t );
    [ [ 1, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 
          114, 115, 117, 116, 76, 76, 77, 76, 77, 77 ], 
      [ 1, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 
          114, 115, 117, 116, 83, 83, 83, 83, 83, 83 ] ]

</pre>

<div class="p"><!----></div>
The two fusion candidates differ only for elements of order 7.

<div class="p"><!----></div>

<pre>
    gap&#62; diff:= Filtered( [ 1 .. Length( repr[1] ) ],
    &#62;                     i -&#62; repr[1][i] &lt;&#62; repr[2][i] );
    [ 20, 21, 22, 23, 24, 25 ]
    gap&#62; OrdersClassRepresentatives( s ){ diff };
    [ 7, 7, 7, 7, 7, 7 ]
    gap&#62; List( repr, l -&#62; l{ diff } );
    [ [ 76, 76, 77, 76, 77, 77 ], [ 83, 83, 83, 83, 83, 83 ] ]
    gap&#62; SizesCentralizers( t ){ [ 76, 77, 83 ] };
    [ 3528, 3528, 49 ]

</pre>

<div class="p"><!----></div>
We can decide which candidate is the correct one if we know the centralizer
order in G of the elements of order 7 in M.
So we compute this centralizer order.

<div class="p"><!----></div>

<pre>
    gap&#62; g:= Image( IsomorphismPermGroup( GL(7,2) ) );;
    gap&#62; repeat x:= Random( g ); until Order(x) = 127;
    gap&#62; n:= Normalizer( g, SubgroupNC( g, [ x ] ) );;
    gap&#62; Size( n ) / 127;
    7
    gap&#62; repeat x:= Random( n ); until Order( x ) = 7;
    gap&#62; c:= Centralizer( g, x );;
    gap&#62; Size( c );
    49

</pre>

<div class="p"><!----></div>
We see that the second candidate is the fusion from M into G.

<div class="p"><!----></div>

<pre>
    gap&#62; GetFusionMap( s, t ) = repr[2];
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.14">
7.14</a>&nbsp;&nbsp;L<sub>2</sub>(59) &#8594; M (May 2009)</h3>

<div class="p"><!----></div>
The sporadic simple Monster group M contains a maximal subgroup G
of the type L<sub>2</sub>(59), see&nbsp;[<a href="#HW04" name="CITEHW04">HW04</a>].
The class fusion of G into M is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "M" );;
    gap&#62; s:= CharacterTable( "L2(59)" );;
    gap&#62; fus:= PossibleClassFusions( s, t );;
    gap&#62; repr:= RepresentativesFusions( s, fus, t );
    [ [ 1, 152, 153, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 98, 
          52, 32, 52, 14, 12, 98, 52, 32, 5, 98, 12, 98, 52, 3 ], 
      [ 1, 152, 153, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 100, 
          50, 30, 50, 15, 11, 100, 50, 30, 4, 100, 11, 100, 50, 3 ], 
      [ 1, 152, 153, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 101, 
          51, 30, 51, 14, 11, 101, 51, 30, 5, 101, 11, 101, 51, 3 ], 
      [ 1, 152, 153, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 102, 
          53, 32, 53, 18, 12, 102, 53, 32, 6, 102, 12, 102, 53, 3 ], 
      [ 1, 152, 153, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 104, 
          52, 33, 52, 17, 12, 104, 52, 33, 5, 104, 12, 104, 52, 3 ] ]

</pre>

<div class="p"><!----></div>
The candidates differ on the classes of element order 30.

<div class="p"><!----></div>

<pre>
    gap&#62; ord:= OrdersClassRepresentatives( s );;
    gap&#62; ord30:= Filtered( [ 1 .. Length( ord ) ], i -&#62; ord[i] = 30 );
    [ 18, 24, 28, 30 ]
    gap&#62; List( repr, x -&#62; x{ ord30 } );
    [ [ 98, 98, 98, 98 ], [ 100, 100, 100, 100 ], [ 101, 101, 101, 101 ], 
      [ 102, 102, 102, 102 ], [ 104, 104, 104, 104 ] ]

</pre>

<div class="p"><!----></div>
According to&nbsp;[<a href="#HW04" name="CITEHW04">HW04</a>],
G contains elements in the class <tt>30G</tt> of M.
This determines the class fusion up to Galois automorphisms.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= Position( ClassNames( t, "Atlas" ), "30G" );;
    gap&#62; good:= Filtered( fus, map -&#62; pos in map );
    [ [ 1, 152, 153, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 104, 
          52, 33, 52, 17, 12, 104, 52, 33, 5, 104, 12, 104, 52, 3 ], 
      [ 1, 153, 152, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 104, 
          52, 33, 52, 17, 12, 104, 52, 33, 5, 104, 12, 104, 52, 3 ] ]
    gap&#62; repr:= RepresentativesFusions( s, good, t );
    [ [ 1, 152, 153, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 104, 
          52, 33, 52, 17, 12, 104, 52, 33, 5, 104, 12, 104, 52, 3 ] ]
    gap&#62; GetFusionMap( s, t ) = repr[1];
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.15">
7.15</a>&nbsp;&nbsp;L<sub>2</sub>(71) &#8594; M (May 2009)</h3>

<div class="p"><!----></div>
The sporadic simple Monster group M contains a maximal subgroup G
of the type L<sub>2</sub>(71), see&nbsp;[<a href="#HW08" name="CITEHW08">HW08</a>].
The class fusion of G into M is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "M" );;
    gap&#62; s:= CharacterTable( "L2(71)" );;
    gap&#62; fus:= PossibleClassFusions( s, t );;
    gap&#62; repr:= RepresentativesFusions( s, fus, t );
    [ [ 1, 169, 170, 112, 112, 112, 112, 19, 112, 11, 112, 112, 19, 112, 112, 
          112, 11, 19, 112, 112, 114, 60, 36, 27, 114, 17, 114, 27, 7, 60, 114, 
          5, 114, 60, 36, 27, 114, 3 ], 
      [ 1, 169, 170, 112, 112, 112, 112, 19, 112, 11, 112, 112, 19, 112, 112, 
          112, 11, 19, 112, 112, 115, 61, 36, 28, 115, 17, 115, 28, 7, 61, 115, 
          5, 115, 61, 36, 28, 115, 3 ], 
      [ 1, 169, 170, 112, 112, 112, 112, 19, 112, 11, 112, 112, 19, 112, 112, 
          112, 11, 19, 112, 112, 117, 61, 43, 28, 117, 17, 117, 28, 9, 61, 117, 
          5, 117, 61, 43, 28, 117, 3 ], 
      [ 1, 169, 170, 113, 113, 113, 113, 20, 113, 12, 113, 113, 20, 113, 113, 
          113, 12, 20, 113, 113, 114, 60, 36, 27, 114, 17, 114, 27, 7, 60, 114, 
          5, 114, 60, 36, 27, 114, 3 ], 
      [ 1, 169, 170, 113, 113, 113, 113, 20, 113, 12, 113, 113, 20, 113, 113, 
          113, 12, 20, 113, 113, 115, 61, 36, 28, 115, 17, 115, 28, 7, 61, 115, 
          5, 115, 61, 36, 28, 115, 3 ], 
      [ 1, 169, 170, 113, 113, 113, 113, 20, 113, 12, 113, 113, 20, 113, 113, 
          113, 12, 20, 113, 113, 117, 61, 43, 28, 117, 17, 117, 28, 9, 61, 117, 
          5, 117, 61, 43, 28, 117, 3 ] ]

</pre>

<div class="p"><!----></div>
The candidates differ on the classes of the element orders 7 and 36.

<div class="p"><!----></div>

<pre>
    gap&#62; ord:= OrdersClassRepresentatives( s );;
    gap&#62; ord36:= Filtered( [ 1 .. Length( ord ) ], i -&#62; ord[i] = 36 );
    [ 21, 25, 27, 31, 33, 37 ]
    gap&#62; List( repr, x -&#62; x{ ord36 } );
    [ [ 114, 114, 114, 114, 114, 114 ], [ 115, 115, 115, 115, 115, 115 ], 
      [ 117, 117, 117, 117, 117, 117 ], [ 114, 114, 114, 114, 114, 114 ], 
      [ 115, 115, 115, 115, 115, 115 ], [ 117, 117, 117, 117, 117, 117 ] ]

</pre>

<div class="p"><!----></div>
According to&nbsp;[<a href="#NW02" name="CITENW02">NW02</a>,Table&nbsp;3],
G contains elements in the classes <tt>7B</tt> and <tt>36D</tt> of M.
This determines the class fusion up to Galois automorphisms.

<div class="p"><!----></div>

<pre>
    gap&#62; pos1:= Position( ClassNames( t, "Atlas" ), "7B" );;
    gap&#62; pos2:= Position( ClassNames( t, "Atlas" ), "36D" );;
    gap&#62; pos:= [ pos1, pos2 ];;
    gap&#62; good:= Filtered( fus, map -&#62; IsSubset( map, pos ) );
    [ [ 1, 169, 170, 113, 113, 113, 113, 20, 113, 12, 113, 113, 20, 113, 113, 
          113, 12, 20, 113, 113, 117, 61, 43, 28, 117, 17, 117, 28, 9, 61, 117, 
          5, 117, 61, 43, 28, 117, 3 ], 
      [ 1, 170, 169, 113, 113, 113, 113, 20, 113, 12, 113, 113, 20, 113, 113, 
          113, 12, 20, 113, 113, 117, 61, 43, 28, 117, 17, 117, 28, 9, 61, 117, 
          5, 117, 61, 43, 28, 117, 3 ] ]
    gap&#62; repr:= RepresentativesFusions( s, good, t );
    [ [ 1, 169, 170, 113, 113, 113, 113, 20, 113, 12, 113, 113, 20, 113, 113, 
          113, 12, 20, 113, 113, 117, 61, 43, 28, 117, 17, 117, 28, 9, 61, 117, 
          5, 117, 61, 43, 28, 117, 3 ] ]
    gap&#62; GetFusionMap( s, t ) = repr[1];
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.16">
7.16</a>&nbsp;&nbsp;L<sub>2</sub>(41) &#8594; M (April 2012)</h3>

<div class="p"><!----></div>
The sporadic simple Monster group M contains a maximal subgroup G
of the type L<sub>2</sub>(41), see&nbsp;[<a href="#NW12" name="CITENW12">NW</a>].
The class fusion of G into M is ambiguous.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "M" );;
    gap&#62; s:= CharacterTable( "L2(41)" );;
    gap&#62; fus:= PossibleClassFusions( s, t );;
    gap&#62; repr:= RepresentativesFusions( s, fus, t );
    [ [ 1, 127, 127, 64, 30, 64, 11, 7, 30, 64, 11, 64, 3, 70, 70, 19, 70, 70, 
          19, 4, 70, 19, 70 ], 
      [ 1, 127, 127, 64, 30, 64, 11, 7, 30, 64, 11, 64, 3, 72, 72, 19, 72, 72, 
          19, 6, 72, 19, 72 ], 
      [ 1, 127, 127, 64, 30, 64, 11, 7, 30, 64, 11, 64, 3, 73, 73, 20, 73, 73, 
          20, 5, 73, 20, 73 ], 
      [ 1, 127, 127, 66, 33, 66, 12, 7, 33, 66, 12, 66, 3, 72, 72, 19, 72, 72, 
          19, 6, 72, 19, 72 ], 
      [ 1, 127, 127, 66, 33, 66, 12, 7, 33, 66, 12, 66, 3, 73, 73, 20, 73, 73, 
          20, 5, 73, 20, 73 ], 
      [ 1, 127, 127, 67, 30, 67, 11, 10, 30, 67, 11, 67, 3, 72, 72, 19, 72, 72, 
          19, 6, 72, 19, 72 ], 
      [ 1, 127, 127, 67, 30, 67, 11, 10, 30, 67, 11, 67, 3, 73, 73, 20, 73, 73, 
          20, 5, 73, 20, 73 ], 
      [ 1, 127, 127, 68, 32, 68, 12, 10, 32, 68, 12, 68, 3, 72, 72, 19, 72, 72, 
          19, 6, 72, 19, 72 ], 
      [ 1, 127, 127, 68, 32, 68, 12, 10, 32, 68, 12, 68, 3, 73, 73, 20, 73, 73, 
          20, 5, 73, 20, 73 ], 
      [ 1, 127, 127, 69, 33, 69, 12, 9, 33, 69, 12, 69, 3, 72, 72, 19, 72, 72, 
          19, 6, 72, 19, 72 ], 
      [ 1, 127, 127, 69, 33, 69, 12, 9, 33, 69, 12, 69, 3, 73, 73, 20, 73, 73, 
          20, 5, 73, 20, 73 ] ]

</pre>

<div class="p"><!----></div>
The candidates differ on the classes of the element orders 3-8.

<div class="p"><!----></div>

<pre>
    gap&#62; ambig:= Parametrized( repr );;
    gap&#62; ambigpos:= PositionsProperty( ambig, IsList );
    [ 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23 ]
    gap&#62; Set( OrdersClassRepresentatives( t ){ ambigpos } );
    [ 3, 4, 5, 6, 7, 8 ]

</pre>

<div class="p"><!----></div>
According to&nbsp;[<a href="#NW12" name="CITENW12">NW</a>,Theorem&nbsp;3],
G contains elements in the classes <tt>3B</tt> and <tt>4C</tt> of M.
This determines the class fusion uniquely.

<div class="p"><!----></div>

<pre>
    gap&#62; pos1:= Position( ClassNames( t, "Atlas" ), "3B" );;
    gap&#62; pos2:= Position( ClassNames( t, "Atlas" ), "4C" );;
    gap&#62; pos:= [ pos1, pos2 ];;
    gap&#62; good:= Filtered( fus, map -&#62; IsSubset( map, pos ) );
    [ [ 1, 127, 127, 69, 33, 69, 12, 9, 33, 69, 12, 69, 3, 73, 73, 20, 73, 73, 
          20, 5, 73, 20, 73 ] ]
    gap&#62; GetFusionMap( s, t ) = good[1];
    true

</pre>

<div class="p"><!----></div>


<div class="p"><!----></div>

<h2>References</h2>

<dl compact="compact">
 <dt><a href="#CITEBN95" name="BN95">[BN95]</a></dt><dd>
T.&nbsp;Breuer and S.&nbsp;P. Norton, <em>Improvements to the Atlas</em>,
  p.&nbsp;297-327, vol.&nbsp;11 of London Mathematical Society Monographs.
  New Series [<a href="#JLPW95" name="CITEJLPW95">JLPW95</a>], 1995, Appendix 2 by T. Breuer and S. Norton, Oxford
  Science Publications. MR 1367961 (96k:20016)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITECTblLib1.2" name="CTblLib1.2">[Bre12]</a></dt><dd>
T.&nbsp;Breuer, <em>The <font face="helvetica">GAP</font> Character Table Library, Version
  1.2</em>, <a href="http://www.math.rwth-aachen.de/~Thomas.Breuer/ctbllib"><tt>http://www.math.rwth-aachen.de/</tt>
<tt><tt>~</tt>Thomas.Breuer/</tt>
<tt>ctbllib</tt></a>, Mar 2012, <font face="helvetica">GAP</font> package.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITECCN85" name="CCN85">[CCN<sup>+</sup>85]</a></dt><dd>
J.&nbsp;H. Conway, R.&nbsp;T. Curtis, S.&nbsp;P. Norton, R.&nbsp;A. Parker, and R.&nbsp;A. Wilson,
  <em>Atlas of finite groups</em>, Oxford University Press, Eynsham, 1985,
  Maximal subgroups and ordinary characters for simple groups, With
  computational assistance from J. G. Thackray. MR 827219 (88g:20025)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEGAP4" name="GAP4">[GAP04]</a></dt><dd>
The GAP&nbsp;Group, <em>GAP-Groups, Algorithms, and
  Programming, Version 4.4</em>, 2004, <a href="http://www.gap-system.org"><tt>http://www.gap-system.org</tt></a>.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEHW04" name="HW04">[HW04]</a></dt><dd>
P.&nbsp;E. Holmes and R.&nbsp;A. Wilson, <em><span class="roman">PSL</span><sub>2</sub>(59) is a subgroup of the
  Monster</em>, J. London Math. Soc. <b>69</b> (2004), no.&nbsp;1,
  141-152. MR 2025332 (2004k:20035)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEHW08" name="HW08">[HW08]</a></dt><dd>
<br /><table align="left" border="0"><tr><td width="50">
<hr />
</td></tr></table><!--hbox-->
 , <em>On subgroups of the Monster containing A<sub>5</sub>'s</em>, J. Algebra
  <b>319</b> (2008), no.&nbsp;7, 2653-2667. MR 2397402 (2009a:20028)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEJLPW95" name="JLPW95">[JLPW95]</a></dt><dd>
C.&nbsp;Jansen, K.&nbsp;Lux, R.&nbsp;Parker, and R.&nbsp;Wilson, <em>An atlas of Brauer
  characters</em>, London Mathematical Society Monographs. New Series, vol.&nbsp;11, The
  Clarendon Press Oxford University Press, New York, 1995, Appendix 2 by T.
  Breuer and S. Norton, Oxford Science Publications. MR 1367961 (96k:20016)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITELW91" name="LW91">[LW91]</a></dt><dd>
S.&nbsp;A. Linton and R.&nbsp;A. Wilson, <em>The maximal subgroups of the Fischer
  groups <span class="roman">Fi</span><sub>24</sub> and <span class="roman">Fi</span>&#8242;<sub>24</sub></em>, Proc. London Math. Soc.
  (3) <b>63</b> (1991), no.&nbsp;1, 113-164. MR 1105720 (92h:20031)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITENW12" name="NW12">[NW]</a></dt><dd>
S.&nbsp;P. Norton and R.&nbsp;A. Wilson, <em>A correction to the 41-structure of the
  Monster, a construction of a new maximal subgroup L<sub>2</sub>(41), and a new
  Moonshine phenomenon</em>, <a href="http://www.maths.qmul.ac.uk/~raw/pubs_files/ML241sub.pdf"><tt>http://www.maths.qmul.ac.uk/</tt>
<tt><tt>~</tt>raw/</tt>
<tt>pubs files/</tt>
<tt>ML241sub.pdf</tt></a>.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITENW02" name="NW02">[NW02]</a></dt><dd>
<br /><table align="left" border="0"><tr><td width="50">
<hr />
</td></tr></table><!--hbox-->
 , <em>Anatomy of the Monster. II</em>, Proc. London Math. Soc. (3)
  <b>84</b> (2002), no.&nbsp;3, 581-598. MR 1888424 (2003b:20023)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEWil93a" name="Wil93a">[Wil93a]</a></dt><dd>
R.&nbsp;A. Wilson, <em>More on maximal subgroups of the Baby Monster</em>, Arch.
  Math. (Basel) <b>61</b> (1993), no.&nbsp;6, 497-507. MR 1254061
  (95i:20021)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEWilson93" name="Wilson93">[Wil93b]</a></dt><dd>
<br /><table align="left" border="0"><tr><td width="50">
<hr />
</td></tr></table><!--hbox-->
 , <em>Some new subgroups of the Baby Monster</em>, Bull. London Math.
  Soc. <b>25</b> (1993), no.&nbsp;1, 23-28. MR 1190359 (93j:20041)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEWil99" name="Wil99">[Wil99]</a></dt><dd>
<br /><table align="left" border="0"><tr><td width="50">
<hr />
</td></tr></table><!--hbox-->
 , <em>The maximal subgroups of the Baby Monster. I</em>, J. Algebra
  <b>211</b> (1999), no.&nbsp;1, 1-14. MR 1656568 (2000b:20016)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEAtlasRep" name="AtlasRep">[WPN<sup>+</sup>11]</a></dt><dd>
R.&nbsp;A. Wilson, R.&nbsp;A. Parker, S.&nbsp;Nickerson, J.&nbsp;N. Bray, and T.&nbsp;Breuer,
  <em>AtlasRep, a <font face="helvetica">GAP</font> Interface to the Atlas of Group
  Representations, Version 1.5</em>, <a href="http://www.math.rwth-aachen.de/~Thomas.Breuer/atlasrep"><tt>http://www.math.rwth-aachen.de/</tt>
<tt><tt>~</tt>Thomas.Breuer/</tt>
<tt>atlasrep</tt></a>, Jul 2011, Refereed <font face="helvetica">GAP</font> package.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEAGR" name="AGR">[WWT<sup>+</sup>]</a></dt><dd>
R.&nbsp;A. Wilson, P.&nbsp;Walsh, J.&nbsp;Tripp, I.&nbsp;Suleiman, R.&nbsp;A. Parker, S.&nbsp;P. Norton,
  S.&nbsp;Nickerson, S.&nbsp;Linton, J.&nbsp;Bray, and R.&nbsp;Abbott, <em>ATLAS of Finite Group
  Representations</em>, <a href="http://brauer.maths.qmul.ac.uk/Atlas/"><tt>http://brauer.maths.qmul.ac.uk/</tt>
<tt>Atlas/</tt></a>.</dd>
</dl>


<div class="p"><!----></div>

<div class="p"><!----></div>

<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 3.59.<br />On  5 May 2012, 08:52.</small>
</html>
