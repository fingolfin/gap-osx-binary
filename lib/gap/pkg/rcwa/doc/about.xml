<!-- #################################################################### -->
<!-- ##                                                                ## -->
<!-- ##  about.xml           RCWA documentation           Stefan Kohl  ## -->
<!-- ##                                                                ## -->
<!-- #################################################################### -->

<Chapter Label="ch:AboutRCWA"><Heading>About the RCWA Package</Heading>

<Index Key="Collatz conjecture">Collatz conjecture</Index>
<Index Key="Collatz conjecture">Collatz mapping</Index>
This package permits to compute in monoids, in particular groups,
whose elements are <E>residue-class-wise affine</E> mappings.
Probably the widest-known occurrence of such a mapping is in the statement
of the <M>3n+1</M> conjecture, which asserts that iterated application of
the <E>Collatz mapping</E>
<Alt Only="LaTeX">
  <Display>
  <![CDATA[
    T: \ \ \mathbb{Z} \longrightarrow \mathbb{Z}, \ \ \ \
    n \ \longmapsto \
    \begin{cases}
      \frac{n}{2}    & \text{if} \ \ n \ \ \text{is even}, \\
      \frac{3n+1}{2} & \text{if} \ \ n \ \ \text{is odd}
    \end{cases}
  ]]>
  </Display>
</Alt>
<Alt Only="HTML"><![CDATA[<center>
  <img src = "collatz.png" width = "342" height = "63"
       alt = "T: Z -> Z, n |-> (n/2 if n even, (3n+1)/2 if n odd)"/>
</center>]]></Alt>
<Alt Only="Text"><Verb><![CDATA[
                                      /
                                      | n/2 if n even,
               T:  Z -> Z,   n  |->  <
                                      | (3n+1)/2 if n odd
                                      \
]]></Verb></Alt>
to any given positive integer eventually yields&nbsp;1
(cf.&nbsp;<Cite Key="Lagarias06"/>).
For definitions, see Section&nbsp;<Ref Label="sec:basicdefinitions"/>. <P/>

Presently, most research in computational group theory focuses on finite
permutation groups, matrix groups, finitely presented groups, polycyclically
presented groups and automata groups.
For details, we refer to&nbsp;<Cite Key="HoltEickOBrien05"/>.
The purpose of this package is twofold:

<List>

  <Item>
    On the one hand, it provides the means to deal with another large
    class of groups which are accessible to computational methods, and
    it therefore extends the range of groups which can be dealt with
    by means of computation.
  </Item>

  <Item>
    On the other -- and perhaps more importantly -- residue-class-wise
    affine groups appear to be interesting mathematical objects in their
    own right, and this package is intended to serve as a tool to obtain
    a better understanding of their rich and often complicated group
    theoretical and combinatorial structure.
  </Item>

</List>

In principle this package permits to construct and investigate all groups
which have faithful representations as residue-class-wise affine groups.
Among many others, the following groups and their subgroups belong to this
class:

<List>

  <Item>
    Finite groups, and certain divisible torsion groups which they
    embed into.
  </Item>

  <Item>
    Free groups of finite rank.
  </Item>

  <Item>
    Free products of finitely many finite groups.
  </Item>

  <Item>
    Direct products of the above groups.
  </Item>

  <Item>
    Wreath products of the above groups with finite groups and
    with&nbsp;(&ZZ;,+).
  </Item>

</List>

This list permits already to conclude that there are finitely generated
residue-class-wise affine groups which do not have finite presentations,
and such with algorithmically unsolvable membership problem.
However the list is certainly by far not exhaustive, and using this
package it is easy to construct groups of types which are not mentioned
there. <P/>

The group CT(&ZZ;) which is generated by all <E>class transpositions</E>
of&nbsp;&ZZ; -- these are involutions which interchange two disjoint residue
classes, see <Ref Func="ClassTransposition" Label="r1, m1, r2, m2"/>
-- is a simple group which has subgroups of all types listed above.
It is countable, but it has an uncountable series of simple subgroups
which is parametrized by the sets of odd primes. <P/>

Proofs of most of the results mentioned so far can be found
in&nbsp;<Cite Key="Kohl09"/>. Descriptions of a part of the algorithms
and methods which are implemented in this package can be found
in&nbsp;<Cite Key="Kohl08b"/>. <P/>

The reader might want to know what type of results one can obtain
with &RCWA;. However, the answer to this is that the package can be
applied in various ways to various different problems, and it is simply
not possible to say in general what can be found out with its help.
So one really cannot give a better answer here than for the same question
about &GAP; itself. The best way to get familiar with the package and
its capabilities is likely to experiment with the examples discussed in
this manual and the groups generated by 3 class transpositions from the
corresponding data library. <P/>

Of course, sometimes this package does not provide an out-of-the-box
solution for a given problem. But quite often it is still possible to
find an answer by an interactive trial-and-error approach.
With substantial help of this package, the author has found the results
mentioned above. Interactive sessions with this package have also led to
the development of most of the algorithms which are now implemented in it.
Just to mention one example, developing the factorization method for
residue-class-wise affine permutations
(see&nbsp;<Ref Attr="FactorizationIntoCSCRCT"
Label="for an rcwa permutation of Z"/>)
solely by means of theory would likely have been very hard.

<!-- #################################################################### -->

</Chapter>

<!-- #################################################################### -->
