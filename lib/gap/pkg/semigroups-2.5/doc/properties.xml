#############################################################################
##
#W  properties.xml
#Y  Copyright (C) 2011-13                                James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<!-- JDM improve --> 
<#GAPDoc Label="IsAbundantSemigroup">
  <ManSection>
    <Prop Name="IsAbundantSemigroup" Arg="S"/>
    <Returns><K>true</K> if the transformation semigroup <A>S</A> is abundant
          and <K>false</K> if it is not.
    </Returns>
    <Description>
      A transformation semigroup is <E>abundant</E> if and only if for all
      <M>f\in S</M> there exists an idempotent <M>e\in S</M> such that
      <M>\textrm{ker}(f)=\textrm{ker}(e)</M>.  <!-- hmm is this right, or do we
      require the existence of an idempotent e' such that im(e')=im(f) too? --> 
      <Example><![CDATA[
gap> gens:=[ Transformation( [ 1, 3, 2, 3 ] ),
>  Transformation( [ 1, 4, 1, 2 ] ),
>  Transformation( [ 2, 4, 1, 1 ] ),
>  Transformation( [ 3, 4, 2, 2 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsAbundantSemigroup(S);
true
gap> IsRegularSemigroup(S);
false]]></Example> 
    </Description>
  </ManSection>
<#/GAPDoc>

<!-- JDM improve --> 
<#GAPDoc Label="IsAdequateSemigroup">
  <ManSection>
    <Prop Name="IsAdequateSemigroup" Arg="S"/>
    <Returns><K>true</K> if the transformation semigroup <A>S</A> is adequate
          and <K>false</K> if it is not.
    </Returns>
    <Description>
      A transformation semigroup is <E>adequate</E> if it is abundant and its
      idempotents commute. See <Ref Prop="IsAbundantSemigroup"/> and 
      <Ref Prop="IsBlockGroup"/>.
      <Example><![CDATA[
gap> S:=Semigroup(Transformation( [ 1, 7, 3, 8, 4, 2, 6, 5, 9 ] ),
>   Transformation( [ 1, 8, 6, 2, 3, 7, 4, 5, 9 ] ),
>   Transformation( [ 1, 9, 9, 9, 5, 6, 7, 9, 9 ] ));;
gap> IsAdequateSemigroup(S);
true
gap> S:=Semigroup( Transformation( [ 1, 3, 2, 3 ] ),
>  Transformation( [ 1, 4, 1, 2 ] ),
>  Transformation( [ 2, 4, 1, 1 ] ),
>  Transformation( [ 3, 4, 2, 2 ] ) );;
gap> IsAdequateSemigroup(S);
false]]></Example> 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBand">
  <ManSection>
    <Prop Name="IsBand" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      <C>IsBand</C> returns <K>true</K> if every element of the semigroup
      <A>S</A> is an idempotent and <K>false</K> if it is not. An inverse
      semigroup is band if and only if it is a semilattice; see 
      <Ref Prop="IsSemilatticeAsSemigroup"/>.

      <Example><![CDATA[
gap> gens:=[ Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 1 ] ), 
> Transformation( [ 2, 2, 2, 5, 5, 5, 8, 8, 8, 2 ] ), 
> Transformation( [ 3, 3, 3, 6, 6, 6, 9, 9, 9, 3 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 4 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 7 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsBand(S);
true
gap> S:=InverseSemigroup(
> PartialPerm( [ 1, 2, 3, 4, 8, 9 ], [ 5, 8, 7, 6, 9, 1 ] ),
> PartialPerm( [ 1, 3, 4, 7, 8, 9, 10 ], [ 2, 3, 8, 7, 10, 6, 1 ] ) );;
gap> IsBand(S);
false
gap> IsBand(IdempotentGeneratedSubsemigroup(S));
true
gap> S:=PartitionMonoid(4);
<regular bipartition monoid on 4 pts with 4 generators>
gap> M:=MinimalIdeal(S);
<simple bipartition semigroup ideal on 4 pts with 1 generator>
gap> IsBand(M);
true]]></Example> 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBlockGroup">
  <ManSection>
    <Prop Name="IsBlockGroup" Arg="S"/>
    <Prop Name="IsSemigroupWithCommutingIdempotents" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsBlockGroup</C> and <C>IsSemigroupWithCommutingIdempotents</C> return
      <K>true</K> if the semigroup <A>S</A> is a block group and <K>false</K>
      if it is not.<P/>

      A semigroup <A>S</A> is a <E>block group</E> if every &L;-class and every
      &R;-class of <A>S</A> contains at most one idempotent. Every semigroup
      of partial permutations is a block group.  
      <Example><![CDATA[
gap> S:=Semigroup(Transformation( [ 5, 6, 7, 3, 1, 4, 2, 8 ] ),
>   Transformation( [ 3, 6, 8, 5, 7, 4, 2, 8 ] ));;
gap> IsBlockGroup(S);
true
gap> S:=Semigroup(Transformation( [ 2, 1, 10, 4, 5, 9, 7, 4, 8, 4 ] ),
> Transformation( [ 10, 7, 5, 6, 1, 3, 9, 7, 10, 2 ] ));;
gap> IsBlockGroup(S);
false
gap> S:=Semigroup(
> PartialPerm( [ 1, 2 ], [ 5, 4 ] ), 
> PartialPerm( [ 1, 2, 3 ], [ 1, 2, 5 ] ), 
> PartialPerm( [ 1, 2, 3 ], [ 2, 1, 5 ] ), 
> PartialPerm( [ 1, 3, 4 ], [ 3, 1, 2 ] ), 
> PartialPerm( [ 1, 3, 4, 5 ], [ 5, 4, 3, 2 ] ) );;
gap> T:=Range(IsomorphismBlockBijectionSemigroup(S));
<bipartition semigroup on 6 pts with 5 generators>
gap> IsBlockGroup(T);
true
gap> IsBlockGroup(Range(IsomorphismBipartitionSemigroup(S)));
true
gap> S:=Semigroup( 
> Bipartition( [ [ 1, -2 ], [ 2, -3 ], [ 3, -4 ], [ 4, -1 ] ] ), 
> Bipartition( [ [ 1, -2 ], [ 2, -1 ], [ 3, -3 ], [ 4, -4 ] ] ), 
> Bipartition( [ [ 1, 2, -3 ], [ 3, -1, -2 ], [ 4, -4 ] ] ), 
> Bipartition( [ [ 1, -1 ], [ 2, -2 ], [ 3, -3 ], [ 4, -4 ] ] ) );;
gap> IsBlockGroup(S);
true]]></Example>
    </Description> 
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBrandtSemigroup">
  <ManSection>
    <Prop Name="IsBrandtSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsBrandtSemigroup</C> return <K>true</K> if the semigroup <A>S</A> is 
      a 0-simple inverse semigroup, and <K>false</K> if it is not. See also
      <Ref Prop="IsZeroSimpleSemigroup"/> and <Ref Prop="IsInverseSemigroup"
        BookName="ref" />.
      <Example><![CDATA[
gap> S:=Semigroup(Transformation( [ 2, 8, 8, 8, 8, 8, 8, 8 ] ),
> Transformation( [ 5, 8, 8, 8, 8, 8, 8, 8 ] ),
> Transformation( [ 8, 3, 8, 8, 8, 8, 8, 8 ] ),
> Transformation( [ 8, 6, 8, 8, 8, 8, 8, 8 ] ),
> Transformation( [ 8, 8, 1, 8, 8, 8, 8, 8 ] ),
> Transformation( [ 8, 8, 8, 1, 8, 8, 8, 8 ] ),
> Transformation( [ 8, 8, 8, 8, 4, 8, 8, 8 ] ),
> Transformation( [ 8, 8, 8, 8, 8, 7, 8, 8 ] ),
> Transformation( [ 8, 8, 8, 8, 8, 8, 2, 8 ] ));;
gap> IsBrandtSemigroup(S);
true
gap> T:=Range(IsomorphismPartialPermSemigroup(S));;
gap> IsBrandtSemigroup(T);
true
gap> S:=DualSymmetricInverseMonoid(4);;
gap> D:=DClasses(S)[3];
{Bipartition( [ [ 1, 2, 3, -1, -2, -3 ], [ 4, -4 ] ] )}
gap> R:=InjectionPrincipalFactor(D);;
gap> S:=Semigroup(PreImages(R, GeneratorsOfSemigroup(Range(R))));;
gap> IsBrandtSemigroup(S);
true]]></Example>
    </Description> 
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCliffordSemigroup">
  <ManSection>
    <Prop Name="IsCliffordSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsCliffordSemigroup</C> returns <K>true</K> if the semigroup <A>S</A>
      is  regular and its idempotents are central, and <K>false</K> if it is
      not.  
      <Example><![CDATA[
gap> S:=Semigroup( Transformation( [ 1, 2, 4, 5, 6, 3, 7, 8 ] ), 
> Transformation( [ 3, 3, 4, 5, 6, 2, 7, 8 ] ), 
> Transformation( [ 1, 2, 5, 3, 6, 8, 4, 4 ] ) );;
gap> IsCliffordSemigroup(S);
true
gap> T:=Range(IsomorphismPartialPermSemigroup(S));;
gap> IsCliffordSemigroup(S);
true
gap> S:=DualSymmetricInverseMonoid(5);;
gap> T:=IdempotentGeneratedSubsemigroup(S);;
gap> IsCliffordSemigroup(T);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCommutativeSemigroup">
  <ManSection>
    <Prop Name="IsCommutativeSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsCommutativeSemigroup</C> returns <K>true</K> if the semigroup
      <A>S</A> is commutative and <K>false</K> if it is not.  
      The function <Ref Prop="IsCommutative" BookName="ref"/> can also be used
      to test if a semigroup is commutative.  <P/>

      A semigroup <A>S</A> is <E>commutative</E> if 
      <C>x*y=y*x</C> for all <C>x,y</C> in <A>S</A>.

      <Example><![CDATA[
gap> gens:=[ Transformation( [ 2, 4, 5, 3, 7, 8, 6, 9, 1 ] ), 
>  Transformation( [ 3, 5, 6, 7, 8, 1, 9, 2, 4 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsCommutativeSemigroup(S);
true
gap> IsCommutative(S);
true
gap> S:=InverseSemigroup(
>  PartialPerm( [ 1, 2, 3, 4, 5, 6 ], [ 2, 5, 1, 3, 9, 6 ] ),
>  PartialPerm( [ 1, 2, 3, 4, 6, 8 ], [ 8, 5, 7, 6, 2, 1 ] ) );;
gap> IsCommutativeSemigroup(S);
false
gap> S:=Semigroup(
> Bipartition( [ [ 1, 2, 3, 6, 7, -1, -4, -6 ], 
>      [ 4, 5, 8, -2, -3, -5, -7, -8 ] ] ), 
>  Bipartition( [ [ 1, 2, -3, -4 ], [ 3, -5 ], [ 4, -6 ], [ 5, -7 ], 
>      [ 6, -8 ], [ 7, -1 ], [ 8, -2 ] ] ) );;
gap> IsCommutativeSemigroup(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCompletelyRegularSemigroup">
  <ManSection>
    <Prop Name="IsCompletelyRegularSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsCompletelyRegularSemigroup</C> returns <K>true</K> if every element
      of the semigroup <A>S</A> is contained in a subgroup of <A>S</A>.<P/> 
      
      An inverse semigroup is completely regular if and only if it is a
      Clifford semigroup; see <Ref Prop="IsCliffordSemigroup"/>. 

      <Example><![CDATA[
gap> gens:=[ Transformation( [ 1, 2, 4, 3, 6, 5, 4 ] ), 
>  Transformation( [ 1, 2, 5, 6, 3, 4, 5 ] ), 
>  Transformation( [ 2, 1, 2, 2, 2, 2, 2 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsCompletelyRegularSemigroup(S);
true
gap> IsInverseSemigroup(S);
true
gap> T:=Range(IsomorphismPartialPermSemigroup(S));;
gap> IsCompletelyRegularSemigroup(T);
true
gap> IsCliffordSemigroup(T);         
true
gap> S:=Semigroup(
> Bipartition( [ [ 1, 3, -4 ], [ 2, 4, -1, -2 ], [ -3 ] ] ), 
> Bipartition( [ [ 1, -1 ], [ 2, 3, 4, -3 ], [ -2, -4 ] ] ) );;
gap> IsCompletelyRegularSemigroup(S);
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRTrivial">
  <ManSection><Heading>IsXTrivial</Heading>
    <Prop Name="IsRTrivial" Arg="S"/>
    <Prop Name="IsLTrivial" Arg="S"/>
    <Prop Name="IsHTrivial" Arg="S"/>
    <Prop Name="IsDTrivial" Arg="S"/>
    <Prop Name="IsAperiodicSemigroup" Arg="S"/>
    <Prop Name="IsCombinatorialSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsXTrivial</C> returns <K>true</K> if Green's &R;-relation,
      &L;-relation, &H;-relation, &D;-relation, respectively, on the
      semigroup <A>S</A> is trivial and <K>false</K> if it is not.
      These properties can also be applied to a Green's class instead of a
      semigroup where applicable. 
      <P/> 

      For inverse semigroups, the properties of being 
      &R;-trivial, &L;-trivial, &D;-trivial, and a semilattice are equivalent;
      see <Ref Prop="IsSemilatticeAsSemigroup"/>.
      <P/>

      A semigroup is <E>aperiodic</E> if its contains no non-trivial
      subgroups (equivalently, all of its group &H;-classes 
      are trivial). A finite semigroup is aperiodic if and only if it is 
      &H;-trivial. <P/>

      <E>Combinatorial</E> is a synonym for aperiodic in this context. 
      <Example><![CDATA[
gap> S:=Semigroup( Transformation( [ 1, 5, 1, 3, 7, 10, 6, 2, 7, 10 ] ), 
>  Transformation( [ 4, 4, 5, 6, 7, 7, 7, 4, 3, 10 ] ) );;
gap> IsHTrivial(S);
true
gap> Size(S);
108
gap> IsRTrivial(S);
false
gap> IsLTrivial(S);
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsEUnitaryInverseSemigroup">
<ManSection>
  <Prop Name="IsEUnitaryInverseSemigroup" Arg="S"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    As described in Section 5.9 of <Cite Key="howie"/>, an inverse semigroup
    <A>S</A> with semilattice of idempotents <A>E</A> is <E>E-unitary</E> if
    for
    <Alt Not="Text">
      <Display>
        s \in S\textrm{ and }e \in E\textrm{: }es \in E \Rightarrow s \in E.
      </Display>
    </Alt>
    <Alt Only="Text">
      for s in S and e in E, es in E implies s in E.
    </Alt><P/>
    Equivalently, <A>S</A> is <E>E-unitary</E> if <A>E</A> is closed in the 
    natural partial order (see Proposition 5.9.1 in <Cite Key="howie"/>):
    <Alt Not="Text">
      <Display>
        \textrm{for } s \in S\textrm{ and }e \in E\textrm{: }e \le s \Rightarrow s
        \in E.
      </Display>
    </Alt>
    <Alt Only="Text">
      for s in S and e in E, e less than s implies s in E.
    </Alt><P/>

    This condition is equivalent to <A>E</A> being majorantly closed in
    <A>S</A>.  See <Ref Oper="IdempotentGeneratedSubsemigroup"/> and <Ref
      Oper="IsMajorantlyClosed"/>.    
    Hence an inverse semigroup of partial permutations, block bijections or 
    partial permutation bipartitions is <E>E-unitary</E> if and only if the 
    idempotent semilattice is majorantly closed.
    <Example><![CDATA[
gap> S:=InverseSemigroup( [ PartialPerm( [ 1, 2, 3, 4 ], [ 2, 3, 1, 6 ] ),
>  PartialPerm( [ 1, 2, 3, 5 ], [ 3, 2, 1, 6 ] ) ]);;
gap> IsEUnitaryInverseSemigroup(S);
true
gap> e:=IdempotentGeneratedSubsemigroup(S);;
gap> ForAll(Difference(S,e), x->not ForAny(e, y->y*x in e));
true
gap> T:=InverseSemigroup( [ 
>  PartialPerm( [ 1, 3, 4, 6, 8 ], [ 2, 5, 10, 7, 9 ] ),
>  PartialPerm( [ 1, 2, 3, 5, 6, 7, 8 ], [ 5, 8, 9, 2, 10, 1, 3 ] ),
>  PartialPerm( [ 1, 2, 3, 5, 6, 7, 9 ], [ 9, 8, 4, 1, 6, 7, 2 ] ) ]);;
gap> IsEUnitaryInverseSemigroup(T);
false
gap> U:=InverseSemigroup( [
>  PartialPerm( [ 1, 2, 3, 4, 5 ], [ 2, 3, 4, 5, 1 ] ),
>  PartialPerm( [ 1, 2, 3, 4, 5 ], [ 2, 1, 3, 4, 5 ] ) ]);;
gap> IsEUnitaryInverseSemigroup(U);
true
gap> IsGroupAsSemigroup(U);
true
gap> StructureDescription(U);
"S5"]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsFactorisableSemigroup">
<ManSection>
  <Prop Name="IsFactorisableSemigroup" Arg="S"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    An inverse monoid is <E>factorisable</E> if every element is the product
    of an element of the group of units and an idempotent; see also 
    <Ref Attr="GroupOfUnits"/> and <Ref Attr="Idempotents"/>. Hence an
    inverse semigroup of partial permutations is factorisable if and only if
    each of its generators is the restriction of some element in the group of
    units. 
    <Example><![CDATA[
gap> S:=InverseSemigroup( PartialPerm( [ 1, 2, 4 ], [ 3, 1, 4 ] ),
> PartialPerm( [ 1, 2, 3, 5 ], [ 4, 1, 5, 2 ] ) );;
gap> IsFactorisableSemigroup(S);
false
gap> IsFactorisableSemigroup(SymmetricInverseSemigroup(5)); 
true
gap> IsFactorisableSemigroup(DualSymmetricInverseMonoid(5));
false
gap> IsFactorisableSemigroup(FactorisableDualSymmetricInverseSemigroup(5));
true]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsGroupAsSemigroup">
  <ManSection>
    <Prop Name="IsGroupAsSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      If the semigroup <A>S</A> is actually a group, then
      <C>IsGroupAsSemigroup</C> returns <K>true</K>.  If it is not a group,
      then <K>false</K> is returned.
      <Example><![CDATA[
gap> gens:=[ Transformation( [ 2, 4, 5, 3, 7, 8, 6, 9, 1 ] ), 
>  Transformation( [ 3, 5, 6, 7, 8, 1, 9, 2, 4 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsGroupAsSemigroup(S);
true
gap> G:=SymmetricGroup(5);;
gap> S:=Range(IsomorphismPartialPermSemigroup(G));
<inverse partial perm semigroup on 5 pts with 2 generators>
gap> IsGroupAsSemigroup(S);
true
gap> S:=SymmetricGroup([1,2,10]);;
gap> T:=Range(IsomorphismBlockBijectionSemigroup(
> Range(IsomorphismPartialPermSemigroup(S))));
<inverse bipartition semigroup on 11 pts with 2 generators>
gap> IsGroupAsSemigroup(T);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsIdempotentGenerated">
  <ManSection><Heading>IsIdempotentGenerated</Heading>
    <Prop Name="IsIdempotentGenerated" Arg="S"/>
    <Prop Name="IsSemiBand" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsIdempotentGenerated</C> and <C>IsSemiBand</C> return 
      <K>true</K> if the semigroup <A>S</A> is generated by its idempotents and
      <K>false</K> if it is not.  See also <Ref Attr="Idempotents"/> and 
      <Ref Attr="IdempotentGeneratedSubsemigroup"/>. <P/>

      An inverse semigroup is idempotent-generated if and only if it is a
      semilattice; see <Ref Prop="IsSemilatticeAsSemigroup"/>.<P/>

      Semiband and  idempotent-generated are synonymous
      in this context. 

      <Example><![CDATA[
gap> S:=SingularTransformationSemigroup(4);
<regular transformation semigroup ideal on 4 pts with 1 generator>
gap> IsIdempotentGenerated(S);
true
gap> S:=SingularBrauerMonoid(5);
<regular bipartition semigroup ideal on 5 pts with 1 generator>
gap> IsIdempotentGenerated(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsInverseSemigroup">
<ManSection>
  <Prop Name="IsInverseSemigroup" Arg="S"/>
  <Prop Name="IsInverseMonoid" Arg="S"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    If <A>S</A> is a semigroup, then <C>IsInverseSemigroup</C> returns
    <K>true</K> if <A>S</A> is an inverse semigroup and <K>false</K> if it is
    not. If <A>S</A> is monoid, then <C>IsInverseMonoid</C> returns <K>true</K>
    if <A>S</A> is an inverse monoid and <K>false</K> if it is not.<P/>

    A semigroup is an <E>inverse semigroup</E> if every element 
    <C>x</C> has a unique semigroup inverse, that is, a unique
    element <C>y</C> such that <C>x*y*x=x</C> and <C>y*x*y=y</C>.

    <Example><![CDATA[
gap> S:=Semigroup( Transformation( [ 1, 2, 4, 5, 6, 3 ] ), 
> Transformation( [ 3, 3, 4, 5, 6, 2 ] ), 
> Transformation( [ 1, 2, 5, 3, 6, 8, 4, 4 ] ) );
gap> IsInverseSemigroup(S);
true]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsLeftSimple">
  <ManSection>
    <Prop Name="IsLeftSimple" Arg="S"/>
    <Prop Name="IsRightSimple" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
    <C>IsLeftSimple</C> and <C>IsRightSimple</C> returns <K>true</K> if the 
    semigroup <A>S</A> has only one &L;-class or one &R;-class,
    respectively, and returns <K>false</K> if it has more than one. <P/>

    An inverse semigroup is left simple if and only if it is right simple if
    and only if it is a group; see <Ref Prop="IsGroupAsSemigroup"/>.
<Example><![CDATA[
gap> S:=Semigroup( Transformation( [ 6, 7, 9, 6, 8, 9, 8, 7, 6 ] ), 
>  Transformation( [ 6, 8, 9, 6, 8, 8, 7, 9, 6 ] ), 
>  Transformation( [ 6, 8, 9, 7, 8, 8, 7, 9, 6 ] ), 
>  Transformation( [ 6, 9, 8, 6, 7, 9, 7, 8, 6 ] ), 
>  Transformation( [ 6, 9, 9, 6, 8, 8, 7, 9, 6 ] ), 
>  Transformation( [ 6, 9, 9, 7, 8, 8, 6, 9, 7 ] ), 
>  Transformation( [ 7, 8, 8, 7, 9, 9, 7, 8, 6 ] ), 
>  Transformation( [ 7, 9, 9, 7, 6, 9, 6, 8, 7 ] ), 
>  Transformation( [ 8, 7, 6, 9, 8, 6, 8, 7, 9 ] ), 
>  Transformation( [ 9, 6, 6, 7, 8, 8, 7, 6, 9 ] ), 
>  Transformation( [ 9, 6, 6, 7, 9, 6, 9, 8, 7 ] ), 
>  Transformation( [ 9, 6, 7, 9, 6, 6, 9, 7, 8 ] ), 
>  Transformation( [ 9, 6, 8, 7, 9, 6, 9, 8, 7 ] ), 
>  Transformation( [ 9, 7, 6, 8, 7, 7, 9, 6, 8 ] ), 
>  Transformation( [ 9, 7, 7, 8, 9, 6, 9, 7, 8 ] ), 
>  Transformation( [ 9, 8, 8, 9, 6, 7, 6, 8, 9 ] ) );;
gap> IsRightSimple(S);
false
gap> IsLeftSimple(S);
true
gap> IsGroupAsSemigroup(S);
false
gap> NrRClasses(S);
16
gap> S:=BrauerMonoid(6);;
gap> S:=Semigroup(RClass(S, Random(MinimalDClass(S))));;
gap> IsLeftSimple(S);
false
gap> IsRightSimple(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsLeftZeroSemigroup">
  <ManSection>
    <Prop Name="IsLeftZeroSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsLeftZeroSemigroup</C> returns  <K>true</K> if the semigroup <A>S</A>
      is a left zero semigroup and <K>false</K> if it is not. <P/>

      A semigroup is a <E>left zero semigroup</E> if <C>x*y=x</C> for
      all <C>x,y</C>. An inverse semigroup is a left zero semigroup if and only
      if it is trivial. 

      <Example><![CDATA[
gap> gens:=[ Transformation( [ 2, 1, 4, 3, 5 ] ), 
>  Transformation( [ 3, 2, 3, 1, 1 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsRightZeroSemigroup(S);
false
gap> gens:=[Transformation( [ 1, 2, 3, 3, 1 ] ), 
> Transformation( [ 1, 2, 3, 3, 3 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsLeftZeroSemigroup(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMonogenicSemigroup">
  <ManSection>
    <Prop Name="IsMonogenicSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
   <Description>
     <C>IsMonogenicSemigroup</C> returns <K>true</K> if the semigroup <A>S</A>
     is monogenic and it returns <K>false</K> if it is not. <P/>

     A semigroup is <E>monogenic</E> if it is generated by a single element.
     See also <Ref Prop="IsMonogenicInverseSemigroup"/> and <Ref Attr="IndexPeriodOfTransformation" BookName="ref"/>.
<Example><![CDATA[
gap> S:=Semigroup(
> Transformation([ 2, 2, 2, 11, 10, 8, 10, 11, 2, 11, 10, 2, 11, 11, 10 ]),
> Transformation([ 2, 2, 2, 8, 11, 15, 11, 10, 2, 10, 11, 2, 10, 4, 7 ]), 
> Transformation([ 2, 2, 2, 11, 10, 8, 10, 11, 2, 11, 10, 2, 11, 11, 10 ]),
> Transformation([ 2, 2, 12, 7, 8, 14, 8, 11, 2, 11, 10, 2, 11, 15, 4 ]));;
gap> IsMonogenicSemigroup(S);
true
gap> S:=Semigroup( 
> Bipartition( [ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -2, -5, -7, -9 ], 
>      [ -1, -10 ], [ -3, -4, -6, -8 ] ] ), 
>  Bipartition( [ [ 1, 4, 7, 8, -2 ], [ 2, 3, 5, 10, -5 ], 
>      [ 6, 9, -7, -9 ], [ -1, -10 ], [ -3, -4, -6, -8 ] ] ) );;
gap> IsMonogenicSemigroup(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMonogenicInverseSemigroup">
  <ManSection>
    <Prop Name="IsMonogenicInverseSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
   <Description>
     <C>IsMonogenicInverseSemigroup</C> returns <K>true</K> if the semigroup
     <A>S</A> is an inverse monogenic semigroup and it returns <K>false</K> if
     it is not. <P/>

     A inverse semigroup is <E>monogenic</E> if it is generated as an inverse
     semigroup by a single element.  See also <Ref
       Prop="IsMonogenicSemigroup"/> and <Ref
       Attr="IndexPeriodOfTransformation" BookName="ref"/>.
<Example><![CDATA[
gap> f:=PartialPerm( [ 1, 2, 3, 6, 8, 10 ], [ 2, 6, 7, 9, 1, 5 ] );;
gap> S:=InverseSemigroup(f, f^2, f^3);;
gap> IsMonogenicSemigroup(S);
false
gap> IsMonogenicInverseSemigroup(S);
true
gap> x:=Random(DualSymmetricInverseMonoid(100));;
gap> S:=InverseSemigroup(x, x^2, x^20);;
gap> IsMonogenicInverseSemigroup(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMonoidAsSemigroup">
  <ManSection>
    <Prop Name="IsMonoidAsSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsMonoidAsSemigroup</C> returns <K>true</K> if and only if the
      semigroup <A>S</A> is mathematically a monoid but does belong to the
      category of monoids <Ref Prop="IsMonoid" BookName="ref"/> in &GAP; This is
      possible if the <Ref Attr="MultiplicativeNeutralElement" BookName="ref"/>
      of <A>S</A> is not equal to the <Ref Attr="One" BookName="ref"/> of any
      element in <A>S</A>. <P/>

      A semigroup satisfying <C>IsMonoidAsSemigroup</C> does not possess the
      attributes of a monoid (such as, <Ref Attr="GeneratorsOfMonoid"
        BookName="ref"/>).<P/>

     See also <Ref Attr="One" BookName="ref"/>, 
     <Ref Prop="IsInverseMonoid" BookName="ref"/>
     and <Ref Oper="IsomorphismTransformationMonoid" BookName="ref"/>.
      <Example><![CDATA[
gap> S:=Semigroup( Transformation( [ 1, 4, 6, 2, 5, 3, 7, 8, 9, 9 ] ),
> Transformation( [ 6, 3, 2, 7, 5, 1, 8, 8, 9, 9 ] ) );;
gap> IsMonoidAsSemigroup(S);
true
gap> IsMonoid(S);
false
gap> MultiplicativeNeutralElement(S);
Transformation( [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 9 ] )
gap> T:=Range(IsomorphismBipartitionSemigroup(S));;
gap> IsMonoidAsSemigroup(T);
true
gap> IsMonoid(T);
false
gap> One(T);
fail
gap> S:=Monoid(Transformation( [ 8, 2, 8, 9, 10, 6, 2, 8, 7, 8 ] ),
> Transformation( [ 9, 2, 6, 3, 6, 4, 5, 5, 3, 2 ] ));;
gap> IsMonoidAsSemigroup(S);
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsOrthodoxSemigroup">
  <ManSection>
    <Prop Name="IsOrthodoxSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsOrthodoxSemigroup</C> returns <K>true</K> if the semigroup 
      <A>S</A> is orthodox and <K>false</K> if it is not.<P/>

      A semigroup is <E>orthodox</E> if it is regular and its idempotent
      elements form a subsemigroup.  Every inverse semigroup is also an orthodox
      semigroup.  <P/>

      See also <Ref Prop="IsRegularSemigroup"/> and 
      <Ref Prop="IsRegularSemigroup" BookName="ref"/>.

      <Example><![CDATA[
gap> gens:=[ Transformation( [ 1, 1, 1, 4, 5, 4 ] ), 
>  Transformation( [ 1, 2, 3, 1, 1, 2 ] ), 
>  Transformation( [ 1, 2, 3, 1, 1, 3 ] ), 
>  Transformation( [ 5, 5, 5, 5, 5, 5 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsOrthodoxSemigroup(S);
true
gap> S:=Semigroup(GeneratorsOfSemigroup(DualSymmetricInverseMonoid(5)));;
gap> IsOrthodoxSemigroup(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRectangularBand">
  <ManSection>
    <Prop Name="IsRectangularBand" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsRectangularBand</C> returns <K>true</K> if the semigroup <A>S</A> 
      is a rectangular band and <K>false</K> if it is not.<P/>
      
      A semigroup <A>S</A> is a <E>rectangular band</E> if for all 
      <M>x, y, z</M>  in <A>S</A>
      we have that <M>x^2 = x</M> and <M>xyz = xz</M>.<P/>

      Equivalently, <A>S</A> is a <E>rectangular band</E> if
      <A>S</A> is isomorphic to a semigroup of the form
      <M>I \times \Lambda</M> with multiplication
      <M>(i,\lambda)(j,\mu) = (i,\mu)</M>.
      In this case, <A>S</A> is called an
      <M>|I| \times |\Lambda|</M> <E>rectangular band</E>.<P/>

      An inverse semigroup is a rectangular band if and only if it is a group.
      <Example><![CDATA[
gap> gens:=[ Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 1 ] ), 
> Transformation( [ 2, 2, 2, 5, 5, 5, 8, 8, 8, 2 ] ), 
> Transformation( [ 3, 3, 3, 6, 6, 6, 9, 9, 9, 3 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 4 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 7 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsRectangularBand(S);
true
gap> IsRectangularBand(MinimalIdeal(PartitionMonoid(4)));
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRegularSemigroup">
  <ManSection>
    <Prop Name="IsRegularSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsRegularSemigroup</C> returns <K>true</K> if the semigroup 
      <A>S</A> is regular and <K>false</K> if it is not. <P/>

      A semigroup <C>S</C> is <E>regular</E> if for all <C>x</C> in <C>S</C> 
      there exists <C>y</C> in <C>S</C> such that <C>x*y*x=x</C>. Every inverse
      semigroup is regular, and a semigroup of partial permutations is regular
      if and only if it is an inverse semigroup.<P/>

      See also <Ref Prop="IsRegularDClass" BookName="ref"/>,
      <Ref Func="IsRegularClass"/>,   
      and <Ref Func="IsRegularSemigroupElement" BookName="ref"/>.
      
      <Example><![CDATA[
gap> IsRegularSemigroup(FullTransformationSemigroup(5));
true
gap> IsRegularSemigroup(JonesMonoid(5));
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRightZeroSemigroup">
  <ManSection>
    <Prop Name="IsRightZeroSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsRightZeroSemigroup</C> returns <K>true</K> if the <A>S</A> is a
      right zero semigroup and <K>false</K> if it is not.<P/>
      
      A semigroup <C>S</C> is a <E>right zero semigroup</E> if <C>x*y=y</C> for 
      all <C>x,y</C> in <C>S</C>. An inverse semigroup is a right zero
      semigroup if and only if it is trivial. 
      <Example><![CDATA[
gap> gens:=[ Transformation( [ 2, 1, 4, 3, 5 ] ), 
>  Transformation( [ 3, 2, 3, 1, 1 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsRightZeroSemigroup(S);
false
gap> gens:=[Transformation( [ 1, 2, 3, 3, 1 ] ), 
>  Transformation( [ 1, 2, 4, 4, 1 ] )];;
gap> S:=Semigroup(gens);;
gap> IsRightZeroSemigroup(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSemilatticeAsSemigroup">
  <ManSection>
    <Prop Name="IsSemilatticeAsSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsSemilatticeAsSemigroup</C> returns <K>true</K> if the semigroup
      <A>S</A> is a semilattice and <K>false</K> if it is not. <P/>
      
      A semigroup is a <E>semilattice</E> if it is commutative and every
      element is an idempotent. The idempotents of an inverse semigroup form a
      semilattice. 
      <Example><![CDATA[
gap> S:=Semigroup(Transformation( [ 2, 5, 1, 7, 3, 7, 7 ] ), 
> Transformation( [ 3, 6, 5, 7, 2, 1, 7 ] ) );;                    
gap> Size(S);
631
gap> IsInverseSemigroup(S);
true
gap> A:=Semigroup(Idempotents(S)); 
<transformation semigroup on 7 pts with 32 generators>
gap> IsSemilatticeAsSemigroup(A);
true
gap> S:=FactorisableDualSymmetricInverseSemigroup(5);;
gap> S:=IdempotentGeneratedSubsemigroup(S);;
gap> IsSemilatticeAsSemigroup(S);
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSimpleSemigroup">
  <ManSection><Heading>IsSimpleSemigroup</Heading>
    <Prop Name="IsSimpleSemigroup" Arg="S"/>
    <Prop Name="IsCompletelySimpleSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsSimpleSemigroup</C> returns <K>true</K> if the semigroup 
      <A>S</A> is simple and <K>false</K> if it is not.<P/>
      
      A semigroup is <E>simple</E> if it has no proper 2-sided ideals. A
      semigroup is <E>completely simple</E> if it is simple and possesses
      minimal left and right ideals. A finite semigroup is simple if and only
      if it is completely simple.  An inverse semigroup is simple if and only
      if it is a group.
      <Example><![CDATA[
gap> S:=Semigroup( 
>  Transformation( [ 2, 2, 4, 4, 6, 6, 8, 8, 10, 10, 12, 12, 2 ] ), 
>  Transformation( [ 1, 1, 3, 3, 5, 5, 7, 7, 9, 9, 11, 11, 3 ] ), 
>  Transformation( [ 1, 7, 3, 9, 5, 11, 7, 1, 9, 3, 11, 5, 5 ] ), 
>  Transformation( [ 7, 7, 9, 9, 11, 11, 1, 1, 3, 3, 5, 5, 7 ] ) );;
gap> IsSimpleSemigroup(S);
true
gap> IsCompletelySimpleSemigroup(S);
true
gap> IsSimpleSemigroup(MinimalIdeal(BrauerMonoid(6)));
true
gap> R:=Range(IsomorphismReesMatrixSemigroup(
> MinimalIdeal(BrauerMonoid(6))));
<Rees matrix semigroup 15x15 over Group(())>]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsZeroGroup">
  <ManSection>
    <Prop Name="IsZeroGroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description> 
      <C>IsZeroGroup</C> returns <K>true</K> if the semigroup 
      <A>S</A> is a zero group and <K>false</K> if it is not.<P/>

      A semigroup <C>S</C> is a <E>zero group</E> if there exists an 
      element <C>z</C> in <C>S</C> such that <C>S</C> without <C>z</C> is a
      group and <C>x*z=z*x=z</C> for all <C>x</C> in <C>S</C>.
      Every zero group is an inverse semigroup. 
      <Example><![CDATA[
gap> S:=Semigroup(Transformation( [ 2, 2, 3, 4, 6, 8, 5, 5, 9 ] ),
> Transformation( [ 3, 3, 8, 2, 5, 6, 4, 4, 9 ] ),
> ConstantTransformation(9, 9));;
gap> IsZeroGroup(S);
true
gap> T:=Range(IsomorphismPartialPermSemigroup(S));;
gap> IsZeroGroup(T);
true
gap> IsZeroGroup(JonesMonoid(2));
true]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsZeroRectangularBand">
  <ManSection>
    <Prop Name="IsZeroRectangularBand" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsZeroRectangularBand</C> returns <K>true</K> if the semigroup 
      <A>S</A> is a zero rectangular band and <K>false</K> if it is not.<P/>

      A semigroup is a <E>0-rectangular band</E> if it is 0-simple and
      &H;-trivial; see also <Ref Prop="IsZeroSimpleSemigroup"/>
      and <Ref Prop="IsHTrivial"/>.
      An inverse semigroup is a 0-rectangular band if and only if it is a
      0-group; see <Ref Prop="IsZeroGroup"/>.
<Example><![CDATA[
gap> S:=Semigroup( 
>  Transformation( [ 1, 3, 7, 9, 1, 12, 13, 1, 15, 9, 1, 18, 1, 1, 13, 
>      1, 1, 21, 1, 1, 1, 1, 1, 25, 26, 1 ] ),
> Transformation( [ 1, 5, 1, 5, 11, 1, 1, 14, 1, 16, 17, 1, 1, 19, 1, 
>      11, 1, 1, 1, 23, 1, 16, 19, 1, 1, 1 ] ),
> Transformation( [ 1, 4, 8, 1, 10, 1, 8, 1, 1, 1, 10, 1, 8, 10, 1, 1, 
>      20, 1, 22, 1, 8, 1, 1, 1, 1, 1 ] ),
> Transformation( [ 1, 6, 6, 1, 1, 1, 6, 1, 1, 1, 1, 1, 6, 1, 6, 1, 1, 
>      6, 1, 1, 24, 1, 1, 1, 1, 6 ] ) );;
gap> IsZeroRectangularBand(Semigroup(Elements(GreensDClasses(S)[7]))); 
true
gap> IsZeroRectangularBand(Semigroup(Elements(GreensDClasses(S)[1])));
false]]></Example>
    </Description>
  </ManSection>  
<#/GAPDoc>

<#GAPDoc Label="IsZeroSemigroup">
  <ManSection>
    <Prop Name="IsZeroSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description> 
      <C>IsZeroSemigroup</C> returns <K>true</K> if the semigroup 
      <A>S</A> is a zero semigroup and <K>false</K> if it is not.<P/>

      A semigroup <C>S</C> is a <E>zero semigroup</E> if there exists an 
      element <C>z</C> in <C>S</C> such that <C>x*y=z</C> for all <C>x,y</C>
      in <C>S</C>. An inverse semigroup is a zero semigroup if and only if it
      is trivial. 

      <Example><![CDATA[
gap> S:=Semigroup( Transformation( [ 4, 7, 6, 3, 1, 5, 3, 6, 5, 9 ] ), 
> Transformation( [ 5, 3, 5, 1, 9, 3, 8, 7, 4, 3 ] ) );;
gap> IsZeroSemigroup(S);
false
gap> S:=Semigroup( Transformation( [ 7, 8, 8, 8, 5, 8, 8, 8 ] ), 
>  Transformation( [ 8, 8, 8, 8, 5, 7, 8, 8 ] ), 
>  Transformation( [ 8, 7, 8, 8, 5, 8, 8, 8 ] ), 
>  Transformation( [ 8, 8, 8, 7, 5, 8, 8, 8 ] ), 
>  Transformation( [ 8, 8, 7, 8, 5, 8, 8, 8 ] ) );;
gap> IsZeroSemigroup(S);
true
gap> MultiplicativeZero(S);
Transformation( [ 8, 8, 8, 8, 5, 8, 8, 8 ] )]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsZeroSimpleSemigroup">
  <ManSection>
    <Prop Name="IsZeroSimpleSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description>
      <C>IsZeroSimpleSemigroup</C> returns <K>true</K> if the semigroup
      <A>S</A> is 0-simple and <K>false</K> if it is not.<P/>

      A semigroup is a <E>0-simple</E> if it has no two-sided ideals other than
      itself and the set containing the zero element; see also <Ref
        Attr="MultiplicativeZero"/>. An inverse semigroup is 0-simple if and
      only if it is a Brandt semigroup; see <Ref Prop="IsBrandtSemigroup"/>.

      <Example><![CDATA[
gap> S:=Semigroup( 
>  Transformation( [ 1, 17, 17, 17, 17, 17, 17, 17, 17, 17, 5, 17, 
>  17, 17, 17, 17, 17 ] ), 
>  Transformation( [ 1, 17, 17, 17, 11, 17, 17, 17, 17, 17, 17, 17, 
>  17, 17, 17, 17, 17 ] ), 
>  Transformation( [ 1, 17, 17, 17, 17, 17, 17, 17, 17, 17, 4, 17, 
>  17, 17, 17, 17, 17 ] ), 
>  Transformation( [ 1, 17, 17, 5, 17, 17, 17, 17, 17, 17, 17, 17, 
>  17, 17, 17, 17, 17 ] ));;
gap> IsZeroSimpleSemigroup(S);
true
gap> S:=Semigroup(
> Transformation( [ 2, 3, 4, 5, 1, 8, 7, 6, 2, 7 ] ),
> Transformation([ 2, 3, 4, 5, 6, 8, 7, 1, 2, 2 ] ));;
gap> IsZeroSimpleSemigroup(S);
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCongruenceFreeSemigroup">
  <ManSection>
    <Prop Name="IsCongruenceFreeSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.  </Returns>
    <Description> 
      <C>IsCongruenceFreeSemigroup</C> returns <K>true</K> if the semigroup 
      <A>S</A> is a congruence-free semigroup and <K>false</K> if it is 
      not.<P/>

      A semigroup <A>S</A> is <E>congruence-free</E> if it has no non-trivial
      proper congruences.<P/>

      A semigroup with zero is congruence-free if and only if it is isomorphic
      to a regular Rees 0-matrix semigroup <C>R</C> whose underlying semigroup
      is the trivial group, no two rows of the matrix of <C>R</C> are identical,
      and no two columns are identical; see Theorem 3.7.1 in 
      <Cite Key="howie"/>.<P/>
     
      A semigroup without zero is congruence-free if and only if it is a simple
      group or has order 2; see Theorem 3.7.2 in <Cite Key="howie"/>.

      <Example><![CDATA[
gap> S := Semigroup( Transformation( [ 4, 2, 3, 3, 4 ] ) );;
gap> IsCongruenceFreeSemigroup(S);
true
gap> S := Semigroup( Transformation( [ 2, 2, 4, 4 ] ),
>  Transformation( [ 5, 3, 4, 4, 6, 6 ] ) );;
gap> IsCongruenceFreeSemigroup(S);
false]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

#EOF
