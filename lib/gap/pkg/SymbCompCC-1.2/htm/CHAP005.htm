<html><head><title>[SymbCompCC] 5 Schur extensions for p-power-poly-pcp-groups</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP004.htm">Previous</a>] [<a href = "theindex.htm">Index</a>]
<h1>5 Schur extensions for p-power-poly-pcp-groups</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP005.htm#SECT001">Computing Schur extensions</a>
<li> <A HREF="CHAP005.htm#SECT002">Computing other invariants from Schur extensions</a>
<li> <A HREF="CHAP005.htm#SECT003">Info classes for the computation of the Schur extension</a>
</ol><p>
<p>
In this chapter we describe how the consistent pp-presentations
of infinite coclass sequences can be used to compute a pp-presentation for 
the corresponding Schur extensions (see <a href="biblio.htm#EF11"><cite>EF11</cite></a>).
<p>
For a group <i>G</i> = <i>F</i>/<i>R</i> the Schur extension <i>H</i> is defined as <i>H</i> = <i>F</i>/[<i>F</i>,<i>R</i>] 
(see <a href="biblio.htm#EN08"><cite>EN08</cite></a>).
<p>
So for a parameter <var>x</var> that can take values in the positive integers, let 
(<i>G</i><sub><i>x</i></sub> = <i>F</i>/<i>R</i><sub><i>x</i></sub> &#124; <i>x</i>  &#8712; <b>N</b>), for <b>N</b> the positive integers, describe an 
infinite coclass sequence of finite <i>p</i>-groups <i>G</i><sub><i>X</i></sub> of coclass <i>r</i>. Then for 
each value for the parameter <var>x</var>, the group <i>G</i><sub><i>x</i></sub> has a consistent polycyclic 
presentation with generators <i>g</i><sub>1</sub>, &#183;.&#183;, <i>g</i><sub><i>n</i></sub>, <i>t</i><sub>1</sub>, &#183;.&#183;, <i>t</i><sub><i>d</i></sub> and relations
<p>
<br clear="all" /><table border="0" width="100%"><tr><td> <table border="0" cellspacing="0" cellpadding="0"> <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left"> </td></tr></table></td><td nowrap="nowrap" align="left"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">&nbsp;<i>g</i><sub><i>i</i></sub><sup><i>p</i></sup> = <i>rel</i>[<i>i</i>][<i>i</i>],</td></tr></table></td><td width="50%"></td></tr> <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left"> </td></tr></table></td><td nowrap="nowrap" align="left"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">&nbsp;<i>t</i><sub><i>i</i></sub><sup><i>expo</i></sup> = <i>rel</i>[<i>n</i>+<i>i</i>][<i>n</i>+<i>i</i>],</td></tr></table></td><td width="50%"></td></tr> <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left"> </td></tr></table></td><td nowrap="nowrap" align="left"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">&nbsp;<i>g</i><sub><i>i</i></sub><sup><i>g</i><sub><i>j</i></sub></sup> = <i>rel</i>[<i>j</i>][<i>i</i>],</td></tr></table></td><td width="50%"></td></tr> <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left"> </td></tr></table></td><td nowrap="nowrap" align="left"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">&nbsp;<i>t</i><sub><i>i</i></sub><sup><i>g</i><sub><i>j</i></sub></sup> = <i>rel</i>[<i>j</i>][<i>n</i>+<i>i</i>],</td></tr></table></td><td width="50%"></td></tr> <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left"> </td></tr></table></td><td nowrap="nowrap" align="left"><table><tr><td nowrap="nowrap" align="right" colspan="1">&nbsp;<i>t</i><sub><i>i</i></sub><sup><i>t</i><sub><i>j</i></sub></sup> = 1&#183;</td></tr></table></td></tr></table> </td></tr></table>
<p>
Then we compute a consistent pp-presentation of the corresponding Schur 
extensions of with generators <i>g</i><sub>1</sub>, &#183;.&#183;, <i>g</i><sub><i>n</i></sub>, <i>t</i><sub>1</sub>, &#183;.&#183;, <i>t</i><sub><i>d</i></sub>, <i>c</i><sub>1</sub>, &#183;.&#183;<i>c</i><sub><i>m</i></sub> and
relations
<p>
<br clear="all" /><table border="0" width="100%"><tr><td> <table border="0" cellspacing="0" cellpadding="0"> <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left"> </td></tr></table></td><td nowrap="nowrap" align="left"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">&nbsp;<i>g</i><sub><i>i</i></sub><sup><i>p</i></sup>=<i>rel</i>[<i>i</i>][<i>i</i>],</td></tr></table></td><td width="50%"></td></tr> <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left"> </td></tr></table></td><td nowrap="nowrap" align="left"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">&nbsp;<i>t</i><sub><i>i</i></sub><sup><i>expo</i></sup> = <i>rel</i>[<i>n</i>+<i>i</i>][<i>n</i>+<i>i</i>],</td></tr></table></td><td width="50%"></td></tr> <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left"> </td></tr></table></td><td nowrap="nowrap" align="left"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">&nbsp;<i>c</i><sub><i>i</i></sub><sup><i>expo</i>_<i>vec</i>[<i>i</i>]</sup> = <i>rel</i>[<i>n</i>+<i>d</i>+<i>i</i>,<i>n</i>+<i>d</i>+<i>i</i>],</td></tr></table></td><td width="50%"></td></tr> <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left"> </td></tr></table></td><td nowrap="nowrap" align="left"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">&nbsp;<i>g</i><sub><i>i</i></sub><sup><i>g</i><sub><i>j</i></sub></sup> = <i>rel</i>[<i>j</i>][<i>i</i>], </td></tr></table></td><td width="50%"></td></tr> <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left"> </td></tr></table></td><td nowrap="nowrap" align="left"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">&nbsp;<i>t</i><sub><i>i</i></sub><sup><i>g</i><sub><i>j</i></sub></sup> = <i>rel</i>[<i>j</i>][<i>n</i>+<i>i</i>],</td></tr></table></td><td width="50%"></td></tr> <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left"> </td></tr></table></td><td nowrap="nowrap" align="left"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">&nbsp;<i>t</i><sub><i>i</i></sub><sup><i>t</i><sub><i>j</i></sub></sup> = <i>rel</i>[<i>n</i>+<i>j</i>][<i>n</i>+<i>i</i>],</td></tr></table></td><td width="50%"></td></tr> <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left"> </td></tr></table></td><td nowrap="nowrap" align="left"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">&nbsp;<i>c</i><sub><i>i</i></sub><sup><i>g</i><sub><i>j</i></sub></sup> = 1, </td></tr></table></td><td width="50%"></td></tr> <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left"> </td></tr></table></td><td nowrap="nowrap" align="left"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">&nbsp;<i>c</i><sub><i>i</i></sub><sup><i>t</i><sub><i>j</i></sub></sup> = 1, </td></tr></table></td><td width="50%"></td></tr> <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left"> </td></tr></table></td><td nowrap="nowrap" align="left"><table><tr><td nowrap="nowrap" align="right" colspan="1">&nbsp;<i>c</i><sub><i>i</i></sub><sup><i>c</i><sub><i>j</i></sub></sup> = 1&#183;</td></tr></table></td></tr></table> </td></tr></table>
<p>
where the <i>t</i><sub><i>i</i></sub>'s commute modulo <i>c</i><sub>1</sub>, &#183;.&#183;, <i>c</i><sub><i>m</i></sub>  and the <i>c</i><sub><i>i</i></sub>'s are 
central. 
<p>
<p>
<h2><a name="SECT001">5.1 Computing Schur extensions</a></h2>
<p><p>
<a name = "SSEC001.2"></a>
<li><code>SchurExtParPres( </code><var>G</var><code> )</code>
<p>
computes the Schur extensions corresponding to the <var>p</var>-power-poly-pcp-groups
<var>G</var> and returns them as <var>p</var>-power-poly-pcp-groups.
<p>
<li><code>SchurExtParPres( </code><var>ParPres</var><code> ) F</code>
<p>
computes a consistent pp-presentation of Schur extensions of the 
groups defined by the record <var>ParPres</var> which describes 
<var>p</var>-power-poly-pcp-groups. The output is a record 
<var>rec</var>(<var>rel</var>, <var>expo</var>, <var>n</var>, <var>d</var>, <var>m</var>, <var>prime</var>, <var>cc</var>, <var>expo_vec</var>, <var>name</var>), 
which describes the Schur extensions as <var>p</var>-power-poly-pcp-groups; it is 
encoded in a form that it can be used as input for 
<a href="CHAP003.htm#SSEC002.1">PPPPcpGroups</a>.
<p>
<pre>
gap&gt; SchurExtParPres( ParPresGlobalVar_2_1[1] );
rec( prime := 2, 
  rel := [ [ [ [ 7, 1 ] ] ], [ [ [ 2, 1 ], [ 3, -1+2*2^x ], [ 6, 1-2*2^x ] ], 
          [ [ 3, 1 ], [ 5, 1 ] ] ], 
      [ [ [ 3, -1+2*2^x ], [ 4, 1 ], [ 6, 2-2*2^x ] ], [ [ 3, 1 ] ], 
          [ [ 4, 1 ], [ 6, 2*2^x ] ] ], 
      [ [ [ 4, 1 ] ], [ [ 4, 1 ] ], [ [ 4, 1 ] ], [ [ 4, 0 ] ] ], 
      [ [ [ 5, 1 ] ], [ [ 5, 1 ] ], [ [ 5, 1 ] ], [ [ 5, 1 ] ], [ [ 5, 0 ] ] ]
        , 
      [ [ [ 6, 1 ] ], [ [ 6, 1 ] ], [ [ 6, 1 ] ], [ [ 6, 1 ] ], [ [ 6, 1 ] ], 
          [ [ 6, 0 ] ] ], 
      [ [ [ 7, 1 ] ], [ [ 7, 1 ] ], [ [ 7, 1 ] ], [ [ 7, 1 ] ], [ [ 7, 1 ] ], 
          [ [ 7, 1 ] ], [ [ 7, 0 ] ] ] ], n := 2, d := 1, m := 4, 
  expo := 2*2^x, expo_vec := [ 2, 0, 0, 0 ], cc := fail, name := "SchurExt_D" 
 )
</pre>
<p>
<p>
<h2><a name="SECT002">5.2 Computing other invariants from Schur extensions</a></h2>
<p><p>
<a name = "SSEC002.1"></a>
<li><code>SchurMultiplicatorsStructurePPPPcps( </code><var>G</var><code> ) F</code>
<p>
computes the abalian invariants of the Schur multiplicators <var>M(G)</var> of the 
<var>p</var>-power-poly-pcp-groups <var>G</var>. The output is a list [<i>d</i><sub>1</sub>, &#183;.&#183;, <i>d</i><sub><i>k</i></sub>] 
consisting elements <i>d</i><sub><i>i</i></sub>, depending on the underlying parameter, such that 
<i>M</i>(<i>G</i>)  &#8773; <i>C</i><sub><i>d</i><sub>1</sub></sub> &times;&#8230;&times;<i>C</i><sub><i>d</i><sub><i>k</i></sub></sub>.
<p>
<pre>
gap&gt; G := PPPPcpGroups( ParPresGlobalVar_2_1[1] );
&lt; P-Power-Poly pcp-groups with 3 generators of relative orders [ 2,2,2*2^x ] &gt;
SchurMultiplicatorsStructurePPPPcps( G );
[ 2 ]
</pre>
<p>
<a name = "SSEC002.2"></a>
<li><code>SchurMultiplicator( </code><var>G</var><code> ) F</code>
<p>
computes the Schur multiplicators of the <var>p</var>-power-poly-pcp-groups <var>G</var> and 
then returns the corresponding 
<a href="CHAP003.htm#SSEC002.1">PPPPcpGroups</a>.
<p>
<pre>
gap&gt; G := PPPPcpGroup( ParPresGlobalVar_3_1[1] );
&lt; P-Power-Poly pcp-group with 5 generators of relative orders [ 3,3,3,3*3^x,3*3^x ] &gt;
gap&gt; SchurMultiplicator( G );
&lt; P-Power-Poly pcp-groups with 2 generators of relative orders [ 3,9*3^x ] &gt;
</pre>
<p>
<a name = "SSEC002.3"></a>
<li><code>AbelianInvariants( </code><var>G</var><code> ) F</code>
<p>
computes the abelian invariants of the <var>p</var>-power-poly-pcp-groups <var>G</var> and returns
them as a list of list describing the parametrised elements.
<p>
<pre>
gap&gt; G := PPPPcpGroups( ParPresGlobalVar_2_1[1] );
&lt; P-Power-Poly pcp-groups with 3 generators of relative orders [ 2,2,2*2^x ] &gt;
gap&gt; AbelianInvariants( G );
[ 2, 2 ]
</pre>
<p>
<a name = "SSEC002.4"></a>
<li><code>ZeroCohomologyPPPPcps( </code><var>G</var><code>[, </code><var>p</var><code>] ) F</code>
<p>
computes the zero-th-cohomology groups <i>H</i><sup>0</sup>(<i>G</i>,<i>R</i>) of the 
<var>p</var>-power-poly-pcp-groups <var>G</var> with coefficients in <i>R</i>, where <i>R</i>  &#8773; <i>GF</i>(<i>p</i>) if
the prime <i>p</i> is given or <i>R</i>  &#8773; <b>Z</b> otherwise. The action of <i>G</i> on <i>R</i> is
taken to be trivial. The function returns a list of integers [<i>a</i><sub>1</sub>,&#8230;, <i>a</i><sub><i>k</i></sub>] where the cohomology group is isomorphic to <i>C</i><sub><i>a</i><sub>1</sub></sub> &times;&#8230;&times;<i>C</i><sub><i>a</i><sub><i>k</i></sub></sub> with <i>C</i><sub><i>i</i></sub> a cyclic group of order <i>i</i> (for <i>i</i>  &gt;  0) and <i>C</i><sub>0</sub> 
is interpreted as <b>Z</b>.
<p>
<pre>
gap&gt; G := PPPPcpGroups( ParPresGlobalVar_2_1[1] );
&lt; P-Power-Poly pcp-groups with 3 generators of relative orders [ 2,2,2*2^x ] &gt;
gap&gt; ZeroCohomologyPPPPcp( G, 2 );
[ 2 ]
</pre>
<p>
<a name = "SSEC002.5"></a>
<li><code>FirstCohomologyPPPPcps( </code><var>G</var><code>[, </code><var>p</var><code>] ) F</code>
<p>
computes the first-cohomology groups <i>H</i><sup>1</sup>(<i>G</i>,<i>R</i>) of the 
<var>p</var>-power-poly-pcp-groups <var>G</var> with coefficients in <i>R</i>, where <i>R</i>  &#8773; <i>GF</i>(<i>p</i>) if
the prime <i>p</i> is given or <i>R</i>  &#8773; <b>Z</b> otherwise. The action of <i>G</i> on <i>R</i> is
taken to be trivial. The function returns a list of integers [<i>a</i><sub>1</sub>,&#8230;, <i>a</i><sub><i>k</i></sub>] where the cohomology group is isomorphic to <i>C</i><sub><i>a</i><sub>1</sub></sub> &times;&#8230;&times;<i>C</i><sub><i>a</i><sub><i>k</i></sub></sub> with <i>C</i><sub><i>i</i></sub> a cyclic group of order <i>i</i> (for <i>i</i>  &gt;  0) and <i>C</i><sub>0</sub> 
is interpreted as <b>Z</b>.
<p>
<pre>
gap&gt; G := PPPPcpGroups( ParPresGlobalVar_2_1[1] );
&lt; P-Power-Poly pcp-groups with 3 generators of relative orders [ 2,2,2*2^x ] &gt;
gap&gt; FirstCohomologyPPPPcps( G );
[  ]
</pre>
<p>
<a name = "SSEC002.6"></a>
<li><code>SecondCohomologyPPPPcps( </code><var>G</var><code>[, </code><var>p</var><code>] ) F</code>
<p>
computes the second-cohomology groups <i>H</i><sup>2</sup>(<i>G</i>,<i>R</i>) of the 
<var>p</var>-power-poly-pcp-groups <var>G</var> with coefficients in <i>R</i>, where <i>R</i>  &#8773; <i>GF</i>(<i>p</i>) if
the prime <i>p</i> is given or <i>R</i>  &#8773; <b>Z</b> otherwise. The action of <i>G</i> on <i>R</i> is
taken to be trivial. The function returns a list of integers [<i>a</i><sub>1</sub>,&#8230;, <i>a</i><sub><i>k</i></sub>] where the cohomology group is isomorphic to <i>C</i><sub><i>a</i><sub>1</sub></sub> &times;&#8230;&times;<i>C</i><sub><i>a</i><sub><i>k</i></sub></sub> with <i>C</i><sub><i>i</i></sub> a cyclic group of order <i>i</i> (for <i>i</i>  &gt;  0) and <i>C</i><sub>0</sub> 
is interpreted as <b>Z</b>.
<p>
<pre>
gap&gt; G := PPPPcpGroups( ParPresGlobalVar_2_1[1] );
&lt; P-Power-Poly pcp-groups with 3 generators of relative orders [ 2,2,2*2^x ] &gt;
gap&gt; SecondCohomologyPPPPcps( G, 2 );
[ 2, 2, 2 ]
</pre>
<p>
<p>
<h2><a name="SECT003">5.3 Info classes for the computation of the Schur extension</a></h2>
<p><p>
The following info classes are available
<p>
<a name = "SSEC003.1"></a>
<li><code>InfoConsistencyRelPPowerPoly V</code>
<p>
<p>
<dl compact>
<dt><code>level 1</code> <dd> shows which consistency relations are computed and gives the 
result;
</dl>
<p>
the default value is 0.
<p>
<a name = "SSEC003.2"></a>
<li><code>InfoCollectingPPowerPoly V</code>
<p>
<p>
<dl compact>
<dt><code>level 1</code> <dd> shows what is done during collecting;
</dl>
<p>
the default value is 0.
<p>
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP004.htm">Previous</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>SymbCompCC manual<br>November 2011
</address></body></html>