<html><head><title>[Unipot] 2 The GAP Package Unipot</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP001.htm">Previous</a>] [<a href = "theindex.htm">Index</a>]
<h1>2 The GAP Package Unipot</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP002.htm#SECT001">General functionality</a>
<li> <A HREF="CHAP002.htm#SECT002">Unipotent subgroups of Chevalley groups</a>
<li> <A HREF="CHAP002.htm#SECT003">Elements of unipotent subgroups of Chevalley groups</a>
<li> <A HREF="CHAP002.htm#SECT004">Symbolic computation</a>
</ol><p>
<p>
This  chapter  describes  the  package  <font face="Gill Sans,Helvetica,Arial">Unipot</font>.  Mainly,  the  package
provides the ability to compute  with  elements of unipotent subgroups of
Chevalley groups, but also some properties of this groups.
<p>
In this chapter we will refer to unipotent subgroups of Chevalley  groups
as ``unipotent  subgroups'' and  to elements  of unipotent  subgroups  as
``unipotent   elements''.  Specifically,   we  only  consider   unipotent
subgroups generated by all positive root elements.
<p>
<p>
<h2><a name="SECT001">2.1 General functionality</a></h2>
<p><p>
In this section we  will  describe the  general functionality provided by
this package.
<p>
<a name = "SSEC001.1"></a>
<li><code>UnipotChevInfo V</code>
<p>
<code>UnipotChevInfo</code>  is an <code>InfoClass</code> used  in this package. <code>InfoLevel</code> of
this <code>InfoClass</code> is set to  1 by default and can be changed to  any level
by <code>SetInfoLevel( UnipotChevInfo, </code><var>n</var><code> )</code>.
<p>
Following levels are used throughout the package:
<dl compact>
<ol type=1>
<li>
    ---
<li>
    When calculating the order of a finite unipotent subgroup,  the power
    presentation of this number is printed.
    (See <a href="CHAP002.htm#SSEC002.5">Size!for `UnipotChevSubGr'</a> for an example)
<li>
    When  comparing  unipotent  elements,  output,  for which of them the
    canonical form must be computed.
    (See <a href="CHAP002.htm#SSEC003.11">Equality!for UnipotChevElem</a> for an example)
<li>
    ---
<li>
    While calculating the canonical form, output the different steps.
<li>
    The  process  of  calculating  the  Chevalley commutator constants is
    printed on the screen
</dl></dl>
<p>
<p>
<h2><a name="SECT002">2.2 Unipotent subgroups of Chevalley groups</a></h2>
<p><p>
In this section we will describe the functionality for unipotent
subgroups provided by this package.
<p>
<a name = "SSEC002.1"></a>
<li><code>IsUnipotChevSubGr( </code><var>grp</var><code> ) C</code>
<p>
Category for unipotent subgroups.
<p>
<a name = "SSEC002.2"></a>
<li><code>UnipotChevSubGr( </code><var>type</var><code>, </code><var>n</var><code>, </code><var>F</var><code> ) F</code>
<p>
<code>UnipotChevSubGr</code>  returns  the  unipotent  subgroup <var>U</var> of the Chevalley
group of type <var>type</var>, rank <var>n</var> over the ring <var>F</var>.
<p>
<var>type</var> must be one of <code>"A"</code>, <code>"B"</code>, <code>"C"</code>, <code>"D"</code>, <code>"E"</code>, <code>"F"</code>, <code>"G"</code>.
<p>
For the type  <code>"A"</code>, <var>n</var> must be a positive integer.
<p>
For the types <code>"B"</code> and <code>"C"</code>, <var>n</var> must be a positive integer <var>geq2</var>.
<p>
For the type  <code>"D"</code>, <var>n</var> must be a positive integer <var>geq4</var>.
<p>
For the type  <code>"E"</code>, <var>n</var> must be one of <var>6, 7, 8</var>.
<p>
For the type  <code>"F"</code>, <var>n</var> must be <var>4</var>.
<p>
For the type  <code>"G"</code>, <var>n</var> must be <var>2</var>.
<p>
<pre>
gap&gt; U_G2 := UnipotChevSubGr("G", 2, Rationals);
&lt;Unipotent subgroup of a Chevalley group of type G2 over Rationals&gt;
gap&gt; IsUnipotChevSubGr(U_G2);
true
</pre>
<pre>
gap&gt; UnipotChevSubGr("E", 3, Rationals);
Error, &lt;n&gt; must be one of 6, 7, 8 for type E  called from
UnipotChevFamily( type, n, F ) called from
&lt;function&gt;( &lt;arguments&gt; ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk&gt;
</pre>
<p>
<a name = "SSEC002.3"></a>
<li><code>PrintObj( </code><var>U</var><code> ) M</code>
<a name = "SSEC002.3"></a>
<li><code>ViewObj( </code><var>U</var><code> ) M</code>
<p>
Special methods for unipotent  subgroups.  (see  <font face="Gill Sans,Helvetica,Arial">GAP</font> Reference Manual,
section  <a href="../../../doc/htm/ref/CHAP006.htm#SECT002">View  and  Print</a>  for general  information  on <code>View</code>  and
<code>Print</code>)
<p>
<pre>
gap&gt; Print(U_G2);
UnipotChevSubGr( "G", 2, Rationals )gap&gt; View(U_G2);
&lt;Unipotent subgroup of a Chevalley group of type G2 over Rationals&gt;gap&gt;
</pre>
<p>
<a name = "SSEC002.4"></a>
<li><code>One( </code><var>U</var><code> ) M</code>
<a name = "SSEC002.4"></a>
<li><code>OneOp( </code><var>U</var><code> ) M</code>
<p>
Special  methods  for unipotent  subgroups. Return the  identity
element   of   the   group  <var>U</var>.   The   returned   element  has
representation <code>UNIPOT_DEFAULT_REP</code> (see <a href="CHAP002.htm#SSEC003.3">UNIPOT_DEFAULT_REP</a>).
<p>
<a name = "SSEC002.5"></a>
<li><code>Size( </code><var>U</var><code> ) M</code>
<p>
<code>Size</code> returns  the order  of a unipotent subgroup.  This  is  a
special  method for  unipotent  subgroups  using the  result  in
Carter <a href="biblio.htm#Carter72"><cite>Carter72</cite></a>, Theorem 5.3.3 (ii).
<p>
<pre>
gap&gt; SetInfoLevel( UnipotChevInfo, 2 );
gap&gt; Size( UnipotChevSubGr("E", 8, GF(7)) );
#I  The order of this group is 7^120 which is
25808621098934927604791781741317238363169114027609954791128059842592785343731\
7437263620645695945672001
gap&gt; SetInfoLevel( UnipotChevInfo, 1 );
</pre>
<p>
<a name = "SSEC002.6"></a>
<li><code>RootSystem( </code><var>U</var><code> ) M</code>
<p>
This  method is similar  to the  method <code>RootSystem</code>  for semisimple  Lie
algebras (see Section <a href="../../../doc/htm/ref/CHAP061.htm#SECT007">Semisimple  Lie Algebras and Root  Systems</a> in
the <font face="Gill Sans,Helvetica,Arial">GAP</font> Reference Manual for further information).
<p>
<code>RootSystem</code> returns the underlying root system of the unipotent subgroup
<var>U</var>. The returned object is from the category <code>IsRootSystem</code>:
<p>
<pre>
gap&gt; R_G2 := RootSystem(U_G2);
&lt;root system of rank 2&gt;
gap&gt; IsRootSystem(last);
true
gap&gt; SimpleSystem(R_G2);
[ [ 2, -1 ], [ -3, 2 ] ]
gap&gt;
</pre>
<p>
Additionally to the properties and attributes described in the  Reference
Manual, following attributes  are installed for the  Root  Systems by the
package <font face="Gill Sans,Helvetica,Arial">Unipot</font>:
<p>
<a name = "SSEC002.7"></a>
<li><code>PositiveRootsFC( </code><var>R</var><code> ) A</code>
<a name = "SSEC002.7"></a>
<li><code>NegativeRootsFC( </code><var>R</var><code> ) A</code>
<p>
The list of positive resp. negative  roots of the root system <var>R</var>.  Every
root is  represented as a list of coefficients  of the linear combination
in fundamental  roots. E.g.  let  <var>r=sum<sub>i=1</sub><sup>l</sup>  k<sub>i</sub>r<sub>i</sub></var>,  where  <var>r<sub>1</sub>,
..., r<sub>l</sub></var> are the  fundamental roots,  then  <var>r</var> is represented as  the
list <var>[k<sub>1</sub>, ..., k<sub>l</sub>]</var>.
<p>
<pre>
gap&gt; U_E6 := UnipotChevSubGr("E",6,GF(2));
&lt;Unipotent subgroup of a Chevalley group of type E6 over GF(2)&gt;
gap&gt; R_E6 := RootSystem(U_E6);
&lt;root system of rank 6&gt;
gap&gt; PositiveRoots(R_E6){[1..6]};
[ [ 2,  0, -1, 0,  0, 0 ], [ 0, 2, 0, -1, 0,  0 ], [ -1, 0, 2, -1,  0, 0 ],
  [ 0, -1, -1, 2, -1, 0 ], [ 0, 0, 0, -1, 2, -1 ], [  0, 0, 0,  0, -1, 2 ] ]
gap&gt; PositiveRootsFC(R_E6){[1..6]};
[ [ 1, 0, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0, 0 ], [ 0, 0, 1, 0, 0, 0 ],
  [ 0, 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 1, 0 ], [ 0, 0, 0, 0, 0, 1 ] ]
gap&gt;
gap&gt; PositiveRootsFC(R)[Length(PositiveRootsFC(R_E6))]; # the highest root
[ 1, 2, 2, 3, 2, 1 ]
</pre>
<p>
<a name = "SSEC002.8"></a>
<li><code>GeneratorsOfGroup( </code><var>U</var><code> ) M</code>
<p>
This  is a special Method  for unipotent  subgroups of  finite  Chevalley
groups.
<p>
<a name = "SSEC002.9"></a>
<li><code>Representative( </code><var>U</var><code> ) M</code>
<p>
This method  returns  an  element  of  the  unipotent  subgroup  <var>U</var> with
indeterminates  instead of ring elements. Such  an element could be  used
for  symbolic  computations (see  <a href="CHAP002.htm#SECT004">Symbolic Computation</a>).  The  returned
element      has       representation      <code>UNIPOT_DEFAULT_REP</code>      (see
<a href="CHAP002.htm#SSEC003.3">UNIPOT_DEFAULT_REP</a>).
<p>
<pre>
gap&gt; Representative(U_G2);
x_{1}( t_1 ) * x_{2}( t_2 ) * x_{3}( t_3 ) * x_{4}( t_4 ) * 
x_{5}( t_5 ) * x_{6}( t_6 )
</pre>
<p>
<a name = "SSEC002.10"></a>
<li><code>CentralElement( </code><var>U</var><code> ) M</code>
<p>
This  method  returns  the  representative of  the  center of <var>U</var> without
calculating the center.
<p>
<p>
<h2><a name="SECT003">2.3 Elements of unipotent subgroups of Chevalley groups</a></h2>
<p><p>
In this section we will describe the functionality for unipotent elements
provided by this package.
<p>
<a name = "SSEC003.1"></a>
<li><code>IsUnipotChevElem( </code><var>elm</var><code> ) C</code>
<p>
Category for elements of a unipotent subgroup.
<p>
<a name = "SSEC003.2"></a>
<li><code>IsUnipotChevRepByRootNumbers( </code><var>elm</var><code> ) R</code>
<a name = "SSEC003.2"></a>
<li><code>IsUnipotChevRepByFundamentalCoeffs( </code><var>elm</var><code> ) R</code>
<a name = "SSEC003.2"></a>
<li><code>IsUnipotChevRepByRoots( </code><var>elm</var><code> ) R</code>
<p>
<code>IsUnipotChevRepByRootNumbers</code>, <code>IsUnipotChevRepByFundamentalCoeffs</code>  and
<code>IsUnipotChevRepByRoots</code>  are  different  representations  for  unipotent
elements.
<p>
Roots of elements with representation <code>IsUnipotChevRepByRootNumbers</code>  are
represented       by       their       numbers       (positions)       in
<code>PositiveRoots(RootSystem(</code><var>U</var><code>))</code>.
<p>
Roots          of          elements          with          representation
<code>IsUnipotChevRepByFundamentalCoeffs</code>  are  represented  by   elements  of
<code>PositiveRootsFC(RootSystem(</code><var>U</var><code>))</code>.
<p>
Roots  of   elements  with  representation  <code>IsUnipotChevRepByRoots</code>  are
represented     by     roots     themself,      i.e.      elements     of
<code>PositiveRoots(RootSystem(</code><var>U</var><code>))</code>.
<p>
(See  <a href="CHAP002.htm#SSEC003.4">UnipotChevElemByRootNumbers</a>,  <a href="CHAP002.htm#SSEC003.5">UnipotChevElemByFundamentalCoeffs</a>
and <a href="CHAP002.htm#SSEC003.6">UnipotChevElemByRoots</a> for examples.)
<p>
<a name = "SSEC003.3"></a>
<li><code>UNIPOT_DEFAULT_REP V</code>
<p>
This variable  contains  the  default representation  for  newly  created
elements, e.g. created by  <code>One</code> or <code>Random</code>. When  <font face="Gill Sans,Helvetica,Arial">Unipot</font>  is loaded,
the  default representation is  <code>IsUnipotChevRepByRootNumbers</code> and can be
changed by assigning a new value to <code>UNIPOT_DEFAULT_REP</code>.
<p>
<pre>
gap&gt; UNIPOT_DEFAULT_REP := IsUnipotChevRepByFundamentalCoeffs;;
</pre>
<p>
<strong>Note</strong> that <font face="Gill Sans,Helvetica,Arial">Unipot</font> doesn't check the type of this  value, i.e. you may
assign any value to <code>UNIPOT_DEFAULT_REP</code>, which  may  result in errors in
following commands:
<p>
<pre>
gap&gt; UNIPOT_DEFAULT_REP := 3;;
gap&gt; One( U_G2 );
... Error message ...
</pre>
<p>
<a name = "SSEC003.4"></a>
<li><code>UnipotChevElemByRootNumbers( </code><var>U</var><code>, </code><var>roots</var><code>, </code><var>felems</var><code> ) O</code>
<li><code>UnipotChevElemByRootNumbers( </code><var>U</var><code>, </code><var>root</var><code>, </code><var>felem</var><code> ) O</code>
<a name = "SSEC003.4"></a>
<li><code>UnipotChevElemByRN( </code><var>U</var><code>, </code><var>roots</var><code>, </code><var>felems</var><code> ) O</code>
<li><code>UnipotChevElemByRN( </code><var>U</var><code>, </code><var>root</var><code>, </code><var>felem</var><code> ) O</code>
<p>
<code>UnipotChevElemByRootNumbers</code> returns  an element of a unipotent subgroup
<var>U</var>    with    representation    <code>IsUnipotChevRepByRootNumbers</code>    (see
<a href="CHAP002.htm#SSEC003.2">IsUnipotChevRepByRootNumbers</a>).
<p>
<var>roots</var> should be a list of root numbers, i.e. integers from the range 1,
...,  <code>Length(PositiveRoots(RootSystem(</code><var>U</var><code>)))</code>. And <var>felems</var> a list  of
corresponding ring elements or indeterminates over that ring  (see <font face="Gill Sans,Helvetica,Arial">GAP</font>
Reference   Manual,   <a href="../../../doc/htm/ref/CHAP064.htm#SSEC001.1">Indeterminate</a>  for  general   information  on
indeterminates  or  section  <a href="CHAP002.htm#SECT004">Symbolic computation</a>  of  this  manual for
examples).
<p>
The second  variant of  <code>UnipotChevElemByRootNumbers</code>  is an abbreviation
for the first one if <var>roots</var> and <var>felems</var> contain only one element.
<p>
<code>UnipotChevElemByRN</code> is just a synonym for <code>UnipotChevElemByRootNumbers</code>.
<p>
<pre>
gap&gt; IsIdenticalObj( UnipotChevElemByRN, UnipotChevElemByRootNumbers );
true
gap&gt; y := UnipotChevElemByRootNumbers(U_G2, [1,5], [2,7] );
x_{1}( 2 ) * x_{5}( 7 )
gap&gt; x := UnipotChevElemByRootNumbers(U_G2, 1, 2);
x_{1}( 2 )
</pre>
<p>
In this example we create two elements: <var>x<sub>r_1</sub>( 2 ) . x<sub>r_5</sub>( 7 )</var> and
<var>x<sub>r_1</sub>(  2  )</var>, where <var>r<sub>i</sub>, i = 1,  ..., 6</var> are the positive roots in
<code>PositiveRoots(RootSystem(</code><var>U</var><code>))</code> and <var>x<sub>r_i</sub>(t),  i  = 1, ..., 6</var>  the
corresponding root elements.
<p>
<a name = "SSEC003.5"></a>
<li><code>UnipotChevElemByFundamentalCoeffs( </code><var>U</var><code>, </code><var>roots</var><code>, </code><var>felems</var><code> ) O</code>
<li><code>UnipotChevElemByFundamentalCoeffs( </code><var>U</var><code>, </code><var>root</var><code>, </code><var>felem</var><code> ) O</code>
<a name = "SSEC003.5"></a>
<li><code>UnipotChevElemByFC( </code><var>U</var><code>, </code><var>roots</var><code>, </code><var>felems</var><code> ) O</code>
<li><code>UnipotChevElemByFC( </code><var>U</var><code>, </code><var>root</var><code>, </code><var>felem</var><code> ) O</code>
<p>
<code>UnipotChevElemByFundamentalCoeffs</code>  returns  an  element  of a unipotent
subgroup  <var>U</var>  with  representation  <code>IsUnipotChevRepByFundamentalCoeffs</code>
(see <a href="CHAP002.htm#SSEC003.2">IsUnipotChevRepByFundamentalCoeffs</a>).
<p>
<var>roots</var>      should      be      a     list      of      elements      of
<code>PositiveRootsFC(RootSystem(</code><var>U</var><code>))</code>.   And   <var>felems</var>    a    list    of
corresponding ring elements or indeterminates over that ring  (see <font face="Gill Sans,Helvetica,Arial">GAP</font>
Reference   Manual,   <a href="../../../doc/htm/ref/CHAP064.htm#SSEC001.1">Indeterminate</a>  for  general   information  on
indeterminates  or  section  <a href="CHAP002.htm#SECT004">Symbolic computation</a>  of  this  manual for
examples).
<p>
The   second   variant  of   <code>UnipotChevElemByFundamentalCoeffs</code>   is  an
abbreviation for  the first one if <var>roots</var> and  <var>felems</var> contain only one
element.
<p>
<code>UnipotChevElemByFC</code>       is       just       a        synonym       for
<code>UnipotChevElemByFundamentalCoeffs</code>.
<p>
<pre>
gap&gt; PositiveRootsFC(RootSystem(U_G2));
[ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ], [ 2, 1 ], [ 3, 1 ], [ 3, 2 ] ]
gap&gt; y1 := UnipotChevElemByFundamentalCoeffs( U_G2, [[ 1, 0 ], [ 3, 1 ]], [2,7] );
x_{[ 1, 0 ]}( 2 ) * x_{[ 3, 1 ]}( 7 )
gap&gt; x1 := UnipotChevElemByFundamentalCoeffs( U_G2, [ 1, 0 ], 2 );
x_{[ 1, 0 ]}( 2 )
</pre>
<p>
In   this   example   we   create   the   same   two   elements   as   in
<a href="CHAP002.htm#SSEC003.4">UnipotChevElemByRootNumbers</a>: <var>x<sub>[  1, 0 ]</sub>( 2  ) . x<sub>[ 3, 1 ]</sub>( 7  )</var>
and <var>x<sub>[ 1, 0 ]</sub>( 2 )</var>, where <var>[ 1, 0 ] = 1r<sub>1</sub> + 0r<sub>2</sub> = r<sub>1</sub></var> and <var>[ 3, 1
]  = 3r<sub>1</sub> + 1r<sub>2</sub>=r<sub>5</sub></var>  are  the  first  and the  fifth  positive roots of
<code>PositiveRootsFC(RootSystem(</code><var>U</var><code>))</code> respectively.
<p>
<a name = "SSEC003.6"></a>
<li><code>UnipotChevElemByRoots( </code><var>U</var><code>, </code><var>roots</var><code>, </code><var>felems</var><code> ) O</code>
<li><code>UnipotChevElemByRoots( </code><var>U</var><code>, </code><var>root</var><code>, </code><var>felem</var><code> ) O</code>
<a name = "SSEC003.6"></a>
<li><code>UnipotChevElemByR( </code><var>U</var><code>, </code><var>roots</var><code>, </code><var>felems</var><code> ) O</code>
<li><code>UnipotChevElemByR( </code><var>U</var><code>, </code><var>root</var><code>, </code><var>felem</var><code> ) O</code>
<p>
<code>UnipotChevElemByRoots</code> returns  an element of  a unipotent  subgroup <var>U</var>
with         representation        <code>IsUnipotChevRepByRoots</code>        (see
<a href="CHAP002.htm#SSEC003.2">IsUnipotChevRepByRoots</a>).
<p>
<var>roots</var>   should   be   a    list   of   elements   of   <code>PositiveRoots(
or  indeterminates  over   that   ring  (see   <font face="Gill Sans,Helvetica,Arial">GAP</font>  Reference  Manual,
"ref:Indeterminate" for general information on indeterminates or  section
"Symbolic computation" of this manual for examples).
<p>
The second variant of `UnipotChevElemByRoots</code> is an abbreviation  for the
first one if <var>roots</var> and <var>felems</var> contain only one element.
<p>
<code>UnipotChevElemByR</code> is just a synonym for <code>UnipotChevElemByRoots</code>.
<p>
<pre>
gap&gt; PositiveRoots(RootSystem(U_G2));
[ [ 2, -1 ], [ -3, 2 ], [ -1, 1 ], [ 1, 0 ], [ 3, -1 ], [ 0, 1 ] ]
gap&gt; y2 := UnipotChevElemByRoots( U_G2, [[ 2, -1 ], [ 3, -1 ]], [2,7] );
x_{[ 2, -1 ]}( 2 ) * x_{[ 3, -1 ]}( 7 )
gap&gt; x2 := UnipotChevElemByRoots( U_G2, [ 2, -1 ], 2 );
x_{[ 2, -1 ]}( 2 )
</pre>
<p>
In this example we create again the two elements as in previous examples:
<var>x<sub>[ 2, -1 ]</sub>( 2 ) . x<sub>[ 3, -1 ]</sub>( 7 )</var> and <var>x<sub>[ 2, -1 ]</sub>( 2 )</var>, where
<var>[ 2, -1 ]  =  r<sub>1</sub></var>  and <var>[ 3, -1 ] =  r<sub>5</sub></var> are the  first  and the fifth
positive roots of <code>PositiveRoots(RootSystem( </code><var>U</var><code>))</code> respectively.
<p>
<a name = "SSEC003.7"></a>
<li><code>UnipotChevElemByRootNumbers( </code><var>x</var><code> ) O</code>
<a name = "SSEC003.7"></a>
<li><code>UnipotChevElemByFundamentalCoeffs( </code><var>x</var><code> ) O</code>
<a name = "SSEC003.7"></a>
<li><code>UnipotChevElemByRoots( </code><var>x</var><code> ) O</code>
<p>
These three methods are  provided  for converting a unipotent element  to
the respective representation.
<p>
If  <var>x</var>  has  already  the required representation,  then  <var>x</var>  itself is
returned. Otherwise  a <strong>new</strong> element  with the required representation is
generated.
<p>
<pre>
gap&gt; x;
x_{1}( 2 )
gap&gt; x1 := UnipotChevElemByFundamentalCoeffs( x );
x_{[ 1, 0 ]}( 2 )
gap&gt; IsIdenticalObj(x, x1); x = x1;
false
true
gap&gt; x2 := UnipotChevElemByFundamentalCoeffs( x1 );;
gap&gt; IsIdenticalObj(x1, x2);
true
</pre>
<p>
<strong>Note:</strong>  If  some  attributes  of  <var>x</var>  are  known  (e.g  <code>Inverse</code>  (see
<a href="CHAP002.htm#SSEC003.15">Inverse!for     `UnipotChevElem'</a>)      or     <code>CanonicalForm</code>      (see
<a href="CHAP002.htm#SSEC003.8">CanonicalForm</a>)), then they are ``converted'' to the new representation,
too.
<p>
<code>&nbsp;UnipotChevElemByRootNumbers( </code><var>U</var><code>, </code><var>list</var><code> ) O</code>
<br><code>&nbsp;UnipotChevElemByRoots( </code><var>U</var><code>, </code><var>list</var><code> ) O</code>
<br><code>&nbsp;UnipotChevElemByFundamentalCoeffs( </code><var>U</var><code>, </code><var>list</var><code> ) O</code>
<p>
<strong>DEPRECATED</strong>  These   are  old  versions  of  <code>UnipotChevElemByXX</code>  (from
<font face="Gill Sans,Helvetica,Arial">Unipot</font>  1.0   and  1.1).  They  are  deprecated  now  and   exist  for
compatibility only. They may be removed at any time.
<p>
<a name = "SSEC003.8"></a>
<li><code>CanonicalForm( </code><var>x</var><code> ) A</code>
<p>
<code>CanonicalForm</code>  returns the  canonical form of <var>x</var>. For more information
on the canonical form  see Carter <a href="biblio.htm#Carter72"><cite>Carter72</cite></a>, Theorem 5.3.3 (ii). It
says:
<p>
Each  element of  a unipotent subgroup <var>U</var> of a Chevalley group with root
system <var>Phi</var> is uniquely expressible in the form
<p><var>
prod<sub>r_iinPhi^+</sub> x<sub>r_i</sub>(t<sub>i</sub>),
<p></var>
where the product is taken over all positive roots in increasing order.
<p>
<pre>
gap&gt; z := UnipotChevElemByFC( U_G2, [[0,1], [1,0]], [3,2]);
x_{[ 0, 1 ]}( 3 ) * x_{[ 1, 0 ]}( 2 )
gap&gt; CanonicalForm(z);
x_{[ 1, 0 ]}( 2 ) * x_{[ 0, 1 ]}( 3 ) * x_{[ 1, 1 ]}( 6 ) *
x_{[ 2, 1 ]}( 12 ) * x_{[ 3, 1 ]}( 24 ) * x_{[ 3, 2 ]}( -72 )
</pre>
<p>
So  if  we  call  the  positive  roots  <var>r<sub>1</sub>,...,r<sub>6</sub></var>,  we  have  <var> z =
x<sub>r_2</sub>(3)x<sub>r_1</sub>(2) = x<sub>r_1</sub>( 2 ) x<sub>r_2</sub>( 3 ) x<sub>r_3</sub>( 6 ) x<sub>r_4</sub>( 12
) x<sub>r_5</sub>( 24 ) x<sub>r_6</sub>( -72 )</var>.
<p>
<a name = "SSEC003.9"></a>
<li><code>PrintObj( </code><var>x</var><code> ) M</code>
<a name = "SSEC003.9"></a>
<li><code>ViewObj( </code><var>x</var><code> ) M</code>
<p>
Special  methods for  unipotent elements. (see <font face="Gill Sans,Helvetica,Arial">GAP</font>  Reference  Manual,
section  <a href="../../../doc/htm/ref/CHAP006.htm#SECT002">View  and  Print</a>  for  general  information on  <code>View</code> and
<code>Print</code>). The output depends on the representation of <var>x</var>.
<p>
<pre>
gap&gt; Print(x);
UnipotChevElemByRootNumbers( UnipotChevSubGr( "G", 2, Rationals ), \
[ 1 ], [ 2 ] )gap&gt; View(x);
x_{1}( 2 )gap&gt;
</pre>
<pre>
gap&gt; Print(x1);
UnipotChevElemByFundamentalCoeffs( UnipotChevSubGr( "G", 2, Rationals ), \
[ [ 1, 0 ] ], [ 2 ] )gap&gt; View(x1);
x_{[ 1, 0 ]}( 2 )gap&gt;
</pre>
<p>
<a name = "SSEC003.10"></a>
<li><code>ShallowCopy( </code><var>x</var><code> ) M</code>
<p>
This is a special method for unipotent elements.
<p>
<code>ShallowCopy</code>  creates  a  copy  of  <var>x</var>.  The  returned  object is  <strong>not
identical</strong> to <var>x</var> but it  is <strong>equal</strong> to <var>x</var> w.r.t. the  equality operator
<code>=</code>. <strong>Note</strong> that <code>CanonicalForm</code> and  <code>Inverse</code>  of  <var>x</var>  (if known)  are
identical to <code>CanonicalForm</code> and <code>Inverse</code> of the returned object.
<p>
(See <font face="Gill Sans,Helvetica,Arial">GAP</font> Reference  Manual,  section <a href="../../../doc/htm/ref/CHAP012.htm#SECT007">Duplication of Objects</a>  for
further information on copyability)
<p>
<a name = "SSEC003.11"></a>
<li><code></code><var>x</var><code> = </code><var>y</var><code> M</code>
<a name = "I0"></a>

<p>
Special  method  for unipotent elements. If <var>x</var> and <var>y</var> are identical  or
are  products of  the  <strong>same</strong> root  elements  then  <code>true</code>  is  returned.
Otherwise <code>CanonicalForm</code> (see <a href="CHAP002.htm#SSEC003.8">CanonicalForm</a>) of both arguments must be
computed (if not already known), which may be expensive. If the canonical
form of one  of  the  elements  must be  calculated  and  <code>InfoLevel</code>  of
<code>UnipotChevInfo</code> is at least 3, the user is notified about this:
<p>
<pre>
gap&gt; y := UnipotChevElemByRN( U_G2, [1,5], [2,7] );
x_{1}( 2 ) * x_{5}( 7 )
gap&gt; z := UnipotChevElemByRN( U_G2, [5,1], [7,2] );
x_{5}( 7 ) * x_{1}( 2 )
gap&gt; SetInfoLevel( UnipotChevInfo, 3 );
gap&gt; y=z;
#I  CanonicalForm for the 1st argument is not known.
#I                    computing it may take a while.
#I  CanonicalForm for the 2nd argument is not known.
#I                    computing it may take a while.
true
gap&gt; SetInfoLevel( UnipotChevInfo, 1 );
</pre>
<p>
<a name = "SSEC003.12"></a>
<li><code></code><var>x</var><code> &lt; </code><var>y</var><code> M</code>
<a name = "I1"></a>

<p>
Special Method for <code>UnipotChevElem</code>
<p>
This is needed e.g. by <code>AsSSortetList</code>.
<p>
The ordering is computed in the following way:
Let    <var>x = x<sub>r_1</sub>(s<sub>1</sub>) ... x<sub>r_n</sub>(s<sub>n</sub>)</var>
and    <var>y = x<sub>r_1</sub>(t<sub>1</sub>) ... x<sub>r_n</sub>(t<sub>n</sub>)</var>, then
<p>
<p><var> x &lt; y &nbsp;Leftrightarrow&nbsp;[ s<sub>1</sub>, ..., s<sub>n</sub> ] &lt; [ t<sub>1</sub>, ..., t<sub>n</sub> ], <p></var>
<p>
where the lists are compared lexicographically.
e.g. for <var>x = x<sub>r_1</sub>(1)x<sub>r_2</sub>(1) = x<sub>r_1</sub>(1)x<sub>r_2</sub>(1)x<sub>r_3</sub>(0)</var>  (field elems: <code>[ 1, 1, 0 ]</code>)
     and <var>y = x<sub>r_1</sub>(1)x<sub>r_3</sub>(1) = x<sub>r_1</sub>(1)x<sub>r_2</sub>(0)x<sub>r_3</sub>(1)</var>  (field elems: <code>[ 1, 0, 1 ]</code>)
we have <var>y &lt; x</var> (above lists ordered lexicographically).
<p>
<a name = "SSEC003.13"></a>
<li><code></code><var>x</var><code> * </code><var>y</var><code> M</code>
<a name = "I2"></a>

<p>
Special  method  for unipotent  elements.  The  expressions  in the  form
<var>x<sub>r</sub>(t)x<sub>r</sub>(u)</var> will be reduced to <var>x<sub>r</sub>(t+u)</var> whenever possible.
<p>
<pre>
gap&gt; y;z;
x_{1}( 2 ) * x_{5}( 7 )
x_{5}( 7 ) * x_{1}( 2 )
gap&gt; y*z;
x_{1}( 2 ) * x_{5}( 14 ) * x_{1}( 2 )
</pre>
<p>
<strong>Note:</strong>  The   representation  of  the   product  will   be  always   the
representation of the first argument.
<p>
<pre>
gap&gt; x; x1; x=x1;
x_{1}( 2 )
x_{[ 1, 0 ]}( 2 )
true
gap&gt; x * x1;
x_{1}( 4 )
gap&gt; x1 * x;
x_{[ 1, 0 ]}( 4 )
</pre>
<p>
<a name = "SSEC003.14"></a>
<li><code>OneOp( </code><var>x</var><code> ) M</code>
<p>
Special method for unipotent elements. <code>OneOp</code> returns the multiplicative
neutral element of <var>x</var>. This is equal to <code></code><var>x</var><code>^0</code>.
<p>
<a name = "SSEC003.15"></a>
<li><code>Inverse( </code><var>x</var><code> ) M</code>
<a name = "SSEC003.15"></a>
<li><code>InverseOp( </code><var>x</var><code> ) M</code>
<p>
Special methods for unipotent elements. We are using the fact
<p><var>
Bigl( x<sub>r_1</sub>( t<sub>1</sub>) . . . x<sub>r_m</sub>(t<sub>m</sub>) Bigr)<sup>-1</sup> 
     = x<sub>r_m</sub>(-t<sub>m</sub>) . . . x<sub>r_1</sub>(-t<sub>1</sub>) . 
<p></var>
<p>
<a name = "SSEC003.16"></a>
<li><code>IsOne( </code><var>x</var><code> ) M</code>
<p>
Special method for unipotent elements. Returns <code>true</code>  if and only if <var>x</var>
is equal to the identity element.
<p>
<a name = "SSEC003.17"></a>
<li><code></code><var>x</var><code> ^ </code><var>i</var><code> M</code>
<p>
Integral powers of the unipotent elements are  calculated  by the default
methods installed in <font face="Gill Sans,Helvetica,Arial">GAP</font>.  But  special (more efficient)  methods  are
instlled for root elements and for the identity.
<p>
<a name = "SSEC003.18"></a>
<li><code></code><var>x</var><code> ^ </code><var>y</var><code> M</code>
<p>
Conjugation  of  two  unipotent elements,  i.e.  <var>x<sup>y</sup>  =  y<sup>-1</sup>xy</var>.  The
representation of  the result  will  be the representation  of <var>x</var>.
<p>
<a name = "SSEC003.19"></a>
<li><code>Comm( </code><var>x</var><code>, </code><var>y</var><code> ) M</code>
<li><code>Comm( </code><var>x</var><code>, </code><var>y</var><code>, "canonical" ) M</code>
<p>
Special methods for unipotent elements.
<p>
<code>Comm</code> returns the commutator of <var>x</var> and <var>y</var>, i.e. <var><var>x</var>  <sup>-1</sup> . <var>y</var><sup>-1</sup>
.  <var>x</var>  .  <var>y</var></var>. The  second variant returns  the  canonical form  of the
commutator.  In some cases it may be more efficient  than <code>CanonicalForm(
Comm( </code><var>x</var><code>, </code><var>y</var><code> ) )</code>
<p>
<a name = "SSEC003.20"></a>
<li><code>IsRootElement( </code><var>x</var><code> ) P</code>
<p>
<code>IsRootElement</code>  returns  <code>true</code>  if  and  only  if  <var>x</var>  is a <em>root</em>
element, i.e. <var><var>x</var>=x<sub>r</sub>(t)</var> for some root <var>r</var>. We  store this property
immediately after creating objects.
<p>
<strong>Note:</strong> the canonical form of <var>x</var> may be a root element even if <var>x</var> isn't
one.
<p>
<pre>
gap&gt; x := UnipotChevElemByRN( U_G2, [1,5,1], [2,7,-2] );
x_{1}( 2 ) * x_{5}( 7 ) * x_{1}( -2 )
gap&gt; IsRootElement(x);
false
gap&gt; CanonicalForm(x); IsRootElement(CanonicalForm(x));
x_{5}( 7 )
true
</pre>
<p>
<a name = "SSEC003.21"></a>
<li><code>IsCentral( </code><var>U</var><code>, </code><var>z</var><code> )</code>
<p>
Special method for a unipotent subgroup and a unipotent element.
<p>
<p>
<h2><a name="SECT004">2.4 Symbolic computation</a></h2>
<p><p>
In  some  cases,  calculation  with explicite  elements  is  not  enough.
<font face="Gill Sans,Helvetica,Arial">Unipot</font>  povides a  way  to  do  symbolic calculations  with  unipotent
elements for this  purpose.  This is  done by using  indeterminates  (see
<font face="Gill Sans,Helvetica,Arial">GAP</font> Reference Manual, <a href="../../../doc/htm/ref/CHAP064.htm#SECT001">Indeterminates</a> for  more information) over
the underlying field instead of the field elements.
<p>
<pre>
gap&gt; U_G2 := UnipotChevSubGr("G", 2, Rationals);;
gap&gt; a := Indeterminate( Rationals, "a" );
a
gap&gt; b := Indeterminate( Rationals, "b", [a] );
b
gap&gt; c := Indeterminate( Rationals, "c", [a,b] );
c
gap&gt; x := UnipotChevElemByFC(U_G2, [ [3,1], [1,0], [0,1] ], [a,b,c] );
x_{[ 3, 1 ]}( a ) * x_{[ 1, 0 ]}( b ) * x_{[ 0, 1 ]}( c )
gap&gt; CanonicalForm(x);
x_{[ 1, 0 ]}( b ) * x_{[ 0, 1 ]}( c ) * x_{[ 3, 1 ]}( a ) *
x_{[ 3, 2 ]}( a*c )
gap&gt; CanonicalForm(x^-1);
x_{[ 1, 0 ]}( -b ) * x_{[ 0, 1 ]}( -c ) * x_{[ 1, 1 ]}( b*c ) *
x_{[ 2, 1 ]}( -b^2*c ) * x_{[ 3, 1 ]}( -a+b^3*c ) * x_{[ 3, 2 ]}( b^3*c^2 )
</pre>
<p>
<p>
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP001.htm">Previous</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>Unipot manual<br>Oktober 2004
</address></body></html>