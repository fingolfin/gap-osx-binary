LoadPackage("recog");
Read("downsp.g");
d := 100;
q := 8;
g := Sp(d,q);
x := constructppd2(g,d,q);
y := PseudoRandom(g);
z := PseudoRandom(g);
h := Group(x,x^y,x^z);
mov := RECOG.MovedSpace(h);
hh := RECOG.LinearAction(mov,GF(q),h);
ri := RecogniseGroup(hh);
SetInfoLevel(InfoRecog,3);
DisplayCompositionSeries(SL(4,8));
# got an O+(6,8)
h;
mov;
s := StabMC(h,mov[1],OnRight);
s := StabMC(s.stab,mov[2],OnRight);
s := s.stab;
repeat a := PseudoRandom(s);
o := Order(a);
until o mod 7 = 0;
o;
aa := a^9;
Order(aa);
RECOG.FixedSpace(Group(aa));
RECOG.MovedSpace(Group(aa));
b := PseudoRandom(g);
k := Group(a,a^b);
mov2 := RECOG.MovedSpace(k);
a := aa;
k := Group(a,a^b);
mov2 := RECOG.MovedSpace(k);
kk := RECOG.LinearAction(mov2,GF(8),k);
ri2 := RecogniseGroup(kk);
Size(ri);
ri;
ri;
RECOG.FixedSpace(Group(a));
RECOG.MovedSpace(Group(a));
k := Group(a,a^b);
mov2 := RECOG.MovedSpace(k);
kk := RECOG.LinearAction(mov2,GF(8),k);
ri2 := RecogniseGroup(kk);
Size(ri2);
ri2;
504*64;
k := Group(a,a^b);
mov2 := RECOG.MovedSpace(k);
kk := RECOG.LinearAction(mov2,GF(8),k);
ri2 := RecogniseGroup(kk);
Size(ri2);
ri2;
b := PseudoRandom(g);
k := Group(a,a^b);
mov2 := RECOG.MovedSpace(k);
kk := RECOG.LinearAction(mov2,GF(8),k);
ri2 := RecogniseGroup(kk);
Size(ri2);
ri2;
b := PseudoRandom(g);
504^2;
k := Group(a,a^b);
mov2 := RECOG.MovedSpace(k);
kk := RECOG.LinearAction(mov2,GF(8),k);
ri2 := RecogniseGroup(kk);
Size(ri2);
ri2;
b := PseudoRandom(g);
l := [];
for i in [1..100] do
b := PseudoRandom(g);
k := Group(a,a^b);
mov2 := RECOG.MovedSpace(k);
kk := RECOG.LinearAction(mov2,GF(8),k);
ri2 := RecogniseGroup(kk);
Add(l,Size(ri2));
Print(Size(ri2)," \c");
od;
SetInfoLevel(InfoRecog,0);
return;
l;
Collected(l);
504^2;
repeat
b := PseudoRandom(g);
k := Group(a,a^b);
mov2 := RECOG.MovedSpace(k);
kk := RECOG.LinearAction(mov2,GF(8),k);
ri2 := RecogniseGroup(kk);
until Size(ri2)=254016;
ri2;
IsConjugate(GeneratorsOfGroup(kk)[1],GeneratorsOfGroup(kk)[2]);
IsConjugate(kk,GeneratorsOfGroup(kk)[1],GeneratorsOfGroup(kk)[2]);
gens := GeneratorsOfGroup(kk);
o := Orb(kk,kk[2],OnPoints,rec(report := 1000, lookingfor := [gens[1]], schreier := true));
o := Orb(kk,gens[2],OnPoints,rec(report := 1000, lookingfor := [gens[1]], schreier := true));
Enumerate(o);
word := TraceSchreierTreeForward(o,o!.found);
Product(GeneratorsOfGroup(k){word});
c := last;
a^(b*c);
last = a;
cent1 := b*c;
repeat
b := PseudoRandom(g);
k := Group(a,a^b);
mov2 := RECOG.MovedSpace(k);
kk := RECOG.LinearAction(mov2,GF(8),k);
ri2 := RecogniseGroup(kk);
until Size(ri2)=254016;
ri2;
IsConjugate(kk,GeneratorsOfGroup(kk)[1],GeneratorsOfGroup(kk)[2]);
gens := GeneratorsOfGroup(kk);
o := Orb(kk,gens[2],OnPoints,rec(report := 1000, lookingfor := [gens[1]], schreier := true));
Enumerate(o);
word := TraceSchreierTreeForward(o,o!.found);
Product(GeneratorsOfGroup(k){word});
c := last;
a^(b*c);
last = a;
cent2 := b*c;
c := Group(cent1,cent2);
mov3 := RECOG.MovedSpace(c);
IsOne(Comm(a,cent2));
IsOne(Comm(a,cent1));
m := GModuleByMats([cent1,cent2],GF(8));
MTX.CompositionFactors(m);
MTX.BasisSocle(m);
Length(last);
MTX.CompositionFactors(m);
cc := Group(last[3].generators);
r := RecogniseClassical(cc);
h;
hh;
r := RecogniseClassical(hh);
qu := r.QuadraticForm;
mov,
mov;
mov2;
mov3;
mov3 := RECOG.MovedSpace(Group(a));
bas := Basis(VectorSpace(GF(8),mov),mov);
v := Coefficients(bas,mov3[1]);
w := Coefficients(bas,mov3[2]);
V := VectorSpace(GF(8),[v,w]);
e := Enumerator(V);
i := 2;
while not(IsZero(EvaluateForm(qu,e[i]))) do i := i + 1; Print(".\c"); od;
i;
EvaluateForm(qu,e[9]);
u := e[9] * mov;
h;
StabMC(h,u,OnRight);
ss := last;
8^4*504^2;
ss := ss.stab;
SetSize(ss,1040449536);
NiceMonomorphism(ss);
ri3 := RecogniseGroup(ss);
SetInfoLevel(InfoRecog,3);
return;
Length(origgens);
S := StabilizerChain(ss);
ssp := Group(ActionOnOrbig(S!.orbit,GeneratorsOfGroup(ss)));
ssp := Group(ActionOnOrbit(S!.orbit,GeneratorsOfGroup(ss)));
ssp := Group(ActionOnOrbit(S!.orb,GeneratorsOfGroup(ss)));
StabilizerChain(ssp);
PCore(ssp);
PCore(ssp,2);
Size(last);
sspm := GroupWithMemory(ssp);
SSm := StabilizerChain(sspm);
slpstrong := SLPOfElms(StrongGenerators(SSm));
ForgetMemory(SSm);
strong := ResultOfStraightLineProgram(slpstrong,GeneratorsOfGroup(ss));
pc := PCore(ssp,2);
gens := GeneratorsOfGroup(pc);
Length(gens);
slps := List(gens,x->SiftGroupElementSLP(SSm,x).slp);
pcore := Group(List(slps,slp->ResultOfStraightLineProgram(slp,strong)));
StabilizerChain(pcore);
pcore := GeneratorsOfGroup(pcore);
cc;
c;
GeneratorsOfGroup(c)=[cent1,cent2];
comm := Comm(cent1,cent2);
derived := FastNormalClosure;
derived := FastNormalClosure([cent1,cent2],[comm],6);
guck := derived;
guck := Group(derived);
movguck := RECOG.MovedSpace(guck);,
;
guckguck := RECOG.LinearAction(movguck,GF(8),guck);
RecogniseClassical(guckguck);
pcore;
gens := Concatenation(derived,GeneratorsOfGroup(ss));
guck := FastNormalClosure(gens,pcore,3);
List(guck,Order);
guck := FastNormalClosure(gens,pcore,10);
Length(guck);
guck := FastNormalClosure(gens,pcore,30);
Length(guck);
IsOne(Comm(Random(guck),Random(guck)));
IsOne(Comm(Random(guck),Random(guck)));
IsOne(Comm(Random(guck),Random(guck)));
IsOne(Comm(Random(guck),Random(guck)));
IsOne(Comm(Random(guck),Random(guck)));
IsOne(Comm(Random(guck),Random(guck)));
IsOne(Comm(Random(guck),Random(guck)));
IsOne(Comm(Random(guck),Random(guck)));
IsOne(Comm(Random(guck),Random(guck)));
IsOne(Comm(Random(guck),Random(guck)));
IsOne(Comm(Random(guck),Random(guck)));
ForAll(guck,x->ForAll(guck,y->IsOne(Comm(x,y))));
List(guck,x->RECOG.MovedSpace(Group(x)));
Concatenation(last);
RankMat(last);
u*guck[1]=u;
ForAll(guck,x->u*x=u);
bas := [u];
ConvertToMatrixRep(bas,8);
RECOG.ExtendToBasisEchelon(bas);
RECOG.ExtendToBasisEchelon;
RECOG.ExtendToBasisEchelon(bas,100,GF(8));
bas;
bas := last2;
ConvertToMatrixRep(bas,8);
basi := bas^-1;
guck2 := List(guck,x->bas*x*basi);
Display(guck2[1]);
guck3 := List(guck2,x->ExtractSubMatrix(x,[2..100],[2..100]));
List(guck3,x->RECOG.MovedSpace(Group(x)));
Concatenation(last);
RankMat(last);
guck3 := List(guck3,TransposedMat);
List(guck3,x->RECOG.MovedSpace(Group(x)));
Concatenation(last);
RankMat(last);
uu := last2;
SemiEchelonMat(uu);
uu := last.vectors[1];
u=uu;
Display(u);
Display(uu);
guck4 := List(guck2,x->ExtractSubMatrix(x,[2..100],[2..100]));
guck4 := List(guck4,x->x-One(x));
List(guck4,RankMat);
