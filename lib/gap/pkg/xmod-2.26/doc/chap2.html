<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (XMod) - Chapter 2: 2d-groups : crossed modules and cat1-groups</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>

<p><a id="X87474A3F785F9E38" name="X87474A3F785F9E38"></a></p>
<div class="ChapSects"><a href="chap2.html#X87474A3F785F9E38">2 <span class="Heading">2d-groups : crossed modules and cat1-groups</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7BAD9A7F7AFEEC89">2.1 <span class="Heading">Constructions for crossed modules</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7C8175AE7F76B586">2.1-1 XMod</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7DE8173F80E07AB1">2.1-2 Source</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X858ADA3B7A684421">2.1-3 Size</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7884284383284A87">2.1-4 SubXMod</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7D435B6279032D4D">2.2 <span class="Heading">Pre-crossed modules</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8487BE427858C5C9">2.2-1 PreXModByBoundaryAndAction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8527F4C07A8F359E">2.2-2 PeifferSubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7E564129785A2DF2">2.2-3 IsPermXMod</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7F868C2181018D0C">2.3 <span class="Heading">Cat1-groups and pre-cat1-groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7DE8173F80E07AB1">2.3-1 Source</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7F4221DF83D1B6D8">2.3-2 Cat1</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7EB380BA7AC52D53">2.3-3 Cat1OfXMod</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7B38B960782937EB">2.4 <span class="Heading">Selection of a small cat1-group</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7B8E67D880E380C8">2.4-1 Cat1Select</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7A081F9D826621DA">2.4-2 AllCat1sBasic</a></span>
</div></div>
</div>

<h3>2 <span class="Heading">2d-groups : crossed modules and cat1-groups</span></h3>

<p><a id="X7BAD9A7F7AFEEC89" name="X7BAD9A7F7AFEEC89"></a></p>

<h4>2.1 <span class="Heading">Constructions for crossed modules</span></h4>

<p>A crossed module (of groups) <span class="SimpleMath">mathcalX = (∂ : S -&gt; R )</span> consists of a group homomorphism <span class="SimpleMath">∂</span>, called the <em>boundary</em> of <span class="SimpleMath">mathcalX</span>, with <em>source</em> <span class="SimpleMath">S</span> and <em>range</em> <span class="SimpleMath">R</span>. The group <span class="SimpleMath">R</span> acts on itself by conjugation, and on <span class="SimpleMath">S</span> by an action <span class="SimpleMath">α : R -&gt; Aut(S)</span> such that, for all <span class="SimpleMath">s,s_1,s_2 ∈ S</span> and <span class="SimpleMath">r ∈ R</span>,</p>

<p class="pcenter">
{\bf XMod\ 1} ~:~  \partial(s^r) 
   = r^{-1} (\partial s) r
   = (\partial s)^r,
\qquad
{\bf XMod\ 2} ~:~  s_1^{\partial s_2} 
   = s_2^{-1}s_1 s_2
   = {s_1}^{s_2}.
</p>

<p>The kernel of <span class="SimpleMath">∂</span> is abelian.</p>

<p>There are a variety of constructors for crossed modules:</p>

<p><a id="X7C8175AE7F76B586" name="X7C8175AE7F76B586"></a></p>

<h5>2.1-1 XMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XMod</code>( <var class="Arg">args</var> )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByBoundaryAndAction</code>( <var class="Arg">bdy</var>, <var class="Arg">act</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByTrivialAction</code>( <var class="Arg">bdy</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByNormalSubgroup</code>( <var class="Arg">G</var>, <var class="Arg">N</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByCentralExtension</code>( <var class="Arg">bdy</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByAutomorphismGroup</code>( <var class="Arg">grp</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByInnerAutomorphismGroup</code>( <var class="Arg">grp</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByGroupOfAutomorphisms</code>( <var class="Arg">G</var>, <var class="Arg">A</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByAbelianModule</code>( <var class="Arg">abgrp</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DirectProduct</code>( <var class="Arg">X1</var>, <var class="Arg">X2</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Here are the standard constructions which these implement:</p>


<ul>
<li><p>A <em>trivial action crossed module</em> <span class="SimpleMath">∂ : S -&gt; R</span> has <span class="SimpleMath">s^r = s</span> for all <span class="SimpleMath">s ∈ S, r ∈ R</span>, the source is abelian and the image lies in the centre of the range.</p>

</li>
<li><p>A <em>conjugation crossed module</em> is an inclusion of a normal subgroup <span class="SimpleMath">S ⊴ R</span>, where <span class="SimpleMath">R</span> acts on <span class="SimpleMath">S</span> by conjugation.</p>

</li>
<li><p>A <em>central extension crossed module</em> has as boundary a surjection <span class="SimpleMath">∂ : S -&gt; R</span> with central kernel, where <span class="SimpleMath">r ∈ R</span> acts on <span class="SimpleMath">S</span> by conjugation with <span class="SimpleMath">∂^-1r</span>.</p>

</li>
<li><p>An <em>automorphism crossed module</em> has as range a subgroup <span class="SimpleMath">R</span> of the automorphism group Aut<span class="SimpleMath">(S)</span> of <span class="SimpleMath">S</span> which contains the inner automorphism group of <span class="SimpleMath">S</span>. The boundary maps <span class="SimpleMath">s ∈ S</span> to the inner automorphism of <span class="SimpleMath">S</span> by <span class="SimpleMath">s</span>.</p>

</li>
<li><p>A <em>crossed abelian module</em> has an abelian module as source and the zero map as boundary.</p>

</li>
<li><p>The direct product <span class="SimpleMath">mathcalX_1 × mathcalX_2</span> of two crossed modules has source <span class="SimpleMath">S_1 × S_2</span>, range <span class="SimpleMath">R_1 × R_2</span> and boundary <span class="SimpleMath">∂_1 × ∂_2</span>, with <span class="SimpleMath">R_1, R_2</span> acting trivially on <span class="SimpleMath">S_2, S_1</span> respectively.</p>

</li>
</ul>
<p><a id="X7DE8173F80E07AB1" name="X7DE8173F80E07AB1"></a></p>

<h5>2.1-2 Source</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Source</code>( <var class="Arg">X0</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Range</code>( <var class="Arg">X0</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Boundary</code>( <var class="Arg">X0</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutoGroup</code>( <var class="Arg">X0</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModAction</code>( <var class="Arg">X0</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>In this implementation the attributes used in the construction of a crossed module <code class="code">X0</code> are as follows.</p>


<ul>
<li><p><code class="code">Source(X0)</code> and <code class="code">Range(X0)</code> are the source <span class="SimpleMath">S</span> and range <span class="SimpleMath">R</span> of <span class="SimpleMath">∂</span>, the boundary <code class="code">Boundary(X0)</code>;</p>

</li>
<li><p><code class="code">AutoGroup(X0)</code> is a group of automorphisms of <span class="SimpleMath">S</span>;</p>

</li>
<li><p><code class="code">XModAction(X0)</code> is a homomorphism from <span class="SimpleMath">R</span> to <code class="code">AutoGroup(X0)</code>.</p>

</li>
</ul>
<p><a id="X858ADA3B7A684421" name="X858ADA3B7A684421"></a></p>

<h5>2.1-3 Size</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Size</code>( <var class="Arg">X0</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Name</code>( <var class="Arg">X0</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>More familiar attributes are <code class="code">Size</code> and <code class="code">Name</code>, the latter formed by concatenating the names of the source and range (if these exist). An <code class="code">Enumerator</code> function has not been implemented. The <code class="code">Display</code> function is used to print details of 2d-groups.</p>

<p>Here is a simple example of an automorphism crossed module, using a cyclic group of size five.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c5 := Group( (5,6,7,8,9) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( c5, "c5" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X1 := XModByAutomorphismGroup( c5 );</span>
[c5 -&gt; PAut(c5)] 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( X1 );</span>
Crossed module [c5 -&gt; PAut(c5)] :-
: Source group c5 has generators:
  [ (5,6,7,8,9) ]
: Range group PAut(c5) has generators:
  [ (1,2,3,4) ]
: Boundary homomorphism maps source generators to:
  [ () ]
: Action homomorphism maps range generators to automorphisms:
  (1,2,3,4) --&gt; { source gens --&gt; [ (5,7,9,6,8) ] }
  This automorphism generates the group of automorphisms.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( X1 );</span>
[ 5, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print( RepresentationsOfObject(X1), "\n" );</span>
[ "IsComponentObjectRep", "IsAttributeStoringRep", "IsPreXModObj" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print( KnownPropertiesOfObject(X1), "\n" );</span>
[ "IsEmpty", "IsTrivial", "IsNonTrivial", "IsFinite", 
  "CanEasilyCompareElements", "CanEasilySortElements", "IsDuplicateFree", 
  "IsPerm2dDomain", "IsPreXMod", "IsXMod", "IsAutomorphismGroup2dDomain" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print( KnownAttributesOfObject(X1), "\n" );</span>
[ "Name", "Size", "Range", "Source", "Boundary", "AutoGroup", "XModAction" ]

</pre></div>

<p><a id="X7884284383284A87" name="X7884284383284A87"></a></p>

<h5>2.1-4 SubXMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubXMod</code>( <var class="Arg">X0</var>, <var class="Arg">src</var>, <var class="Arg">rng</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TrivialSubXMod</code>( <var class="Arg">X0</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormalSubXMods</code>( <var class="Arg">X0</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>With the standard crossed module constructors listed above as building blocks, sub-crossed modules, normal sub-crossed modules <span class="SimpleMath">mathcalN ⊲ mathcalX</span>, and also quotients <span class="SimpleMath">mathcalX/mathcalN</span> may be constructed. A sub-crossed module <span class="SimpleMath">mathcalS = (δ : N -&gt; M)</span> is <em>normal</em> in <span class="SimpleMath">mathcalX = (∂ : S -&gt; R)</span> if</p>


<ul>
<li><p><span class="SimpleMath">N,M</span> are normal subgroups of <span class="SimpleMath">S,R</span> respectively,</p>

</li>
<li><p><span class="SimpleMath">δ</span> is the restriction of <span class="SimpleMath">∂</span>,</p>

</li>
<li><p><span class="SimpleMath">n^r ∈ N</span> for all <span class="SimpleMath">n ∈ N,~r ∈ R</span>,</p>

</li>
<li><p><span class="SimpleMath">s^-1s^m ∈ N</span> for all <span class="SimpleMath">m ∈ M,~s ∈ S</span>.</p>

</li>
</ul>
<p>These conditions ensure that <span class="SimpleMath">M ⋉ N</span> is normal in the semidirect product <span class="SimpleMath">R ⋉ S</span>.</p>

<p><a id="X7D435B6279032D4D" name="X7D435B6279032D4D"></a></p>

<h4>2.2 <span class="Heading">Pre-crossed modules</span></h4>

<p><a id="X8487BE427858C5C9" name="X8487BE427858C5C9"></a></p>

<h5>2.2-1 PreXModByBoundaryAndAction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreXModByBoundaryAndAction</code>( <var class="Arg">bdy</var>, <var class="Arg">act</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubPreXMod</code>( <var class="Arg">X0</var>, <var class="Arg">src</var>, <var class="Arg">rng</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>When axiom {\bf XMod\ 2} is <em>not</em> satisfied, the corresponding structure is known as a <em>pre-crossed module</em>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := (11,12,13,14,15,16,17,18);;  d := (12,18)(13,17)(14,16);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d16 := Group( c, d );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sk4 := Subgroup( d16, [ c^4, d ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( d16, "d16" );  SetName( sk4, "sk4" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bdy16 := GroupHomomorphismByImages( d16, sk4, [c,d], [c^4,d] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h1 := GroupHomomorphismByImages( d16, d16, [c,d], [c^5,d] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h2 := GroupHomomorphismByImages( d16, d16, [c,d], [c,c^4*d] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aut16 := Group( [ h1, h2 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">act16 := GroupHomomorphismByImages( sk4, aut16, [c^4,d], [h1,h2] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P16 := PreXModByBoundaryAndAction( bdy16 );</span>
[d16-&gt;sk4]

</pre></div>

<p><a id="X8527F4C07A8F359E" name="X8527F4C07A8F359E"></a></p>

<h5>2.2-2 PeifferSubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PeifferSubgroup</code>( <var class="Arg">X0</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModByPeifferQuotient</code>( <var class="Arg">prexmod</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>The <em>Peiffer subgroup</em> of a pre-crossed module <span class="SimpleMath">P</span> of <span class="SimpleMath">S</span> is the subgroup of <span class="SimpleMath">ker(∂)</span> generated by <em>Peiffer commutators</em></p>

<p class="pcenter">
\langle s_1,s_2 \rangle \quad=\quad 
(s_1^{-1})^{\partial s_2}~s_2^{-1}~s_1~s_2~.
</p>

<p>Then <span class="SimpleMath">mathcalP = (0 : P -&gt; {1_R})</span> is a normal sub-pre-crossed module of <span class="SimpleMath">mathcalX</span> and <span class="SimpleMath">mathcalX/mathcalP = (∂ : S/P -&gt; R)</span> is a crossed module.</p>

<p>In the following example the Peiffer subgroup is cyclic of size <span class="SimpleMath">4</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := PeifferSubgroup( P16 );</span>
Group( [ (11,15)(12,16)(13,17)(14,18), (11,17,15,13)(12,18,16,14) ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X16 := XModByPeifferQuotient( P16 );</span>
[d16/P-&gt;sk4]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( X16 );</span>
Crossed module [d16/P-&gt;sk4] :-
: Source group has generators:
  [ f1, f2 ]
: Range group has generators:
  [ (11,15)(12,16)(13,17)(14,18), (12,18)(13,17)(14,16) ]
: Boundary homomorphism maps source generators to:
  [ (12,18)(13,17)(14,16), (11,15)(12,16)(13,17)(14,18) ]
  The automorphism group is trivial
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso16 := IsomorphismPermGroup( Source( X16 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S16 := Image( iso16 );</span>
Group([ (1,2), (3,4) ])   

</pre></div>

<p><a id="X7E564129785A2DF2" name="X7E564129785A2DF2"></a></p>

<h5>2.2-3 IsPermXMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPermXMod</code>( <var class="Arg">X0</var> )</td><td class="tdright">( property )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPcPreXMod</code>( <var class="Arg">X0</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>When both source and range groups are of the same type, corresponding properties are assigned to the crossed module.</p>

<p><a id="X7F868C2181018D0C" name="X7F868C2181018D0C"></a></p>

<h4>2.3 <span class="Heading">Cat1-groups and pre-cat1-groups</span></h4>

<p><a id="X7DE8173F80E07AB1" name="X7DE8173F80E07AB1"></a></p>

<h5>2.3-1 Source</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Source</code>( <var class="Arg">C</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Range</code>( <var class="Arg">C</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TailMap</code>( <var class="Arg">C</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HeadMap</code>( <var class="Arg">C</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RangeEmbedding</code>( <var class="Arg">C</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KernelEmbedding</code>( <var class="Arg">C</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Boundary</code>( <var class="Arg">C</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Name</code>( <var class="Arg">C</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Size</code>( <var class="Arg">C</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>These are the attributes of a cat1-group <span class="SimpleMath">mathcalC</span> in this implementation.</p>

<p>In <a href="chapBib.html#biBL1">[Lod82]</a>, Loday reformulated the notion of a crossed module as a cat1-group, namely a group <span class="SimpleMath">G</span> with a pair of homomorphisms <span class="SimpleMath">t,h : G -&gt; G</span> having a common image <span class="SimpleMath">R</span> and satisfying certain axioms. We find it convenient to define a cat1-group <span class="SimpleMath">mathcalC = (e;t,h : G -&gt; R )</span> as having source group <span class="SimpleMath">G</span>, range group <span class="SimpleMath">R</span>, and three homomorphisms: two surjections <span class="SimpleMath">t,h : G -&gt; R</span> and an embedding <span class="SimpleMath">e : R -&gt; G</span> satisfying:</p>

<p class="pcenter">
{\bf Cat\ 1} ~:~ te = he = {\rm id}_R,
\qquad
{\bf Cat\ 2} ~:~ [\ker t, \ker h] = \{ 1_G \}.
</p>

<p>It follows that <span class="SimpleMath">teh = h</span>, <span class="SimpleMath">het = t</span>, <span class="SimpleMath">tet = t</span>, <span class="SimpleMath">heh = h</span>.</p>

<p>The maps <span class="SimpleMath">t,h</span> are often referred to as the <em>source</em> and <em>target</em>, but we choose to call them the <em>tail</em> and <em>head</em> of <span class="SimpleMath">mathcalC</span>, because <em>source</em> is the <strong class="pkg">GAP</strong> term for the domain of a function. The <code class="code">RangeEmbedding</code> is the embedding of <code class="code">R</code> in <code class="code">G</code>, the <code class="code">KernelEmbedding</code> is the inclusion of the kernel of <code class="code">t</code> in <code class="code">G</code>, and the <code class="code">Boundary</code> is the restriction of <code class="code">h</code> to the kernel of <code class="code">t</code>.</p>

<p><a id="X7F4221DF83D1B6D8" name="X7F4221DF83D1B6D8"></a></p>

<h5>2.3-2 Cat1</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Cat1</code>( <var class="Arg">args</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreCat1ByTailHeadEmbedding</code>( <var class="Arg">t</var>, <var class="Arg">h</var>, <var class="Arg">e</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreCat1ByEndomorphisms</code>( <var class="Arg">t</var>, <var class="Arg">h</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreCat1ByNormalSubgroup</code>( <var class="Arg">G</var>, <var class="Arg">N</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Cat1ByPeifferQuotient</code>( <var class="Arg">P</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Reverse</code>( <var class="Arg">C0</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>These are some of the constructors for pre-cat1-groups and cat1-groups.</p>

<p>The following listing shows an example of a cat1-group of pc-groups:</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3 := SymmetricGroup(IsPcGroup,3);;   </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens3 := GeneratorsOfGroup(s3);</span>
[ f1, f2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pc4 := CyclicGroup(4);; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName(s3,"s3");  SetName( pc4, "pc4" );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3c4 := DirectProduct( s3, pc4 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( s3c4, "s3c4" );  </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens3c4 := GeneratorsOfGroup( s3c4 );</span>
[ f1, f2, f3, f4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := gens3[1];;  b := gens3[2];;  one := One(s3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2 := GroupHomomorphismByImages( s3c4, s3, gens3c4, [a,b,one,one] );</span>
[ f1, f2, f3, f4 ] -&gt; [ f1, f2, &amp;lt;identity&amp;gt; of ..., &amp;lt;identity&amp;gt; of ... ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e2 := Embedding( s3c4, 1 );</span>
[ f1, f2 ] -&gt; [ f1, f2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := Cat1( t2, t2, e2 );</span>
[s3c4=&gt;s3]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( C2 );</span>
Cat1-group [s3c4=&gt;s3] :-
: Source group s3c4 has generators:
  [ f1, f2, f3, f4 ]
: Range group s3 has generators:
  [ f1, f2 ]
: tail homomorphism maps source generators to:
  [ f1, f2, &amp;lt;identity&amp;gt; of ..., &amp;lt;identity&amp;gt; of ... ]
: head homomorphism maps source generators to:
  [ f1, f2, &amp;lt;identity&amp;gt; of ..., &amp;lt;identity&amp;gt; of ... ]
: range embedding maps range generators to:
  [ f1, f2 ]
: kernel has generators:
  [ f3, f4 ]
: boundary homomorphism maps generators of kernel to:
  [ &amp;lt;identity&amp;gt; of ..., &amp;lt;identity&amp;gt; of ... ]
: kernel embedding maps generators of kernel to:
  [ f3, f4 ]
: associated crossed module is [ker(t2)-&gt;s3]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPcCat1( C2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( C2 );</span>
[ 24, 6 ]

</pre></div>

<p><a id="X7EB380BA7AC52D53" name="X7EB380BA7AC52D53"></a></p>

<h5>2.3-3 Cat1OfXMod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Cat1OfXMod</code>( <var class="Arg">X0</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; XModOfCat1</code>( <var class="Arg">C0</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreCat1OfPreXMod</code>( <var class="Arg">P0</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PreXModOfPreCat1</code>( <var class="Arg">P0</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>The category of crossed modules is equivalent to the category of cat1-groups, and the functors between these two categories may be described as follows. Starting with the crossed module <span class="SimpleMath">mathcalX = (∂ : S -&gt; R)</span> the group <span class="SimpleMath">G</span> is defined as the semidirect product <span class="SimpleMath">G = R ⋉ S</span> using the action from <span class="SimpleMath">mathcalX</span>, with multiplication rule</p>

<p class="pcenter">
(r_1,s_1)(r_2,s_2) ~=~ (r_1r_2,{s_1}^{r_2}s_2).
</p>

<p>The structural morphisms are given by</p>

<p class="pcenter">
t(r,s) = r, \quad h(r,s) = r (\partial s), \quad er = (r,1).
</p>

<p>On the other hand, starting with a cat1-group <span class="SimpleMath">mathcalC = (e;t,h : G -&gt; R)</span>, we define <span class="SimpleMath">S = ker t</span>, the range <span class="SimpleMath">R</span> remains unchanged, and <span class="SimpleMath">∂ = h∣_S</span>. The action of <span class="SimpleMath">R</span> on <span class="SimpleMath">S</span> is conjugation in <span class="SimpleMath">G</span> via the embedding of <span class="SimpleMath">R</span> in <span class="SimpleMath">G</span>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( Kernel( t2 ), "ker(t2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X2 := XModOfCat1( C2 );</span>
[Group( [ f3, f4 ] )-&gt;s3]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( X2 );</span>
Crossed module [ker(t2)-&gt;s3] :-
: Source group has generators:
  [ f3, f4 ]
: Range group s3 has generators:
  [ f1, f2 ]
: Boundary homomorphism maps source generators to:
  [ &amp;lt;identity&amp;gt; of ..., &amp;lt;identity&amp;gt; of ... ]
  The automorphism group is trivial
: associated cat1-group is [s3c4=&gt;s3]

</pre></div>

<p><a id="X7B38B960782937EB" name="X7B38B960782937EB"></a></p>

<h4>2.4 <span class="Heading">Selection of a small cat1-group</span></h4>

<p>The <code class="code">Cat1</code> function may also be used to select a cat1-group from a data file. All cat1-structures on groups of size up to <span class="SimpleMath">70</span> (ordered according to the <strong class="pkg">GAP</strong> 4 numbering of small groups) are stored in a list in file <code class="file">cat1data.g</code>. Global variables <code class="code">CAT1_LIST_MAX_SIZE := 70</code> and <code class="code">CAT1_LIST_CLASS_SIZES</code> are also stored. The data is read into the list <code class="code">CAT1_LIST</code> only when this function is called.</p>

<p><a id="X7B8E67D880E380C8" name="X7B8E67D880E380C8"></a></p>

<h5>2.4-1 Cat1Select</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Cat1Select</code>( <var class="Arg">size</var>, <var class="Arg">gpnum</var>, <var class="Arg">num</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>The function <code class="code">Cat1Select</code> may be used in three ways. <code class="code">Cat1Select( size )</code> returns the names of the groups with this size, while <code class="code">Cat1Select( size, gpnum )</code> prints a list of cat1-structures for this chosen group. <code class="code">Cat1Select( size, gpnum, num )</code> (or just <code class="code">Cat1( size, gpnum, num )</code>) returns the chosen cat1-group.</p>

<p>The example below is the first case in which <span class="SimpleMath">t ≠ h</span> and the associated conjugation crossed module is given by the normal subgroup <code class="code">c3</code> of <code class="code">s3</code>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## check the number of groups of size 18</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L18 := Cat1Select( 18 ); </span>
Usage:  Cat1Select( size, gpnum, num );
[ "D18", "C18", "C3 x S3", "(C3 x C3) : C2", "C6 x C3" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## check the number of cat1-structrues on the fourth of these</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cat1Select( 18, 4 );</span>
Usage:  Cat1Select( size, gpnum, num );
There are 4 cat1-structures for the group (C3 x C3) : C2.
[ [range gens], [tail genimages], [head genimages] ] :-
(1)  [ [ f1 ], [ f1, &lt;identity&gt; of ..., &lt;identity&gt; of ... ], 
  [ f1, &lt;identity&gt; of ..., &lt;identity&gt; of ... ] ]
(2)  [ [ f1, f3 ], [ f1, &lt;identity&gt; of ..., f3 ], 
  [ f1, &lt;identity&gt; of ..., f3 ] ]
(3)  [ [ f1, f3 ], [ f1, &lt;identity&gt; of ..., f3 ], 
  [ f1, f3^2, &lt;identity&gt; of ... ] ]
(4)  [ [ f1, f2, f2*f3 ],  tail = head = identity mapping ]
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## select the third of these cat1-structures </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C18 := Cat1( 18, 4, 3 );</span>
[(C3 x C3) : C2=&gt;Group( [ f1, &lt;identity&gt; of ..., f3 ] )]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## convert from a pc-cat1-group to a permutation cat1-group</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso18 := IsomorphismPermObject( C18 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PC18 := Image( iso18 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( PC18 );                     </span>

Cat1-group [..=&gt;..] :- 
: Source group has generators:
  [ (2,3)(5,6), (4,5,6), (1,2,3) ]
: Range group has generators:
  [ (2,3), (), (1,2,3) ]
: tail homomorphism maps source generators to:
  [ (2,3), (), (1,2,3) ]
: head homomorphism maps source generators to:
  [ (2,3), (1,3,2), (1,2,3) ]
: range embedding maps range generators to:
  [ (2,3)(5,6), (), (1,2,3) ]
: kernel has generators:
  [ (4,5,6) ]
: boundary homomorphism maps generators of kernel to:
  [ (1,3,2) ]
: kernel embedding maps generators of kernel to:
  [ (4,5,6) ]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">convert the result to the associated permutation crossed module </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X18 := XModByCat1( PC18 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( X18 ); </span>

Crossed module X([..=&gt;..]) :- 
: Source group has generators:
  [ (4,5,6) ]
: Range group has generators:
  [ (2,3), (), (1,2,3) ]
: Boundary homomorphism maps source generators to:
  [ (1,3,2) ]
: Action homomorphism maps range generators to automorphisms:
  (2,3) --&gt; { source gens --&gt; [ (4,6,5) ] }
  () --&gt; { source gens --&gt; [ (4,5,6) ] }
  (1,2,3) --&gt; { source gens --&gt; [ (4,5,6) ] }
  These 3 automorphisms generate the group of automorphisms.
: associated cat1-group is [..=&gt;..]


</pre></div>

<p><a id="X7A081F9D826621DA" name="X7A081F9D826621DA"></a></p>

<h5>2.4-2 AllCat1sBasic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllCat1sBasic</code>( <var class="Arg">gp</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>For a group <span class="SimpleMath">G</span> of size greater than <span class="SimpleMath">70</span> which is reasonably straightforward this function may be used to construct a list of all cat1-group structures on <span class="SimpleMath">G</span>. The operation also attempts to write output to a file in the folder <code class="file">xmod/lib</code>. (Other operations in the file <code class="file">cat1data.gi</code> have been used to deal with the more complicated groups of size up to <span class="SimpleMath">70</span>, but these are not described here.)</p>

<p>Van Luyen Le has a more efficient algorithm, extending the data up to groups of size 171, which is expected to appear in a future release of <strong class="pkg">HAP</strong>.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gp := SmallGroup( 102, 2 ); </span>
&lt;pc group of size 102 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StructureDescription( gp ); </span>
"C3 x D34"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">all := AllCat1sBasic( gp );</span>
#I Edit last line of .../xmod/lib/nn.kk.out to end with ] ] ] ] ]
[ [Group( [ f1, f2, f3 ] )=&gt;Group( [ f1, &lt;identity&gt; of ..., &lt;identity&gt; of ... 
     ] )], [Group( [ f1, f2, f3 ] )=&gt;Group( [ f1, f2, &lt;identity&gt; of ... ] )], 
  [Group( [ f1, f2, f3 ] )=&gt;Group( [ f1, &lt;identity&gt; of ..., f3 ] )], 
  [Group( [ f1, f2, f3 ] )=&gt;Group( [ f1, f2, f3 ] )] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( all[3] ); </span>

Cat1-group [..=&gt;..] :- 
: Source group has generators:
  [ f1, f2, f3 ]
: Range group has generators:
  [ f1, &lt;identity&gt; of ..., f3 ]
: tail homomorphism maps source generators to:
  [ f1, &lt;identity&gt; of ..., f3 ]
: head homomorphism maps source generators to:
  [ f1, &lt;identity&gt; of ..., f3 ]
: range embedding maps range generators to:
  [ f1, &lt;identity&gt; of ..., f3 ]
: kernel has generators:
  [ f2 ]
: boundary homomorphism maps generators of kernel to:
  [ &lt;identity&gt; of ... ]
: kernel embedding maps generators of kernel to:
  [ f2 ]


</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
