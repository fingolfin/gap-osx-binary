% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{\textsf{LAGUNA}\mbox{}}}\\
\vfill

\hypersetup{pdftitle=\textsf{LAGUNA}}
\markright{\scriptsize \mbox{}\hfill \textsf{LAGUNA} \hfill\mbox{}}
{\Huge \textbf{Lie AlGebras and UNits of group Algebras\mbox{}}}\\
\vfill

{\Huge Version 3.7.0\mbox{}}\\[1cm]
{11 November 2014\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{Victor Bovdi   \mbox{}}}\\
{\Large \textbf{Alexander Konovalov    \mbox{}}}\\
{\Large \textbf{Richard Rossmanith\mbox{}}}\\
{\Large \textbf{ Csaba Schneider    \mbox{}}}\\
\hypersetup{pdfauthor=Victor Bovdi   ; Alexander Konovalov    ; Richard Rossmanith;  Csaba Schneider    }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{Victor Bovdi   }  Email: \href{mailto://vbovdi@science.unideb.hu} {\texttt{vbovdi@science.unideb.hu}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Institute of Mathematics and Informatics\\
 University of Debrecen\\
 P.O.Box 12, Debrecen, H-4010 Hungary \end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{Alexander Konovalov    }  Email: \href{mailto://alexk@mcs.st-andrews.ac.uk} {\texttt{alexk@mcs.st-andrews.ac.uk}}\\
  Homepage: \href{http://www.cs.st-andrews.ac.uk/~alexk/} {\texttt{http://www.cs.st-andrews.ac.uk/\texttt{\symbol{126}}alexk/}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 School of Computer Science\\
 University of St Andrews\\
 Jack Cole Building, North Haugh,\\
 St Andrews, Fife, KY16 9SX, Scotland \end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{ Csaba Schneider    }  Email: \href{mailto://csaba.schneider@sztaki.hu} {\texttt{csaba.schneider@sztaki.hu}}\\
  Homepage: \href{http://www.sztaki.hu/~schneider} {\texttt{http://www.sztaki.hu/\texttt{\symbol{126}}schneider}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Informatics Laboratory\\
 Computer and Automation Research Institute\\
 The Hungarian Academy of Sciences\\
 1111 Budapest, Lagymanyosi u. 11, Hungary \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Abstract}
\logpage{[ 0, 0, 1 ]}
 \index{LAGUNA package@\textsf{LAGUNA} package} The title ``\textsf{LAGUNA}'' stands for ``\textsc{L}ie \textsc{A}l\textsc{G}ebras and \textsc{UN}its of group \textsc{A}lgebras''. This is the new name of the \textsf{GAP}4 package \textsf{LAG}, which is thus replaced by \textsf{LAGUNA}. 

 \textsf{LAGUNA} extends the \textsf{GAP} functionality for computations in group rings. Besides computing some general
properties and attributes of group rings and their elements, \textsf{LAGUNA} is able to perform two main kinds of computations. Namely, it can verify
whether a group algebra of a finite group satisfies certain Lie properties;
and it can calculate the structure of the normalized unit group of a group
algebra of a finite $p$-group over the field of $p$ elements. 

 \mbox{}}\\[1cm]
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 2 ]}
 {\copyright} 2003-2014 by Victor Bovdi, Alexander Konovalov, Richard
Rossmanith, and Csaba Schneider

 \textsf{LAGUNA} is free software; you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation;
either version 2 of the License, or (at your option) any later version. For
details, see the FSF's own site \href{http://www.gnu.org/licenses/gpl.html} {\texttt{http://www.gnu.org/licenses/gpl.html}}. 

 If you obtained \textsf{LAGUNA}, we would be grateful for a short notification sent to one of the authors.

 If you publish a result which was partially obtained with the usage of \textsf{LAGUNA}, please cite it in the following form:

 V. Bovdi, A. Konovalov, R. Rossmanith and C. Schneider. \emph{LAGUNA --- Lie AlGebras and UNits of group Algebras, Version 3.7.0;} 11 November 2014 (\href{http://www.cs.st-andrews.ac.uk/~alexk/laguna/} {\texttt{http://www.cs.st-andrews.ac.uk/\texttt{\symbol{126}}alexk/laguna/}}). \mbox{}}\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 3 ]}
 Some of the features of \textsf{LAGUNA} were already included in the \textsf{GAP}4 package \textsf{LAG} written by the third author, Richard Rossmanith.  The three other authors first would like to thank Greg Gamble for maintaining \textsf{LAG} and for upgrading it from version 2.0 to version 2.1, and Richard Rossmanith
for allowing them to update and extend the \textsf{LAG} package. We are also grateful to Wolfgang Kimmerle for organizing the workshop
``Computational Group and Group Ring Theory'' (University of Stuttgart, 28--29
November, 2002), which allowed us to meet and have fruitful discussions that
led towards the final \textsf{LAGUNA} release. 

 We are all very grateful to the members of the \textsf{GAP} team: Thomas Breuer, Willem de Graaf, Alexander Hulpke, Stefan Kohl, Steve
Linton, Frank L{\"u}beck, Max Neunh{\"o}ffer and many other colleagues for
helpful comments and advise. We acknowledge very much Herbert Pahlings for
communicating the package and the referee for careful testing \textsf{LAGUNA} and useful suggestions. 

 A part of the work on upgrading \textsf{LAG} to \textsf{LAGUNA} was done in 2002 during Alexander Konovalov's visits to Debrecen, St Andrews
and Stuttgart Universities. He would like to express his gratitude to Adalbert
Bovdi and Victor Bovdi, Colin Campbell, Edmund Robertson and Steve Linton,
Wolfgang Kimmerle, Martin Hertweck and Stefan Kohl for their warm hospitality,
and to the NATO Science Fellowship Program, to the London Mathematical Society
and to the DAAD for the support of these visits. 

 \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 4 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Introduction}}\label{Intro}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  
\section{\textcolor{Chapter }{General aims}}\label{IntroFirst}
\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X8557083378F2A3B2}{}
{
  \textsf{LAGUNA} -- \textsc{L}ie \textsc{A}l\textsc{G}ebras and \textsc{UN}its of group \textsc{A}lgebras -- is the new name of the \textsf{GAP}4 package \textsf{LAG}. The \textsf{LAG} package arose as a byproduct of the third author's PhD thesis  \cite{Ros97}. Its first version was ported to \textsf{GAP}4 and was brought into the standard \textsf{GAP}4 package format during his visit to St Andrews in September 1998. 

 The main objective of \textsf{LAG} is to deal with Lie algebras associated with some associative algebras, and,
in particular, Lie algebras of group algebras. Using \textsf{LAG} it is possible to verify some properties or calculate certain Lie ideals of
such Lie algebras very efficiently, due to their special structure. In the
current version of \textsf{LAGUNA} the main part of the Lie algebra functionality is heavily built on the
previous \textsf{LAG} releases. 

 The \textsf{GAP}4 package \textsf{LAGUNA} also extends the \textsf{GAP} functionality for calculations with units of modular group algebras. In
particular, using this package, one can check whether an element of such a
group algebra is invertible. \textsf{LAGUNA} also contains an implementation of an efficient algorithm to calculate the
(normalized) unit group of the group algebra of a finite $p$-group over the field of $p$ elements. \index{SISYPHOS package@\textsf{SISYPHOS} package} Thus, the present version of \textsf{LAGUNA} provides a part of the functionality of the \textsf{SISYPHOS} program, which was developed by Martin Wursthorn to study the modular
isomorphism problem; see \cite{Wursthorn}. 

 The corresponding functions of \textsf{LAGUNA} use the same algorithmic and theoretical approach as those in \textsf{SISYPHOS}. The reason why we reimplemented the normalised unit group algorithms in the \textsf{LAGUNA} package is that \textsf{SISYPHOS} has no interface to \textsf{GAP}4, and, even in \textsf{GAP}3, it is cumbersome to use the \textsf{SISYPHOS} output for further computation with the normalised unit group. For instance,
using \textsf{SISYPHOS} with its \textsf{GAP}3 interface, it is difficult to embed a finite $p$-group into the normalized unit group of its group algebra over the field of $p$ elements, but this can easily be done with \textsf{LAGUNA}. }

  
\section{\textcolor{Chapter }{General computations in group rings}}\label{IntroFirstAndaHalf}
\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X790BFE667E3BEC3A}{}
{
  The \textsf{LAGUNA} package provides a set of functions to carry out some basic computations with
a group ring and its elements. Among other things, \textsf{LAGUNA} provides elementary functions to compute such basic notions as support,
length, trace and augmentation of an element. For modular group algebras of
finite $p$-groups \textsf{LAGUNA} is able to calculate the power-structure of the augmentation ideal, which is
useful for the construction of the normalised unit group; see Sections \ref{GenSec}--\ref{Ideals} for more details. }

  
\section{\textcolor{Chapter }{Computations in the normalized unit group}}\label{IntroSecond}
\logpage{[ 1, 3, 0 ]}
\hyperdef{L}{X7B7E5E987DBBA237}{}
{
  One of the aims of the \textsf{LAGUNA} package is to carry out efficient computations in the normalised unit group of
the group algebra $FG$ of a finite $p$-group $G$ over the field $F$ of $p$ elements. If $U$ is the unit group of $FG$ then it is easy to see that $U$ is the direct product of $F^*$ and $V(FG)$, where $F^*$ is the multiplicative group of $F$, and $V(FG)$ is the group of normalised units. A unit of $FG$ of the form $\alpha_1 \cdot g_1 + \alpha_2 \cdot g_2 + \cdots + \alpha_k \cdot g_k$ with $\alpha_i \in F$ and $g_i \in G$ is said to be normalised if the sum $\alpha_1 + \alpha_2 + \cdots + \alpha_k$ is equal to $1$. 

 It is well-known that the normalised unit group $V$ has order $|F|^{|G|-1}$, and so $V$ is a finite $p$-group. Thus computing $V$ efficiently means to compute a polycyclic presentation for $V$. For the theory of polycyclic presentations refer to \cite[Chapter 9]{Sims}. For this computation we use an algorithm that was also used in the \textsf{SISYPHOS} package. For a brief description see Chapter \ref{Theory}. The functions that compute the structure of the normalised unit group are
described in Section \ref{UnitGroup}. }

  
\section{\textcolor{Chapter }{Computing Lie properties of the group algebra }}\label{IntroThird}
\logpage{[ 1, 4, 0 ]}
\hyperdef{L}{X78B33FFF7A5D2FEF}{}
{
  The functions that are used to compute Lie properties of $p$-modular group algebras were already included in the previous versions of \textsf{LAG}. The bracket operation $[\cdot,\cdot]$ on a $p$-modular group algebra $FG$ is defined by $[a,b]=ab-ba$. It is well-known and very easy to check that $(FG, +, [\cdot,\cdot])$ is a Lie algebra. Then we may ask what kind of Lie algebra properties are
satisfied by $FG$. The results in \cite{LR86}, \cite{PPS73}, and \cite{Ros00} give fast, practical algorithms to check whether the Lie algebra $FG$ is abelian, nilpotent, soluble, centre-by-metabelian, etc. The functions that
implement these algorithms are described in Section \ref{LieAlgebra}. }

 
\section{\textcolor{Chapter }{Installation and system requirements}}\label{IntroFourth}
\logpage{[ 1, 5, 0 ]}
\hyperdef{L}{X7DB566D5785B7DBC}{}
{
  \textsf{LAGUNA} does not use external binaries and, therefore, works without restrictions on
the type of the operating system. It is designed for \textsf{GAP}4.4 and no compatibility with previous releases of \textsf{GAP}4 is guaranteed. 

 To use the \textsf{LAGUNA} online help it is necessary to install the \textsf{GAP}4 package \textsf{GAPDoc} by Frank L{\"u}beck and Max Neunh{\"o}ffer, which is available from the \textsf{GAP} site or from \href{http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc/} {\texttt{http://www.math.rwth-aachen.de/\texttt{\symbol{126}}Frank.Luebeck/GAPDoc/}}. 

 \textsf{LAGUNA} is distributed in standard formats (\texttt{zoo}, \texttt{tar.gz}, \texttt{tar.bz2}, \texttt{-win.zip}) and can be obtained from \href{http://www.cs.st-andrews.ac.uk/~alexk/laguna/} {\texttt{http://www.cs.st-andrews.ac.uk/\texttt{\symbol{126}}alexk/laguna/}}. To unpack the archive \texttt{laguna-X.X.X.zoo} you need the program \texttt{unzoo}, which can be obtained from the \textsf{GAP} homepage \href{http://www.gap-system.org/} {\texttt{http://www.gap-system.org/}} (see section `Distribution'). To install \textsf{LAGUNA}, copy this archive into the \texttt{pkg} subdirectory of your \textsf{GAP}4.4 installation. The subdirectory \texttt{laguna} will be created in the \texttt{pkg} directory after the following command: 

 \texttt{unzoo -x laguna-X.X.X.zoo} 

 }

 }

 
\chapter{\textcolor{Chapter }{A sample calculation with \textsf{LAGUNA}}}\label{Example}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7E9EADCA7F1D9DC8}{}
{
  Before explaining the theory behind the \textsf{LAGUNA} package we present a sample calculation to show the reader what \textsf{LAGUNA} is able to compute. We will carry out some calculations in the group algebra
of the dihedral group of order 16 over the field of two elements. First we
create this modular group algebra. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@K := GF( 2 );|
  GF(2)
  !gapprompt@gap>| !gapinput@G := DihedralGroup( 16 );|
  <pc group of size 16 with 4 generators>
  !gapprompt@gap>| !gapinput@KG := GroupRing( K, G );|
  <algebra-with-one over GF(2), with 4 generators>
  
\end{Verbatim}
 The group algebra \texttt{KG} has some properties and attributes that are direct consequences of its
definition. These can be checked very quickly. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@IsGroupAlgebra( KG ); |
  true
  !gapprompt@gap>| !gapinput@IsPModularGroupAlgebra( KG );|
  true
  !gapprompt@gap>| !gapinput@IsFModularGroupAlgebra( KG );|
  true
  !gapprompt@gap>| !gapinput@UnderlyingGroup( KG );|
  <pc group of size 16 with 4 generators>
  !gapprompt@gap>| !gapinput@LeftActingDomain( KG );|
  GF(2)
  
\end{Verbatim}
 Since \texttt{KG} is naturally a group algebra, the information provided by \texttt{LeftActingDomain} can also be obtained using two other functions as follows. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@UnderlyingRing( KG );|
  GF(2)
  !gapprompt@gap>| !gapinput@UnderlyingField( KG );|
  GF(2)
\end{Verbatim}
 Let us construct a certain element of the group algebra. For example, we take
a minimal generating system of the group \texttt{G} and find the corresponding elements in \texttt{KG}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@MinimalGeneratingSet( G );|
  [ f1, f2 ]
  !gapprompt@gap>| !gapinput@l := List( last, g -> g^Embedding( G, KG ) );|
  [ (Z(2)^0)*f1, (Z(2)^0)*f2 ]
  
\end{Verbatim}
 Now we construct an element \texttt{x} as follows. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@a :=l[1]; b:=l[2]; # a and b are images of group generators in KG|
  (Z(2)^0)*f1
  (Z(2)^0)*f2
  !gapprompt@gap>| !gapinput@e := One( KG );    # for convenience, we denote the identity by e|
  (Z(2)^0)*<identity> of ...
  !gapprompt@gap>| !gapinput@x := ( e + a ) * ( e + b ); |
  (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2  
  
\end{Verbatim}
 We may investigate some of the basic properties of our element. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@Support( x );|
  [ <identity> of ..., f1, f2, f1*f2 ]
  !gapprompt@gap>| !gapinput@CoefficientsBySupport( x );|
  [ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ]
  !gapprompt@gap>| !gapinput@Length( x );|
  4
  !gapprompt@gap>| !gapinput@TraceOfMagmaRingElement( x );|
  Z(2)^0
  
\end{Verbatim}
 We can also calculate the augmentation of \texttt{x}, which is defined as the sum of its coefficients. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Augmentation( x );|
  0*Z(2)
  !gapprompt@gap>| !gapinput@IsUnit( KG, x );|
  false
\end{Verbatim}
 Since the augmentation of \texttt{x} is zero, \texttt{x} is not invertible, but \texttt{1+x} is. This is again very easy to check. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@y := e + x;|
  (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
  !gapprompt@gap>| !gapinput@IsUnit( KG, y );|
  true  
  
\end{Verbatim}
 \textsf{LAGUNA} can calculate the inverse of \texttt{1+x} very quickly. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@y^-1;|
  (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f4+(Z(2)^0)*f1*f2+(Z(2)^
  0)*f1*f3+(Z(2)^0)*f1*f4+(Z(2)^0)*f2*f4+(Z(2)^0)*f1*f2*f4+(Z(2)^0)*f2*f3*f4+(
  Z(2)^0)*f1*f2*f3*f4
  !gapprompt@gap>| !gapinput@y * y^-1;|
  (Z(2)^0)*<identity> of ... 
  
\end{Verbatim}
 We may also want to check whether \texttt{y} is symmetric, that is, whether it is invariant under the classical involution;
or whether it is unitary, that is, whether the classical involution inverts \texttt{y}. We find that \texttt{y} is neither. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@Involution( y );|
  (Z(2)^0)*f1+(Z(2)^0)*f1*f2+(Z(2)^0)*f2*f3*f4
  !gapprompt@gap>| !gapinput@y = Involution( y );|
  false
  !gapprompt@gap>| !gapinput@IsSymmetric( y );|
  false
  !gapprompt@gap>| !gapinput@y * Involution( y );|
  (Z(2)^0)*<identity> of ...+(Z(2)^0)*f2+(Z(2)^0)*f2*f3*f4  
  !gapprompt@gap>| !gapinput@IsUnitary( y );|
  false
  
\end{Verbatim}
 Now we calculate some important ideals of \texttt{KG}. First we obtain the augmentation ideal which is the set of elements with
augmentation zero. In our case the augmentation ideal of \texttt{KG} coincides with the radical of \texttt{KG}, and this is taken into account in \textsf{LAGUNA}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@AugmentationIdeal( KG );|
  <two-sided ideal in <algebra-with-one over GF(2), with 4 generators>,
    (dimension 15)>
  !gapprompt@gap>| !gapinput@RadicalOfAlgebra( KG ) = AugmentationIdeal( KG );|
  true
  
\end{Verbatim}
 It is well-known that the augmentation ideal of \texttt{KG} is a nilpotent ideal. Using Jennings' theory on dimension subgroups, we can
obtain its nilpotency index without immediate calculation of its powers. This
is implemented in \textsf{LAGUNA}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@AugmentationIdealNilpotencyIndex( KG );|
  9
\end{Verbatim}
 \newpage On the other hand, we can also calculate the powers of the augmentation ideal. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@AugmentationIdealPowerSeries( KG );|
  [ <algebra of dimension 15 over GF(2)>, <algebra of dimension 13 over GF(2)>, 
    <algebra of dimension 11 over GF(2)>, <algebra of dimension 9 over GF(2)>, 
    <algebra of dimension 7 over GF(2)>, <algebra of dimension 5 over GF(2)>, 
    <algebra of dimension 3 over GF(2)>, <algebra of dimension 1 over GF(2)>, 
    <algebra over GF(2)> ]
  
\end{Verbatim}
 We see that the length of this list is exactly the nilpotency index of the
augmentation ideal of \texttt{KG}. 

 Now let's work with the unit group of \texttt{KG}. First we calculate the normalized unit group, which is the set of elements
with augmentation one. The generators of the unit group are obtained as
explained in Chapter \ref{Theory}. This can be computed very quickly, but further computation with this group
is very inefficient. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@V := NormalizedUnitGroup( KG );|
  <group of size 32768 with 15 generators>   
  
\end{Verbatim}
 In order to make our computation in the normalised unit group efficient, we
calculate a power-commutator presentation for this group. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@W := PcNormalizedUnitGroup( KG );|
  <pc group of size 32768 with 15 generators>
  
\end{Verbatim}
 \textsf{GAP} has many efficient and practical algorithms for groups given by a
power-commutator presentation. In order to use these algorithms to carry out
computation in the normalised unit group, we need to set up isomorphisms
between the outputs of \texttt{NormalizedUnitGroup} and \texttt{PcNormalizedUnitGroup}. 

 The first isomorphism maps \texttt{NormalizedUnitGroup(KG)} onto the polycyclically presented \texttt{PcNormalizedUnitGroup(PC)}. Let's find the images of the elements of the group \texttt{G} in \texttt{W}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@t := NaturalBijectionToPcNormalizedUnitGroup( KG );|
  MappingByFunction( <group of size 32768 with 15 generators>, <pc group of size\
   32768 with 15 generators>, function( x ) ... end )
  !gapprompt@gap>| !gapinput@List( AsList( G ), x -> ( x^Embedding( G, KG ) )^t );|
  [ <identity> of ..., f2, f1, f3, f7, f1*f2*f3, f2*f3, f2*f7, f1*f3, f1*f7,
    f3*f7, f1*f2*f7, f1*f2*f3*f7, f2*f3*f7, f1*f3*f7, f1*f2 ]
  
\end{Verbatim}
 \newpage The second isomorphism is the inverse of the first. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@f := NaturalBijectionToNormalizedUnitGroup( KG );|
  [ f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15 ] ->
  [ (Z(2)^0)*f2, (Z(2)^0)*f1, (Z(2)^0)*f3,
    (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2,
    (Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f2*f3,
    (Z(2)^0)*f1+(Z(2)^0)*f3+(Z(2)^0)*f1*f3, (Z(2)^0)*f4,
    (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f1*f2+(Z(2)^0)*f1*f3+(Z(2)^
      0)*f2*f3+(Z(2)^0)*f1*f2*f3, (Z(2)^0)*f2+(Z(2)^0)*f4+(Z(2)^0)*f2*f4,
    (Z(2)^0)*f1+(Z(2)^0)*f4+(Z(2)^0)*f1*f4,
    (Z(2)^0)*f3+(Z(2)^0)*f4+(Z(2)^0)*f3*f4,
    (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f4+(Z(2)^0)*f1*f2+(Z(2)^0)*f1*f4+(Z(2)^
      0)*f2*f4+(Z(2)^0)*f1*f2*f4, (Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f4+(Z(2)^
      0)*f2*f3+(Z(2)^0)*f2*f4+(Z(2)^0)*f3*f4+(Z(2)^0)*f2*f3*f4,
    (Z(2)^0)*f1+(Z(2)^0)*f3+(Z(2)^0)*f4+(Z(2)^0)*f1*f3+(Z(2)^0)*f1*f4+(Z(2)^
      0)*f3*f4+(Z(2)^0)*f1*f3*f4, (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^
      0)*f4+(Z(2)^0)*f1*f2+(Z(2)^0)*f1*f3+(Z(2)^0)*f1*f4+(Z(2)^0)*f2*f3+(Z(2)^
      0)*f2*f4+(Z(2)^0)*f3*f4+(Z(2)^0)*f1*f2*f3+(Z(2)^0)*f1*f2*f4+(Z(2)^
      0)*f1*f3*f4+(Z(2)^0)*f2*f3*f4+(Z(2)^0)*f1*f2*f3*f4 ]
\end{Verbatim}
 For example, we may calculate the conjugacy classes of the group \texttt{W}, and then map their representatives back into the group algebra. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@cc := ConjugacyClasses( W );;|
  !gapprompt@gap>| !gapinput@Length( cc );|
  848
  !gapprompt@gap>| !gapinput@Representative( cc[ Length( cc ) ] );|
  f1*f2*f4*f6*f12*f15
  !gapprompt@gap>| !gapinput@last^f;|
  (Z(2)^0)*<identity> of ...+(Z(2)^0)*f2+(Z(2)^0)*f4+(Z(2)^0)*f1*f2+(Z(2)^
  0)*f1*f3+(Z(2)^0)*f1*f4+(Z(2)^0)*f2*f3+(Z(2)^0)*f2*f4+(Z(2)^0)*f3*f4+(Z(2)^
  0)*f1*f2*f3+(Z(2)^0)*f1*f3*f4
  
\end{Verbatim}
 Having a power-commutator presentation of the normalised unit group, we may
use the full power of the \textsf{GAP} functionality for such groups. For example, the lower central series can be
calculated very quickly. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@LowerCentralSeries( W );|
  [ <pc group of size 32768 with 15 generators>,
    Group([ f3, f5*f8*f10*f12*f13*f14*f15, f6*f8*f12*f14*f15, f7, f9*f12,
        f10*f14, f11*f13, f13*f14, f14*f15 ]),
    Group([ f7, f9*f12, f10*f15, f11*f15, f13*f15, f14*f15 ]),
    Group([ f11*f15, f13*f15, f14*f15 ]), Group([ <identity> of ... ]) ]
  
\end{Verbatim}
 \newpage Let's now compute, for instance, a minimal system of generators of the centre
of the normalised unit group. First we carry out the computation in the group
which is determined by the power-commutator presentation, then we map the
result into our group algebra. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@C := Centre( W );|
  Group([ f3*f5*f13*f15, f7, f15, f13*f15, f14*f15, f11*f13*f14*f15 ])
  !gapprompt@gap>| !gapinput@m := MinimalGeneratingSet( C );|
  [ f7*f13*f14*f15, f13*f14*f15, f7*f11*f14*f15, f15, f3*f5*f14 ]
  !gapprompt@gap>| !gapinput@List( m, g -> g^f );|
  [ (Z(2)^0)*<identity> of ...+(Z(2)^0)*f3+(Z(2)^0)*f1*f2+(Z(2)^0)*f3*f4+(Z(2)^
      0)*f1*f2*f3+(Z(2)^0)*f1*f2*f4+(Z(2)^0)*f1*f2*f3*f4,
    (Z(2)^0)*f3+(Z(2)^0)*f4+(Z(2)^0)*f1*f2+(Z(2)^0)*f3*f4+(Z(2)^0)*f1*f2*f3+(
      Z(2)^0)*f1*f2*f4+(Z(2)^0)*f1*f2*f3*f4, (Z(2)^0)*<identity> of ...+(Z(2)^
      0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f1*f2+(Z(2)^0)*f2*f3+(Z(2)^0)*f2*f4+(Z(2)^
      0)*f3*f4+(Z(2)^0)*f1*f2*f3+(Z(2)^0)*f1*f2*f4+(Z(2)^0)*f2*f3*f4+(Z(2)^
      0)*f1*f2*f3*f4, (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f4+(Z(2)^
      0)*f1*f2+(Z(2)^0)*f1*f3+(Z(2)^0)*f1*f4+(Z(2)^0)*f2*f3+(Z(2)^0)*f2*f4+(
      Z(2)^0)*f3*f4+(Z(2)^0)*f1*f2*f3+(Z(2)^0)*f1*f2*f4+(Z(2)^0)*f1*f3*f4+(Z(2)^
      0)*f2*f3*f4+(Z(2)^0)*f1*f2*f3*f4, (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1+(
      Z(2)^0)*f3+(Z(2)^0)*f1*f3+(Z(2)^0)*f1*f4+(Z(2)^0)*f2*f3+(Z(2)^0)*f2*f4+(
      Z(2)^0)*f3*f4+(Z(2)^0)*f1*f3*f4 ]
  
\end{Verbatim}
 We finish our example by calculating some properties of the Lie algebra
associated with \texttt{KG}. This example needs no further explanation. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@L := LieAlgebra( KG );|
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra of dimension 16 over GF(2)>
  !gapprompt@gap>| !gapinput@D := LieDerivedSubalgebra( L );|
  #I  LAGUNA package: Computing the Lie derived subalgebra ...
  <Lie algebra of dimension 9 over GF(2)>
  !gapprompt@gap>| !gapinput@LC := LieCentre( L );|
  <Lie algebra of dimension 7 over GF(2)>
  !gapprompt@gap>| !gapinput@LieLowerNilpotencyIndex( KG );|
  5
  !gapprompt@gap>| !gapinput@LieUpperNilpotencyIndex( KG );|
  5
  !gapprompt@gap>| !gapinput@IsLieAbelian( L );|
  false
  !gapprompt@gap>| !gapinput@IsLieSolvable( L );|
  #I  LAGUNA package: Checking Lie solvability ...
  true
  !gapprompt@gap>| !gapinput@IsLieMetabelian( L );|
  false
  !gapprompt@gap>| !gapinput@IsLieCentreByMetabelian( L );|
  true
  
\end{Verbatim}
 }

 
\chapter{\textcolor{Chapter }{The basic theory behind \textsf{LAGUNA}}}\label{Theory}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X81154D7881F7378F}{}
{
  In this chapter we describe the theory that is behind the algorithms used by \textsf{LAGUNA}. 
\section{\textcolor{Chapter }{Notation and definitions}}\label{TheoryFirst}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X85C2DE1486FB45FD}{}
{
  \index{group algebra} Let $G$ be a group and $F$ a field. Then the \emph{group algebra} $FG$ consists of the set of formal linear combinations of the form 
\[ \sum_{g \in G}\alpha_g g,\qquad \alpha_g \in F \]
 where all but finitely many of the $\alpha_g$ are zero. The group algebra $FG$ is an $F$-algebra with the obvious operations. Clearly, $\dim FG=|G|$.

 \index{augmentation homomorphism} \index{augmentation ideal} The \emph{augmentation homomorphism} $ \chi : FG \rightarrow F$ is defined by 
\[ \chi\left(\sum_{g \in G}\alpha_g g\right)=\sum_{g \in G}\alpha_g. \]
 It is easy to see that $\chi$ is indeed a homomorphism onto $F$. The kernel of $\chi$ is called the \emph{augmentation ideal} of $FG$. The augmentation ideal is denoted $A(FG)$, or simply $A$ when there is no danger of confusion. It follows from the isomorphism theorems
that $\dim A(FG)=\dim FG-1=|G|-1$. Another way to write the augmentation ideal is 
\[ A(FG)=\left\{\sum_{g \in G}\alpha_g g\ |\ \sum_{g \in G}\alpha_g=0\right\}. \]


 \index{unit} \index{unit group} \index{normalised unit} \index{normalised unit group} An invertible element of $FG$ is said to be a \emph{unit}. Clearly the elements of $G$ and the non-zero elements of $F$ are units. The set of units in $FG$ is a group with respect to the multiplication of $FG$. The \emph{unit group} of $FG$ is denoted $U(FG)$ or simply $U$ when there is no risk of confusion. A unit $u$ is said to be \emph{normalised} if $\chi(u)=1$. The set of normalised units forms a subgroup of the unit group, and is
referred to as the \emph{normalised unit group}. The normalised unit group of $FG$ is denoted $V(FG)$, or simply $V$. It is easy to prove that $U(FG) = F^* \times V(FG)$ where $F^*$ denotes the multiplicative group of $F$. }

  
\section{\textcolor{Chapter }{$p$-modular group algebras}}\label{TheorySecond}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X80A5F4BD78768C75}{}
{
  \index{p-modular group algebra@$p$-modular group algebra} A group algebra $FG$ is said to be $p$-modular if $F$ is the field of characteristic $p$, and $G$ is a finite $p$-group. A lot of information about the structure of $p$-modular group algebras can be found in \cite[Chapter VIII]{HB}. In a $p$-modular group algebra we have that an element $u$ is a unit if and only if $\chi(u)\neq 0$. Hence the normalised unit group $V$ consists of all elements of $FG$ with augmentation $1$. In other words $V$ is a coset of the augmentation ideal, namely $V=1+A$. This also implies that $|V|=|A|=|F|^{|G|-1}$, and so $V$ is a finite $p$-group. 

 \index{power-commutator presentation} One of the aims of the \textsf{LAGUNA} package is to compute a power-commutator presentation for the normalised unit
group in the case when $G$ is a finite $p$-group and $F$ is a field of $p$ elements. Such a presentation is given by generators $y_1, \ldots, y_{|G|-1} $ and two types of relations: $y_i^p=(y_{i+1})^{\alpha_{i,i+1}} \cdots (y_{|G|-1})^{\alpha_{i,|G|-1}}$ for $ 1 \leq i \leq |G|-1 $, and $ [y_j,y_i]=(y_{j+1})^{\alpha_{j,i,j+1}} \cdots (y_{|G|-1})^{\alpha_{j,i,|G|-1}} $ for $ 1 \leq i < j \leq |G|-1$, where the exponents $\alpha_{i,k}$ and $\alpha_{i,j,k}$ are elements of the set $\{0,\ldots,p-1\}$. Having such a presentation, it is possible to carry out efficient
computations in the finite $p$-group $V$; see \cite[Chapter 9]{Sims}. }

  
\section{\textcolor{Chapter }{Polycyclic generating set for $V$}}\label{TheoryThird}
\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X7FB81FE082DFF909}{}
{
  Let $G$ be a finite $p$-group and $F$ the field of $p$ elements. Our aim is to construct a power-commutator presentation for $V=V(FG)$. We noted earlier that $V=1+A$, where $A$ is the augmentation ideal. We use this piece of information and construct a
polycyclic generating set for $V$ using a suitable basis for $A$. Before constructing this generating set, we note that $A$ is a nilpotent ideal in $FG$. In other words there is some $c$ such that $A^c\neq 0$ but $A^{c+1}=0$. Hence we can consider the following series of ideals in $A$: 
\[ A\rhd A^2\rhd\cdots\rhd A^{c}\rhd A^{c+1}=0. \]
 It is clear that a quotient $A^i/A^{i+1}$of this chain has trivial multiplication, that is, such a quotient is a
nil-ring. The chain $A^i$ gives rise to a series of normal subgroups in $V$: 
\[ V=1+A\rhd 1+A^2\rhd\cdots\rhd 1+A^c\rhd 1+A^{c+1}=1. \]
 It is easy to see that the chain $1+A^i$ is central, that is, $(1+A^i)/(1+A^{i+1})\leq Z((1+A)/(1+A^{i+1}))$. 

 \index{Jennings series} \index{dimension basis} \index{weight, of dimension basis element} Now we show how to compute a basis for $A^i$ that gives a polycyclic generating set for $1+A^i$. Let 
\[ G=G_1 \rhd G_2\rhd\cdots\rhd G_{k}\rhd G_{k+1}=1 \]
 be the \emph{Jennings series} of $G$. That is, $G_{i+1}=[G_i,G]G_{j^p}$ where $j$ is the smallest non-negative integer such that $j\geq i/p$. For all $i\leq k$ select elements $x_{i,1},\ldots,x_{i,l_i}$ of $G_i$ such that $\{x_{i,1}G_{i+1},\ldots,x_{i,l_i}G_{i+1}\}$ is a minimal generating set for the elementary abelian group $G_i/G_{i+1}$. For the Jennings series it may happen that $G_i=G_{i+1}$ for some $i$. In this case we choose an empty generating set for the quotient $G_i/G_{i+1}$ and $l_i=0$. Then the set $x_{1,1},\ldots,x_{1,l_1},\ldots,x_{k,1},\ldots,x_{k,l_k}$ is said to be a \emph{dimension basis} for $G$. The \emph{weight} of a dimension basis element $x_{i,j}$ is $i$.

 \index{standard product} A non-empty product 
\[ u=(x_{1,1}-1)^{\alpha_{1,1}}\cdots(x_{1,l_1}-1)^{\alpha_{1,l_1}}\cdots
(x_{k,1}-1)^{\alpha_{k,1}}\cdots(x_{k,l_k}-1)^{\alpha_{k,l_k}} \]
 where $0\leq \alpha_{i,j}\leq p-1$ is said to be \emph{standard}. Clearly, a standard product is an element of the augmentation ideal $A$. The weight of the standard product $u$ is 
\[ \sum_{i=1}^k i(\alpha_{i,1}+\cdots+\alpha_{i,l_i}). \]
 The total number of standard products is $|G|-1$ . 

 \textsc{Lemma (}\cite[Theorem VIII.2.6]{HB}\textsc{).} For $i\leq c$, the set $S_i$ of standard products of weight at least $i$ forms a basis for $A^i$. Moreover, the set $1+S_i=\{1+s\ |\ s \in S_i\}$ is a polycyclic generating set for $1+A^i$. In particular $1+S_1$ is a polycyclic generating set for $V$. 

 A basis for $A$ consisting of the standard products is referred to as a \emph{weighted basis}. Note that a weighted basis is a basis for the augmentation ideal, and not
for the whole group algebra.

 Let $x_1,\ldots,x_{{|G|}-1}$ denote the standard products where we choose the indices so that the weight of $x_i$ is not larger than the weight of $x_{i+1}$ for all $i$, and set $y_i=1+x_i$. Then every element $v$ of $V$ can be uniquely written in the form 
\[ v=y_1^{\alpha_1}\cdots (y_{|G|-1})^{\alpha_{|G|-1}}, \quad
\alpha_1,\ldots,\alpha_{|G|-1} \in \{0,\ldots,p-1\}. \]
 This expression is called the \emph{canonical form} of $v$. We note that by adding a generator of $F^*$ to the set $y_1,\ldots,y_{|G|-1|}$ we can obtain a polycyclic generating set for the unit group $U$. }

  
\section{\textcolor{Chapter }{Computing the canonical form}}\label{TheoryFourth}
\logpage{[ 3, 4, 0 ]}
\hyperdef{L}{X7DCB12F48752C17E}{}
{
  We show how to compute the canonical form of a normalised unit with respect to
the polycyclic generating set $y_1,\ldots,y_{|G|-1}$. We use the following elementary lemma. 

 \textsc{Lemma.} Let $i\leq c$ and suppose that $w \in A^i$. Assume that $x_{s_i},x_{s_i+1}\ldots,x_{r_i}$ are the standard products with weight $i$ and for $s_i\leq j\leq r_i$ set $y_j=1+x_j$. Then for all $\alpha_{s_i},\ldots,\alpha_{r_i}\in\{0,\ldots,p-1\}$ we have that 
\[ w\equiv \alpha_{s_i}x_{s_i}+\cdots+\alpha_{r_i}x_{r_i}\quad \bmod \quad
A^{i+1} \]
 if an only if 
\[ 1+w\equiv (y_{s_i})^{\alpha_{s_i}}\cdots (y_{r_i})^{\alpha_{r_i}}\quad \bmod
\quad 1+A^{i+1}. \]
 

 Suppose that $w$ is an element of the augmentation ideal $A$ and $1+w$ is a normalised unit. Let $x_1,\ldots,x_{r_1}$ be the standard products of weight 1, and let $y_1,\ldots,y_{r_1}$ be the corresponding elements in the polycyclic generating set. Then using the
previous lemma, we find $\alpha_1,\ldots,\alpha_{r_1}$ such that 
\[ w\equiv \alpha_{1}x_{1}+\cdots+\alpha_{r_1}x_{r_1}\quad \bmod \quad A^{2}, \]
 and so 
\[ 1+w\equiv (y_{1})^{\alpha_{1}}\cdots (y_{r_1})^{\alpha_{r_1}}\quad \bmod \quad
1+A^{2}. \]
 Now we have that $1+w=(y_{1})^{\alpha_{1}}\cdots (y_{r_1})^{\alpha_{r_1}}(1+w_2)$ for some $w_2 \in A^2$. Then suppose that $x_{s_2},x_{s_2+1},\ldots,x_{r_2}$ are the standard products of weight 2. We find $\alpha_{s_2},\ldots,\alpha_{r_2}$ such that 
\[ w_2\equiv \alpha_{s_2}x_{s_2}+\cdots+\alpha_{r_2}x_{r_2}\quad \bmod \quad
A^{3}. \]
 Then the lemma above implies that 
\[ 1+w_2\equiv (y_{s_2})^{\alpha_{s_2}}\cdots (y_{r_2})^{\alpha_{r_2}}\quad \bmod
\quad 1+A^{3}. \]
 Thus $1+w_2=(y_{s_2})^{\alpha_{s_2}}\cdots (y_{r_2})^{\alpha_{r_2}}(1+w_3)$ for some $w_3 \in A^3$, and so $1+w=(y_{1})^{\alpha_{1}}\cdots
(y_{r_1})^{\alpha_{r_1}}(y_{s_2})^{\alpha_{s_2}}\cdots
(y_{r_2})^{\alpha_{r_2}}(1+w_3)$. We repeat this process, and after $c$ steps we obtain the canonical form for the element $1+w$. }

  
\section{\textcolor{Chapter }{Computing a power commutator presentation for $V$}}\label{TheoryFifth}
\logpage{[ 3, 5, 0 ]}
\hyperdef{L}{X78FD250584304FB1}{}
{
  Using the procedure in the previous section, it is easy to compute a power
commutator presentation for the normalized unit group $V$ of a $p$-modular group algebra over the field of $p$ elements. First we compute the polycyclic generating sequence $y_1,\ldots,y_{|G|-1}$ as in Section \ref{TheoryThird}. Then for each $y_i$ and for each $y_j,\ y_i$ such that $i<j$ we compute the canonical form for $y_i^p$ and $[y_j,y_i]$ as described in Section \ref{TheoryFourth}. 

 Once a power-commutator presentation for $V$ is constructed, it is easy to obtain a polycyclic presentation for the unit
group $U$ by adding an extra central generator $y$ corresponding to a generator of the cyclic group $F^*$ and enforcing that $y^{p-1}=1$. }

  
\section{\textcolor{Chapter }{Verifying Lie properties of $FG$}}\label{TheorySixth}
\logpage{[ 3, 6, 0 ]}
\hyperdef{L}{X7FAB1A7F87AAE7F0}{}
{
  If $FG$ is a group algebra then one can consider the Lie bracket operation defined by $[a,b]=ab-ba$. Then it is well-known that $FG$ with respect to the scalar multiplication, the addition, and the bracket
operation becomes a Lie algebra over $F$. This Lie algebra is also denoted $FG$. Some Lie properties of such Lie algebras can be computed very efficiently.
In particular, it can be verified whether the Lie algebra $FG$ is nilpotent, soluble, metabelian, centre-by-metabelian. Fast algorithms that
achieve these goals are described in \cite{LR86}, \cite{PPS73}, and \cite{Ros00}. }

 }

 
\chapter{\textcolor{Chapter }{\textsf{LAGUNA} functions}}\label{Funct}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X785535C8820CD403}{}
{
  
\section{\textcolor{Chapter }{General functions for group algebras}}\label{GenSec}
\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X7B473F157842958E}{}
{
  

\subsection{\textcolor{Chapter }{IsGroupAlgebra}}
\logpage{[ 4, 1, 1 ]}\nobreak
\hyperdef{L}{X861A702283A667DF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsGroupAlgebra({\mdseries\slshape KG})\index{IsGroupAlgebra@\texttt{IsGroupAlgebra}}
\label{IsGroupAlgebra}
}\hfill{\scriptsize (property)}}\\


 A group ring over a field is called a group algebra. For a group ring \mbox{\texttt{\mdseries\slshape KG}}, \texttt{IsGroupAlgebra} returns \texttt{true}, if the underlying ring of \mbox{\texttt{\mdseries\slshape KG}} is a field; \texttt{false} is returned otherwise. This property will be set automatically for every group
ring created by the function \texttt{GroupRing}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@IsGroupAlgebra( GroupRing( GF( 2 ), DihedralGroup( 16 ) ) );|
  true
  !gapprompt@gap>| !gapinput@IsGroupAlgebra( GroupRing( Integers, DihedralGroup( 16 ) ) );|
  false      
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsFModularGroupAlgebra}}
\logpage{[ 4, 1, 2 ]}\nobreak
\hyperdef{L}{X82DBCA8F7DB21AC5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsFModularGroupAlgebra({\mdseries\slshape KG})\index{IsFModularGroupAlgebra@\texttt{IsFModularGroupAlgebra}}
\label{IsFModularGroupAlgebra}
}\hfill{\scriptsize (property)}}\\


 \index{modular group algebra} A group algebra $KG$ over a field $K$ is called \emph{modular}, if the characteristic of the field $K$ divides the order of some element in $G$. For a group algebra \mbox{\texttt{\mdseries\slshape KG}} of a finite group $G$, \texttt{IsModularGroupAlgebra} returns \texttt{true}, if \mbox{\texttt{\mdseries\slshape KG}} is modular according to this definition; \texttt{false} is returned otherwise. This property will be set automatically for every group
algebra, created by the function \texttt{GroupRing}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@IsFModularGroupAlgebra( GroupRing( GF( 2 ), SymmetricGroup( 6 ) ) );|
  true
  !gapprompt@gap>| !gapinput@IsFModularGroupAlgebra( GroupRing( GF( 2 ), CyclicGroup( 3 ) ) );|
  false  
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsPModularGroupAlgebra}}
\logpage{[ 4, 1, 3 ]}\nobreak
\hyperdef{L}{X849599E07C38A739}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPModularGroupAlgebra({\mdseries\slshape KG})\index{IsPModularGroupAlgebra@\texttt{IsPModularGroupAlgebra}}
\label{IsPModularGroupAlgebra}
}\hfill{\scriptsize (property)}}\\


 A group algebra $KG$ is said to be $p$-modular, if $K$ is a field of characteristic $p$ and $G$ is a finite $p$-group for the same prime $p$. For a group algebra \mbox{\texttt{\mdseries\slshape KG}} of a finite group $G$, \texttt{IsPModularGroupAlgebra} returns \texttt{true}, if \mbox{\texttt{\mdseries\slshape KG}} is $p$-modular according to this definition; \texttt{false} is returned otherwise. This property will be set automatically for every group
algebra, created by the function \texttt{GroupRing}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@IsPModularGroupAlgebra( GroupRing( GF( 2 ), DihedralGroup( 16 ) ) );|
  true
  !gapprompt@gap>| !gapinput@IsPModularGroupAlgebra( GroupRing( GF( 2 ), SymmetricGroup( 6 ) ) );|
  false        
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{UnderlyingGroup (of a group ring)}}
\logpage{[ 4, 1, 4 ]}\nobreak
\hyperdef{L}{X7C966B177BB62C72}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UnderlyingGroup({\mdseries\slshape KG})\index{UnderlyingGroup@\texttt{UnderlyingGroup}!of a group ring}
\label{UnderlyingGroup:of a group ring}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the underlying group of a group ring 



 This attribute stores the underlying group of a group ring \mbox{\texttt{\mdseries\slshape KG}}. In fact, it refers to the attribute \texttt{UnderlyingMagma} which returns the same result, and was introduced for group rings for
convenience, and for teaching purposes. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF ( 2 ), DihedralGroup( 16 ) );|
  <algebra-with-one over GF(2), with 4 generators>
  !gapprompt@gap>| !gapinput@G := UnderlyingGroup( KG );|
  <pc group of size 16 with 4 generators>  
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{UnderlyingRing}}
\logpage{[ 4, 1, 5 ]}\nobreak
\hyperdef{L}{X8534C18E7EA81CB8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UnderlyingRing({\mdseries\slshape KG})\index{UnderlyingRing@\texttt{UnderlyingRing}}
\label{UnderlyingRing}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the underlying ring of a group ring 



 This attribute stores the underlying ring of a group ring \mbox{\texttt{\mdseries\slshape KG}}. In fact, it refers to the attribute \texttt{LeftActingDomain} which returns the same result, and was introduced for group rings for
convenience, and for teaching purposes. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );|
  <algebra-with-one over GF(2), with 4 generators>
  !gapprompt@gap>| !gapinput@UnderlyingRing( KG );|
  GF(2)     
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{UnderlyingField}}
\logpage{[ 4, 1, 6 ]}\nobreak
\hyperdef{L}{X790470C48340E8F7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UnderlyingField({\mdseries\slshape KG})\index{UnderlyingField@\texttt{UnderlyingField}}
\label{UnderlyingField}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the underlying field of a group algebra 



 This attribute stores the underlying field of a group algebra \mbox{\texttt{\mdseries\slshape KG}}. In fact, it refers to the attribute \texttt{LeftActingDomain} which returns the same result, and was introduced for group algebras for
convenience, and for teaching purposes. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );|
  <algebra-with-one over GF(2), with 4 generators>
  !gapprompt@gap>| !gapinput@UnderlyingField( KG );|
  GF(2)    
  
\end{Verbatim}
 }

  
\section{\textcolor{Chapter }{Operations with group algebra elements}}\label{ElemFunctions}
\logpage{[ 4, 2, 0 ]}
\hyperdef{L}{X81DC99ED7AC03E46}{}
{
  

\subsection{\textcolor{Chapter }{Support}}
\logpage{[ 4, 2, 1 ]}\nobreak
\hyperdef{L}{X7B689C0284AC4296}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Support({\mdseries\slshape x})\index{Support@\texttt{Support}}
\label{Support}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 support of x as a list of elements of the underlying group 



 Returns the support of a group ring element \mbox{\texttt{\mdseries\slshape x}}. The support of a non-zero element $ x = \alpha_1 \cdot g_1 + \alpha_2 \cdot g_2 + \cdots + \alpha_k \cdot g_k$ of a group ring is the list of elements $g_i \in G$ for which the coefficient $\alpha_i$ is non-zero. The support of the zero element of a group ring is defined to be
the empty list. This method is also applicable to elements of magma rings. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  # First we create an element x to use in in the series of examples.
  # We map the minimal generating system of the group G to its group algebra
  # and denote their images as a and b
  !gapprompt@gap>| !gapinput@G:=DihedralGroup(16);; KG:=GroupRing(GF(2),G);;|
  !gapprompt@gap>| !gapinput@l := List( MinimalGeneratingSet( G ), g -> g^Embedding( G, KG ) );|
  [ (Z(2)^0)*f1, (Z(2)^0)*f2 ]
  !gapprompt@gap>| !gapinput@a := l[1]; b := l[2]; e := One( KG ); # we denote the identity by e|
  (Z(2)^0)*f1
  (Z(2)^0)*f2
  (Z(2)^0)*<identity> of ...
  !gapprompt@gap>| !gapinput@x := ( e + a ) * ( e + b );|
  (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
  !gapprompt@gap>| !gapinput@Support( x );|
  [ <identity> of ..., f1, f2, f1*f2 ]     
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{CoefficientsBySupport}}
\logpage{[ 4, 2, 2 ]}\nobreak
\hyperdef{L}{X8401D79C8678D3FA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CoefficientsBySupport({\mdseries\slshape x})\index{CoefficientsBySupport@\texttt{CoefficientsBySupport}}
\label{CoefficientsBySupport}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 coefficients of support elements as list of elements of the underlying ring 



 Returns a list that contains the coefficients corresponding to the elements of \texttt{Support( x )} in the same order as the elements appear in \texttt{Support( x )}. This method is also applicable to elements of magma rings. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@x;|
  (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
  !gapprompt@gap>| !gapinput@CoefficientsBySupport( x );|
  [ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ]   
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{TraceOfMagmaRingElement}}
\logpage{[ 4, 2, 3 ]}\nobreak
\hyperdef{L}{X81DD298A7C06EC82}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TraceOfMagmaRingElement({\mdseries\slshape x})\index{TraceOfMagmaRingElement@\texttt{TraceOfMagmaRingElement}}
\label{TraceOfMagmaRingElement}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 an element of the underlying ring 



 Returns the trace of a group ring element \mbox{\texttt{\mdseries\slshape x}}. By definition, the trace of an element $ x = \alpha_1 \cdot 1 + \alpha_2 \cdot g_2 + \cdots + \alpha_k \cdot g_k $ is equal to $\alpha_1$, that is, the coefficient of the identity element in $G$. The trace of the zero element is zero. This method is also applicable to
elements of magma rings. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@x;|
  (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
  !gapprompt@gap>| !gapinput@TraceOfMagmaRingElement( x );|
  Z(2)^0        
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Length}}
\logpage{[ 4, 2, 4 ]}\nobreak
\hyperdef{L}{X780769238600AFD1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Length({\mdseries\slshape x})\index{Length@\texttt{Length}}
\label{Length}
}\hfill{\scriptsize (attribute)}}\\


 The length of an element of a group ring \mbox{\texttt{\mdseries\slshape x}} is defined as the number of elements in its support. This method is also
applicable to elements of magma rings. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@x;|
  (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
  !gapprompt@gap>| !gapinput@Length( x );|
  4     
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Augmentation}}
\logpage{[ 4, 2, 5 ]}\nobreak
\hyperdef{L}{X86FA17BE858F2245}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Augmentation({\mdseries\slshape x})\index{Augmentation@\texttt{Augmentation}}
\label{Augmentation}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the sum of coefficients of a group ring element 



 The augmentation of a group ring element $ x = \alpha_1 \cdot g_1 + \alpha_2 \cdot g_2 + \cdots + \alpha_k \cdot g_k$ is the sum of its coefficients $ \alpha_1 + \alpha_2 + \cdots + \alpha_k $. The method is also applicable to elements of magma rings. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@x;|
  (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
  !gapprompt@gap>| !gapinput@Augmentation( x );|
  0*Z(2)     
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{PartialAugmentations}}
\logpage{[ 4, 2, 6 ]}\nobreak
\hyperdef{L}{X83A318C887B3E735}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PartialAugmentations({\mdseries\slshape KG, x})\index{PartialAugmentations@\texttt{PartialAugmentations}}
\label{PartialAugmentations}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
 a list of partial augmentations and a list of conjugacy class representatives 



 \index{partial augmentation} The partial augmentation of an element $ x = \alpha_1 \cdot g_1 + \alpha_2 \cdot g_2 + \cdots + \alpha_k \cdot g_k$ of the group ring $KG$, corresponding to the conjugacy class of an element $g$ from the underlying group $G$ is the sum of coefficients $\alpha_i$ taken over all $g_i$ such that $g_i$ is conjugated to $g$. The function returns a list of two lists, the first one is a list of partial
augmentations, and the second is a list of representatives of appropriate
conjugacy classes of elements of the group $G$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@y := x + a*b^2;|
  (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2+(Z(2)^
  0)*f1*f3
  !gapprompt@gap>| !gapinput@PartialAugmentations( KG, y );|
  [ [ Z(2)^0, 0*Z(2), Z(2)^0, Z(2)^0 ], [ <identity> of ..., f1, f2, f1*f2 ] ]    
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Involution}}
\logpage{[ 4, 2, 7 ]}\nobreak
\hyperdef{L}{X81EB2A0A8756372B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Involution({\mdseries\slshape x[[, f], s]})\index{Involution@\texttt{Involution}}
\label{Involution}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
 an element of a group ring 



 Let $KG$ be a group ring, $f$ be a homomorphism from the group $G$ to the unit group of the ring $K$. Furthermore, let $s$ be a mapping $G \rightarrow G$, such that $s^2$ is the identity mapping on $G$ and for every element $g \in G$ $f(g*s(g))$ equals $f(s(g)*g)$ and equals the identity element of the ring $K$. Then the involution of $KG$ induced by $f$ and $s$ is defined by $ \alpha_1 \cdot g_1 + \alpha_2 \cdot g_2 + \cdots + \alpha_k \cdot g_k \mapsto
\alpha_1 \cdot f(g_1) \cdot s(g_1) + \alpha_2 \cdot f(g_2) \cdot s(g_2) +
\cdots + \alpha_k \cdot f(g_k) \cdot s(g_k)$. 

 The method returns the image of \mbox{\texttt{\mdseries\slshape x}} under the involution of $KG$ induced by $f$ and $s$. If the mapping $f$ is omitted, $f$ is assumed to map everything to the identity element of the ring $K$. If both mappings are omitted, it returns the result of so-called classical
involution, induced by the mapping $ x \mapsto x^{-1}$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@x;|
  (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
  !gapprompt@gap>| !gapinput@Involution( x );|
  (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1+(Z(2)^0)*f1*f2+(Z(2)^0)*f2*f3*f4
  !gapprompt@gap>| !gapinput@l := List( MinimalGeneratingSet( G ), g -> g^Embedding( G, KG ) );|
  [ (Z(2)^0)*f1, (Z(2)^0)*f2 ]
  !gapprompt@gap>| !gapinput@List( l, Involution ); # check how involution acts on elements of G|
  [ (Z(2)^0)*f1, (Z(2)^0)*f2*f3*f4 ]
  !gapprompt@gap>| !gapinput@List( l, g -> g^-1 );|
  [ (Z(2)^0)*f1, (Z(2)^0)*f2*f3*f4 ]     
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsSymmetric}}
\logpage{[ 4, 2, 8 ]}\nobreak
\hyperdef{L}{X82D0BA3D7D3994F6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSymmetric({\mdseries\slshape x})\index{IsSymmetric@\texttt{IsSymmetric}}
\label{IsSymmetric}
}\hfill{\scriptsize (attribute)}}\\


 \index{symmetric element} An element of a group ring is called \emph{symmetric} if it is fixed under the classical involution. This property is checked here. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@IsSymmetric( x );|
  false
  !gapprompt@gap>| !gapinput@IsSymmetric( x * Involution( x ) );|
  true     
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsUnitary}}
\logpage{[ 4, 2, 9 ]}\nobreak
\hyperdef{L}{X7990BD877E89A9EC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsUnitary({\mdseries\slshape x})\index{IsUnitary@\texttt{IsUnitary}}
\label{IsUnitary}
}\hfill{\scriptsize (attribute)}}\\


 \index{unitary element} A unit of a group ring is called unitary if the classical involution inverts
it. This property is checked here. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@IsUnitary(x);|
  false
  !gapprompt@gap>| !gapinput@l:=List(MinimalGeneratingSet(G),g -> g^Embedding(G,KG));|
  [ (Z(2)^0)*f1, (Z(2)^0)*f2 ]
  !gapprompt@gap>| !gapinput@List(l,IsUnitary); # check that elements of G are unitary|
  [ true, true ]   
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsUnit}}
\logpage{[ 4, 2, 10 ]}\nobreak
\hyperdef{L}{X85CBFBAE78DE72E8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsUnit({\mdseries\slshape [KG, ]x})\index{IsUnit@\texttt{IsUnit}}
\label{IsUnit}
}\hfill{\scriptsize (method)}}\\


 This method improves a standard \textsf{GAP} functionality for modular group algebras. 

 In the two-argument version the method returns \texttt{true} if \mbox{\texttt{\mdseries\slshape x}} is an invertible element of the modular group algebra \mbox{\texttt{\mdseries\slshape KG}} and \texttt{false} otherwise. This can be done very quickly by checking whether the augmentation
of the element \mbox{\texttt{\mdseries\slshape x}} is non-zero. 

 If the first argument is omitted, then \textsf{LAGUNA} constructs the group $H$ generated by the support of \mbox{\texttt{\mdseries\slshape x}}, and, if this group is a finite $p$-group, then checks whether the coefficients of \mbox{\texttt{\mdseries\slshape x}} belong to a field $F$ of characteristic $p$. If this is the case, then \texttt{IsUnit( FH, x )} is called; otherwise, standard \textsf{GAP} method is used. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@x;|
  (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
  !gapprompt@gap>| !gapinput@IsUnit( KG, x ); # clearly, is not a unit due to augmentation zero|
  false
  !gapprompt@gap>| !gapinput@y := One( KG ) + x; # this should give a unit|
  (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
  !gapprompt@gap>| !gapinput@IsUnit( KG, y );|
  true       
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{InverseOp}}
\logpage{[ 4, 2, 11 ]}\nobreak
\hyperdef{L}{X82EC4F49877D6EB1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{InverseOp({\mdseries\slshape x})\index{InverseOp@\texttt{InverseOp}}
\label{InverseOp}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 the inverse element of an element of a group ring 



 This method improves a standard \textsf{GAP} functionality for modular group algebras. It calculates the inverse of a group
algebra element. The user can also invoke this function by typing \texttt{ x\texttt{\symbol{94}}-1 }. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@y;|
  (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
  !gapprompt@gap>| !gapinput@y^-1;|
  (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f4+(Z(2)^0)*f1*f2+(Z(2)^
  0)*f1*f3+(Z(2)^0)*f1*f4+(Z(2)^0)*f2*f4+(Z(2)^0)*f1*f2*f4+(Z(2)^0)*f2*f3*f4+(
  Z(2)^0)*f1*f2*f3*f4
  !gapprompt@gap>| !gapinput@y * y^-1;|
  (Z(2)^0)*<identity> of ...    
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{BicyclicUnitOfType1}}
\logpage{[ 4, 2, 12 ]}\nobreak
\hyperdef{L}{X7FD01F52845445EC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BicyclicUnitOfType1({\mdseries\slshape [KG, ]a, g})\index{BicyclicUnitOfType1@\texttt{BicyclicUnitOfType1}}
\label{BicyclicUnitOfType1}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BicyclicUnitOfType2({\mdseries\slshape [KG, ]a, g})\index{BicyclicUnitOfType2@\texttt{BicyclicUnitOfType2}}
\label{BicyclicUnitOfType2}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
 an element of a group ring 



 \index{bicyclic unit} let $a$ be an element of order $n$ of a group $G$. We put $\alpha = 1 + a + a^2 + ... +a^{n-1} $. Then $(a-1)*g*\alpha$ and $\alpha*g*(a-1)$ are nilpotent of index two for any element $g$ of the group $G$ not containing in the normalizer $N_G(\langle a \rangle)$, and the units $u_{a,g} = 1 + (a-1) * g * \alpha $ and $v_{a,g} = 1 + \alpha * g * (a-1) $ are called \emph{bicyclic units} of the 1st and 2nd type respectively. Note that $u_{a,g}$ and $v_{a,g}$ may coincide for some $a$ and $g$, but in general this does not hold. In the three-argument version these
methods construct bicyclic units of both types when \mbox{\texttt{\mdseries\slshape a}} and \mbox{\texttt{\mdseries\slshape g}} are elements of the underlying group $G$ of a group ring \mbox{\texttt{\mdseries\slshape KG}}. The two-argument version accepts images of elements \mbox{\texttt{\mdseries\slshape a}} and \mbox{\texttt{\mdseries\slshape g}} from the underlying group in the group ring $KG$ obtained using the mapping \texttt{Embedding( G, KG )}. Note that it is not actually checked that $g$ is not contained in $N_G(\langle a \rangle)$, because this is verified in \texttt{BicyclicUnitGroup} (\ref{BicyclicUnitGroup}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@G := SmallGroup(32,6);|
  <pc group of size 32 with 5 generators>
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF(2), G );|
  <algebra-with-one over GF(2), with 5 generators>
  !gapprompt@gap>| !gapinput@g := MinimalGeneratingSet( G );|
  [ f1, f2 ]
  !gapprompt@gap>| !gapinput@g[1] in Normalizer( G, Subgroup( G, [g[2]] ) );|
  false
  !gapprompt@gap>| !gapinput@g[2] in Normalizer( G, Subgroup( G, [g[1]] ) );|
  false
  !gapprompt@gap>| !gapinput@g := List( g, x -> x^Embedding( G, KG ) );|
  [ (Z(2)^0)*f1, (Z(2)^0)*f2 ]
  !gapprompt@gap>| !gapinput@BicyclicUnitOfType1(g[1],g[2]) = BicyclicUnitOfType2(g[1],g[2]);|
  false                                                                       
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{BassCyclicUnit}}
\logpage{[ 4, 2, 13 ]}\nobreak
\hyperdef{L}{X8631AD178508D219}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BassCyclicUnit({\mdseries\slshape [ZG, ]g, k})\index{BassCyclicUnit@\texttt{BassCyclicUnit}}
\label{BassCyclicUnit}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
 an element of a group ring 



 \index{Bass cyclic unit} Let \mbox{\texttt{\mdseries\slshape g}} be an element of order $n$ of the group $G$, and 1 {\textless} \mbox{\texttt{\mdseries\slshape k}} {\textless} $n$ be such that \mbox{\texttt{\mdseries\slshape k}} and $n$ are coprime, then \mbox{\texttt{\mdseries\slshape k}}\texttt{\symbol{94}}Phi($n$) is congruent to 1 modulo $n$. The unit  $$b(g,k)=\left(\sum_{j=0}^{k-1}g^j\right)^{\varphi(n)}+\frac{1-k^{\varphi
(n)}}{n}\hat{g},$$   where $\hat{g} = g + g^2 + ... + g^n$,  is called a \emph{Bass cyclic unit} of the integral group ring \mbox{\texttt{\mdseries\slshape ZG}}. 

 The three-argument version constructs the Bass cyclic unit $b(g,k)$ for the element \mbox{\texttt{\mdseries\slshape g}} from the underlying group $G$ of the group ring \mbox{\texttt{\mdseries\slshape ZG}}. The two-argument version accepts the image of \mbox{\texttt{\mdseries\slshape g}} in the group ring $ZG$ obtained using the mapping \texttt{Embedding( G, KG )}. 

 Remark that when $G$ is a finite nilpotent group, the group generated by the Bass cyclic units
contain a subgroup of finite index in the centre of the unit group of \mbox{\texttt{\mdseries\slshape ZG}} \cite{JePaSe96}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@S := SymmetricGroup( 5 );;|
  !gapprompt@gap>| !gapinput@ZS := GroupRing( Integers, S );;|
  !gapprompt@gap>| !gapinput@f := Embedding( S, ZS );;|
  !gapprompt@gap>| !gapinput@BassCyclicUnit( ZS, (1,3,2,5,4) , 3 );|
  (1)*()+(-2)*(1,2,4,3,5)+(-2)*(1,3,2,5,4)+(3)*(1,4,5,2,3)+(1)*(1,5,3,4,2)
  !gapprompt@gap>| !gapinput@BassCyclicUnit( (1,3,2,5,4)^f, 3 ); |
  (1)*()+(-2)*(1,2,4,3,5)+(-2)*(1,3,2,5,4)+(3)*(1,4,5,2,3)+(1)*(1,5,3,4,2)
  
\end{Verbatim}
 }

  
\section{\textcolor{Chapter }{Important attributes of group algebras}}\label{Ideals}
\logpage{[ 4, 3, 0 ]}
\hyperdef{L}{X841733AB86D30446}{}
{
  

\subsection{\textcolor{Chapter }{AugmentationHomomorphism}}
\logpage{[ 4, 3, 1 ]}\nobreak
\hyperdef{L}{X7F7FD75E84BEE0EF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AugmentationHomomorphism({\mdseries\slshape KG})\index{AugmentationHomomorphism@\texttt{AugmentationHomomorphism}}
\label{AugmentationHomomorphism}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a homomorphism from a group ring to the underlying ring 



 The mapping which maps an element of a group ring $KG$ to its augmentation is a homomorphism from $KG$ onto the ring $K$; see \texttt{Augmentation} (\ref{Augmentation}). This attribute stores this homomorphism for the group ring \mbox{\texttt{\mdseries\slshape KG}}. 

 Please note that for calculation of the augmentation of an element of a group
ring the user is strongly recommended to use \texttt{Augmentation} (\ref{Augmentation}) which works much faster than \texttt{AugmentationHomomorphism}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@F := GF( 2 ); G := SymmetricGroup( 3 ); FG := GroupRing( F, G );|
  GF(2)
  Sym( [ 1 .. 3 ] )
  <algebra-with-one over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@e := Embedding( G,FG );|
  <mapping: SymmetricGroup( [ 1 .. 3 ] ) -> AlgebraWithOne( GF(2), ... ) >
  !gapprompt@gap>| !gapinput@x := (1,2)^e; y := (1,3)^e;|
  (Z(2)^0)*(1,2)
  (Z(2)^0)*(1,3)
  !gapprompt@gap>| !gapinput@a := AugmentationHomomorphism( FG );|
  [ (Z(2)^0)*(1,2,3), (Z(2)^0)*(1,2) ] -> [ Z(2)^0, Z(2)^0 ]
  !gapprompt@gap>| !gapinput@x^a; y^a; ( x + y )^a; # this is slower|
  Z(2)^0
  Z(2)^0
  0*Z(2)   
  !gapprompt@gap>| !gapinput@Augmentation(x); Augmentation(y); Augmentation( x + y ); # this is faster|
  Z(2)^0
  Z(2)^0
  0*Z(2)   
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{AugmentationIdeal}}
\logpage{[ 4, 3, 2 ]}\nobreak
\hyperdef{L}{X7B21DB3E7CD80983}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AugmentationIdeal({\mdseries\slshape KG})\index{AugmentationIdeal@\texttt{AugmentationIdeal}}
\label{AugmentationIdeal}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 an ideal of a group ring 



 If $KG$ is a group ring, then its augmentation ideal $A$ is generated by all elements of the form $g-1$, where $g \in G$ \texttt{\symbol{92}} \texttt{\symbol{123}} $1$ \texttt{\symbol{125}}. The augmentation ideal consists of all elements of $FG$ with augmentation $0$; see \texttt{Augmentation} (\ref{Augmentation}). This method changes a standard \textsf{GAP} functionality for modular group algebras and returns the augmentation ideal of
a modular group algebra \mbox{\texttt{\mdseries\slshape KG}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );|
  <algebra-with-one over GF(2), with 4 generators>
  !gapprompt@gap>| !gapinput@AugmentationIdeal( KG );|
  <two-sided ideal in <algebra-with-one over GF(2), with 4 generators>,
    (dimension 15)>
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{RadicalOfAlgebra}}
\logpage{[ 4, 3, 3 ]}\nobreak
\hyperdef{L}{X850C29907A509533}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RadicalOfAlgebra({\mdseries\slshape KG})\index{RadicalOfAlgebra@\texttt{RadicalOfAlgebra}}
\label{RadicalOfAlgebra}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 an ideal of a group algebra 



 This method improves a standard \textsf{GAP} functionality for modular group algebras of finite $p$-groups. Since in this case the radical of the group algebra coincides with
its augmentation ideal, this method simply checks if the algebra \mbox{\texttt{\mdseries\slshape KG}} is a $p$-modular group algebra, and, if yes, it returns the augmentation ideal;
otherwise, the standard \textsf{GAP} method will be used. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );|
  <algebra-with-one over GF(2), with 4 generators>
  !gapprompt@gap>| !gapinput@RadicalOfAlgebra( KG );|
  <two-sided ideal in <algebra-with-one over GF(2), with 4 generators>,
    (dimension 15)>
  !gapprompt@gap>| !gapinput@RadicalOfAlgebra( KG ) = AugmentationIdeal( KG );|
  true     
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{WeightedBasis}}
\logpage{[ 4, 3, 4 ]}\nobreak
\hyperdef{L}{X8292BEFC7922E773}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WeightedBasis({\mdseries\slshape KG})\index{WeightedBasis@\texttt{WeightedBasis}}
\label{WeightedBasis}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a record of two components: weighted basis elements and their weights 



 The argument \mbox{\texttt{\mdseries\slshape KG}} must be a $p$-modular group algebra. 

 For a group algebra $KG$, let $A$ denote the augmentation ideal, and assume that $c$ is the smallest number such that $A^c=0$. Then a weighted basis of $KG$ is some basis $ b_1, \ldots, b_n $ for the augmentation ideal $A$, for which there are indices $ i_1=1, \ldots, i_{c-1} $ such that $ b_{i_k}, \ldots, b_n $ is a basis for $A^k$. The weight of an element $b_i$ of a weighted basis is the unique integer $w$ such that $b_i$ belongs to $w$-th power of $A$ but does not belong to its $(w+1)$-th power. 

 Note that this function actually constructs a basis for the \emph{augmentation ideal} of \mbox{\texttt{\mdseries\slshape KG}} and not for \mbox{\texttt{\mdseries\slshape KG}} itself. Since the augmentation ideal has co-dimension 1 in \texttt{KG}, a basis for \texttt{KG} can be easily obtained by adjoining the identity element of the group. 

 The method returns a record whose basis entry is the basis and the weights
entry is a list of the corresponding weights the of basis elements. See
Section \ref{TheoryThird} for more details. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF( 2 ), ElementaryAbelianGroup( 4 ) );|
  <algebra-with-one over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@WeightedBasis( KG );|
  rec(
    weightedBasis := [ (Z(2)^0)*<identity> of ...+(Z(2)^0)*f2,
        (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1,
        (Z(2)^0)*<identity> of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2 ],
    weights := [ 1, 1, 2 ] )
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{AugmentationIdealPowerSeries}}
\logpage{[ 4, 3, 5 ]}\nobreak
\hyperdef{L}{X84B25D3A812A8A2E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AugmentationIdealPowerSeries({\mdseries\slshape KG})\index{AugmentationIdealPowerSeries@\texttt{AugmentationIdealPowerSeries}}
\label{AugmentationIdealPowerSeries}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a list of ideals of a group algebra 



 The argument \mbox{\texttt{\mdseries\slshape KG}} is a $p$-modular group algebra. The method returns a list whose elements are the terms
of the augmentation ideal filtration of \mbox{\texttt{\mdseries\slshape KG}}, that is \texttt{AugmentationIdealPowerSeries(A)[i]} is the $i$-th power of the augmentation ideal of \mbox{\texttt{\mdseries\slshape KG}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );|
  <algebra-with-one over GF(2), with 4 generators>
  !gapprompt@gap>| !gapinput@AugmentationIdealPowerSeries( KG );|
  [ <algebra of dimension 15 over GF(2)>, <algebra of dimension 13 over GF(2)>,
    <algebra of dimension 11 over GF(2)>, <algebra of dimension 9 over GF(2)>,
    <algebra of dimension 7 over GF(2)>, <algebra of dimension 5 over GF(2)>,
    <algebra of dimension 3 over GF(2)>, <algebra of dimension 1 over GF(2)>,
    <algebra over GF(2)> ]
  !gapprompt@gap>| !gapinput@Length(last);|
  9      
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{AugmentationIdealNilpotencyIndex}}
\logpage{[ 4, 3, 6 ]}\nobreak
\hyperdef{L}{X8567023A821E39A6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AugmentationIdealNilpotencyIndex({\mdseries\slshape KG})\index{AugmentationIdealNilpotencyIndex@\texttt{AugmentationIdealNilpotencyIndex}}
\label{AugmentationIdealNilpotencyIndex}
}\hfill{\scriptsize (attribute)}}\\


 For the $p$-modular group algebra \mbox{\texttt{\mdseries\slshape KG}} the method returns the smallest number $n$ such that $A^n=0$, where $A$ is the augmentation ideal of \mbox{\texttt{\mdseries\slshape KG}}. This can be done using Jenning's theory without the explicit calculations of
the powers of the augmentation ideal. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );|
  <algebra-with-one over GF(2), with 4 generators>
  !gapprompt@gap>| !gapinput@AugmentationIdealNilpotencyIndex( KG );|
  9      
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{AugmentationIdealOfDerivedSubgroupNilpotencyIndex}}
\logpage{[ 4, 3, 7 ]}\nobreak
\hyperdef{L}{X7C0D5F3C842302EC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AugmentationIdealOfDerivedSubgroupNilpotencyIndex({\mdseries\slshape KG})\index{AugmentationIdealOfDerivedSubgroupNilpotencyIndex@\texttt{Augmentation}\-\texttt{Ideal}\-\texttt{Of}\-\texttt{Derived}\-\texttt{Subgroup}\-\texttt{Nilpotency}\-\texttt{Index}}
\label{AugmentationIdealOfDerivedSubgroupNilpotencyIndex}
}\hfill{\scriptsize (attribute)}}\\


 For the $p$-modular group algebra \mbox{\texttt{\mdseries\slshape KG}} this attribute stores the nilpotency index of the augmentation ideal of $KG'$ where $G'$ denotes the derived subgroup of $G$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );|
  <algebra-with-one over GF(2), with 4 generators>
  !gapprompt@gap>| !gapinput@AugmentationIdealOfDerivedSubgroupNilpotencyIndex( KG );|
  4
  !gapprompt@gap>| !gapinput@D := DerivedSubgroup( UnderlyingGroup( KG ) );|
  Group([ f3, f4 ])
  !gapprompt@gap>| !gapinput@KD := GroupRing( GF( 2 ), D );|
  <algebra-with-one over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@AugmentationIdealNilpotencyIndex( KD );|
  4       
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LeftIdealBySubgroup}}
\logpage{[ 4, 3, 8 ]}\nobreak
\hyperdef{L}{X837294D57E415E37}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LeftIdealBySubgroup({\mdseries\slshape KG, H})\index{LeftIdealBySubgroup@\texttt{LeftIdealBySubgroup}}
\label{LeftIdealBySubgroup}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RightIdealBySubgroup({\mdseries\slshape KG, H})\index{RightIdealBySubgroup@\texttt{RightIdealBySubgroup}}
\label{RightIdealBySubgroup}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TwoSidedIdalBySubgroup({\mdseries\slshape KG, H})\index{TwoSidedIdalBySubgroup@\texttt{TwoSidedIdalBySubgroup}}
\label{TwoSidedIdalBySubgroup}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
 an ideal of a group ring 



 Let \mbox{\texttt{\mdseries\slshape KG}} be a group ring of a group $G$ over the ring $K$, and \mbox{\texttt{\mdseries\slshape H}} be a subgroup of $G$. Then the set $J_l(H)$ of all elements of \mbox{\texttt{\mdseries\slshape KG}} of the form 
\[ \sum_{h \in H} x_h(h-1) \]
 is the left ideal in \mbox{\texttt{\mdseries\slshape KG}} generated by all elements $h-1$ with $h$ in $H$. The right ideal $J_r(H)$ is defined analogously. These operations are used to consrtuct such ideals,
taking into account the fact, that the ideal $J_l(H)$ is two-sided if and only if \mbox{\texttt{\mdseries\slshape H}} is normal in $G$. An attempt of constructing two-sided ideal for a non-normal subgroup \mbox{\texttt{\mdseries\slshape H}} will lead to an error message. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF(2), DihedralGroup(16) );|
  <algebra-with-one over GF(2), with 4 generators>
  !gapprompt@gap>| !gapinput@G := DihedralGroup(16);|
  <pc group of size 16 with 4 generators>
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF(2), G );|
  <algebra-with-one over GF(2), with 4 generators>
  !gapprompt@gap>| !gapinput@D := DerivedSubgroup( G );|
  Group([ f3, f4 ])
  !gapprompt@gap>| !gapinput@LeftIdealBySubgroup( KG, D );|
  <two-sided ideal in <algebra-with-one over GF(2), with 4 generators>,
    (dimension 12)>                              
  !gapprompt@gap>| !gapinput@H := Subgroup( G, [ GeneratorsOfGroup(G)[1] ]);|
  Group([ f1 ])
  !gapprompt@gap>| !gapinput@IsNormal( G, H );|
  false
  !gapprompt@gap>| !gapinput@LeftIdealBySubgroup( KG, H );|
  <left ideal in <algebra-with-one over GF(2), with 4 generators>, (dimension 8
   )>
  
\end{Verbatim}
 }

  
\section{\textcolor{Chapter }{Computations with the unit group}}\label{UnitGroup}
\logpage{[ 4, 4, 0 ]}
\hyperdef{L}{X863248708784F94C}{}
{
  

\subsection{\textcolor{Chapter }{NormalizedUnitGroup}}
\logpage{[ 4, 4, 1 ]}\nobreak
\hyperdef{L}{X817D5AC78754527F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NormalizedUnitGroup({\mdseries\slshape KG})\index{NormalizedUnitGroup@\texttt{NormalizedUnitGroup}}
\label{NormalizedUnitGroup}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a group generated by group algebra elements 



 Determines the normalized unit group of a $p$-modular group algebra \mbox{\texttt{\mdseries\slshape KG}} over the field of $p$ elements. Returns the normalized unit group as the group generated by certain
elements of \mbox{\texttt{\mdseries\slshape KG}}; see Section \ref{TheoryThird} for more details. 

 For efficient computations the user is recommended to use \texttt{PcNormalizedUnitGroup} (\ref{PcNormalizedUnitGroup}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );|
  <algebra-with-one over GF(2), with 4 generators>
  !gapprompt@gap>| !gapinput@V := NormalizedUnitGroup( KG );|
  <group of size 32768 with 15 generators>
  !gapprompt@gap>| !gapinput@u := GeneratorsOfGroup( V )[4];|
  (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2  
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{PcNormalizedUnitGroup}}
\logpage{[ 4, 4, 2 ]}\nobreak
\hyperdef{L}{X7D40E42A7B678598}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PcNormalizedUnitGroup({\mdseries\slshape KG})\index{PcNormalizedUnitGroup@\texttt{PcNormalizedUnitGroup}}
\label{PcNormalizedUnitGroup}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a group given by power-commutator presentation 



 The argument \mbox{\texttt{\mdseries\slshape KG}} is a $p$-modular group algebra over the field of $p$ elements. \texttt{PcNormalizedUnitGroup} returns the normalized unit group of \mbox{\texttt{\mdseries\slshape KG}} given by a power-commutator presentation. The generators in this polycyclic
presentation correspond to the weighted basis elements of \mbox{\texttt{\mdseries\slshape KG}}. For more details, see Section \ref{TheoryThird}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@W := PcNormalizedUnitGroup( KG );|
  <pc group of size 32768 with 15 generators>
  !gapprompt@gap>| !gapinput@w := GeneratorsOfGroup( W )[4];|
  f4       
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{NaturalBijectionToPcNormalizedUnitGroup}}
\logpage{[ 4, 4, 3 ]}\nobreak
\hyperdef{L}{X7E08F6E87C586A36}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NaturalBijectionToPcNormalizedUnitGroup({\mdseries\slshape KG})\index{NaturalBijectionToPcNormalizedUnitGroup@\texttt{Natural}\-\texttt{Bijection}\-\texttt{To}\-\texttt{Pc}\-\texttt{Normalized}\-\texttt{Unit}\-\texttt{Group}}
\label{NaturalBijectionToPcNormalizedUnitGroup}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a homomorphism of groups 



 The normalised unit group of a $p$-modular group algebra $KG$ over the field of $p$ elements can be computed using two methods, namely \texttt{NormalizedUnitGroup} (\ref{NormalizedUnitGroup}) and \texttt{PcNormalizedUnitGroup} (\ref{PcNormalizedUnitGroup}). These two methods return two different objects, and they can be used for
different types of computations. The elements of \texttt{NormalizedUnitGroup(KG)} are represented in their natural group algebra representation, and hence they
can easily be identified in the group algebra. However, the more quickly
constructed \texttt{NormalizedUnitGroup(KG)} is often not suitable for further fast calculations. Hence one will have to
use \texttt{PcNormalizedUnitGroup(KG)} if one wants to find some group theoretic properties of the normalized unit
group. This method returns the bijection from \texttt{NormalizedUnitGroup(\mbox{\texttt{\mdseries\slshape KG}})} onto \texttt{PcNormalizedUnitGroup(\mbox{\texttt{\mdseries\slshape KG}})}. This bijection can be used to map the result of a computation in \texttt{PcNormalizedUnitGroup(\mbox{\texttt{\mdseries\slshape KG}})} into \texttt{NormalizedUnitGroup(\mbox{\texttt{\mdseries\slshape KG}})}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@f := NaturalBijectionToPcNormalizedUnitGroup( KG );|
  MappingByFunction( <group of size 32768 with 15 generators>, <pc group of size\
   32768 with 15 generators>, function( x ) ... end )
  !gapprompt@gap>| !gapinput@u := GeneratorsOfGroup( V )[4];;|
  !gapprompt@gap>| !gapinput@u^f;|
  f4   
  !gapprompt@gap>| !gapinput@GeneratorsOfGroup( V )[4]^f = GeneratorsOfGroup( W )[4];|
  true      
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{NaturalBijectionToNormalizedUnitGroup}}
\logpage{[ 4, 4, 4 ]}\nobreak
\hyperdef{L}{X83715EF37B9FA94A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NaturalBijectionToNormalizedUnitGroup({\mdseries\slshape KG})\index{NaturalBijectionToNormalizedUnitGroup@\texttt{Natural}\-\texttt{Bijection}\-\texttt{To}\-\texttt{Normalized}\-\texttt{Unit}\-\texttt{Group}}
\label{NaturalBijectionToNormalizedUnitGroup}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a homomorphism of groups 



 For a $p$-modular group algebra \mbox{\texttt{\mdseries\slshape KG}} over the field of $p$ elements this function returns the inverse of the mapping \texttt{NaturalBijectionToPcNormalizedUnitGroup} (\ref{NaturalBijectionToPcNormalizedUnitGroup}) }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@t := NaturalBijectionToNormalizedUnitGroup(KG);;|
  !gapprompt@gap>| !gapinput@w := GeneratorsOfGroup(W)[4];;|
  !gapprompt@gap>| !gapinput@w^t;|
  (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2    
  !gapprompt@gap>| !gapinput@GeneratorsOfGroup( W )[4]^t = GeneratorsOfGroup( V )[4];|
  true     
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Embedding (from group to unit group)}}
\logpage{[ 4, 4, 5 ]}\nobreak
\hyperdef{L}{X84D64AF17941FA7F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Embedding({\mdseries\slshape H, V})\index{Embedding@\texttt{Embedding}!from group to unit group}
\label{Embedding:from group to unit group}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
 a homomorphism from an underlying group to a normalized unit group in
pc-presentation 



 Let \mbox{\texttt{\mdseries\slshape H}} be a subgroup of a group $G$ and \mbox{\texttt{\mdseries\slshape V}} be the normalized unit group of the group algebra $KG$ given by the power-commutator presentation (see \texttt{PcNormalizedUnitGroup} (\ref{PcNormalizedUnitGroup}). Then \texttt{Embedding( H, V )} returns the homomorphism from \mbox{\texttt{\mdseries\slshape H}} to \mbox{\texttt{\mdseries\slshape V}}, which is the composition of \texttt{Embedding( H, KG )} and \texttt{NaturalBijectionToPcNormalizedUnitGroup( KG )}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@G := DihedralGroup( 16 );|
  <pc group of size 16 with 4 generators>
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF( 2 ), G );|
  <algebra-with-one over GF(2), with 4 generators>
  !gapprompt@gap>| !gapinput@V:=PcNormalizedUnitGroup( KG );|
  <pc group of size 32768 with 15 generators>
  !gapprompt@gap>| !gapinput@ucs := UpperCentralSeries( V );|
  [ <pc group of size 32768 with 15 generators>,
    <pc group of size 4096 with 12 generators>,
    Group([ f3*f5*f13*f15, f7, f15, f13*f15, f14*f15, f11*f13*f14*f15, f12,
        f9*f12, f10 ]),
    Group([ f3*f5*f13*f15, f7, f15, f13*f15, f14*f15, f11*f13*f14*f15 ]),
    Group([  ]) ]
  !gapprompt@gap>| !gapinput@f := Embedding( G, V );|
  [ f1, f2, f3, f4 ] -> [ f2, f1, f3, f7 ]
  !gapprompt@gap>| !gapinput@G1 := Image( f, G ); |
  Group([ f2, f1, f3, f7 ])
  !gapprompt@gap>| !gapinput@H := Intersection( ucs[2], G1 ); # compute intersection in V(KG)|
  Group([ f3, f7, f3*f7 ])
  !gapprompt@gap>| !gapinput@T:=PreImage( f, H );             # find its preimage in G|
  Group([ f3, f4, f3*f4 ])
  !gapprompt@gap>| !gapinput@IdGroup( T ); |
  [ 4, 1 ]
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Units}}
\logpage{[ 4, 4, 6 ]}\nobreak
\hyperdef{L}{X853C045B7BA6A580}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Units({\mdseries\slshape KG})\index{Units@\texttt{Units}}
\label{Units}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the unit group of a group ring 



 This improves a standard \textsf{GAP} functionality for modular group algebras of finite $p$-groups over the field of $p$ elements. It returns the unit group of \mbox{\texttt{\mdseries\slshape KG}} as a direct product of \texttt{Units(K)} and \texttt{NormalizedUnitGroup(KG)}, where the latter is generated by certain elements of \mbox{\texttt{\mdseries\slshape KG}}; see Chapter \ref{Theory} for more details. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@U := Units( KG );|
  #I  LAGUNA package: Computing the unit group ...
  <group of size 32768 with 15 generators>
  !gapprompt@gap>| !gapinput@GeneratorsOfGroup( U )[5]; # now elements of U are already in KG|
  (Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f2*f3
  !gapprompt@gap>| !gapinput@FH := GroupRing( GF(3), SmallGroup(27,3) );|
  <algebra-with-one over GF(3), with 3 generators>
  !gapprompt@gap>| !gapinput@T := Units( FH );|
  #I  LAGUNA package: Computing the unit group ...
  <group of size 5083731656658 with 27 generators>
  !gapprompt@gap>| !gapinput@x := GeneratorsOfGroup( T )[1];|
  DirectProductElement( [ Z(3), (Z(3)^0)*<identity> of ... ] )
  !gapprompt@gap>| !gapinput@x in FH;|
  false
  !gapprompt@gap>| !gapinput@x[1] * x[2] in FH; # how to get the corresponding element of FH|
  true 
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{PcUnits}}
\logpage{[ 4, 4, 7 ]}\nobreak
\hyperdef{L}{X7E67BDA77E5E6077}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PcUnits({\mdseries\slshape KG})\index{PcUnits@\texttt{PcUnits}}
\label{PcUnits}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a group given by power-commutator presentation 



 Returns the unit group of \mbox{\texttt{\mdseries\slshape KG}} as a direct product of \texttt{Units(K)} and \texttt{PcNormalizedUnitGroup(KG)}, where the latter is a group given by a polycyclic presentation. See Section \ref{TheoryFourth} for more details. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@W := PcUnits( KG );|
  <pc group of size 32768 with 15 generators>
  !gapprompt@gap>| !gapinput@GeneratorsOfGroup( W )[5];|
  f5   
  !gapprompt@gap>| !gapinput@FH := GroupRing( GF(3), SmallGroup(27,3) );|
  <algebra-with-one over GF(3), with 3 generators>
  !gapprompt@gap>| !gapinput@T := PcUnits(FH);|
  <group of size 5083731656658 with 27 generators>
  !gapprompt@gap>| !gapinput@x := GeneratorsOfGroup( T )[2];|
  DirectProductElement( [ Z(3)^0, f1 ] )                      
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsGroupOfUnitsOfMagmaRing}}
\logpage{[ 4, 4, 8 ]}\nobreak
\hyperdef{L}{X7F2532888184CB22}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsGroupOfUnitsOfMagmaRing({\mdseries\slshape U})\index{IsGroupOfUnitsOfMagmaRing@\texttt{IsGroupOfUnitsOfMagmaRing}}
\label{IsGroupOfUnitsOfMagmaRing}
}\hfill{\scriptsize (property)}}\\


 This property will be automatically set \texttt{true}, if \mbox{\texttt{\mdseries\slshape U}} is a group generated by some units of a magma ring, including \texttt{Units(KG)} and \texttt{NormalizedUnitgroup(KG)}. Otherwise this property will not be bound. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@IsGroupOfUnitsOfMagmaRing( NormalizedUnitGroup( KG ) );|
  true
  !gapprompt@gap>| !gapinput@IsGroupOfUnitsOfMagmaRing( Units( KG ) );|
  true     
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsUnitGroupOfGroupRing}}
\logpage{[ 4, 4, 9 ]}\nobreak
\hyperdef{L}{X7EF9BF297A9412AB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsUnitGroupOfGroupRing({\mdseries\slshape U})\index{IsUnitGroupOfGroupRing@\texttt{IsUnitGroupOfGroupRing}}
\label{IsUnitGroupOfGroupRing}
}\hfill{\scriptsize (property)}}\\


 This property will be automatically set \texttt{true}, if \mbox{\texttt{\mdseries\slshape U}} is the unit group of a $p$-modular group algebra, obtained either by \texttt{Units(KG)} or by \texttt{PcUnits(KG)}. Otherwise this property will not be bound. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@IsUnitGroupOfGroupRing( Units( KG ) );|
  true
  !gapprompt@gap>| !gapinput@IsUnitGroupOfGroupRing( PcUnits( KG ) );|
  true     
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsNormalizedUnitGroupOfGroupRing}}
\logpage{[ 4, 4, 10 ]}\nobreak
\hyperdef{L}{X82AC131384191CCE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsNormalizedUnitGroupOfGroupRing({\mdseries\slshape U})\index{IsNormalizedUnitGroupOfGroupRing@\texttt{IsNormalizedUnitGroupOfGroupRing}}
\label{IsNormalizedUnitGroupOfGroupRing}
}\hfill{\scriptsize (property)}}\\


 This property will be automatically set \texttt{true}, if \mbox{\texttt{\mdseries\slshape U}} is the normalized unit group of a $p$-modular group algebra, obtained either by \texttt{NormalizedUnitGroup(KG)} or by \texttt{PcNormalizedUnitGroup(KG)}. Otherwise this property will not be bound. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@IsNormalizedUnitGroupOfGroupRing( NormalizedUnitGroup( KG ) );|
  true
  !gapprompt@gap>| !gapinput@IsNormalizedUnitGroupOfGroupRing( PcNormalizedUnitGroup( KG ) );|
  true     
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{UnderlyingGroupRing}}
\logpage{[ 4, 4, 11 ]}\nobreak
\hyperdef{L}{X82DCA8A57D0D1114}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UnderlyingGroupRing({\mdseries\slshape U})\index{UnderlyingGroupRing@\texttt{UnderlyingGroupRing}}
\label{UnderlyingGroupRing}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a group ring 



 If \mbox{\texttt{\mdseries\slshape U}} is the (normalized) unit group of a $p$-modular group algebra $KG$ obtained using one of the functions \texttt{Units(KG)}, \texttt{PcUnits(KG)}, \texttt{NormalizedUnitGroup(KG)} or \texttt{PcNormalizedUnitGroup(KG)}, then the attribute \texttt{UnderlyingGroupRing} stores $KG$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@UnderlyingGroupRing( Units( KG ) );|
  <algebra-with-one of dimension 16 over GF(2)>
  !gapprompt@gap>| !gapinput@UnderlyingGroupRing( PcUnits( KG ) );|
  <algebra-with-one of dimension 16 over GF(2)>
  !gapprompt@gap>| !gapinput@UnderlyingGroupRing( NormalizedUnitGroup( KG ) );|
  <algebra-with-one of dimension 16 over GF(2)>
  !gapprompt@gap>| !gapinput@UnderlyingGroupRing( PcNormalizedUnitGroup( KG ) );|
  <algebra-with-one of dimension 16 over GF(2)>
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{UnitarySubgroup}}
\logpage{[ 4, 4, 12 ]}\nobreak
\hyperdef{L}{X7A0FFABC86F89517}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UnitarySubgroup({\mdseries\slshape U})\index{UnitarySubgroup@\texttt{UnitarySubgroup}}
\label{UnitarySubgroup}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the subgroup of the unit group 



 Let \mbox{\texttt{\mdseries\slshape U}} be the normalized unit group of a group ring in either natural (see \texttt{NormalizedUnitGroup} (\ref{NormalizedUnitGroup})) or power-commutator (see \texttt{PcNormalizedUnitGroup} (\ref{PcNormalizedUnitGroup})) presentation. The attribute stores the unitary subgroup of \mbox{\texttt{\mdseries\slshape U}}, generated by all unitary units of \mbox{\texttt{\mdseries\slshape U}} (see \texttt{IsUnitary} (\ref{IsUnitary})). The method is straightforward, so it is not recommended to run it for large
groups. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF( 2 ), DihedralGroup( 8 ) );|
  <algebra-with-one over GF(2), with 3 generators>
  !gapprompt@gap>| !gapinput@U := NormalizedUnitGroup( KG );|
  <group of size 128 with 7 generators>
  !gapprompt@gap>| !gapinput@HU := UnitarySubgroup( U );|
  <group with 5 generators>
  !gapprompt@gap>| !gapinput@IdGroup( HU );|
  [ 64, 261 ]
  !gapprompt@gap>| !gapinput@V := PcNormalizedUnitGroup( KG );|
  <pc group of size 128 with 7 generators>
  !gapprompt@gap>| !gapinput@HV := UnitarySubgroup( V );|
  Group([ f1, f2, f5, f6, f7 ])
  !gapprompt@gap>| !gapinput@IdGroup( HV );|
  [ 64, 261 ]
  !gapprompt@gap>| !gapinput@Image(NaturalBijectionToPcNormalizedUnitGroup( KG ), HU ) = HV;|
  true
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{BicyclicUnitGroup}}
\logpage{[ 4, 4, 13 ]}\nobreak
\hyperdef{L}{X859F07AE7A4D317B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BicyclicUnitGroup({\mdseries\slshape U})\index{BicyclicUnitGroup@\texttt{BicyclicUnitGroup}}
\label{BicyclicUnitGroup}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the subgroup of the unit group, generated by bicyclic units 



 Let \mbox{\texttt{\mdseries\slshape U}} be the normalized unit group of a group ring in either natural (see \texttt{NormalizedUnitGroup} (\ref{NormalizedUnitGroup})) or power-commutator (see \texttt{PcNormalizedUnitGroup} (\ref{PcNormalizedUnitGroup})) presentation. The attribute stores the subgroup of \mbox{\texttt{\mdseries\slshape U}}, generated by all bicyclic units $u_{g,h}$ and $v_{g,h}$ (see \texttt{BicyclicUnitOfType1} (\ref{BicyclicUnitOfType1}) and \texttt{BicyclicUnitOfType2} (\ref{BicyclicUnitOfType2})), where $g$ and $h$ run over the elements of the underlying group, and $h$ do not belongs to the normalizer of $ \langle g \rangle $ in $G$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF( 2 ), DihedralGroup( 8 ) );|
  <algebra-with-one over GF(2), with 3 generators>
  !gapprompt@gap>| !gapinput@U := NormalizedUnitGroup( KG );|
  <group of size 128 with 7 generators>
  !gapprompt@gap>| !gapinput@BU := BicyclicUnitGroup( U );|
  <group with 2 generators>
  !gapprompt@gap>| !gapinput@IdGroup( BU );|
  [ 4, 2 ]
  !gapprompt@gap>| !gapinput@V := PcNormalizedUnitGroup( KG );|
  <pc group of size 128 with 7 generators>
  !gapprompt@gap>| !gapinput@BV := BicyclicUnitGroup( V );|
  Group([ f5*f6, f6*f7 ])
  !gapprompt@gap>| !gapinput@IdGroup( BV );|
  [ 4, 2 ]
  !gapprompt@gap>| !gapinput@Image( NaturalBijectionToPcNormalizedUnitGroup( KG ), BU ) = BV;|
  true
  
\end{Verbatim}
  

\subsection{\textcolor{Chapter }{GroupBases}}
\logpage{[ 4, 4, 14 ]}\nobreak
\hyperdef{L}{X7A39E44D87CDF7B0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GroupBases({\mdseries\slshape KG})\index{GroupBases@\texttt{GroupBases}}
\label{GroupBases}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a list of lists of group rings elements 



 The subgroup $B$ of the normalized unit group of the group algebra $KG$ is called a \emph{group basis}, if the elements of $B$ are linearly independent over the field $K$ and $ KB=KG $. If \mbox{\texttt{\mdseries\slshape KG}} is a $p$-modular group algebra, then \texttt{GroupBases} returns a list of representatives of the conjugacy classes of the group bases
of the group algebra \mbox{\texttt{\mdseries\slshape KG}} in its normalised unit group. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@D8 := DihedralGroup( 8 );|
  <pc group of size 8 with 3 generators>
  !gapprompt@gap>| !gapinput@K := GF(2);|
  GF(2)
  !gapprompt@gap>| !gapinput@KD8 := GroupRing( GF( 2 ), D8 );|
  <algebra-with-one over GF(2), with 3 generators>
  !gapprompt@gap>| !gapinput@gb := GroupBases( KD8 );;|
  !gapprompt@gap>| !gapinput@Length( gb );|
  32
  !gapprompt@gap>| !gapinput@gb[1];|
  [ (Z(2)^0)*<identity> of ..., (Z(2)^0)*f3,
    (Z(2)^0)*f1*f2+(Z(2)^0)*f2*f3+(Z(2)^0)*f1*f2*f3,
    (Z(2)^0)*f2+(Z(2)^0)*f1*f2+(Z(2)^0)*f1*f2*f3,
    (Z(2)^0)*<identity> of ...+(Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f2*f3+(Z(2)^
      0)*f1*f2*f3, (Z(2)^0)*f2+(Z(2)^0)*f1*f3+(Z(2)^0)*f2*f3,
    (Z(2)^0)*<identity> of ...+(Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f1*f2+(Z(2)^
      0)*f2*f3, (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f2*f3 ]
  !gapprompt@gap>| !gapinput@Length( last );|
  8    
  
\end{Verbatim}
 }

  
\section{\textcolor{Chapter }{The Lie algebra of a group algebra}}\label{LieAlgebra}
\logpage{[ 4, 5, 0 ]}
\hyperdef{L}{X783C1A3D86A6656B}{}
{
  

\subsection{\textcolor{Chapter }{LieAlgebraByDomain}}
\logpage{[ 4, 5, 1 ]}\nobreak
\hyperdef{L}{X7827B4158459DEA0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LieAlgebraByDomain({\mdseries\slshape A})\index{LieAlgebraByDomain@\texttt{LieAlgebraByDomain}}
\label{LieAlgebraByDomain}
}\hfill{\scriptsize (method)}}\\


 This method takes a group algebra as its argument, and constructs its
associated Lie algebra in which the product is the bracket operation: $[a,b]=ab-ba$. It is recommended that the user never calls this method. The Lie algebra for
an associative algebra should normally be created using \texttt{LieAlgebra( A )}. When \texttt{LieAlgebra} is first invoked, it constructs the Lie algebra for \mbox{\texttt{\mdseries\slshape A}} using \texttt{LieAlgebraByDomain}. After that it stores this Lie algebra and simply returns it if \texttt{LieAlgebra} is called again. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@G := SymmetricGroup(3);; FG := GroupRing( GF( 2 ), G );|
  <algebra-with-one over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@L := LieAlgebra( FG );|
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(2)>
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsLieAlgebraByAssociativeAlgebra}}
\logpage{[ 4, 5, 2 ]}\nobreak
\hyperdef{L}{X7AA7DA6082639B23}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsLieAlgebraByAssociativeAlgebra({\mdseries\slshape L})\index{IsLieAlgebraByAssociativeAlgebra@\texttt{IsLieAlgebraByAssociativeAlgebra}}
\label{IsLieAlgebraByAssociativeAlgebra}
}\hfill{\scriptsize (Category)}}\\


 This category signifies that the Lie algebra \mbox{\texttt{\mdseries\slshape L}} was constructed as the Lie algebra associated with an associative algebra
(this piece of information cannot be obtained later). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF(3), DihedralGroup(16) );|
  <algebra-with-one over GF(3), with 4 generators>
  !gapprompt@gap>| !gapinput@L := LieAlgebra ( KG );|
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(3)>
  !gapprompt@gap>| !gapinput@IsLieAlgebraByAssociativeAlgebra( L );|
  true
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{UnderlyingAssociativeAlgebra}}
\logpage{[ 4, 5, 3 ]}\nobreak
\hyperdef{L}{X85F4712B84624DB8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UnderlyingAssociativeAlgebra({\mdseries\slshape L})\index{UnderlyingAssociativeAlgebra@\texttt{UnderlyingAssociativeAlgebra}}
\label{UnderlyingAssociativeAlgebra}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the underlying associative algebra of a Lie algebra 



 If a Lie algebra \mbox{\texttt{\mdseries\slshape L}} is constructed from an associative algebra, then it remembers this underlying
associative algebra as one of its attributes. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF(2), DihedralGroup(16) ); |
  <algebra-with-one over GF(2), with 4 generators>
  !gapprompt@gap>| !gapinput@L := LieAlgebra ( KG );|
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(2)>
  !gapprompt@gap>| !gapinput@UnderlyingAssociativeAlgebra( L );|
  <algebra-with-one over GF(2), with 4 generators>
  !gapprompt@gap>| !gapinput@last = KG;|
  true  
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{NaturalBijectionToLieAlgebra}}
\logpage{[ 4, 5, 4 ]}\nobreak
\hyperdef{L}{X84050A268514F2EE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NaturalBijectionToLieAlgebra({\mdseries\slshape A})\index{NaturalBijectionToLieAlgebra@\texttt{NaturalBijectionToLieAlgebra}}
\label{NaturalBijectionToLieAlgebra}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a mapping 



 The natural linear bijection between the (isomorphic, but not equal)
underlying vector spaces of an associative algebra \mbox{\texttt{\mdseries\slshape A}} and its associated Lie algebra is stored as an attribute of \mbox{\texttt{\mdseries\slshape A}}. Note that this is a vector space isomorphism between two algebras, but not
an algebra isomorphism. }

 
\begin{Verbatim}[commandchars=@|D,fontsize=\small,frame=single,label=Example]
  
  @gapprompt|gap>D @gapinput|F := GF( 2 ); G := SymmetricGroup( 3 ); FG := GroupRing( F, G );D
  GF(2)
  Sym( [ 1 .. 3 ] )
  <algebra-with-one over GF(2), with 2 generators>
  @gapprompt|gap>D @gapinput|t := NaturalBijectionToLieAlgebra( FG );; D
  #I  LAGUNA package: Constructing Lie algebra ...
  @gapprompt|gap>D @gapinput|a := Random( FG );D
  (Z(2)^0)*()+(Z(2)^0)*(1,2,3)+(Z(2)^0)*(1,3,2)+(Z(2)^0)*(1,3)
  @gapprompt|gap>D @gapinput|a * a;                     # product in the associative algebraD
  (Z(2)^0)*(1,2,3)+(Z(2)^0)*(1,3,2)
  @gapprompt|gap>D @gapinput|b := a^t;D
  LieObject( (Z(2)^0)*()+(Z(2)^0)*(1,2,3)+(Z(2)^0)*(1,3,2)+(Z(2)^0)*(1,3) )
  @gapprompt|gap>D @gapinput|b * b; # product in the Lie algebra (commutator) - must be zero!D
  LieObject( <zero> of ... )
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{NaturalBijectionToAssociativeAlgebra}}
\logpage{[ 4, 5, 5 ]}\nobreak
\hyperdef{L}{X821DAFD585EA1DF3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NaturalBijectionToAssociativeAlgebra({\mdseries\slshape L})\index{NaturalBijectionToAssociativeAlgebra@\texttt{Natural}\-\texttt{Bijection}\-\texttt{To}\-\texttt{Associative}\-\texttt{Algebra}}
\label{NaturalBijectionToAssociativeAlgebra}
}\hfill{\scriptsize (attribute)}}\\


 This is the inverse of the previous linear bijection, stored as an attribute
of the Lie algebra \mbox{\texttt{\mdseries\slshape L}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@G := SymmetricGroup(3); FG := GroupRing( GF( 2 ), G );|
  Sym( [ 1 .. 3 ] )
  <algebra-with-one over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@L := LieAlgebra( FG );|
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(2)>
  !gapprompt@gap>| !gapinput@s := NaturalBijectionToAssociativeAlgebra( L );;|
  !gapprompt@gap>| !gapinput@InverseGeneralMapping( s ) = NaturalBijectionToLieAlgebra( FG );|
  true   
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsLieAlgebraOfGroupRing}}
\logpage{[ 4, 5, 6 ]}\nobreak
\hyperdef{L}{X78C26E3F80E55AC2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsLieAlgebraOfGroupRing({\mdseries\slshape L})\index{IsLieAlgebraOfGroupRing@\texttt{IsLieAlgebraOfGroupRing}}
\label{IsLieAlgebraOfGroupRing}
}\hfill{\scriptsize (property)}}\\


 If a Lie algebra \mbox{\texttt{\mdseries\slshape L}} is constructed from an associative algebra which happens to be in fact a group
ring, it has many nice properties that can be used for fast algorithms, so
this information is stored as a property. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@F := GF( 2 ); G := SymmetricGroup( 3 ); FG := GroupRing( F, G );|
  GF(2)
  Sym( [ 1 .. 3 ] )
  <algebra-with-one over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@L := LieAlgebra( FG );|
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(2)>
  !gapprompt@gap>| !gapinput@IsLieAlgebraOfGroupRing( L );|
  true   
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{UnderlyingGroup (of Lie algebra of a group ring)}}
\logpage{[ 4, 5, 7 ]}\nobreak
\hyperdef{L}{X87CCD17A790BE256}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UnderlyingGroup({\mdseries\slshape L})\index{UnderlyingGroup@\texttt{UnderlyingGroup}!of Lie algebra of a group ring}
\label{UnderlyingGroup:of Lie algebra of a group ring}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the underlying group 



 The underlying group of a Lie algebra \mbox{\texttt{\mdseries\slshape L}} that is constructed from a group ring is defined as the underlying group of
this group ring; see \texttt{UnderlyingGroup} (\ref{UnderlyingGroup:of a group ring}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@F := GF( 2 ); G := SymmetricGroup( 3 ); FG := GroupRing( F, G );|
  GF(2)
  Sym( [ 1 .. 3 ] )
  <algebra-with-one over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@L := LieAlgebra( FG );|
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(2)>
  !gapprompt@gap>| !gapinput@UnderlyingGroup( L );|
  Sym( [ 1 .. 3 ] )
  !gapprompt@gap>| !gapinput@LeftActingDomain( L );|
  GF(2)   
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Embedding (from group to Lie algebra)}}
\logpage{[ 4, 5, 8 ]}\nobreak
\hyperdef{L}{X833439F7846784B5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Embedding({\mdseries\slshape U, L})\index{Embedding@\texttt{Embedding}!from group to Lie algebra}
\label{Embedding:from group to Lie algebra}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
 a mapping, which is a composition of two mappings 



 Let $FG$ be a group ring, let \mbox{\texttt{\mdseries\slshape U}} be a submagma of $G$, and let \mbox{\texttt{\mdseries\slshape L}} be the Lie algebra associated with $FG$. Then \texttt{Embedding(\mbox{\texttt{\mdseries\slshape U}}, \mbox{\texttt{\mdseries\slshape L}} )} returns the obvious mapping from \mbox{\texttt{\mdseries\slshape U}} to \mbox{\texttt{\mdseries\slshape L}} (as the composition of the mappings \texttt{Embedding( \mbox{\texttt{\mdseries\slshape U}}, FG )} and \texttt{NaturalBijectionToLieAlgebra( FG )}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@F := GF( 2 ); G := SymmetricGroup( 3 ); FG := GroupRing( F, G );|
  GF(2)
  Sym( [ 1 .. 3 ] )
  <algebra-with-one over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@L := LieAlgebra( FG );|
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(2)>
  !gapprompt@gap>| !gapinput@f := Embedding( G, L );;|
  !gapprompt@gap>| !gapinput@(1,2)^f + (1,3)^f;|
  LieObject( (Z(2)^0)*(1,2)+(Z(2)^0)*(1,3) )   
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LieCentre}}
\logpage{[ 4, 5, 9 ]}\nobreak
\hyperdef{L}{X8111F58E7DE3E25C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LieCentre({\mdseries\slshape L})\index{LieCentre@\texttt{LieCentre}}
\label{LieCentre}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a Lie algebra 



 The centre of the Lie algebra associated with a group ring corresponds to the
centre of the underlying group ring, and it can be calculated very fast by
considering the conjugacy classes of the group. This method returns the centre
of \mbox{\texttt{\mdseries\slshape L}} using this idea. }

 
\begin{Verbatim}[commandchars=@|B,fontsize=\small,frame=single,label=Example]
  
  @gapprompt|gap>B @gapinput|G := SmallGroup( 256, 400 ); FG := GroupRing( GF( 2 ), G ); B
  <pc group of size 256 with 8 generators>
  <algebra-with-one over GF(2), with 8 generators>
  @gapprompt|gap>B @gapinput|L := LieAlgebra( FG );B
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(2)>
  @gapprompt|gap>B @gapinput|C := LieCentre( L );B
  <Lie algebra of dimension 28 over GF(2)>
  @gapprompt|gap>B @gapinput|D := LieDerivedSubalgebra( L );B
  #I  LAGUNA package: Computing the Lie derived subalgebra ...
  <Lie algebra of dimension 228 over GF(2)>
  @gapprompt|gap>B @gapinput|c := Dimension( C ); d := Dimension( D ); l := Dimension( L );B
  28
  228
  256
  @gapprompt|gap>B @gapinput|c + d = l; # This is always the case for Lie algebras of group algebras! B
  true
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LieDerivedSubalgebra}}
\logpage{[ 4, 5, 10 ]}\nobreak
\hyperdef{L}{X7C95C0057C977747}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LieDerivedSubalgebra({\mdseries\slshape L})\index{LieDerivedSubalgebra@\texttt{LieDerivedSubalgebra}}
\label{LieDerivedSubalgebra}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 a Lie algebra 



 If \mbox{\texttt{\mdseries\slshape L}} is the Lie algebra associated with a group ring, then this method returns the
Lie derived subalgebra of \mbox{\texttt{\mdseries\slshape L}}. This can be done very fast using the conjugacy classes of the underlying
group. }

 
\begin{Verbatim}[commandchars=@|B,fontsize=\small,frame=single,label=Example]
  
  @gapprompt|gap>B @gapinput|G := SmallGroup( 256, 400 ); FG := GroupRing( GF( 2 ), G ); B
  <pc group of size 256 with 8 generators>
  <algebra-with-one over GF(2), with 8 generators>
  @gapprompt|gap>B @gapinput|L := LieAlgebra( FG );B
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(2)>
  @gapprompt|gap>B @gapinput|C := LieCentre( L );B
  <Lie algebra of dimension 28 over GF(2)>
  @gapprompt|gap>B @gapinput|D := LieDerivedSubalgebra( L );B
  #I  LAGUNA package: Computing the Lie derived subalgebra ...    
  <Lie algebra of dimension 228 over GF(2)>
  @gapprompt|gap>B @gapinput|l := Dimension( L ); c := Dimension( C ); d := Dimension( D );B
  256
  28
  228
  @gapprompt|gap>B @gapinput|c + d = l; # This is always the case for Lie algebras of group algebras!B
  true
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsLieAbelian}}
\logpage{[ 4, 5, 11 ]}\nobreak
\hyperdef{L}{X7F97D08F7B738ADE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsLieAbelian({\mdseries\slshape L})\index{IsLieAbelian@\texttt{IsLieAbelian}}
\label{IsLieAbelian}
}\hfill{\scriptsize (method)}}\\


 The Lie algebra \mbox{\texttt{\mdseries\slshape L}} of an associative algebra $A$ is Lie abelian, if and only if $A$ is abelian, so this method refers to \texttt{IsAbelian( A )}. }

 
\begin{Verbatim}[commandchars=@|B,fontsize=\small,frame=single,label=Example]
  
  @gapprompt|gap>B @gapinput|G := SymmetricGroup( 3 ); FG := GroupRing( GF( 2 ), G); B
  Sym( [ 1 .. 3 ] )
  <algebra-with-one over GF(2), with 2 generators>
  @gapprompt|gap>B @gapinput|L := LieAlgebra( FG );          B
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(2)>
  @gapprompt|gap>B @gapinput|IsAbelian( G );B
  false
  @gapprompt|gap>B @gapinput|IsAbelian( L );    # This command should not be used for Lie algebras!B
  true                    
  @gapprompt|gap>B @gapinput|IsLieAbelian( L ); # Instead, IsLieAbelian is the correct command.B
  false   
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsLieSolvable}}
\logpage{[ 4, 5, 12 ]}\nobreak
\hyperdef{L}{X859FF1B3812B8FCC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsLieSolvable({\mdseries\slshape L})\index{IsLieSolvable@\texttt{IsLieSolvable}}
\label{IsLieSolvable}
}\hfill{\scriptsize (method)}}\\


 In \cite{PPS73} Passi, Passman, and Sehgal have classified all groups $G$ such that the Lie algebra associated with the group ring is solvable. This
method uses their classification, making it considerably faster than the more
elementary method which just calculates Lie commutators. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@G := SmallGroup( 256, 400 ); FG := GroupRing( GF( 2 ), G ); |
  <pc group of size 256 with 8 generators>
  <algebra-with-one over GF(2), with 8 generators>
  !gapprompt@gap>| !gapinput@L := LieAlgebra( FG );|
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(2)>
  !gapprompt@gap>| !gapinput@IsLieSolvable( L );                       # This is very fast.|
  #I  LAGUNA package: Checking Lie solvability ...
  true
  !gapprompt@gap>| !gapinput@List( LieDerivedSeries( L ), Dimension ); # This is very slow.|
  #I  LAGUNA package: Computing the Lie derived subalgebra ...
  [ 256, 228, 189, 71, 0 ]   
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsLieNilpotent}}
\logpage{[ 4, 5, 13 ]}\nobreak
\hyperdef{L}{X78452F4E875A62A8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsLieNilpotent({\mdseries\slshape L})\index{IsLieNilpotent@\texttt{IsLieNilpotent}}
\label{IsLieNilpotent}
}\hfill{\scriptsize (method)}}\\


 In \cite{PPS73} Passi, Passman, and Sehgal have classified all groups $G$ such that the Lie algebra associated with the group ring is Lie nilpotent.
This method uses their classification, making it considerably faster than the
more elementary method which just calculates Lie commutators. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@G := SmallGroup( 256, 400 ); FG := GroupRing( GF( 2 ), G ); |
  <pc group of size 256 with 8 generators>
  <algebra-with-one over GF(2), with 8 generators>
  !gapprompt@gap>| !gapinput@L := LieAlgebra( FG );|
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(2)>
  !gapprompt@gap>| !gapinput@IsLieNilpotent( L );                           # This is very fast.|
  #I  LAGUNA package: Checking Lie nilpotency ...
  true
  !gapprompt@gap>| !gapinput@List( LieLowerCentralSeries( L ), Dimension ); # This is very slow.|
  #I  LAGUNA package: Computing the Lie derived subalgebra ...
  [ 256, 228, 222, 210, 191, 167, 138, 107, 76, 54, 29, 15, 6, 0 ]   
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsLieMetabelian}}
\logpage{[ 4, 5, 14 ]}\nobreak
\hyperdef{L}{X8504EC257B764BA6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsLieMetabelian({\mdseries\slshape L})\index{IsLieMetabelian@\texttt{IsLieMetabelian}}
\label{IsLieMetabelian}
}\hfill{\scriptsize (property)}}\\


 In \cite{LR86} Levin and Rosenberger have classified all groups $G$ such that the Lie algebra associated with the group ring is Lie metabelian.
This method uses their classification, making it considerably faster than the
more elementary method which just calculates Lie commutators. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@G := SmallGroup( 256, 400 ); FG := GroupRing( GF( 2 ), G ); |
  <pc group of size 256 with 8 generators>
  <algebra-with-one over GF(2), with 8 generators>
  !gapprompt@gap>| !gapinput@L := LieAlgebra( FG );|
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(2)>
  !gapprompt@gap>| !gapinput@IsLieMetabelian( L );|
  false   
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsLieCentreByMetabelian}}
\logpage{[ 4, 5, 15 ]}\nobreak
\hyperdef{L}{X7EEAA09F818CE548}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsLieCentreByMetabelian({\mdseries\slshape L})\index{IsLieCentreByMetabelian@\texttt{IsLieCentreByMetabelian}}
\label{IsLieCentreByMetabelian}
}\hfill{\scriptsize (property)}}\\


 In \cite{Ross} the third author of this package classified all groups $G$ such that the Lie algebra associated with the group ring is Lie
centre-by-metabelian. This method uses the classification, making it
considerably faster than the more elementary method which just calculates Lie
commutators. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@G := SymmetricGroup( 3 ); FG := GroupRing( GF( 2 ), G ); |
  Sym( [ 1 .. 3 ] )
  <algebra-with-one over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@L := LieAlgebra( FG );       |
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(2)>
  !gapprompt@gap>| !gapinput@IsLieMetabelian( L );                                             |
  false
  !gapprompt@gap>| !gapinput@IsLieCentreByMetabelian( L );|
  true   
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{CanonicalBasis}}
\logpage{[ 4, 5, 16 ]}\nobreak
\hyperdef{L}{X7C8EBFF5805F8C51}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CanonicalBasis({\mdseries\slshape L})\index{CanonicalBasis@\texttt{CanonicalBasis}}
\label{CanonicalBasis}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 basis of a Lie algebra 



 The canonical basis of a group algebra $FG$ is formed by the elements of $G$. Here \mbox{\texttt{\mdseries\slshape L}} is the Lie algebra associated with $FG$, and the method returns the images of the elements of $G$ in \mbox{\texttt{\mdseries\slshape L}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@G := SymmetricGroup( 3 ); FG := GroupRing( GF( 2 ), G ); |
  Sym( [ 1 .. 3 ] )
  <algebra-with-one over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@L := LieAlgebra( FG );       |
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(2)>
  !gapprompt@gap>| !gapinput@B := CanonicalBasis( L );|
  CanonicalBasis( <Lie algebra of dimension 6 over GF(2)> )
  !gapprompt@gap>| !gapinput@Elements( B );|
  [ LieObject( (Z(2)^0)*() ), LieObject( (Z(2)^0)*(2,3) ),
    LieObject( (Z(2)^0)*(1,2) ), LieObject( (Z(2)^0)*(1,2,3) ),
    LieObject( (Z(2)^0)*(1,3,2) ), LieObject( (Z(2)^0)*(1,3) ) ]
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsBasisOfLieAlgebraOfGroupRing}}
\logpage{[ 4, 5, 17 ]}\nobreak
\hyperdef{L}{X83026DFF8461B96D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsBasisOfLieAlgebraOfGroupRing({\mdseries\slshape B})\index{IsBasisOfLieAlgebraOfGroupRing@\texttt{IsBasisOfLieAlgebraOfGroupRing}}
\label{IsBasisOfLieAlgebraOfGroupRing}
}\hfill{\scriptsize (property)}}\\


 A basis \mbox{\texttt{\mdseries\slshape B}} has this property if the preimages of the basis vectors in the group algebra
form a group. It can be verified if a basis has this property. This is
important for the speed of the calculation of the structure constants table;
see \texttt{StructureConstantsTable} (\ref{StructureConstantsTable}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@G := SymmetricGroup( 3 ); FG := GroupRing( GF( 2 ), G ); |
  Sym( [ 1 .. 3 ] )
  <algebra-with-one over GF(2), with 2 generators>
  !gapprompt@gap>| !gapinput@L := LieAlgebra( FG );    |
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(2)>
  !gapprompt@gap>| !gapinput@B := CanonicalBasis( L );|
  CanonicalBasis( <Lie algebra of dimension 6 over GF(2)> )
  !gapprompt@gap>| !gapinput@IsBasisOfLieAlgebraOfGroupRing( B );|
  true   
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{StructureConstantsTable}}
\logpage{[ 4, 5, 18 ]}\nobreak
\hyperdef{L}{X804ADF0280F67CDC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{StructureConstantsTable({\mdseries\slshape B})\index{StructureConstantsTable@\texttt{StructureConstantsTable}}
\label{StructureConstantsTable}
}\hfill{\scriptsize (method)}}\\


 A very fast implementation for calculating the structure constants table for
the Lie algebra \texttt{L} associated with a group ring with respect to its canonical basis \mbox{\texttt{\mdseries\slshape B}} using its special structure; see \texttt{CanonicalBasis} (\ref{CanonicalBasis}). }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@G := CyclicGroup( 2 ); FG := GroupRing( GF( 2 ), G ); |
  <pc group of size 2 with 1 generators>
  <algebra-with-one over GF(2), with 1 generators>
  !gapprompt@gap>| !gapinput@L := LieAlgebra( FG );|
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(2)>
  !gapprompt@gap>| !gapinput@B := CanonicalBasis( L );|
  CanonicalBasis( <Lie algebra of dimension 2 over GF(2)> )
  !gapprompt@gap>| !gapinput@StructureConstantsTable( B );    |
  #I  LAGUNA package: Computing the structure constants table ...   
  [ [ [ [  ], [  ] ], [ [  ], [  ] ] ], [ [ [  ], [  ] ], [ [  ], [  ] ] ], -1, 
    0*Z(2) ]  
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LieUpperNilpotencyIndex}}
\logpage{[ 4, 5, 19 ]}\nobreak
\hyperdef{L}{X87E9411284D1A346}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LieUpperNilpotencyIndex({\mdseries\slshape KG})\index{LieUpperNilpotencyIndex@\texttt{LieUpperNilpotencyIndex}}
\label{LieUpperNilpotencyIndex}
}\hfill{\scriptsize (attribute)}}\\


 \index{upper Lie power series} In a modular group algebra $KG$ the \emph{upper Lie power series} is defined as follows: $KG^{(1)}=KG$, $KG^{(n+1)}$ is the associative ideal, generated by $[KG^{(n)},KG]$. The upper Lie nilpotency index $t^L(G)$ of the group algebra $KG$ is defined to be the smallest number $n$ such that $KG^{(n)}=0$. It can be calculated very fast using Lie dimension subgroups \cite{Shalev91}, that is, using only information about the underlying group; see \texttt{LieDimensionSubgroups} (\ref{LieDimensionSubgroups}). This is why it is stored as an attribute of the group algebra \mbox{\texttt{\mdseries\slshape KG}} rather than that of its associated Lie algebra. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );|
  <algebra-with-one over GF(2), with 4 generators>
  !gapprompt@gap>| !gapinput@LieUpperNilpotencyIndex( KG );|
  5      
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LieLowerNilpotencyIndex}}
\logpage{[ 4, 5, 20 ]}\nobreak
\hyperdef{L}{X7D71DF0579FBE1C9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LieLowerNilpotencyIndex({\mdseries\slshape KG})\index{LieLowerNilpotencyIndex@\texttt{LieLowerNilpotencyIndex}}
\label{LieLowerNilpotencyIndex}
}\hfill{\scriptsize (attribute)}}\\


 \index{lower Lie power series} In a modular group algebra $KG$ the \emph{lower Lie power series} is defined as follows: $KG^{[n]}$ is the associative ideal, generated by all (left-normed) Lie-products $[x_1, x_2, \dots, x_n]$, $ x_i \in KG $. The lower Lie nilpotency index $t_L(G)$ of the group algebra $KG$ is defined to be the minimal smallest $n$ such that $KG^{[n]}=0$. In \cite{Du} the Jennings' conjecture was proved, which means that the nilpotency class of
the normalized unit group of the modular group algebra $KG$ is equal to $t_L(G)-1$. 

 This allows to express lower Lie nilpotency index via the nilpotency class of
the normalized unit group, and with its polycyclic presentation, provided by \textsf{LAGUNA}, this will be faster than elementary calculations with Lie commutators. As
the previous attribute, this index is also stored as an attribute of the group
algebra \mbox{\texttt{\mdseries\slshape KG}}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );|
  <algebra-with-one over GF(2), with 4 generators>
  !gapprompt@gap>| !gapinput@LieLowerNilpotencyIndex( KG );|
  5     
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LieDerivedLength}}
\logpage{[ 4, 5, 21 ]}\nobreak
\hyperdef{L}{X7E5950517F0CDB47}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LieDerivedLength({\mdseries\slshape L})\index{LieDerivedLength@\texttt{LieDerivedLength}}
\label{LieDerivedLength}
}\hfill{\scriptsize (attribute)}}\\


 \index{Lie derived series} \index{Lie derived length} Let $L$ be a Lie algebra. The \emph{Lie derived series} of $L$ is defined as follows: $\delta^{[0]}(L) = L$ and $\delta^{[n]}(L) = [\delta^{[n-1]}(L), \delta^{[n-1]}(L)]$. $L$ is called Lie solvable if there exists an integer $m$ such that $ \delta^{[m]}(L) = 0 $. In this case the integer $m$ is called the \emph{Lie derived length} of $L$, and it is returned by this function. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF ( 2 ), DihedralGroup( 16 ) );;|
  !gapprompt@gap>| !gapinput@L := LieAlgebra( KG );|
  #I  LAGUNA package: Constructing Lie algebra ...
  <Lie algebra over GF(2)>
  !gapprompt@gap>| !gapinput@LieDerivedLength( L );|
  #I  LAGUNA package: Computing the Lie derived subalgebra ...
  3                                                            
  
\end{Verbatim}
 }

  
\section{\textcolor{Chapter }{Other commands}}\label{Other}
\logpage{[ 4, 6, 0 ]}
\hyperdef{L}{X7B16423A7FBED034}{}
{
  

\subsection{\textcolor{Chapter }{SubgroupsOfIndexTwo}}
\logpage{[ 4, 6, 1 ]}\nobreak
\hyperdef{L}{X85CE6B407910F768}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SubgroupsOfIndexTwo({\mdseries\slshape G})\index{SubgroupsOfIndexTwo@\texttt{SubgroupsOfIndexTwo}}
\label{SubgroupsOfIndexTwo}
}\hfill{\scriptsize (attribute)}}\\


 Returns a list of subgroups of $G$ with index two. Such subgroups are important for the investigation of the Lie
structure of the group algebra $KG$ in the case of characteristic 2. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@SubgroupsOfIndexTwo( DihedralGroup( 16 ) );|
  [ Group([ f3, f4, f1 ]), Group([ f3, f4, f2 ]), Group([ f3, f4, f1*f2 ]) ]
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{DihedralDepth}}
\logpage{[ 4, 6, 2 ]}\nobreak
\hyperdef{L}{X7AFBD42180787A07}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DihedralDepth({\mdseries\slshape U})\index{DihedralDepth@\texttt{DihedralDepth}}
\label{DihedralDepth}
}\hfill{\scriptsize (method)}}\\


 For a finite 2-group \mbox{\texttt{\mdseries\slshape U}}, the function returns its \emph{dihedral depth}, which is defined to be the maximal number $d$ such that \mbox{\texttt{\mdseries\slshape U}} contains a subgroup isomorphic to the dihedral group of order $2^{d+1}$. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@KD8 := GroupRing( GF(2), DihedralGroup( 8 ) );|
  <algebra-with-one over GF(2), with 3 generators>
  !gapprompt@gap>| !gapinput@UD8 := PcNormalizedUnitGroup( KD8 );|
  <pc group of size 128 with 7 generators>
  !gapprompt@gap>| !gapinput@DihedralDepth( UD8 );|
  2      
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{DimensionBasis}}
\logpage{[ 4, 6, 3 ]}\nobreak
\hyperdef{L}{X7D7CD02F803FFC08}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DimensionBasis({\mdseries\slshape G})\index{DimensionBasis@\texttt{DimensionBasis}}
\label{DimensionBasis}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 record with two components: `dimensionBasis' (list of group elements) and
`weights' (list of weights) 



 For a finite $p$-group \mbox{\texttt{\mdseries\slshape G}}, returns its Jennings basis as it was described in Section \ref{TheoryThird}. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@G := DihedralGroup( 16 );|
  <pc group of size 16 with 4 generators>  
  !gapprompt@gap>| !gapinput@DimensionBasis( G );|
  rec( dimensionBasis := [ f1, f2, f3, f4 ], weights := [ 1, 1, 2, 4 ] )    
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LieDimensionSubgroups}}
\logpage{[ 4, 6, 4 ]}\nobreak
\hyperdef{L}{X84B7C6A38473722F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LieDimensionSubgroups({\mdseries\slshape G})\index{LieDimensionSubgroups@\texttt{LieDimensionSubgroups}}
\label{LieDimensionSubgroups}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 list of subgroups 



 For a finite $p$-group \mbox{\texttt{\mdseries\slshape G}}, returns the series of its Lie dimension subgroups. The $m$-th Lie dimension subgroup $ D_{(m)} $ is the intersection of the group $G$ and $ 1+KG^{(m)} $, where $KG^{(m)}$ is the $m$-th term of the upper Lie power series of $KG$; see \texttt{LieUpperNilpotencyIndex} (\ref{LieUpperNilpotencyIndex}) }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@G := DihedralGroup( 16 );|
  <pc group of size 16 with 4 generators>  
  !gapprompt@gap>| !gapinput@LieDimensionSubgroups( G );|
  [ <pc group of size 16 with 4 generators>, Group([ f3, f4 ]), Group([ f4 ]),
    Group([ <identity> of ... ]) ]     
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LieUpperCodimensionSeries (for group ring)}}
\logpage{[ 4, 6, 5 ]}\nobreak
\hyperdef{L}{X7B2EAF81791D6C68}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LieUpperCodimensionSeries({\mdseries\slshape KG})\index{LieUpperCodimensionSeries@\texttt{LieUpperCodimensionSeries}!for group ring}
\label{LieUpperCodimensionSeries:for group ring}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LieUpperCodimensionSeries({\mdseries\slshape G})\index{LieUpperCodimensionSeries@\texttt{LieUpperCodimensionSeries}!for group}
\label{LieUpperCodimensionSeries:for group}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 list of subgroups 



 A notion of upper Lie codimension subgroups was introduced in \cite{CS}. For a finite $p$-group \mbox{\texttt{\mdseries\slshape G}}, $C_i$ is the set of all elements $g$ in \mbox{\texttt{\mdseries\slshape G}}, such that the Lie commutator $[ g, g_1, ..., g_i ]$ of the length $i+1$ is equal to zero for all $g_1, ..., g_i$ from \mbox{\texttt{\mdseries\slshape G}}, and $ C_0 = {1} $. By Du's theorem (see \cite{Du}), $C_i$ coincides with the intersection of $G$ and the i-th term of the upper central series ${1}=Z_0 < Z_1 < Z_2 < ... < Z_n = V(KG)$ of the normalized unit group $V(KG)$. This fact is used in \textsf{LAGUNA} to speed up computation of this series. Since $V(KG)$ is involved in computation, for the first time the argiment should be the
group ring \mbox{\texttt{\mdseries\slshape KG}}, but later you can also apply it to the group \mbox{\texttt{\mdseries\slshape G}} itself. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@G := DihedralGroup(16);|
  <pc group of size 16 with 4 generators>
  !gapprompt@gap>| !gapinput@KG := GroupRing( GF(2), G );|
  <algebra-with-one over GF(2), with 4 generators>
  !gapprompt@gap>| !gapinput@LieUpperCodimensionSeries( KG );|
  [ Group([ f1, f2, f3, f4 ]), Group([ f3, f4, f3*f4 ]), Group([ f4 ]), 
    Group([ f4 ]), Group([  ]) ]
  !gapprompt@gap>| !gapinput@LieUpperCodimensionSeries( G );|
  [ Group([ f1, f2, f3, f4 ]), Group([ f3, f4, f3*f4 ]), Group([ f4 ]), 
    Group([ f4 ]), Group([  ]) ]
  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LAGInfo}}
\logpage{[ 4, 6, 6 ]}\nobreak
\hyperdef{L}{X7E5804B881DE4FF2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LAGInfo\index{LAGInfo@\texttt{LAGInfo}}
\label{LAGInfo}
}\hfill{\scriptsize (info class)}}\\


 \texttt{LAGInfo} is a special Info class for \textsf{LAGUNA} algorithms. It has 5 levels: 0, 1 (default), 2, 3 and 4. To change info level
to \texttt{k}, use command \texttt{SetInfoLevel(LAGInfo, k)}. }

 
\begin{Verbatim}[commandchars=@|B,fontsize=\small,frame=single,label=Example]
  
  @gapprompt|gap>B @gapinput|SetInfoLevel( LAGInfo, 2 );B
  @gapprompt|gap>B @gapinput|KD8 := GroupRing( GF( 2 ), DihedralGroup( 8 ) );B
  <algebra-with-one over GF(2), with 3 generators>
  @gapprompt|gap>B @gapinput|UD8 := PcNormalizedUnitGroup( KD8 );B
  #I  LAGInfo: Computing the pc normalized unit group ...
  #I  LAGInfo: Calculating weighted basis ...
  #I  LAGInfo: Calculating dimension basis ...
  #I  LAGInfo: dimension basis finished !
  #I  LAGInfo: Weighted basis finished !
  #I  LAGInfo: Computing the augmentation ideal filtration...
  #I  LAGInfo: Filtration finished !
  #I  LAGInfo: finished, converting to PcGroup
  <pc group of size 128 with 7 generators>     
  
\end{Verbatim}
 }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{manual}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
