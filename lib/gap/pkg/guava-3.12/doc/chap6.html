<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (guava) - Chapter 6: Manipulating Codes</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body>


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap5.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chap7.html">Next Chapter</a>&nbsp;  </div>

<p><a id="X866FC1117814B64D" name="X866FC1117814B64D"></a></p>
<div class="ChapSects"><a href="chap6.html#X866FC1117814B64D">6 <span class="Heading">Manipulating Codes</span></a>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap6.html#X8271A4697FDA97B2">6.1 <span class="Heading">
Functions that Generate a New Code from a Given Code
</span></a>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X794679BE7F9EB5C1">6.1-1 ExtendedCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E6E4DDA79574FDB">6.1-2 PuncturedCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X87691AB67FF5621B">6.1-3 EvenWeightSubcode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X79577EB27BE8524B">6.1-4 PermutedCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X87E5849784BC60D2">6.1-5 ExpurgatedCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8134BE2B8478BE8A">6.1-6 AugmentedCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B0A6E1F82686B43">6.1-7 RemovedElementsCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X784E1255874FCA8A">6.1-8 AddedElementsCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X81CBEAFF7B9DE6EF">6.1-9 ShortenedCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7A5D5419846FC867">6.1-10 LengthenedCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7982D699803ECD0F">6.1-11 SubCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X809376187C1525AA">6.1-12 ResidueCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E92DC9581F96594">6.1-13 ConstructionBCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X799B12F085ACB609">6.1-14 DualCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X81FE1F387DFCCB22">6.1-15 ConversionFieldCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X82D18907800FE3D9">6.1-16 TraceCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8799F4BF81B0842B">6.1-17 CosetCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X873EA5EE85699832">6.1-18 ConstantWeightSubcode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7AA203A380BC4C79">6.1-19 StandardFormCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7EF49A257D6DB53B">6.1-20 PiecewiseConstantCode</a></span>
</div></div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap6.html#X7964BF0081CC8352">6.2 <span class="Heading">
Functions that Generate a New Code from Two or More Given Codes
</span></a>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X79E00D3A8367D65A">6.2-1 DirectSumCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X86E9D6DE7F1A07E6">6.2-2 UUVCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7BFBBA5784C293C1">6.2-3 DirectProductCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X78F0B1BC81FB109C">6.2-4 IntersectionCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8228A1F57A29B8F4">6.2-5 UnionCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7A85F8AF8154D387">6.2-6 ExtendedDirectSumCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E17107686A845DB">6.2-7 AmalgamatedDirectSumCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7D8981AF7DFE9814">6.2-8 BlockwiseDirectSumCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C37D467791CE99B">6.2-9 ConstructionXCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B50943B8014134F">6.2-10 ConstructionXXCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X790C614985BFAE16">6.2-11 BZCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X820327D6854A50B5">6.2-12 BZCodeNC</a></span>
</div></div>
</div>

<h3>6 <span class="Heading">Manipulating Codes</span></h3>

<p>In this chapter we describe several functions <strong class="pkg">GUAVA</strong> uses to manipulate codes. Some of the best codes are obtained by starting with for example a BCH code, and manipulating it.</p>

<p>In some cases, it is faster to perform calculations with a manipulated code than to use the original code. For example, if the dimension of the code is larger than half the word length, it is generally faster to compute the weight distribution by first calculating the weight distribution of the dual code than by directly calculating the weight distribution of the original code. The size of the dual code is smaller in these cases.</p>

<p>Because <strong class="pkg">GUAVA</strong> keeps all information in a code record, in some cases the information can be preserved after manipulations. Therefore, computations do not always have to start from scratch.</p>

<p>In Section <a href="chap6.html#X8271A4697FDA97B2"><b>6.1</b></a>, we describe functions that take a code with certain parameters, modify it in some way and return a different code (see <code class="func">ExtendedCode</code> (<a href="chap6.html#X794679BE7F9EB5C1"><b>6.1-1</b></a>), <code class="func">PuncturedCode</code> (<a href="chap6.html#X7E6E4DDA79574FDB"><b>6.1-2</b></a>), <code class="func">EvenWeightSubcode</code> (<a href="chap6.html#X87691AB67FF5621B"><b>6.1-3</b></a>), <code class="func">PermutedCode</code> (<a href="chap6.html#X79577EB27BE8524B"><b>6.1-4</b></a>), <code class="func">ExpurgatedCode</code> (<a href="chap6.html#X87E5849784BC60D2"><b>6.1-5</b></a>), <code class="func">AugmentedCode</code> (<a href="chap6.html#X8134BE2B8478BE8A"><b>6.1-6</b></a>), <code class="func">RemovedElementsCode</code> (<a href="chap6.html#X7B0A6E1F82686B43"><b>6.1-7</b></a>), <code class="func">AddedElementsCode</code> (<a href="chap6.html#X784E1255874FCA8A"><b>6.1-8</b></a>), <code class="func">ShortenedCode</code> (<a href="chap6.html#X81CBEAFF7B9DE6EF"><b>6.1-9</b></a>), <code class="func">LengthenedCode</code> (<a href="chap6.html#X7A5D5419846FC867"><b>6.1-10</b></a>), <code class="func">ResidueCode</code> (<a href="chap6.html#X809376187C1525AA"><b>6.1-12</b></a>), <code class="func">ConstructionBCode</code> (<a href="chap6.html#X7E92DC9581F96594"><b>6.1-13</b></a>), <code class="func">DualCode</code> (<a href="chap6.html#X799B12F085ACB609"><b>6.1-14</b></a>), <code class="func">ConversionFieldCode</code> (<a href="chap6.html#X81FE1F387DFCCB22"><b>6.1-15</b></a>), <code class="func">ConstantWeightSubcode</code> (<a href="chap6.html#X873EA5EE85699832"><b>6.1-18</b></a>), <code class="func">StandardFormCode</code> (<a href="chap6.html#X7AA203A380BC4C79"><b>6.1-19</b></a>) and <code class="func">CosetCode</code> (<a href="chap6.html#X8799F4BF81B0842B"><b>6.1-17</b></a>)). In Section <a href="chap6.html#X7964BF0081CC8352"><b>6.2</b></a>, we describe functions that generate a new code out of two codes (see <code class="func">DirectSumCode</code> (<a href="chap6.html#X79E00D3A8367D65A"><b>6.2-1</b></a>), <code class="func">UUVCode</code> (<a href="chap6.html#X86E9D6DE7F1A07E6"><b>6.2-2</b></a>), <code class="func">DirectProductCode</code> (<a href="chap6.html#X7BFBBA5784C293C1"><b>6.2-3</b></a>), <code class="func">IntersectionCode</code> (<a href="chap6.html#X78F0B1BC81FB109C"><b>6.2-4</b></a>) and <code class="func">UnionCode</code> (<a href="chap6.html#X8228A1F57A29B8F4"><b>6.2-5</b></a>)).</p>

<p><a id="X8271A4697FDA97B2" name="X8271A4697FDA97B2"></a></p>

<h4>6.1 <span class="Heading">
Functions that Generate a New Code from a Given Code
</span></h4>

<p><a id="X794679BE7F9EB5C1" name="X794679BE7F9EB5C1"></a></p>

<h5>6.1-1 ExtendedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ExtendedCode</code>( <var class="Arg">C[, i]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ExtendedCode</code> extends the code <var class="Arg">C</var> <var class="Arg">i</var> times and returns the result. <var class="Arg">i</var> is equal to 1 by default. Extending is done by adding a parity check bit after the last coordinate. The coordinates of all codewords now add up to zero. In the binary case, each codeword has even weight.</p>

<p>The word length increases by <var class="Arg">i</var>. The size of the code remains the same. In the binary case, the minimum distance increases by one if it was odd. In other cases, that is not always true.</p>

<p>A cyclic code in general is no longer cyclic after extending.</p>


<table class="example">
<tr><td><pre>
gap&gt; C1 := HammingCode( 3, GF(2) );
a linear [7,4,3]1 Hamming (3,2) code over GF(2)
gap&gt; C2 := ExtendedCode( C1 );
a linear [8,4,4]2 extended code
gap&gt; IsEquivalent( C2, ReedMullerCode( 1, 3 ) );
true
gap&gt; List( AsSSortedList( C2 ), WeightCodeword );
[ 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8 ]
gap&gt; C3 := EvenWeightSubcode( C1 );
a linear [7,3,4]2..3 even weight subcode 
</pre></td></tr></table>

<p>To undo extending, call <code class="code">PuncturedCode</code> (see <code class="func">PuncturedCode</code> (<a href="chap6.html#X7E6E4DDA79574FDB"><b>6.1-2</b></a>)). The function <code class="code">EvenWeightSubcode</code> (see <code class="func">EvenWeightSubcode</code> (<a href="chap6.html#X87691AB67FF5621B"><b>6.1-3</b></a>)) also returns a related code with only even weights, but without changing its word length.</p>

<p><a id="X7E6E4DDA79574FDB" name="X7E6E4DDA79574FDB"></a></p>

<h5>6.1-2 PuncturedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PuncturedCode</code>( <var class="Arg">C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">PuncturedCode</code> punctures <var class="Arg">C</var> in the last column, and returns the result. Puncturing is done simply by cutting off the last column from each codeword. This means the word length decreases by one. The minimum distance in general also decrease by one.</p>

<p>This command can also be called with the syntax <code class="code">PuncturedCode( C, L )</code>. In this case, <code class="code">PuncturedCode</code> punctures <var class="Arg">C</var> in the columns specified by <var class="Arg">L</var>, a list of integers. All columns specified by <var class="Arg">L</var> are omitted from each codeword. If l is the length of <var class="Arg">L</var> (so the number of removed columns), the word length decreases by l. The minimum distance can also decrease by l or less.</p>

<p>Puncturing a cyclic code in general results in a non-cyclic code. If the code is punctured in all the columns where a word of minimal weight is unequal to zero, the dimension of the resulting code decreases.</p>


<table class="example">
<tr><td><pre>
gap&gt; C1 := BCHCode( 15, 5, GF(2) );
a cyclic [15,7,5]3..5 BCH code, delta=5, b=1 over GF(2)
gap&gt; C2 := PuncturedCode( C1 );
a linear [14,7,4]3..5 punctured code
gap&gt; ExtendedCode( C2 ) = C1;
false
gap&gt; PuncturedCode( C1, [1,2,3,4,5,6,7] );
a linear [8,7,1]1 punctured code
gap&gt; PuncturedCode( WholeSpaceCode( 4, GF(5) ) );
a linear [3,3,1]0 punctured code  # The dimension decreased from 4 to 3 
</pre></td></tr></table>

<p><code class="code">ExtendedCode</code> extends the code again (see <code class="func">ExtendedCode</code> (<a href="chap6.html#X794679BE7F9EB5C1"><b>6.1-1</b></a>)), although in general this does not result in the old code.</p>

<p><a id="X87691AB67FF5621B" name="X87691AB67FF5621B"></a></p>

<h5>6.1-3 EvenWeightSubcode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; EvenWeightSubcode</code>( <var class="Arg">C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">EvenWeightSubcode</code> returns the even weight subcode of <var class="Arg">C</var>, consisting of all codewords of <var class="Arg">C</var> with even weight. If <var class="Arg">C</var> is a linear code and contains words of odd weight, the resulting code has a dimension of one less. The minimum distance always increases with one if it was odd. If <var class="Arg">C</var> is a binary cyclic code, and g(x) is its generator polynomial, the even weight subcode either has generator polynomial g(x) (if g(x) is divisible by x-1) or g(x)* (x-1) (if no factor x-1 was present in g(x)). So the even weight subcode is again cyclic.</p>

<p>Of course, if all codewords of <var class="Arg">C</var> are already of even weight, the returned code is equal to <var class="Arg">C</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; C1 := EvenWeightSubcode( BCHCode( 8, 4, GF(3) ) );
an (8,33,4..8)3..8 even weight subcode
gap&gt; List( AsSSortedList( C1 ), WeightCodeword );
[ 0, 4, 4, 4, 4, 4, 4, 6, 4, 4, 4, 4, 6, 4, 4, 6, 4, 4, 8, 6, 4, 6, 8, 4, 4, 
  4, 6, 4, 6, 8, 4, 6, 8 ]
gap&gt; EvenWeightSubcode( ReedMullerCode( 1, 3 ) );
a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2) 
</pre></td></tr></table>

<p><code class="code">ExtendedCode</code> also returns a related code of only even weights, but without reducing its dimension (see <code class="func">ExtendedCode</code> (<a href="chap6.html#X794679BE7F9EB5C1"><b>6.1-1</b></a>)).</p>

<p><a id="X79577EB27BE8524B" name="X79577EB27BE8524B"></a></p>

<h5>6.1-4 PermutedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PermutedCode</code>( <var class="Arg">C, L</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">PermutedCode</code> returns <var class="Arg">C</var> after column permutations. <var class="Arg">L</var> (in GAP disjoint cycle notation) is the permutation to be executed on the columns of <var class="Arg">C</var>. If <var class="Arg">C</var> is cyclic, the result in general is no longer cyclic. If a permutation results in the same code as <var class="Arg">C</var>, this permutation belongs to the automorphism group of <var class="Arg">C</var> (see <code class="func">AutomorphismGroup</code> (<a href="chap4.html#X87677B0787B4461A"><b>4.4-3</b></a>)). In any case, the returned code is equivalent to <var class="Arg">C</var> (see <code class="func">IsEquivalent</code> (<a href="chap4.html#X843034687D9C75B0"><b>4.4-1</b></a>)).</p>


<table class="example">
<tr><td><pre>
gap&gt; C1 := PuncturedCode( ReedMullerCode( 1, 4 ) );
a linear [15,5,7]5 punctured code
gap&gt; C2 := BCHCode( 15, 7, GF(2) );
a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
gap&gt; C2 = C1;
false
gap&gt; p := CodeIsomorphism( C1, C2 );
( 2, 4,14, 9,13, 7,11,10, 6, 8,12, 5)
gap&gt; C3 := PermutedCode( C1, p );
a linear [15,5,7]5 permuted code
gap&gt; C2 = C3;
true 
</pre></td></tr></table>

<p><a id="X87E5849784BC60D2" name="X87E5849784BC60D2"></a></p>

<h5>6.1-5 ExpurgatedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ExpurgatedCode</code>( <var class="Arg">C, L</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ExpurgatedCode</code> expurgates the code <var class="Arg">C</var>&gt; by throwing away codewords in list <var class="Arg">L</var>. <var class="Arg">C</var> must be a linear code. <var class="Arg">L</var> must be a list of codeword input. The generator matrix of the new code no longer is a basis for the codewords specified by <var class="Arg">L</var>. Since the returned code is still linear, it is very likely that, besides the words of <var class="Arg">L</var>, more codewords of <var class="Arg">C</var> are no longer in the new code.</p>


<table class="example">
<tr><td><pre>
gap&gt; C1 := HammingCode( 4 );; WeightDistribution( C1 );
[ 1, 0, 0, 35, 105, 168, 280, 435, 435, 280, 168, 105, 35, 0, 0, 1 ]
gap&gt; L := Filtered( AsSSortedList(C1), i -&gt; WeightCodeword(i) = 3 );;
gap&gt; C2 := ExpurgatedCode( C1, L );
a linear [15,4,3..4]5..11 code, expurgated with 7 word(s)
gap&gt; WeightDistribution( C2 );
[ 1, 0, 0, 0, 14, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 ] 
</pre></td></tr></table>

<p>This function does not work on non-linear codes. For removing words from a non-linear code, use <code class="code">RemovedElementsCode</code> (see <code class="func">RemovedElementsCode</code> (<a href="chap6.html#X7B0A6E1F82686B43"><b>6.1-7</b></a>)). For expurgating a code of all words of odd weight, use `EvenWeightSubcode' (see <code class="func">EvenWeightSubcode</code> (<a href="chap6.html#X87691AB67FF5621B"><b>6.1-3</b></a>)).</p>

<p><a id="X8134BE2B8478BE8A" name="X8134BE2B8478BE8A"></a></p>

<h5>6.1-6 AugmentedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AugmentedCode</code>( <var class="Arg">C, L</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">AugmentedCode</code> returns <var class="Arg">C</var> after augmenting. <var class="Arg">C</var> must be a linear code, <var class="Arg">L</var> must be a list of codeword inputs. The generator matrix of the new code is a basis for the codewords specified by <var class="Arg">L</var> as well as the words that were already in code <var class="Arg">C</var>. Note that the new code in general will consist of more words than only the codewords of <var class="Arg">C</var> and the words <var class="Arg">L</var>. The returned code is also a linear code.</p>

<p>This command can also be called with the syntax <code class="code">AugmentedCode(C)</code>. When called without a list of codewords, <code class="code">AugmentedCode</code> returns <var class="Arg">C</var> after adding the all-ones vector to the generator matrix. <var class="Arg">C</var> must be a linear code. If the all-ones vector was already in the code, nothing happens and a copy of the argument is returned. If <var class="Arg">C</var> is a binary code which does not contain the all-ones vector, the complement of all codewords is added.</p>


<table class="example">
<tr><td><pre>
gap&gt; C31 := ReedMullerCode( 1, 3 );
a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
gap&gt; C32 := AugmentedCode(C31,["00000011","00000101","00010001"]);
a linear [8,7,1..2]1 code, augmented with 3 word(s)
gap&gt; C32 = ReedMullerCode( 2, 3 );
true 
gap&gt; C1 := CordaroWagnerCode(6);
a linear [6,2,4]2..3 Cordaro-Wagner code over GF(2)
gap&gt; Codeword( [0,0,1,1,1,1] ) in C1;
true
gap&gt; C2 := AugmentedCode( C1 );
a linear [6,3,1..2]2..3 code, augmented with 1 word(s)
gap&gt; Codeword( [1,1,0,0,0,0] ) in C2;
true
</pre></td></tr></table>

<p>The function <code class="code">AddedElementsCode</code> adds elements to the codewords instead of adding them to the basis (see <code class="func">AddedElementsCode</code> (<a href="chap6.html#X784E1255874FCA8A"><b>6.1-8</b></a>)).</p>

<p><a id="X7B0A6E1F82686B43" name="X7B0A6E1F82686B43"></a></p>

<h5>6.1-7 RemovedElementsCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RemovedElementsCode</code>( <var class="Arg">C, L</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">RemovedElementsCode</code> returns code <var class="Arg">C</var> after removing a list of codewords <var class="Arg">L</var> from its elements. <var class="Arg">L</var> must be a list of codeword input. The result is an unrestricted code.</p>


<table class="example">
<tr><td><pre>
gap&gt; C1 := HammingCode( 4 );; WeightDistribution( C1 );
[ 1, 0, 0, 35, 105, 168, 280, 435, 435, 280, 168, 105, 35, 0, 0, 1 ]
gap&gt; L := Filtered( AsSSortedList(C1), i -&gt; WeightCodeword(i) = 3 );;
gap&gt; C2 := RemovedElementsCode( C1, L );
a (15,2013,3..15)2..15 code with 35 word(s) removed
gap&gt; WeightDistribution( C2 );
[ 1, 0, 0, 0, 105, 168, 280, 435, 435, 280, 168, 105, 35, 0, 0, 1 ]
gap&gt; MinimumDistance( C2 );
3        # C2 is not linear, so the minimum weight does not have to
         # be equal to the minimum distance 
</pre></td></tr></table>

<p>Adding elements to a code is done by the function <code class="code">AddedElementsCode</code> (see <code class="func">AddedElementsCode</code> (<a href="chap6.html#X784E1255874FCA8A"><b>6.1-8</b></a>)). To remove codewords from the base of a linear code, use <code class="code">ExpurgatedCode</code> (see <code class="func">ExpurgatedCode</code> (<a href="chap6.html#X87E5849784BC60D2"><b>6.1-5</b></a>)).</p>

<p><a id="X784E1255874FCA8A" name="X784E1255874FCA8A"></a></p>

<h5>6.1-8 AddedElementsCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AddedElementsCode</code>( <var class="Arg">C, L</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">AddedElementsCode</code> returns code <var class="Arg">C</var> after adding a list of codewords <var class="Arg">L</var> to its elements. <var class="Arg">L</var> must be a list of codeword input. The result is an unrestricted code.</p>


<table class="example">
<tr><td><pre>
gap&gt; C1 := NullCode( 6, GF(2) );
a cyclic [6,0,6]6 nullcode over GF(2)
gap&gt; C2 := AddedElementsCode( C1, [ "111111" ] );
a (6,2,1..6)3 code with 1 word(s) added
gap&gt; IsCyclicCode( C2 );
true
gap&gt; C3 := AddedElementsCode( C2, [ "101010", "010101" ] );
a (6,4,1..6)2 code with 2 word(s) added
gap&gt; IsCyclicCode( C3 );
true 
</pre></td></tr></table>

<p>To remove elements from a code, use <code class="code">RemovedElementsCode</code> (see <code class="func">RemovedElementsCode</code> (<a href="chap6.html#X7B0A6E1F82686B43"><b>6.1-7</b></a>)). To add elements to the base of a linear code, use <code class="code">AugmentedCode</code> (see <code class="func">AugmentedCode</code> (<a href="chap6.html#X8134BE2B8478BE8A"><b>6.1-6</b></a>)).</p>

<p><a id="X81CBEAFF7B9DE6EF" name="X81CBEAFF7B9DE6EF"></a></p>

<h5>6.1-9 ShortenedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ShortenedCode</code>( <var class="Arg">C[, L]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ShortenedCode( C )</code> returns the code <var class="Arg">C</var> shortened by taking a cross section. If <var class="Arg">C</var> is a linear code, this is done by removing all codewords that start with a non-zero entry, after which the first column is cut off. If <var class="Arg">C</var> was a [n,k,d] code, the shortened code generally is a [n-1,k-1,d] code. It is possible that the dimension remains the same; it is also possible that the minimum distance increases.</p>

<p>If <var class="Arg">C</var> is a non-linear code, <code class="code">ShortenedCode</code> first checks which finite field element occurs most often in the first column of the codewords. The codewords not starting with this element are removed from the code, after which the first column is cut off. The resulting shortened code has at least the same minimum distance as <var class="Arg">C</var>.</p>

<p>This command can also be called using the syntax <code class="code">ShortenedCode(C,L)</code>. When called in this format, <code class="code">ShortenedCode</code> repeats the shortening process on each of the columns specified by <var class="Arg">L</var>. <var class="Arg">L</var> therefore is a list of integers. The column numbers in <var class="Arg">L</var> are the numbers as they are before the shortening process. If <var class="Arg">L</var> has l entries, the returned code has a word length of l positions shorter than <var class="Arg">C</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; C1 := HammingCode( 4 );
a linear [15,11,3]1 Hamming (4,2) code over GF(2)
gap&gt; C2 := ShortenedCode( C1 );
a linear [14,10,3]2 shortened code
gap&gt; C3 := ElementsCode( ["1000", "1101", "0011" ], GF(2) );
a (4,3,1..4)2 user defined unrestricted code over GF(2)
gap&gt; MinimumDistance( C3 );
2
gap&gt; C4 := ShortenedCode( C3 );
a (3,2,2..3)1..2 shortened code
gap&gt; AsSSortedList( C4 );
[ [ 0 0 0 ], [ 1 0 1 ] ]
gap&gt; C5 := HammingCode( 5, GF(2) );
a linear [31,26,3]1 Hamming (5,2) code over GF(2)
gap&gt; C6 := ShortenedCode( C5, [ 1, 2, 3 ] );
a linear [28,23,3]2 shortened code
gap&gt; OptimalityLinearCode( C6 );
0
</pre></td></tr></table>

<p>The function <code class="code">LengthenedCode</code> lengthens the code again (only for linear codes), see <code class="func">LengthenedCode</code> (<a href="chap6.html#X7A5D5419846FC867"><b>6.1-10</b></a>). In general, this is not exactly the inverse function.</p>

<p><a id="X7A5D5419846FC867" name="X7A5D5419846FC867"></a></p>

<h5>6.1-10 LengthenedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LengthenedCode</code>( <var class="Arg">C[, i]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">LengthenedCode( C )</code> returns the code <var class="Arg">C</var> lengthened. <var class="Arg">C</var> must be a linear code. First, the all-ones vector is added to the generator matrix (see <code class="func">AugmentedCode</code> (<a href="chap6.html#X8134BE2B8478BE8A"><b>6.1-6</b></a>)). If the all-ones vector was already a codeword, nothing happens to the code. Then, the code is extended <var class="Arg">i</var> times (see <code class="func">ExtendedCode</code> (<a href="chap6.html#X794679BE7F9EB5C1"><b>6.1-1</b></a>)). <var class="Arg">i</var> is equal to 1 by default. If <var class="Arg">C</var> was an [n,k] code, the new code generally is a [n+i,k+1] code.</p>


<table class="example">
<tr><td><pre>
gap&gt; C1 := CordaroWagnerCode( 5 );
a linear [5,2,3]2 Cordaro-Wagner code over GF(2)
gap&gt; C2 := LengthenedCode( C1 );
a linear [6,3,2]2..3 code, lengthened with 1 column(s) 
</pre></td></tr></table>

<p><code class="code">ShortenedCode</code>' shortens the code, see <code class="func">ShortenedCode</code> (<a href="chap6.html#X81CBEAFF7B9DE6EF"><b>6.1-9</b></a>). In general, this is not exactly the inverse function.</p>

<p><a id="X7982D699803ECD0F" name="X7982D699803ECD0F"></a></p>

<h5>6.1-11 SubCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SubCode</code>( <var class="Arg">C[, s]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This function <code class="code">SubCode</code> returns a subcode of <var class="Arg">C</var> by taking the first k - s rows of the generator matrix of <var class="Arg">C</var>, where k is the dimension of <var class="Arg">C</var>. The interger <var class="Arg">s</var> may be omitted and in this case it is assumed as 1.</p>


<table class="example">
<tr><td><pre>
gap&gt; C := BCHCode(31,11);
a cyclic [31,11,11]7..11 BCH code, delta=11, b=1 over GF(2)
gap&gt; S1:= SubCode(C);
a linear [31,10,11]7..13 subcode
gap&gt; WeightDistribution(S1);
[ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 190, 0, 0, 272, 255, 0, 0, 120, 66,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
gap&gt; S2:= SubCode(C, 8);
a linear [31,3,11]14..20 subcode
gap&gt; History(S2);
[ "a linear [31,3,11]14..20 subcode of",
  "a cyclic [31,11,11]7..11 BCH code, delta=11, b=1 over GF(2)" ]
gap&gt; WeightDistribution(S2);
[ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0 ]
</pre></td></tr></table>

<p><a id="X809376187C1525AA" name="X809376187C1525AA"></a></p>

<h5>6.1-12 ResidueCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ResidueCode</code>( <var class="Arg">C[, c]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The function <code class="code">ResidueCode</code> takes a codeword <var class="Arg">c</var> of <var class="Arg">C</var> (if <var class="Arg">c</var> is omitted, a codeword of minimal weight is used). It removes this word and all its linear combinations from the code and then punctures the code in the coordinates where <var class="Arg">c</var> is unequal to zero. The resulting code is an [n-w, k-1, d-lfloor w*(q-1)/q rfloor ] code. <var class="Arg">C</var> must be a linear code and <var class="Arg">c</var> must be non-zero. If <var class="Arg">c</var> is not in <var class="Arg"></var> then no change is made to <var class="Arg">C</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; C1 := BCHCode( 15, 7 );
a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
gap&gt; C2 := ResidueCode( C1 );
a linear [8,4,4]2 residue code
gap&gt; c := Codeword( [ 0,0,0,1,0,0,1,1,0,1,0,1,1,1,1 ], C1);;
gap&gt; C3 := ResidueCode( C1, c );
a linear [7,4,3]1 residue code 
</pre></td></tr></table>

<p><a id="X7E92DC9581F96594" name="X7E92DC9581F96594"></a></p>

<h5>6.1-13 ConstructionBCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ConstructionBCode</code>( <var class="Arg">C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The function <code class="code">ConstructionBCode</code> takes a binary linear code <var class="Arg">C</var> and calculates the minimum distance of the dual of <var class="Arg">C</var> (see <code class="func">DualCode</code> (<a href="chap6.html#X799B12F085ACB609"><b>6.1-14</b></a>)). It then removes the columns of the parity check matrix of <var class="Arg">C</var> where a codeword of the dual code of minimal weight has coordinates unequal to zero. The resulting matrix is a parity check matrix for an [n-dd, k-dd+1, &gt;= d] code, where dd is the minimum distance of the dual of <var class="Arg">C</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; C1 := ReedMullerCode( 2, 5 );
a linear [32,16,8]6 Reed-Muller (2,5) code over GF(2)
gap&gt; C2 := ConstructionBCode( C1 );
a linear [24,9,8]5..10 Construction B (8 coordinates)
gap&gt; BoundsMinimumDistance( 24, 9, GF(2) );
rec( n := 24, k := 9, q := 2, references := rec(  ), 
  construction := [ [ Operation "UUVCode" ], 
      [ [ [ Operation "UUVCode" ], [ [ [ Operation "DualCode" ], 
                      [ [ [ Operation "RepetitionCode" ], [ 6, 2 ] ] ] ], 
                  [ [ Operation "CordaroWagnerCode" ], [ 6 ] ] ] ], 
          [ [ Operation "CordaroWagnerCode" ], [ 12 ] ] ] ], lowerBound := 8, 
  lowerBoundExplanation := [ "Lb(24,9)=8, u u+v construction of C1 and C2:", 
      "Lb(12,7)=4, u u+v construction of C1 and C2:", 
      "Lb(6,5)=2, dual of the repetition code", 
      "Lb(6,2)=4, Cordaro-Wagner code", "Lb(12,2)=8, Cordaro-Wagner code" ], 
  upperBound := 8, 
  upperBoundExplanation := [ "Ub(24,9)=8, otherwise construction B would 
                             contradict:", "Ub(18,4)=8, Griesmer bound" ] )
# so C2 is optimal
</pre></td></tr></table>

<p><a id="X799B12F085ACB609" name="X799B12F085ACB609"></a></p>

<h5>6.1-14 DualCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DualCode</code>( <var class="Arg">C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">DualCode</code> returns the dual code of <var class="Arg">C</var>. The dual code consists of all codewords that are orthogonal to the codewords of <var class="Arg">C</var>. If <var class="Arg">C</var> is a linear code with generator matrix G, the dual code has parity check matrix G (or if <var class="Arg">C</var> has parity check matrix H, the dual code has generator matrix H). So if <var class="Arg">C</var> is a linear [n, k] code, the dual code of <var class="Arg">C</var> is a linear [n, n-k] code. If <var class="Arg">C</var> is a cyclic code with generator polynomial g(x), the dual code has the reciprocal polynomial of g(x) as check polynomial.</p>

<p>The dual code is always a linear code, even if <var class="Arg">C</var> is non-linear.</p>

<p>If a code <var class="Arg">C</var> is equal to its dual code, it is called <em>self-dual</em>.</p>


<table class="example">
<tr><td><pre>
gap&gt; R := ReedMullerCode( 1, 3 );
a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
gap&gt; RD := DualCode( R );
a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
gap&gt; R = RD;
true
gap&gt; N := WholeSpaceCode( 7, GF(4) );
a cyclic [7,7,1]0 whole space code over GF(4)
gap&gt; DualCode( N ) = NullCode( 7, GF(4) );
true 
</pre></td></tr></table>

<p><a id="X81FE1F387DFCCB22" name="X81FE1F387DFCCB22"></a></p>

<h5>6.1-15 ConversionFieldCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ConversionFieldCode</code>( <var class="Arg">C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ConversionFieldCode</code> returns the code obtained from <var class="Arg">C</var> after converting its field. If the field of <var class="Arg">C</var> is GF(q^m), the returned code has field GF(q). Each symbol of every codeword is replaced by a concatenation of m symbols from GF(q). If <var class="Arg">C</var> is an (n, M, d_1) code, the returned code is a (n* m, M, d_2) code, where d_2 &gt; d_1.</p>

<p>See also <code class="func">HorizontalConversionFieldMat</code> (<a href="chap7.html#X8033E9A67BA155C8"><b>7.3-10</b></a>).</p>


<table class="example">
<tr><td><pre>
gap&gt; R := RepetitionCode( 4, GF(4) );
a cyclic [4,1,4]3 repetition code over GF(4)
gap&gt; R2 := ConversionFieldCode( R );
a linear [8,2,4]3..4 code, converted to basefield GF(2)
gap&gt; Size( R ) = Size( R2 );
true
gap&gt; GeneratorMat( R );
[ [ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ] ]
gap&gt; GeneratorMat( R2 );
[ [ Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2) ],
  [ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ] ] 
</pre></td></tr></table>

<p><a id="X82D18907800FE3D9" name="X82D18907800FE3D9"></a></p>

<h5>6.1-16 TraceCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TraceCode</code>( <var class="Arg">C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Input: <var class="Arg">C</var> is a linear code defined over an extension E of <var class="Arg">F</var> (<var class="Arg">F</var> is the ``base field'')</p>

<p>Output: The linear code generated by Tr_E/F(c), for all c in C.</p>

<p><code class="code">TraceCode</code> returns the image of the code <var class="Arg">C</var> under the trace map. If the field of <var class="Arg">C</var> is GF(q^m), the returned code has field GF(q).</p>

<p>Very slow. It does not seem to be easy to related the parameters of the trace code to the original except in the ``Galois closed'' case.</p>


<table class="example">
<tr><td><pre>
gap&gt; C:=RandomLinearCode(10,4,GF(4)); MinimumDistance(C);
a  [10,4,?] randomly generated code over GF(4)
5
gap&gt; trC:=TraceCode(C,GF(2)); MinimumDistance(trC);
a linear [10,7,1]1..3 user defined unrestricted code over GF(2)
1

</pre></td></tr></table>

<p><a id="X8799F4BF81B0842B" name="X8799F4BF81B0842B"></a></p>

<h5>6.1-17 CosetCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CosetCode</code>( <var class="Arg">C, w</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">CosetCode</code> returns the coset of a code <var class="Arg">C</var> with respect to word <var class="Arg">w</var>. <var class="Arg">w</var> must be of the codeword type. Then, <var class="Arg">w</var> is added to each codeword of <var class="Arg">C</var>, yielding the elements of the new code. If <var class="Arg">C</var> is linear and <var class="Arg">w</var> is an element of <var class="Arg">C</var>, the new code is equal to <var class="Arg">C</var>, otherwise the new code is an unrestricted code.</p>

<p>Generating a coset is also possible by simply adding the word <var class="Arg">w</var> to <var class="Arg">C</var>. See <a href="chap4.html#X832DA51986A3882C"><b>4.2</b></a>.</p>


<table class="example">
<tr><td><pre>
gap&gt; H := HammingCode(3, GF(2));
a linear [7,4,3]1 Hamming (3,2) code over GF(2)
gap&gt; c := Codeword("1011011");; c in H;
false
gap&gt; C := CosetCode(H, c);
a (7,16,3)1 coset code
gap&gt; List(AsSSortedList(C), el-&gt; Syndrome(H, el));
[ [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ],
  [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ],
  [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ] ]
# All elements of the coset have the same syndrome in H 
</pre></td></tr></table>

<p><a id="X873EA5EE85699832" name="X873EA5EE85699832"></a></p>

<h5>6.1-18 ConstantWeightSubcode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ConstantWeightSubcode</code>( <var class="Arg">C, w</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">ConstantWeightSubcode</code> returns the subcode of <var class="Arg">C</var> that only has codewords of weight <var class="Arg">w</var>. The resulting code is a non-linear code, because it does not contain the all-zero vector.</p>

<p>This command also can be called with the syntax <code class="code">ConstantWeightSubcode(C)</code> In this format, <code class="code">ConstantWeightSubcode</code> returns the subcode of <var class="Arg">C</var> consisting of all minimum weight codewords of <var class="Arg">C</var>.</p>

<p><code class="code">ConstantWeightSubcode</code> first checks if Leon's binary <code class="code">wtdist</code> exists on your computer (in the default directory). If it does, then this program is called. Otherwise, the constant weight subcode is computed using a GAP program which checks each codeword in <var class="Arg">C</var> to see if it is of the desired weight.</p>


<table class="example">
<tr><td><pre>
gap&gt; N := NordstromRobinsonCode();; WeightDistribution(N);
[ 1, 0, 0, 0, 0, 0, 112, 0, 30, 0, 112, 0, 0, 0, 0, 0, 1 ]
gap&gt; C := ConstantWeightSubcode(N, 8);
a (16,30,6..16)5..8 code with codewords of weight 8
gap&gt; WeightDistribution(C);
[ 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0 ] 
gap&gt; eg := ExtendedTernaryGolayCode();; WeightDistribution(eg);
[ 1, 0, 0, 0, 0, 0, 264, 0, 0, 440, 0, 0, 24 ]
gap&gt; C := ConstantWeightSubcode(eg);
a (12,264,6..12)3..6 code with codewords of weight 6
gap&gt; WeightDistribution(C);
[ 0, 0, 0, 0, 0, 0, 264, 0, 0, 0, 0, 0, 0 ] 
</pre></td></tr></table>

<p><a id="X7AA203A380BC4C79" name="X7AA203A380BC4C79"></a></p>

<h5>6.1-19 StandardFormCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; StandardFormCode</code>( <var class="Arg">C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">StandardFormCode</code> returns <var class="Arg">C</var> after putting it in standard form. If <var class="Arg">C</var> is a non-linear code, this means the elements are organized using lexicographical order. This means they form a legal GAP `Set'.</p>

<p>If <var class="Arg">C</var> is a linear code, the generator matrix and parity check matrix are put in standard form. The generator matrix then has an identity matrix in its left part, the parity check matrix has an identity matrix in its right part. Although <strong class="pkg">GUAVA</strong> always puts both matrices in a standard form using <code class="code">BaseMat</code>, this never alters the code. <code class="code">StandardFormCode</code> even applies column permutations if unavoidable, and thereby changes the code. The column permutations are recorded in the construction history of the new code (see <code class="func">Display</code> (<a href="chap4.html#X83A5C59278E13248"><b>4.6-3</b></a>)). <var class="Arg">C</var> and the new code are of course equivalent.</p>

<p>If <var class="Arg">C</var> is a cyclic code, its generator matrix cannot be put in the usual upper triangular form, because then it would be inconsistent with the generator polynomial. The reason is that generating the elements from the generator matrix would result in a different order than generating the elements from the generator polynomial. This is an unwanted effect, and therefore <code class="code">StandardFormCode</code> just returns a copy of <var class="Arg">C</var> for cyclic codes.</p>


<table class="example">
<tr><td><pre>
gap&gt; G := GeneratorMatCode( Z(2) * [ [0,1,1,0], [0,1,0,1], [0,0,1,1] ], 
          "random form code", GF(2) );
a linear [4,2,1..2]1..2 random form code over GF(2)
gap&gt; Codeword( GeneratorMat( G ) );
[ [ 0 1 0 1 ], [ 0 0 1 1 ] ]
gap&gt; Codeword( GeneratorMat( StandardFormCode( G ) ) );
[ [ 1 0 0 1 ], [ 0 1 0 1 ] ] 
</pre></td></tr></table>

<p><a id="X7EF49A257D6DB53B" name="X7EF49A257D6DB53B"></a></p>

<h5>6.1-20 PiecewiseConstantCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PiecewiseConstantCode</code>( <var class="Arg">part, wts[, F]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">PiecewiseConstantCode</code> returns a code with length n = sum n_i, where <var class="Arg">part</var>=[ n_1, dots, n_k ]. <var class="Arg">wts</var> is a list of <var class="Arg">constraints</var> w=(w_1,...,w_k), each of length k, where 0 &lt;= w_i &lt;= n_i. The default field is GF(2).</p>

<p>A constraint is a list of integers, and a word c = ( c_1, dots, c_k ) (according to <var class="Arg">part</var>, i.e., each c_i is a subword of length n_i) is in the resulting code if and only if, for some constraint w in <var class="Arg">wts</var>, |c_i| = w_i for all 1 &lt;= i &lt;= k, where | ...| denotes the Hamming weight.</p>

<p>An example might make things clearer:</p>


<table class="example">
<tr><td><pre>
gap&gt; PiecewiseConstantCode( [ 2, 3 ],
     [ [ 0, 0 ], [ 0, 3 ], [ 1, 0 ], [ 2, 2 ] ],GF(2) );
the C code programs are compiled, so using Leon's binary....
the C code programs are compiled, so using Leon's binary....
the C code programs are compiled, so using Leon's binary....
the C code programs are compiled, so using Leon's binary....
a (5,7,1..5)1..5 piecewise constant code over GF(2)
gap&gt; AsSSortedList(last);
[ [ 0 0 0 0 0 ], [ 0 0 1 1 1 ], [ 0 1 0 0 0 ], [ 1 0 0 0 0 ], 
  [ 1 1 0 1 1 ], [ 1 1 1 0 1 ], [ 1 1 1 1 0 ] ]
gap&gt;

</pre></td></tr></table>

<p>The first constraint is satisfied by codeword 1, the second by codeword 2, the third by codewords 3 and 4, and the fourth by codewords 5, 6 and 7.</p>

<p><a id="X7964BF0081CC8352" name="X7964BF0081CC8352"></a></p>

<h4>6.2 <span class="Heading">
Functions that Generate a New Code from Two or More Given Codes
</span></h4>

<p><a id="X79E00D3A8367D65A" name="X79E00D3A8367D65A"></a></p>

<h5>6.2-1 DirectSumCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DirectSumCode</code>( <var class="Arg">C1, C2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">DirectSumCode</code> returns the direct sum of codes <var class="Arg">C1</var> and <var class="Arg">C2</var>. The direct sum code consists of every codeword of <var class="Arg">C1</var> concatenated by every codeword of <var class="Arg">C2</var>. Therefore, if <var class="Arg">Ci</var> was a (n_i,M_i,d_i) code, the result is a (n_1+n_2,M_1*M_2,min(d_1,d_2)) code.</p>

<p>If both <var class="Arg">C1</var> and <var class="Arg">C2</var> are linear codes, the result is also a linear code. If one of them is non-linear, the direct sum is non-linear too. In general, a direct sum code is not cyclic.</p>

<p>Performing a direct sum can also be done by adding two codes (see Section <a href="chap4.html#X832DA51986A3882C"><b>4.2</b></a>). Another often used method is the `u, u+v'-construction, described in <code class="func">UUVCode</code> (<a href="chap6.html#X86E9D6DE7F1A07E6"><b>6.2-2</b></a>).</p>


<table class="example">
<tr><td><pre>
gap&gt; C1 := ElementsCode( [ [1,0], [4,5] ], GF(7) );;
gap&gt; C2 := ElementsCode( [ [0,0,0], [3,3,3] ], GF(7) );;
gap&gt; D := DirectSumCode(C1, C2);;
gap&gt; AsSSortedList(D);
[ [ 1 0 0 0 0 ], [ 1 0 3 3 3 ], [ 4 5 0 0 0 ], [ 4 5 3 3 3 ] ]
gap&gt; D = C1 + C2;   # addition = direct sum
true 
</pre></td></tr></table>

<p><a id="X86E9D6DE7F1A07E6" name="X86E9D6DE7F1A07E6"></a></p>

<h5>6.2-2 UUVCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UUVCode</code>( <var class="Arg">C1, C2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">UUVCode</code> returns the so-called (u|u+v) construction applied to <var class="Arg">C1</var> and <var class="Arg">C2</var>. The resulting code consists of every codeword u of <var class="Arg">C1</var> concatenated by the sum of u and every codeword v of <var class="Arg">C2</var>. If <var class="Arg">C1</var> and <var class="Arg">C2</var> have different word lengths, sufficient zeros are added to the shorter code to make this sum possible. If <var class="Arg">Ci</var> is a (n_i,M_i,d_i) code, the result is an (n_1+max(n_1,n_2),M_1* M_2,min(2* d_1,d_2)) code.</p>

<p>If both <var class="Arg">C1</var> and <var class="Arg">C2</var> are linear codes, the result is also a linear code. If one of them is non-linear, the UUV sum is non-linear too. In general, a UUV sum code is not cyclic.</p>

<p>The function <code class="code">DirectSumCode</code> returns another sum of codes (see <code class="func">DirectSumCode</code> (<a href="chap6.html#X79E00D3A8367D65A"><b>6.2-1</b></a>)).</p>


<table class="example">
<tr><td><pre>
gap&gt; C1 := EvenWeightSubcode(WholeSpaceCode(4, GF(2)));
a cyclic [4,3,2]1 even weight subcode
gap&gt; C2 := RepetitionCode(4, GF(2));
a cyclic [4,1,4]2 repetition code over GF(2)
gap&gt; R := UUVCode(C1, C2);
a linear [8,4,4]2 U U+V construction code
gap&gt; R = ReedMullerCode(1,3);
true 
</pre></td></tr></table>

<p><a id="X7BFBBA5784C293C1" name="X7BFBBA5784C293C1"></a></p>

<h5>6.2-3 DirectProductCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DirectProductCode</code>( <var class="Arg">C1, C2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">DirectProductCode</code> returns the direct product of codes <var class="Arg">C1</var> and <var class="Arg">C2</var>. Both must be linear codes. Suppose <var class="Arg">Ci</var> has generator matrix G_i. The direct product of <var class="Arg">C1</var> and <var class="Arg">C2</var> then has the Kronecker product of G_1 and G_2 as the generator matrix (see the GAP command <code class="code">KroneckerProduct</code>).</p>

<p>If <var class="Arg">Ci</var> is a [n_i, k_i, d_i] code, the direct product then is an [n_1* n_2,k_1* k_2,d_1* d_2] code.</p>


<table class="example">
<tr><td><pre>
gap&gt; L1 := LexiCode(10, 4, GF(2));
a linear [10,5,4]2..4 lexicode over GF(2)
gap&gt; L2 := LexiCode(8, 3, GF(2));
a linear [8,4,3]2..3 lexicode over GF(2)
gap&gt; D := DirectProductCode(L1, L2);
a linear [80,20,12]20..45 direct product code 
</pre></td></tr></table>

<p><a id="X78F0B1BC81FB109C" name="X78F0B1BC81FB109C"></a></p>

<h5>6.2-4 IntersectionCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IntersectionCode</code>( <var class="Arg">C1, C2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">IntersectionCode</code> returns the intersection of codes <var class="Arg">C1</var> and <var class="Arg">C2</var>. This code consists of all codewords that are both in <var class="Arg">C1</var> and <var class="Arg">C2</var>. If both codes are linear, the result is also linear. If both are cyclic, the result is also cyclic.</p>


<table class="example">
<tr><td><pre>
gap&gt; C := CyclicCodes(7, GF(2));
[ a cyclic [7,7,1]0 enumerated code over GF(2),
  a cyclic [7,6,1..2]1 enumerated code over GF(2),
  a cyclic [7,3,1..4]2..3 enumerated code over GF(2),
  a cyclic [7,0,7]7 enumerated code over GF(2),
  a cyclic [7,3,1..4]2..3 enumerated code over GF(2),
  a cyclic [7,4,1..3]1 enumerated code over GF(2),
  a cyclic [7,1,7]3 enumerated code over GF(2),
  a cyclic [7,4,1..3]1 enumerated code over GF(2) ]
gap&gt; IntersectionCode(C[6], C[8]) = C[7];
true 
</pre></td></tr></table>

<p>The <em>hull</em> of a linear code is the intersection of the code with its dual code. In other words, the hull of C is <code class="code">IntersectionCode(C, DualCode(C))</code>.</p>

<p><a id="X8228A1F57A29B8F4" name="X8228A1F57A29B8F4"></a></p>

<h5>6.2-5 UnionCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UnionCode</code>( <var class="Arg">C1, C2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">UnionCode</code> returns the union of codes <var class="Arg">C1</var> and <var class="Arg">C2</var>. This code consists of the union of all codewords of <var class="Arg">C1</var> and <var class="Arg">C2</var> and all linear combinations. Therefore this function works only for linear codes. The function <code class="code">AddedElementsCode</code> can be used for non-linear codes, or if the resulting code should not include linear combinations. See <code class="func">AddedElementsCode</code> (<a href="chap6.html#X784E1255874FCA8A"><b>6.1-8</b></a>). If both arguments are cyclic, the result is also cyclic.</p>


<table class="example">
<tr><td><pre>
gap&gt; G := GeneratorMatCode([[1,0,1],[0,1,1]]*Z(2)^0, GF(2));
a linear [3,2,1..2]1 code defined by generator matrix over GF(2)
gap&gt; H := GeneratorMatCode([[1,1,1]]*Z(2)^0, GF(2));
a linear [3,1,3]1 code defined by generator matrix over GF(2)
gap&gt; U := UnionCode(G, H);
a linear [3,3,1]0 union code
gap&gt; c := Codeword("010");; c in G;
false
gap&gt; c in H;
false
gap&gt; c in U;
true 
</pre></td></tr></table>

<p><a id="X7A85F8AF8154D387" name="X7A85F8AF8154D387"></a></p>

<h5>6.2-6 ExtendedDirectSumCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ExtendedDirectSumCode</code>( <var class="Arg">L, B, m</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>The extended direct sum construction is described in section V of Graham and Sloane <a href="chapBib.html#biBGS85">[GS85]</a>. The resulting code consists of <var class="Arg">m</var> copies of <var class="Arg">L</var>, extended by repeating the codewords of <var class="Arg">B</var> <var class="Arg">m</var> times.</p>

<p>Suppose <var class="Arg">L</var> is an [n_L, k_L]r_L code, and <var class="Arg">B</var> is an [n_L, k_B]r_B code (non-linear codes are also permitted). The length of <var class="Arg">B</var> must be equal to the length of <var class="Arg">L</var>. The length of the new code is n = m n_L, the dimension (in the case of linear codes) is k &lt;= m k_L + k_B, and the covering radius is r &lt;= lfloor m Psi( L, B ) rfloor, with</p>

<p class="pcenter">
\Psi( L, B ) = \max_{u \in F_2^{n_L}} \frac{1}{2^{k_B}}
               \sum_{v \in B} {\rm d}( L, v + u ).
</p>

<p>However, this computation will not be executed, because it may be too time consuming for large codes.</p>

<p>If L subseteq B, and L and B are linear codes, the last copy of <var class="Arg">L</var> is omitted. In this case the dimension is k = m k_L + (k_B - k_L).</p>


<table class="example">
<tr><td><pre>
gap&gt; c := HammingCode( 3, GF(2) );
a linear [7,4,3]1 Hamming (3,2) code over GF(2)
gap&gt; d := WholeSpaceCode( 7, GF(2) );
a cyclic [7,7,1]0 whole space code over GF(2)
gap&gt; e := ExtendedDirectSumCode( c, d, 3 );
a linear [21,15,1..3]2 3-fold extended direct sum code
</pre></td></tr></table>

<p><a id="X7E17107686A845DB" name="X7E17107686A845DB"></a></p>

<h5>6.2-7 AmalgamatedDirectSumCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AmalgamatedDirectSumCode</code>( <var class="Arg">c1, c2[, check]</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">AmalgamatedDirectSumCode</code> returns the amalgamated direct sum of the codes <var class="Arg">c1</var> and <var class="Arg">c2</var>. The amalgamated direct sum code consists of all codewords of the form (u | 0 | v) if (u | 0) in c_1 and (0 | v) in c_2 and all codewords of the form (u | 1 | v) if (u | 1) in c_1 and (1 | v) in c_2. The result is a code with length n = n_1 + n_2 - 1 and size M &lt;= M_1 * M_2 / 2.</p>

<p>If both codes are linear, they will first be standardized, with information symbols in the last and first coordinates of the first and second code, respectively.</p>

<p>If <var class="Arg">c1</var> is a normal code (see <code class="func">IsNormalCode</code> (<a href="chap7.html#X80283A2F7C8101BD"><b>7.4-5</b></a>)) with the last coordinate acceptable (see <code class="func">IsCoordinateAcceptable</code> (<a href="chap7.html#X7D24F8BF7F9A7BF1"><b>7.4-3</b></a>)), and <var class="Arg">c2</var> is a normal code with the first coordinate acceptable, then the covering radius of the new code is r &lt;= r_1 + r_2. However, checking whether a code is normal or not is a lot of work, and almost all codes seem to be normal. Therefore, an option <var class="Arg">check</var> can be supplied. If <var class="Arg">check</var> is true, then the codes will be checked for normality. If <var class="Arg">check</var> is false or omitted, then the codes will not be checked. In this case it is assumed that they are normal. Acceptability of the last and first coordinate of the first and second code, respectively, is in the last case also assumed to be done by the user.</p>


<table class="example">
<tr><td><pre>
gap&gt; c := HammingCode( 3, GF(2) );
a linear [7,4,3]1 Hamming (3,2) code over GF(2)
gap&gt; d := ReedMullerCode( 1, 4 );
a linear [16,5,8]6 Reed-Muller (1,4) code over GF(2)
gap&gt; e := DirectSumCode( c, d );
a linear [23,9,3]7 direct sum code
gap&gt; f := AmalgamatedDirectSumCode( c, d );;
gap&gt; MinimumDistance( f );;
gap&gt; CoveringRadius( f );; 
gap&gt; f;
a linear [22,8,3]7 amalgamated direct sum code
</pre></td></tr></table>

<p><a id="X7D8981AF7DFE9814" name="X7D8981AF7DFE9814"></a></p>

<h5>6.2-8 BlockwiseDirectSumCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; BlockwiseDirectSumCode</code>( <var class="Arg">C1, L1, C2, L2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">BlockwiseDirectSumCode</code> returns a subcode of the direct sum of <var class="Arg">C1</var> and <var class="Arg">C2</var>. The fields of <var class="Arg">C1</var> and <var class="Arg">C2</var> must be same. The lists <var class="Arg">L1</var> and <var class="Arg">L2</var> are two equally long with elements from the ambient vector spaces of <var class="Arg">C1</var> and <var class="Arg">C2</var>, respectively, <em>or</em> <var class="Arg">L1</var> and <var class="Arg">L2</var> are two equally long lists containing codes. The union of the codes in <var class="Arg">L1</var> and <var class="Arg">L2</var> must be <var class="Arg">C1</var> and <var class="Arg">C2</var>, respectively.</p>

<p>In the first case, the blockwise direct sum code is defined as</p>

<p class="pcenter">
bds = \bigcup_{1 \leq i \leq \ell} ( C_1 + (L_1)_i ) \oplus ( C_2 + (L_2)_i ),
</p>

<p>where ell is the length of <var class="Arg">L1</var> and <var class="Arg">L2</var>, and oplus is the direct sum.</p>

<p>In the second case, it is defined as</p>

<p class="pcenter">
bds = \bigcup_{1 \leq i \leq \ell} ( (L_1)_i \oplus (L_2)_i ).
</p>

<p>The length of the new code is n = n_1 + n_2.</p>


<table class="example">
<tr><td><pre>
gap&gt; C1 := HammingCode( 3, GF(2) );;
gap&gt; C2 := EvenWeightSubcode( WholeSpaceCode( 6, GF(2) ) );;
gap&gt; BlockwiseDirectSumCode( C1, [[ 0,0,0,0,0,0,0 ],[ 1,0,1,0,1,0,0 ]],
&gt; C2, [[ 0,0,0,0,0,0 ],[ 1,0,1,0,1,0 ]] );
a (13,1024,1..13)1..2 blockwise direct sum code
</pre></td></tr></table>

<p><a id="X7C37D467791CE99B" name="X7C37D467791CE99B"></a></p>

<h5>6.2-9 ConstructionXCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ConstructionXCode</code>( <var class="Arg">C, A</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Consider a list of j linear codes of the same length N over the same field F, C = { C_1, C_2, ..., C_j }, where the parameter of the ith code is C_i = [N, K_i, D_i] and C_j subset C_j-1 subset ... subset C_2 subset C_1. Consider a list of j-1 auxiliary linear codes of the same field F, A = { A_1, A_2, ..., A_j-1 } where the parameter of the ith code A_i is [n_i, k_i=(K_i-K_i+1), d_i], an [n, K_1, d] linear code over field F can be constructed where n = N + sum_i=1^j-1 n_i, and d = min{ D_j, D_j-1 + d_j-1, D_j-2 + d_j-2 + d_j-1, ..., D_1 + sum_i=1^j-1 d_i}.</p>

<p>For more information on Construction X, refer to <a href="chapBib.html#biBSloane72">[SRC72]</a>.</p>


<table class="example">
<tr><td><pre>
gap&gt; C1 := BCHCode(127, 43);
a cyclic [127,29,43]31..59 BCH code, delta=43, b=1 over GF(2)
gap&gt; C2 := BCHCode(127, 47);
a cyclic [127,22,47..51]36..63 BCH code, delta=47, b=1 over GF(2)
gap&gt; C3 := BCHCode(127, 55);
a cyclic [127,15,55]41..62 BCH code, delta=55, b=1 over GF(2)
gap&gt; G1 := ShallowCopy( GeneratorMat(C2) );;
gap&gt; Append(G1, [ GeneratorMat(C1)[23] ]);;
gap&gt; C1 := GeneratorMatCode(G1, GF(2));
a linear [127,23,1..43]35..63 code defined by generator matrix over GF(2)
gap&gt; MinimumDistance(C1);
43
gap&gt; C := [ C1, C2, C3 ];
[ a linear [127,23,43]35..63 code defined by generator matrix over GF(2), 
  a cyclic [127,22,47..51]36..63 BCH code, delta=47, b=1 over GF(2), 
  a cyclic [127,15,55]41..62 BCH code, delta=55, b=1 over GF(2) ]
gap&gt; IsSubset(C[1], C[2]);
true
gap&gt; IsSubset(C[2], C[3]);
true
gap&gt; A := [ RepetitionCode(4, GF(2)), EvenWeightSubcode( QRCode(17, GF(2)) ) ];
[ a cyclic [4,1,4]2 repetition code over GF(2), a cyclic [17,8,6]3..6 even weight subcode ]
gap&gt; CX := ConstructionXCode(C, A);
a linear [148,23,53]43..74 Construction X code
gap&gt; History(CX);
[ "a linear [148,23,53]43..74 Construction X code of", 
  "Base codes: [ a cyclic [127,15,55]41..62 BCH code, delta=55, b=1 over GF(2)\
, a cyclic [127,22,47..51]36..63 BCH code, delta=47, b=1 over GF(2), a linear \
[127,23,43]35..63 code defined by generator matrix over GF(2) ]", 
  "Auxiliary codes: [ a cyclic [4,1,4]2 repetition code over GF(2), a cyclic [\
17,8,6]3..6 even weight subcode ]" ]
</pre></td></tr></table>

<p><a id="X7B50943B8014134F" name="X7B50943B8014134F"></a></p>

<h5>6.2-10 ConstructionXXCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ConstructionXXCode</code>( <var class="Arg">C1, C2, C3, A1, A2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Consider a set of linear codes over field F of the same length, n, C_1=[n, k_1, d_1], C_2=[n, k_2, d_2] and C_3=[n, k_3, d_3] such that C_2 subset C_1, C_3 subset C_1 and C_4 = C_2 cap C_3. Given two auxiliary codes A_1=[n_1, k_1-k_2, e_1] and A_2=[n_2, k_1-k_3, e_2] over the same field F, there exists an [n+n_1+n_2, k_1, d] linear code C_XX over field F, where d = min{d_4, d_3 + e_1, d_2 + e_2, d_1 + e_1 + e_2}.</p>

<p>The codewords of C_XX can be partitioned into three sections ( v | a | b ) where v has length n, a has length n_1 and b has length n_2. A codeword from Construction XX takes the following form:</p>


<ul>
<li><p>( v | 0 | 0 ) if v in C_4</p>

</li>
<li><p>( v | a_1 | 0 ) if v in C_3 backslash C_4</p>

</li>
<li><p>( v | 0 | a_2 ) if v in C_2 backslash C_4</p>

</li>
<li><p>( v | a_1 | a_2 ) otherwise</p>

</li>
</ul>
<p>For more information on Construction XX, refer to <a href="chapBib.html#biBAlltop84">[All84]</a>.</p>


<table class="example">
<tr><td><pre>
gap&gt; a := PrimitiveRoot(GF(32));
Z(2^5)
gap&gt; f0 := MinimalPolynomial( GF(2), a^0 );
x_1+Z(2)^0
gap&gt; f1 := MinimalPolynomial( GF(2), a^1 );
x_1^5+x_1^2+Z(2)^0
gap&gt; f5 := MinimalPolynomial( GF(2), a^5 );
x_1^5+x_1^4+x_1^2+x_1+Z(2)^0
gap&gt; C2 := CheckPolCode( f0 * f1, 31, GF(2) );; MinimumDistance(C2);; Display(C2);
a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)
gap&gt; C3 := CheckPolCode( f0 * f5, 31, GF(2) );; MinimumDistance(C3);; Display(C3);
a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)
gap&gt; C1 := UnionCode(C2, C3);; MinimumDistance(C1);; Display(C1);
a linear [31,11,11]7..11 union code of
U: a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)
V: a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)
gap&gt; A1 := BestKnownLinearCode( 10, 5, GF(2) );
a linear [10,5,4]2..4 shortened code
gap&gt; A2 := DualCode( RepetitionCode(6, GF(2)) );
a cyclic [6,5,2]1 dual code
gap&gt; CXX:= ConstructionXXCode(C1, C2, C3, A1, A2 );
a linear [47,11,15..17]13..23 Construction XX code
gap&gt; MinimumDistance(CXX);
17
gap&gt; History(CXX);        
[ "a linear [47,11,17]13..23 Construction XX code of", 
  "C1: a cyclic [31,11,11]7..11 union code", 
  "C2: a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)", 
  "C3: a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)", 
  "A1: a linear [10,5,4]2..4 shortened code", 
  "A2: a cyclic [6,5,2]1 dual code" ]
</pre></td></tr></table>

<p><a id="X790C614985BFAE16" name="X790C614985BFAE16"></a></p>

<h5>6.2-11 BZCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; BZCode</code>( <var class="Arg">O, I</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Given a set of outer codes of the same length O_i = [N, K_i, D_i] over GF(q^e_i), where i=1,2,...,t and a set of inner codes of the same length I_i = [n, k_i, d_i] over GF(q), <code class="code">BZCode</code> returns a Blokh-Zyablov multilevel concatenated code with parameter [ n x N, sum_i=1^t e_i x K_i, min_i=1,...,t{d_i x D_i} ] over GF(q).</p>

<p>Note that the set of inner codes must satisfy chain condition, i.e. I_1 = [n, k_1, d_1] subset I_2=[n, k_2, d_2] subset ... subset I_t=[n, k_t, d_t] where 0=k_0 &lt; k_1 &lt; k_2 &lt; ... &lt; k_t. The dimension of the inner codes must satisfy the condition e_i = k_i - k_i-1, where GF(q^e_i) is the field of the ith outer code.</p>

<p>For more information on Blokh-Zyablov multilevel concatenated code, refer to <a href="chapBib.html#biBBrouwer98">[Bro98]</a>.</p>

<p><a id="X820327D6854A50B5" name="X820327D6854A50B5"></a></p>

<h5>6.2-12 BZCodeNC</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; BZCodeNC</code>( <var class="Arg">O, I</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This function is the same as <code class="code">BZCode</code>, except this version is faster as it does not estimate the covering radius of the code. Users are encouraged to use this version unless you are working on very small codes.</p>


<table class="example">
<tr><td><pre>
gap&gt; #
gap&gt; # Binary code
gap&gt; #
gap&gt; O := [ CyclicMDSCode(2,3,7), BestKnownLinearCode(9,5,GF(2)), CyclicMDSCode(2,3,4) ];
[ a cyclic [9,7,3]1 MDS code over GF(8), a linear [9,5,3]2..3 shortened code, 
  a cyclic [9,4,6]4..5 MDS code over GF(8) ]
gap&gt; A := ExtendedCode( HammingCode(3,GF(2)) );;
gap&gt; I := [ SubCode(A), A, DualCode( RepetitionCode(8, GF(2)) ) ];
[ a linear [8,3,4]3..4 subcode, a linear [8,4,4]2 extended code, a cyclic [8,7,2]1 dual code ]
gap&gt; C := BZCodeNC(O, I);
a linear [72,38,12]0..72 Blokh Zyablov concatenated code
gap&gt; #
gap&gt; # Non binary code
gap&gt; #
gap&gt; O2 := ExtendedCode(GoppaCode(ConwayPolynomial(5,2), Elements(GF(5))));;
gap&gt; O3 := ExtendedCode(GoppaCode(ConwayPolynomial(5,3), Elements(GF(5))));;
gap&gt; O1 := DualCode( O3 );;
gap&gt; MinimumDistance(O1);; MinimumDistance(O2);; MinimumDistance(O3);;
gap&gt; Cy := CyclicCodes(5, GF(5));;
gap&gt; for i in [4, 5] do; MinimumDistance(Cy[i]);; od;
gap&gt; O  := [ O1, O2, O3 ];
[ a linear [6,4,3]1 dual code, a linear [6,3,4]2..3 extended code,
  a linear [6,2,5]3..4 extended code ]
gap&gt; I  := [ Cy[5], Cy[4], Cy[3] ];
[ a cyclic [5,1,5]3..4 enumerated code over GF(5),
  a cyclic [5,2,4]2..3 enumerated code over GF(5),
  a cyclic [5,3,1..3]2 enumerated code over GF(5) ]
gap&gt; C  := BZCodeNC( O, I );
a linear [30,9,5..15]0..30 Blokh Zyablov concatenated code
gap&gt; MinimumDistance(C);
15
gap&gt; History(C);
[ "a linear [30,9,15]0..30 Blokh Zyablov concatenated code of",
  "Inner codes: [ a cyclic [5,1,5]3..4 enumerated code over GF(5), a cyclic [5\
,2,4]2..3 enumerated code over GF(5), a cyclic [5,3,1..3]2 enumerated code ove\
r GF(5) ]",
  "Outer codes: [ a linear [6,4,3]1 dual code, a linear [6,3,4]2..3 extended c\
ode, a linear [6,2,5]3..4 extended code ]" ]
</pre></td></tr></table>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap5.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chap7.html">Next Chapter</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
