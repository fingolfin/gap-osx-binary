<Chapter Label="Quickstart"><Heading>Quickstart</Heading>

This chapter is intended for those who would like to get started with
<Package>QPA</Package> right away by playing with a few examples.  We
assume that the user is familiar with <Package>GAP</Package> syntax,
for instance the different ways to display various
<Package>GAP</Package> objects: <C>View</C>, <C>Print</C> and
<C>Display</C>.  These features are all implemented for the objects
defined in <Package>QPA</Package>, and by using <C>Display</C> on an
object, you will get a complete description of it.<P/>

The following examples show how to create the most fundamental
algebraic structures featured in <Package>QPA</Package>, namely
quivers, path algebras and quotients of path algebras, modules and
module homomorphisms. Sometimes, there is more than one way of
constructing such objects. See their respective chapter in the
documentation for more on this. The code from the examples can be
found in the <C>examples/</C> directory of the distribution of
<Package>QPA</Package>.<P/>

<!-- Example 9 from GBNP: -->
<Section Label="Example 1"><Heading>Example 1 -- quivers, path
algebras and quotients of path algebras</Heading>

We construct a quiver <Math>Q</Math>, i.e. a finite directed graph,
with one vertex and two loops:

<Example><![CDATA[
gap> Q := Quiver( 1, [ [1,1,"a"], [1,1,"b"] ] );
<quiver with 1 vertices and 2 arrows>
gap> Display(Q);
Quiver( ["v1"], [["v1","v1","a"],["v1","v1","b"]] )
]]></Example>

When displaying <Math>Q</Math>, we observe that the vertex has been
named <C>v1</C>, and that this name is used when describing the
arrows. (The "Display" style of viewing a quiver can also be used in
construction, i.e., we could have written <C>Q := Quiver( ["v1"],
[["v1","v1","a"],["v1","v1","b"]] )</C> to get the same object.)<P/>

If we want to know the number and names of the vertices and arrows,
without getting the structure of <Math>Q</Math>, we can request this
information as shown below. We can also access the vertices and arrows
directly.

<Example> <![CDATA[
gap> VerticesOfQuiver(Q);
[ v1 ]
gap> ArrowsOfQuiver(Q);
[ a, b ]
gap> Q.a;
a
]]></Example>

The next step is to create the path algebra <Math>kQ</Math> from
<Math>Q</Math>, where <Math>k</Math> is the rational numbers (in
general, one can chose any field implemented in
<Package>GAP</Package>).

<Example> <![CDATA[
gap> kQ := PathAlgebra(Rationals, Q);
<Rationals[<quiver with 1 vertices and 2 arrows>]>
gap> Display(kQ);
<Path algebra of the quiver <quiver with 1 vertices and 2 arrows> 
over the field Rationals>
]]></Example>

We know that this algebra has three generators, with the vertex
<C>v_1</C> as the identity. This can be verified by
<Package>QPA</Package>. For convenience, we introduce new variables
<C>v1</C>, <C>a</C> and <C>b</C> to get easier access to the
generators.

<Example><![CDATA[
gap> AssignGeneratorVariables(kQ);
#I  Assigned the global variables [ v1, a, b ]
gap> v1; a; b;
(1)*v1
(1)*a
(1)*b
gap> id := One(kQ);
(1)*v1
gap> v1 = id;
true
]]></Example>

Now, we want to construct a finite dimensional algebra, by dividing
out some ideal. The generators of the ideal (the relations) are given
in terms of paths, and it is important to know the convention of
writing paths used in <Package>QPA</Package>. If we first go the arrow
<Math>a</Math> and then the arrow <Math>b</Math>, the path is written
as <Math>a*b</Math>. <P/>

Say that we want our ideal to be generated by the relations
<C>\{a^2, a*b - b*a, b^2\}</C>. Then we make a list <C>relations</C> consisting
of these relations and to construct the quotient we say: <C>A := kQ/relations;</C> 
on the command line in <Package>GAP</Package>. 

<Example><![CDATA[
gap> relations := [a^2,a*b-b*a, b*b];
[ (1)*a^2, (1)*a*b+(-1)*b*a, (1)*b^2 ]
gap> A := kQ/relations;
<Rationals[<quiver with 1 vertices and 2 arrows>]/<two-sided ideal in 
<Rationals[<quiver with 1 vertices and 2 arrows>]>, (3 generators)>>
]]></Example>
See <Ref Sect="qpa:Quotients_of_path_algebras"/> for further remarks on 
constructing quotients of path algebras. 
</Section>

<Section><Heading>Example 2 -- Introducing modules</Heading>

In representation theory, there are several conventions for expressing
modules of path algebras, and again it is useful to comment on the
convention used in <Package>QPA</Package>. A module (or
representation) of an algebra <Math>A = kQ/I</Math> is, briefly
explained, a picture of <Math>Q</Math> where the vertices are finite
dimensional <Math>k</Math>-vectorspaces, and the arrows are linear
transformations between the vector spaces respecting the relations of
<Math>I</Math>.  The modules are <E>right</E> modules, and a linear
transformation from <Math>k^n</Math> to <Math>k^m</Math> is
represented by a <Math>n \times m</Math>-matrix.<P/>

There are several ways of constructing modules in
<Math>QPA</Math>. First, we will explore some modules which
<Math>QPA</Math> gives us for free, namely the indecomposable
projectives. We start by constructing a new algebra. The underlying
quiver has three vertices and three arrows and looks like an
<Math>A_3</Math> quiver with both arrows pointing to the right, and
one additional loop in the final vertex. The only relation is to go
this loop twice.

<Example><![CDATA[
gap> Q := Quiver( 3, [ [1,2,"a"], [2,3,"b"], [3,3,"c"] ]);
<quiver with 3 vertices and 3 arrows>
gap> kQ := PathAlgebra(Rationals, Q);
<Rationals[<quiver with 3 vertices and 3 arrows>]>
gap> relations := [kQ.c*kQ.c];
[ (1)*c^2 ]
gap> A := kQ/relations;
<Rationals[<quiver with 3 vertices and 3 arrows>]/
<two-sided ideal in <Rationals[<quiver with 3 vertices and 3 arrows>]>, 
  (1 generators)>>
]]></Example>

The indecomposable projectives are easily created with one command. We
use <C>Display</C> to explore the modules.

<Example><![CDATA[
gap> projectives := IndecProjectiveModules(A);
[ <[ 1, 1, 2 ]>, <[ 0, 1, 2 ]>, <[ 0, 0, 2 ]> ]
gap> proj1 := projectives[1];
<[ 1, 1, 2 ]>
gap> Display(proj1);
<Module over <Rationals[<quiver with 3 vertices and 3 arrows>]/
<two-sided ideal in <Rationals[<quiver with 3 vertices and 3 arrows>]>, 
  (1 generators)>> with dimension vector 
[ 1, 1, 2 ]> and linear maps given by
for arrow a:
[ [  1 ] ]
for arrow b:
[ [  1,  0 ] ]
for arrow c:
[ [  0,  1 ],
  [  0,  0 ] ]
]]></Example>

If we, for some reason, want to use the maps of this module, we can
get the matrices directly by using the command
<C>MatricesOfPathAlgebraModule(proj1)</C>:

<Example><![CDATA[
gap> M := MatricesOfPathAlgebraModule(proj1);
[ [ [ 1 ] ], [ [ 1, 0 ] ], [ [ 0, 1 ], [ 0, 0 ] ] ]
gap> M[1];
[ [ 1 ] ]
]]></Example>

Naturally, the indecomposable injective modules are just as easily
constructed, and so are the simple modules.

<Example><![CDATA[
gap> injectives := IndecInjectiveModules(A);
[ <[ 1, 0, 0 ]>, <[ 1, 1, 0 ]>, <[ 2, 2, 2 ]> ]
gap> simples := SimpleModules(A);
[ <[ 1, 0, 0 ]>, <[ 0, 1, 0 ]>, <[ 0, 0, 1 ]> ]
]]></Example>

We know for a fact that the simple module in vertex 1 and the
indecomposable injective module in vertex 1 coincide. Let us look at
this relationship in <Package>QPA</Package>:

<Example><![CDATA[
gap> s1 := simples[1];
<[ 1, 0, 0 ]>
gap> inj1 := injectives[1];
<[ 1, 0, 0 ]>
gap> IsIdenticalObj(s1,inj1);
false
gap> s1 = inj1;
true
gap> IsomorphicModules(s1,inj1);
true
]]></Example>

We observe that <Package>QPA</Package> recognizes the modules
as "the same" (that is, isomorphic); however, they are <E>not</E>
the same instance and hence the simplest test for equality fails. This
is important to bear in mind -- objects which are isomorphic and
regarded as the same in the "real world", are not necessarily the same
in <Package>GAP</Package>.

</Section>

<Section><Heading>Example 3 -- Constructing modules and module homomorphisms</Heading>

Assume we want to construct the following <Math>A</Math>-module
<Math>M</Math>, where <Math>A</Math> is the same algebra as in the
previous example
<M>
\xymatrix{0\ar[r]^0 &amp; &QQ;\ar[r]^1 &amp; &QQ; \ar@(ur,dr)^0}
</M>. 
This module is neither indecomposable projective or injective, nor
simple, so we need to do the dirty work ourselves. Usually, the
easiest way to construct a module is to state the dimension vector and
the non-zero maps. Here, there is only one non-zero map, and we write

<Example><![CDATA[
gap> M := RightModuleOverPathAlgebra( A, [0,1,1], [ ["b", [[1]] ] ] );
<[ 0, 1, 1 ]>
]]></Example>

To make sure we got everything right, we can use <C>Display(M)</C> to
view the maps. The most tricky thing is usually to get the correct
numbers of brackets. Here is a slightly bigger example:
<M>
\xymatrix{&QQ;\ar[r]^{\left(\begin{smallmatrix}0 &amp; 0\end{smallmatrix}\right)} &amp; 
&QQ;^2\ar[r]^{\left(\begin{smallmatrix}1 &amp; 0\\ -1 &amp; 0\end{smallmatrix}\right)} &amp; 
&QQ;^2\ar@(ur,dr)^{\left(\begin{smallmatrix}0 &amp; 0\\ 1 &amp; 0\end{smallmatrix}\right)}}
</M>.

<Example><![CDATA[
gap> N := RightModuleOverPathAlgebra( A, [1,2,2], [ ["a",[[1,1]] ], 
   ["b", [[1,0], [-1,0]] ], ["c", [[0,0],[1,0]] ] ] );
<[ 1, 2, 2 ]>
]]></Example>

Now we want to construct a map between the two modules, say <Math>f: M
\rightarrow N</Math>, which is non-zero only in vertex 2. This is done by

<Example><![CDATA[
gap> f := RightModuleHomOverAlgebra(M,N, [ [[0]], [[1,1]], NullMat(1,2,Rationals)]);
<<[ 0, 1, 1 ]> ---> <[ 1, 2, 2 ]>>
gap> Display(f);
<<Module over <Rationals[<quiver with 3 vertices and 3 arrows>]/
<two-sided ideal in <Rationals[<quiver with 3 vertices and 3 arrows>]>, 
  (1 generators)>> with dimension vector 
[ 0, 1, 1 ]> ---> <Module over <Rationals[<quiver with 3 vertices and 3 arrows>]/
<two-sided ideal in <Rationals[<quiver with 3 vertices and 3 arrows>]>, 
  (1 generators)>> with dimension vector [ 1, 2, 2 ]>>
with linear map for vertex number 1:
[ [  0 ] ]
linear map for vertex number 2:
[ [  1,  1 ] ]
linear map for vertex number 3:
[ [  0,  0 ] ]
]]></Example>

Note the two different ways of writing zero maps. Again, we can
retrieve the matrices describing <Math>f</Math>:

<Example><![CDATA[
gap> MatricesOfPathAlgebraMatModuleHomomorphism(f);
[ [ [ 0 ] ], [ [ 1, 1 ] ], [ [ 0, 0 ] ] ]
]]></Example>

</Section>
</Chapter>
