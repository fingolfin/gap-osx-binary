%
\Chapter{Nearrings of transformations on groups}
%

We are going to study transformations on the alternating group on four elements
$A_4$.

*The problem*: Let <T> be the nearring of mappings from $A_4$ to $A_4$
        generated by the single mapping <t> which maps (2,3,4) to (2,4,3),
        (2,4,3) to (1,2)(3,4), (1,2)(3,4) to (1,2,3), (1,2,3) back to (2,3,4)
        and all other elements of $A_4$ to the neutral element (). Then,
        how many mappings are there in <T> that have (1,2,3) as a fixed point?
        If there are only a few we would be interested in a list of all of
        these.
        
*The solution*: \hfill\break
        The first thing to do is create the nearring <T>. So we start with
        the group $A_4$, which can easily be constructed with the command
\beginexample
    gap> A4 := AlternatingGroup( 4 );
    Alt( [ 1 .. 4 ] )
\endexample
        The result is an object which represents the group $A_4$. If we want
        to see its elements we have to ask {\GAP} to make a list of elements
        out of the group.
\beginexample
    gap> AsSortedList( A4 );                                       
    [ (), (2,3,4), (2,4,3), (1,2)(3,4), (1,2,3), (1,2,4), (1,3,2),
     (1,3,4), (1,3)(2,4), (1,4,2), (1,4,3), (1,4)(2,3) ]
\endexample
        Now we create the mapping <t>. We use the function
        `MappingByPositionList' to enter it.
\beginexample
    t := EndoMappingByPositionList( A4, [1,3,4,5,2,1,1,1,1,1,1,1] );
    <mapping: AlternatingGroup( [ 1 .. 4 ] ) -> AlternatingGroup( 
    [ 1 .. 4 ] ) >
\endexample
        For `Mappings' the usual operations `+' and
        `*' can be used to add and multiply them.
\beginexample
    gap> t+t;
    <mapping: AlternatingGroup( [ 1 .. 4 ] ) -> AlternatingGroup( 
    [ 1 .. 4 ] ) >
    gap> last * t;
    <mapping: AlternatingGroup( [ 1 .. 4 ] ) -> AlternatingGroup( 
    [ 1 .. 4 ] ) >
\endexample
        (Recall that `last' stands for the result of the last computation, in
        this case this is `t + t'). 
        Now we can construct the nearring. We use the function
        `TransformationNearRingByGenerators' which asks for the group ($A_4$)
        and a list of generating elements (the list with <t> as the only entry)
        as arguments.
\beginexample
    gap> T := TransformationNearRingByGenerators( A4, [ t ] );;
\endexample
        Nearrings, allthough generated by a single element can become rather
        big. Before we print out all elements we ask for the size of <T>.
\beginexample
    gap> Size( T );
    20736
\endexample
        It seems reasonable not to print all elements. *Note* that they are
        not even computed, yet. All we wanted to know was the size of <T> and
        this can be computed without generating all elements. But, yes, we
        could generate them with `AsList' or `AsSortedList'. At last we want
        to find out how many of these 20736 `GroupTransformations' have (1,2,3)
        as a fixed point. We filter them out, but we use a second semicolon at
        the end to suppress printing, because there might be a lot of them.
        Then we ask for the length of the resulting list <F> of mappings.
\beginexample
    gap> F := Filtered( T, tfm -> Image( tfm, (1,2,3) ) = (1,2,3) );;
    gap> Length( F );
    1728
\endexample
        It seems not to be worth printing the whole list. But we could for
        example choose a random transformation from this list <F> for testing
        purposes.
\beginexample
    gap> Random( F );;
\endexample
        There are of course other properties of the nearring <T>
        which might be interesting. It is clear that a nearring which is
        generated by a single element is not necessarily abelian. <T> is a
        counterexample. As for finding counterexamples, SONATA can be used
        as a research tool.
\beginexample
    gap> IsCommutative( T );
    false
\endexample
        Finally, we try to disprove the conjecture that every transformation
        nearring on an abelian group that is generated by a single element 
        must be commutative.
\beginexample
    gap> g := CyclicGroup(2);;
    gap> m := MapNearRing(g);;
    gap> Filtered( m, n -> not( IsCommutative(                                            
    >        TransformationNearRingByGenerators( g, [n] ) ) ) );
    gap> [ <mapping: Group( [ f1 ] ) -> Group( [ f1 ] ) >, 
           <mapping: Group( [ f1 ] ) -> Group( [ f1 ] ) > ]
    gap> GraphOfMapping(last[1]);
    [ [ <identity> of ..., f1 ], [ f1, <identity> of ... ] ]
\endexample

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% End: 
