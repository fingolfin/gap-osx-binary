%
\Chapter{Nearring ideals}
%

For an introduction to nearring ideals we suggest \cite{Pilz:Nearrings},
\cite{meldrum85:NATLWG}, and \cite{Clay:Nearrings}.

Ideals of nearrings can either be left, right or twosided ideals. However,
all of them are called ideals. Mathematicians tend to use the expression
ideal also for subgroups of the group reduct of the nearring. {\GAP} does
not allow that.

Left, right or twosided ideals in {\GAP} form their own category `IsNRI'.
Whenever a left, right or twosided ideal is constructed it lies in this
category. The objects in this category are what {\GAP} considers as ideals.
We will refer to them as `NRI's.

All the functions in this chapter can be applied to all types of nearrings.

The functions described in this chapter can be found in the source files
`nrid.g?', `idlatt.g?' and `nrconstr.g?'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Construction of nearring ideals}


There are several ways to construct ideals in nearrings.
`NearRingLeftIdealByGenerators', `NearRingRightIdealByGenerators' and
`NearRingIdealByGenerators' can be used to construct (left / right)
ideals generated by a subset of the nearring.
`NearRingLeftIdealBySubgroupNC', `NearRingRightIdealBySubgroupNC' and
`NearRingIdealBySubgroupNC' construct (left / right) ideals from a subgroup
of the group reduct of the nearring which is an ideal. Finally
`NearRingLeftIdeals', `NearRingRightIdeals' and `NearRingIdeals'
compute lists of all (left / right) ideals of a nearring.

\>NearRingIdealByGenerators( <nr>, <gens> )

The function `NearRingIdealByGenerators' takes as arguments a nearring <nr>
and a list <gens> of arbitrarily many elements of <nr>. It returns the
smallest ideal of <nr> containing all elements of <gens>.

\>NearRingLeftIdealByGenerators( <nr>, <gens> )

The function `NearRingLeftIdealByGenerators' takes as arguments a nearring <nr>
and a list <gens> of arbitrarily many elements of <nr>. It returns the
smallest left ideal of <nr> containing all elements of <gens>.

\>NearRingRightIdealByGenerators( <nr>, <gens> )

The function `NearRingRightIdealByGenerators' takes as arguments a nearring
<nr> and a list <gens> of arbitrarily many elements of <nr>. It returns the
smallest right ideal of <nr> containing all elements of <gens>.

\beginexample
    gap> n := LibraryNearRing( GTW8_4, 12 );
    LibraryNearRing(8/4, 12)
    gap> e := AsNearRingElement( n, (1,3)(2,4) );         
    ((1,3)(2,4))
    gap> r := NearRingRightIdealByGenerators( n, [e] );
    < nearring right ideal >
    gap> l := NearRingLeftIdealByGenerators( n, [e] );
    < nearring left ideal >
    gap> i := NearRingIdealByGenerators( n, [e] );
    < nearring ideal >
    gap> r = i;
    true
    gap> l = i;
    false
    gap> l = r;
    false
\endexample

\>NearRingIdealBySubgroupNC( <nr>, <S> )

From a nearring <nr> and a subgroup <S> of the group reduct of <nr>,
`NearRingIdealBySubgroupNC' constructs a ({\GAP}--) ideal of <nr>. It is
assumed (and hence not checked) that <S> is an ideal of <nr>. See Section
"IsSubgroupNearRingLeftIdeal" for information how to check this.

\>NearRingLeftIdealBySubgroupNC( <nr>, <S> )

From a nearring <nr> and a subgroup <S> of the group reduct of <nr>,
`NearRingLeftIdealBySubgroupNC' constructs a ({\GAP}--) left ideal of <nr>. It
is assumed (and hence not checked) that <S> is a left ideal of <nr>. See
Section "IsSubgroupNearRingLeftIdeal" for information how to check this.

\>NearRingRightIdealBySubgroupNC( <nr>, <S> )

From a nearring <nr> and a subgroup <S> of the group reduct of <nr>,
`NearRingRightIdealBySubgroupNC' constructs a ({\GAP}--) right ideal of <nr>.
It is assumed (and hence not checked) that <S> is a right ideal of <nr>.
See Section "IsSubgroupNearRingRightIdeal" for information how to check this.

\beginexample
    gap> a := GroupReduct( n );                                          
    8/4
    gap> nsgps := NormalSubgroups( a );
    [ Group(()), Group([ (1,3)(2,4) ]), 
      Group([ (1,3)(2,4), (1,2)(3,4) ]), Group([ (1,3)(2,4), (2,4) ]), 
      Group([ (1,2,3,4), (1,3)(2,4) ]), 8/4 ]
    gap> l := Filtered( nsgps,                                             
    > s -> IsSubgroupNearRingRightIdeal( n, s ) );                      
    [ Group(()), Group([ (1,3)(2,4), (2,4) ]), 8/4 ]
    gap> l := List( l,      
    > s -> NearRingRightIdealBySubgroupNC( n, s ) );
    [ < nearring right ideal >, < nearring right ideal >, 
      < nearring right ideal > ]
\endexample

\>NearRingIdeals( <nr> )

`NearRingIdeals'  computes all ideals of the nearring <nr>. The return value
is a list of ideals of <nr>

For one-sided ideals the functions

\>NearRingLeftIdeals( <nr> )

and

\>NearRingRightIdeals( <nr> )

can be used.

\beginexample
    gap> NearRingIdeals( n );
    [ < nearring ideal >, < nearring ideal >, < nearring ideal > ]
    gap> NearRingRightIdeals( n );
    [ < nearring right ideal >, < nearring right ideal >, 
      < nearring right ideal > ]
    gap> NearRingLeftIdeals( n );
    [ < nearring left ideal >, < nearring left ideal >, < nearring left ideal >, 
      < nearring left ideal > ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Testing for ideal properties}


\>IsNRI( <obj> )

`IsNRI' returns `true' if the object <obj> is a left ideal, a right ideal or
an ideal of a nearring. (Such an object may be considered as a (one or
twosided) {\GAP} -- nearring ideal.)

\>IsNearRingLeftIdeal( <I> )

The function `IsNearRingLeftIdeal' can be applied to any `NRI'.
It returns `true' if <I> is a left ideal in its parent nearring.

\>IsNearRingRightIdeal( <I> )

The function `IsNearRingRightIdeal' can be applied to any `NRI'.
It returns `true' if <I> is a right ideal in its parent nearring.

\>IsNearRingIdeal( <I> )

The function `IsNearRingIdeal' can be applied to any `NRI'.
It returns `true' if <I> is an ideal in its parent nearring.

\beginexample
    gap> n := LibraryNearRing( GTW6_2, 39 );                      
    LibraryNearRing(6/2, 39)
    gap> e := Enumerator(n)[3];
    ((1,3,2))
    gap> l := NearRingLeftIdealByGenerators( n, [e] );
    < nearring left ideal >
    gap> IsNRI( l );
    true
    gap> IsNearRingLeftIdeal( l );
    true
    gap> IsNearRingRightIdeal( l );
    true
    gap> l;
    < nearring ideal >
\endexample

\>IsSubgroupNearRingLeftIdeal( <nr>, <S> )

Let $(N,+,.)$ be a nearring. A subgroup $S$ of the group $(N,+)$ is a
*left ideal* of $N$ if for all $a$, $b$ in $N$ and  $s$ in $S$:\
$a.(b+s)-a.b$ in $S$. 
`IsSubgroupNearRingLeftIdeal' takes as arguments a nearring <nr> and a subgroup
<S> of the group reduct of <nr> and returns `true' if <S> is a nearring
ideal of <nr> and `false' otherwise.

*Note*, that if `IsSubgroupNearRingLeftIdeal' returns `true' this means that
<S> is a left ideal only in the mathematical sense, not in {\GAP}--sense (it is
a group, not a left ideal). You can use `NearRingLeftIdealBySubgroupNC' (see
Section "NearRingLeftIdealBySubgroupNC") to construct the corresponding left
ideal.

\>IsSubgroupNearRingRightIdeal( <nr>, <S> )

Let $(N,+,.)$ be a nearring. A subgroup $S$ of the group $(N,+)$ is a
*right ideal* of $N$ if $S.N \subseteq S$.
`IsSubgroupNearRingRightIdeal' takes as arguments a nearring <nr> and a
subgroup <S> of the group reduct of <nr> and returns `true' if <S> is a
right ideal of <nr> and `false' otherwise.

*Note*, that if `IsSubgroupNearRingRightIdeal' returns `true' this means that
<S> is a right ideal only in the mathematical sense, not in {\GAP}--sense (it
is a group, not a right ideal). You can use
`NearRingRight\-Ideal\-BySubgroupNC' (see Section
"NearRingRightIdealBySubgroupNC") to construct the corresponding right ideal.

\beginexample
    gap> n := LibraryNearRing( GTW6_2, 39 );                    
    LibraryNearRing(6/2, 39)
    gap> s := Subgroups( GroupReduct( n ) );
    [ Group(()), Group([ (2,3) ]), Group([ (1,3) ]), Group([ (1,2) ]), 
      Group([ (1,3,2) ]), Group([ (1,2,3), (1,2) ]) ]
    gap> List( s, sg -> IsSubgroupNearRingLeftIdeal( n, sg ) );
    [ true, false, false, false, true, true ]
    gap> List( s, sg -> IsSubgroupNearRingRightIdeal( n, sg ) );
    [ true, false, false, false, true, true ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Special ideal properties}


\>IsPrimeNearRingIdeal( <I> )

An ideal $I$ of a nearring $N$ is *prime* if for any two ideals $J$ and $K$
of $N$ whenever $J.K$ is contained in $I$ then at least one of them is
contained in $I$.
`IsPrimeNearRingIdeal' returns `true' if <I> is a prime ideal in its parent
nearring and `false' otherwise.

\beginexample
    gap> n := LibraryNearRingWithOne( GTW27_2, 5 );
    LibraryNearRingWithOne(27/2, 5)
    gap> Filtered( NearRingIdeals( n ), IsPrimeNearRingIdeal );
    [ < nearring ideal of size 9 >, < nearring ideal of size 27 > ]
\endexample

\>IsMaximalNearRingIdeal( <I> )

A proper ideal $I$ of a nearring $N$ is *maximal* if there is no
proper ideal containing $I$ properly.
`IsMaximal\-NearRingIdeal( <I> ) returns `true' if <I> is a
maximal ideal in its parent nearring and `false' otherwise.

\beginexample
    gap> n := LibraryNearRingWithOne( GTW27_2, 5 );
    LibraryNearRingWithOne(27/2, 5)
    gap> Filtered( NearRingIdeals( n ), IsMaximalNearRingIdeal );
    [ < nearring ideal of size 9 > ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Generators of nearring ideals}


\>GeneratorsOfNearRingIdeal( <I> )

For an `NRI' <I> the function `GeneratorsOfNearRingIdeal'
returns a set of elements of the parent nearring of <I> that generates <I>
as an ideal.

\>GeneratorsOfNearRingLeftIdeal( <I> )

For an `NRI' <I> the function `GeneratorsOfNearRingLeftIdeal'
returns a set of elements of the parent nearring of <I> that generates <I>
as a left ideal.

\>GeneratorsOfNearRingRightIdeal( <I> )

For an `NRI' <I> the function `GeneratorsOfNearRingRightIdeal'
returns a set of elements of the parent nearring of <I> that generates <I>
as a right ideal.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Near-ring ideal elements}


\>AsList( <I> )!{near ring ideals}

The function `AsList' computes the elements of the (left / right) ideal <I>.
It returns the elements as a list.

\>AsSortedList( <I> )!{near ring ideals}

does essentially the same, but returns a set of elements.

\>Enumerator( <I> )!{near ring ideals}

does essentially the same as `AsList', but returns an enumerator for the
elements of <nr>.

\beginexample
    gap> n := LibraryNearRing( GTW8_2, 2 );
    LibraryNearRing(8/2, 2)
    gap> li := NearRingLeftIdeals( n );
    [ < nearring left ideal >, < nearring left ideal >, 
      < nearring left ideal >, < nearring left ideal >, 
      < nearring left ideal >, < nearring left ideal > ]
    gap> l := li[3];
    < nearring left ideal >
    gap> e := Enumerator( l );;
    gap> e[2];
    ((1,2)(3,6,5,4))
    gap> AsList( e ); AsList( l );
    [ (()), ((1,2)(3,6,5,4)), ((3,5)(4,6)), ((1,2)(3,4,5,6)) ]
    [ (()), ((1,2)(3,6,5,4)), ((3,5)(4,6)), ((1,2)(3,4,5,6)) ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Random ideal elements}


\>Random( <I> )!{near ring ideal element}

`Random' returns a random element of the (left / right) ideal <I>.

\beginexample
    gap> Random( l );
    ((3,5)(4,6))
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Membership of an ideal}


For a (left / right) ideal <I> of a nearring $N$ and an element <n> of $N$

\>`<n> in <I>'{in}

tests whether <n> is an element of <I>.

\beginexample
    gap> Random( n ) in l;
    true
    gap> Random( n ) in l;
    false
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Size of ideals}


\>Size( <I> )!{near ring ideals}

`Size' returns the number of elements of the (left / right) ideal <I>.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Group reducts of ideals}


\>GroupReduct( <I> )!{near ring ideals}

`GroupReduct' returns the group reduct of the (left / right) ideal <I>.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Comparision of ideals}


\>`<I> = <J>'{=}

If <I> and <J> are (left / right) ideals of the same nearring and consist of
the same elements, then `true' is returned. Otherwise the answer is `false'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations with ideals}


The most important operations for nearring (left / right) ideals are *meet*
and *join* in the lattice. {\GAP} offers the functions `Intersection',
`Closure\-NearRing\-LeftIdeal', `Closure\-NearRing\-RightIdeal' and
`Closure\-NearRing\-LeftIdeal' for this purpose.

\>Intersection( <ideallist> )!{for nearring ideals}

computes the intersection of the (left / right) ideals in the list <ideallist>.
All of the (left / right) ideals in <ideallist> must be (left / right) ideals
of the same nearring.

\>Intersection( <I1>, \dots, <In> )

computes the intersection of the (left / right) ideals <I1>, \dots, <In>.

In both cases the result is again a (left / right) ideal.

\>ClosureNearRingLeftIdeal( <L1>, <L2> )

The function `ClosureNearRingLeftIdeal' computes the left ideal <L1> + <L2>
of the nearRing $N$ if both <L1> and <L2> are (left) ideals of $N$.

\>ClosureNearRingRightIdeal( <R1>, <R2> )

The function `ClosureNearRingRightIdeal' computes the right ideal <L1> + <L2>
of the nearring $N$ if both <R1> and <R2> are (right) ideals of $N$.

\>ClosureNearRingIdeal( <I1>, <I2> )

The function `ClosureNearRingIdeal' computes the ideal <L1> + <L2>
of the nearring $N$ if both <I1> and <I2> are ideals of $N$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Commutators}


\>NearRingCommutator( <I>, <J> )

The function `NearRingCommutator' returns the commutator of the two
ideals <I> and <J> of a common nearring.

\beginexample
    gap> l := LibraryNearRing( GTW6_2, 3 );
    LibraryNearRing(6/2, 3)
    gap> i := NearRingIdeals( l );               
    [ < nearring ideal >, < nearring ideal > ]
    gap> List( i, Size );
    [ 1, 6 ]
    gap> NearRingCommutator( i[2], i[2] );
    < nearring ideal of size 6 >
\endexample

The function `PrintNearRingCommutatorsTable' prints a complete overview
over the action of the commutator operator on a group.

\beginexample
    gap> l := LibraryNearRing( GTW8_4, 13 );
    LibraryNearRing(8/4, 13)
    gap> NearRingIdeals( l );
    [ < nearring ideal >, < nearring ideal >, < nearring ideal > ]
    gap> PrintNearRingCommutatorsTable( l );
    [ 1, 1, 1 ]
    [ 1, 1, 2 ]
    [ 1, 2, 2 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Simple nearrings}


\>IsSimpleNearRing( <nr> )

The function `IsSimpleNearRing' returns `true' if the nearring <nr> has
no proper (two-sided) ideals.


\beginexample
    gap> NumberLibraryNearRings( GTW4_2 );                         
    23
    gap> Filtered( AllLibraryNearRings( GTW4_2 ), IsSimpleNearRing );
    [ LibraryNearRing(4/2, 3), LibraryNearRing(4/2, 16), 
      LibraryNearRing(4/2, 17) ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Factor nearrings}


\>FactorNearRing( <nr>, <I> )

For a nearring <nr> and an ideal <I> of the nearring <nr> the function
`FactorNearRing' returns the factor nearring of <nr> modulo the ideal <I>.
Alternatively,

\>`<nr> / <I>'{/}

can be used and has the same effect.

The result is always an `ExplicitMultiplicationNearRing', so all functions
for such nearrings can be applied to the factor nearring.

\beginexample
    gap> n := LibraryNearRing( GTW8_2, 2 );
    LibraryNearRing(8/2, 2)
    gap> e := AsNearRingElement( n, (1,2) );
    ((1,2))
    gap> e in n;
    true
    gap> i := NearRingRightIdealByGenerators( n, [e] );
    < nearring right ideal >
    gap> Size(i);
    4
    gap> IsNearRingLeftIdeal( i );
    true
    gap> i;
    < nearring ideal of size 4 >
    gap> f := n/i;          
    FactorNearRing( LibraryNearRing(8/2, 2), < nearring ideal of size 4 > )
    gap> IdLibraryNearRing(f);
    [ 2/1, 1 ]
\endexample



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
