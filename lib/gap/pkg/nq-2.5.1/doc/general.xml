<?xml version="1.0" encoding="UTF-8"?>

<Chapter><Heading>General remarks</Heading>

In this chapter we define notation used throughout this manual and
recollect basic facts about nilpotent groups.  We also provide some
background information about the functionality implemented in this
package. 


<Section><Heading>Commutators and the Lower Central Series</Heading>

<Index>commutator</Index> The <E>commutator</E> of two elements
<M>h_1</M> and <M>h_2</M> of a group <M>G</M> is the element
<M>h_1^{-1}h_2^{-1}h_1h_2</M> and is denoted by <M>[h_1,h_2]</M>.
It satisfies the equation <M>h_1h_2 = h_2h_1[h_1,h_2]</M> and
can be interpreted as the correction term that has to be introduced
into a word if two elements of a group are interchanged.
Iterated commutators are written in <E>left-normed fashion</E>:
<Index>left-normed commutator</Index>
<M>[h_1,h_2,\ldots,h_{n-1},h_n]=[[h_1,h_2,\ldots,h_{n-1}],h_n]</M>.

<P/> 
<Index>lower central series</Index>
The <E>lower central series</E> of <M>G</M> is defined inductively
as <M>\gamma_1(G) = G, \gamma_i(G) = [\gamma_{i-1}(G),G]</M> for
<M>i \ge 2</M>.  Each term in the lower central series is a normal
(even fully invariant) subgroup of <M>G</M>.  The factors of the
lower central series are abelian groups.  On each factor the induced
action of <M>G</M> via conjugation is the trivial action.

<P/>The factor <M>\gamma_k(G)/\gamma_{k+1}(G)</M> is generated by
the elements <M>[g,h]\gamma_{k+1}(G),</M> where <M>g</M> runs
through a set of (representatives of) generators for
<M>G/\gamma_2(G)</M> and <M>h</M> runs through a set of
(representatives of) generators for
<M>\gamma_{k-1}(G)/\gamma_k(G).</M> Therefore, each factor of the
lower central series is finitely generated if <M>G</M> is finitely
generated.

<P/> If one factor of the lower central series is finite, then all
subsequent factors are finite.  Then the exponent of the
<M>k+1</M>-th factor is a divisor of the exponent of the <M>k</M>-th
factor of the lower central series.  In particular, the exponents of
all factors of the lower central series are bounded by the
exponent of the first finite factor of the lower central series.
</Section>

<Section><Heading>Nilpotent groups</Heading>

<Index>nilpotent</Index>
A group <M>G</M> is called <E>nilpotent</E> if there is a positive
integer <M>c</M> such that all <M>(c+1)</M>-fold commutators are
trivial in <M>G.</M> The smallest integer with this property is
called the 
<Index>nilpotency class</Index><Index>class</Index>
<E>nilpotency class</E> of <M>G</M>.  In terms of the lower
central series a group <M>G \not= 1</M> has nilpotency class <M>c</M>
if and only if
<M>\gamma_{c}(G) \not= 1</M> and <M>\gamma_{c+1}(G) = 1</M>.

<P/>Examples of nilpotent groups are finite <M>p</M>-groups, the
group of unitriangular matrices over a ring with one and the factor
groups of a free group modulo the terms of its lower central
series.  

<P/>Finiteness of a nilpotent group can be decided by the group's
commutator factor group.  A nilpotent group is finite if and only if
its commutator factor group is finite.  A group whose commutator
factor group is finite can only have finite nilpotent quotient
groups.

<P/> By refining the lower central series of a finitely generated
nilpotent group one can obtain a (sub)normal series
<M>G_1&gt;G_2&gt;...&gt;G_{k+1}=1</M> with cyclic (central) factors.
Therefore, every finitely generated nilpotent group is
<Index>polycyclic</Index><E>polycyclic</E>.  Such a <E>polycyclic
series</E> gives rise to a <Index>polycyclic generating
sequence</Index> polycyclic generating sequence by choosing a
generator <M>a_i</M> for each cyclic factor <M>G_i/G_{i+1}</M>.
Let <M>I</M> be the
set of indices such that <M>G_i/G_{i+1}</M> is finite.  A simple
induction argument shows that every element of the group can be
written uniquely as a <E>normal word</E> <M>a_1^{e_1}\ldots
a_n^{e_n}</M> with integers <M>e_i</M> and <M>0\leq e_i&lt;m_i</M>
for <M>i\in I</M>.

</Section>

<Section><Heading>Nilpotent presentations </Heading>

<P/>From a polycyclic generating sequence one can obtain a
<Index>polycyclic presentation</Index> <E>polycyclic
presentation</E> for the group.  The following set of power and
commutator relations is a defining set of relations.  The
<Index>power relation</Index> <E>power relations</E> express
<M>a_i^{m_i}</M> in terms of the generators
<M>a_{i+1},\ldots,a_n</M> whenever <M>G_i/G_{i+1}</M> is finite with
order <M>m_i</M>. The <Index>commutator relation</Index>
<E>commutator relations</E> are obtained by expressing
<M>[a_j,a_i]</M> for <M>j&gt;i</M> as a word in the generators
<M>a_{i+1},\ldots,a_n</M>.  If the polycyclic series is obtained
from refining the lower central series, then <M>[a_j,a_i]</M> is
even a word in <M>a_{j+1},\ldots,a_n</M>.  In this case we obtain a
nilpotent presentation.

<P/>To be more precise, a <Index>nilpotent presentation</Index>
<E>nilpotent presentation</E> is given on a finite number of
generators <M>a_1,\ldots,a_n</M>.  Let <M>I</M> be the set of
indices such that <M>G_i/G_{i+1}</M> is finite.  Let <M>m_i</M> be
the order of <M>G_i/G_{i+1}</M> for <M>i\in I</M>.  Then a nilpotent
presentation has the form
<Display>
\langle a,\ldots,a_n | 
    a_i^{m_i}   = w_{ii}(a_{i+1},\ldots,a_n) 
               \mbox{ for } i\in I;\; 
    [a_j,a_i] = w_{ij}(a_{j+1},\ldots,a_n)
               \mbox{ for } 1\leq i &lt; j\leq n\rangle
</Display>
Here, <M>w_{ij}(a_k,\ldots,a_n)</M> denotes a group word in the
generators <M>a_k,\ldots,a_n</M>. 

<P/>In a group given by a polycyclic presentation each element in
the group can be written as a <E>normal word</E> <M>a_1^{e_1}\ldots
a_n^{e_n}</M> with <M>e_i \in \mathbb{Z}</M> and <M>0 \leq e_i &lt; m_i</M>
for <M>i \in I</M>.  A procedure called <E>collection</E> can be
used to convert an arbitrary word in the generators into an
equivalent normal word.  In general, the resulting normal word need
not be unique.  The result of collecting a word may depend on the
steps chosen during the collection procedure.  A polycyclic
presentation with the property that two different normal words are
never equivalent is called
<E>consistent</E><Index>consistent</Index>.  A polycyclic
presentation derived from a polycyclic series as above is
consistent.  The following example shows an inconsistent polycyclic
presentation

<Display>\langle a,b\mid a^2, b^a = b^2 \rangle </Display> 

as <M>b = baa = ab^2a = a^2b^4 = b^4</M> which implies <M>b^3=1</M>.
Here we have the equivalent normal words <M>b^3</M> and the empty
word.  It can be proved that consistency can be checked by
collecting a finite number of words in the given generating set in
two essentially different ways and checking if the resulting normal
forms are the same in both cases.  See Chapter 9 of the book <Cite
Key="Sims94"/> for an introduction to polycyclic groups and
polycyclic presentations.

<P/>For computations in a polycyclic group one chooses a consistent
polycyclic presentation as it offers a simple solution to the word
problem: Equality between two words is decided by collecting both
words to their respective normal forms and comparing the normal
forms.  Nilpotent groups and nilpotent presentations are special
cases of polycyclic groups and polycyclic presentations.  Nilpotent
presentations allow specially efficient collection methods.  The
package <Package>Polycyclic</Package> provides algorithms to compute
with polycyclic groups given by a polycyclic presentation.

<P/>However, inconsistent nilpotent presentations arise naturally in
the nilpotent quotient algorithm.  There is an algorithm based on
the test words for consistency mentioned above to modify the arising
inconsistent presentations suitably to obtain a consistent one for
the same group.
</Section>

<Section><Heading>A sketch of the algorithm</Heading>

The input for the ANU NQ in its simplest form is a finite
presentation <M>\langle X|R\rangle</M> for a group <M>G</M>.  The
first step of the algorithm determines a nilpotent presentation for
the commutator quotient of <M>G</M>.  This is a presentation of the
class-<M>1</M> quotient of <M>G</M>.  Call its generators
<M>a_1,...,a_d</M>.  It also determines a homomorphism of <M>G</M>
onto the commutator quotient and describes it by specifying the
image of each generator in <M>X</M> as a word in the <M>a_i</M>.

<P/>For the general step assume that the algorithm has computed a
nilpotent presentation for the class-<M>c</M> quotient of <M>G</M>
and that <M>a_1,...,a_d</M> are the generators introduced in the
first step of the algorithm.  Furthermore, there is a map from X
into the class-<M>c</M> quotient describing the epimorphism from
<M>G</M> onto <M>G/\gamma_{c+1}(G)</M>.

<P/>Let <M>b_1,...b_k</M> be the generators from the last step of the
algorithm, the computation of <M>\gamma_c(G)/\gamma_{c+1}(G)</M>.
This means that <M>b_1,...b_k</M> generate
<M>\gamma_c(G)/\gamma_{c+1}(G)</M>.  Then the commutators
<M>[b_j,a_i]</M> generate <M>\gamma_{c+1}(G)/\gamma_{c+2}(G)</M>. 
The algorithm introduces new, central generators <M>c_{ij}</M> into
the presentation, adds the relations <M>[b_j,a_i] = c_{ij}</M> and
modifies the existing relations by appending suitable words in the
<M>c_{ij}</M>, called <E>tails</E>, to the right hand sides of the
power and commutator relations.  The resulting presentation is a
nilpotent presentation for the <E>nilpotent cover</E> of
<M>G/\gamma_{c+1}(G)</M>.  The nilpotent cover is the largest central
extension of <M>G/\gamma_{c+1}(G)</M> generated by <M>d</M> elements.
It is is uniquely determined up to isomorphism.

<P/>The resulting presentation of the nilpotent cover is in general
inconsistent.  Consistency is achieved by running the consistency
test.  This results in relations among the generators
<M>c_{ij}</M> which can be used to eliminate some of those
generators or introduce power relations.  After this has been done
we have a consistent nilpotent presentation for the nilpotent cover
of <M>G/\gamma_{c+1}(G)</M>.

<P/>Furthermore, the nilpotent cover need not satisfy the relations
of <M>G</M>.  In other words, the epimorphism from <M>G</M> onto
<M>G/\gamma_{c+1}(G)</M> cannot be lifted to an epimorphism onto the
nilpotent cover.  Applying the epimorphism to each relator of
<M>G</M> and collecting the resulting words of the nilpotent cover
yields a set of words in the <M>c_{ij}</M>.  This gives further
relations between the <M>c_{ij}</M> which leads to further
eliminations or modifications of the power relations for the
<M>c_{ij}</M>.

<P/>After this, the inductive step of the ANU NQ is complete and a
consistent nilpotent presentation for <M>G/\gamma_{c+2}(G)</M> is
obtained together with an epimorphism from <M>G</M> onto the
class-<M>(c+1)</M> quotient.

<P/>Chapter 11 of the book <Cite Key="Sims94"/> discusses a
nilpotent quotient algorithm.  A description of the implementation
in the ANU NQ is contained in <Cite Key="Nickel96"/>
</Section>

<Section><Heading>Identical Relations</Heading><Label Name="IdRels"/>

Let <M>w</M> be a word in free generators <M>x_1,\ldots,x_n</M>.  A
group <M>G</M> satisfies the relation <M>w=1</M> <E>identically</E> if
each map from <M>x_1,\ldots,x_n</M> into <M>G</M> maps <M>w</M> to
the identity element of <M>G</M>.  We also say that <M>G</M> satisfies the
<Index>identical relation</Index> <Index>law</Index> <E>identical
relation</E> <M>w=1</M> or satisfies the <E>law</E> <M>w=1</M>.  In
slight abuse of notation, we call the elements <M>x_1,\ldots,x_n</M>
<Index>identical generator</Index> 
<E>identical</E> generators.

<P/> Common examples of identical relations are: A group of
nilpotency class at most <M>c</M> satisfies the law
<M>[x_1,\ldots,x_{c+1}]=1</M>.  A group that satisfies the law
<M>[x,y,\ldots,y]=1</M> where <M>y</M> occurs <M>n</M>-times, is
called an <M>n</M>-Engel group.  A group that satisfies the law
<M>x^d=1</M> is a group of exponent <M>d</M>.

<P/>
To describe finitely presented groups that satisfy one or more laws,
we extend a common notation for finitely presented groups 
by specifying the identical generators as part of the generator
list, separated from the group generators by a semicolon: For
example
<Display>
\langle a,b,c; x,y | x^5, [x,y,y,y]\rangle
</Display>
is a group on 3 generators <M>a,b,c</M> of exponent <M>5</M>
satisfying the 3rd Engel law.  The presentation above is equivalent
to a presentation on 3 generators with an infinite set of relators,
where the set of relators consists of all fifth powers of words in
the generators and all commutators <M>[x,y,y,y]</M> where <M>x</M>
and <M>y</M> run through all words in the generators <M>a,b,c</M>.
The standalone programme accepts the notation introduced above as a
description of
its input.  In <Package>GAP 4</Package> finitely presented groups
are specified in a different way, see 
<Ref Func="NilpotentQuotient" Style="Text"/> for a description.

<P/>
This notation can also be used in words that mix group and identical
generators as in the following example:
<Display>
\langle a,b,c; x | [x,c], [a,x,x,x] \rangle
</Display>
The first relator specifies a law which says that <M>c</M> commutes
with all elements of   the group.  The second turns  <M>a</M> into a
third right Engel element.   

<P/>An element <M>a</M> is called <E>a right <M>n</M>-th 
Engel element</E> or <E>a right <M>n</M>-Engel element</E> 
<Index>right Engel element</Index> 
if it satisfies the commutator law <M>[a,x,...,x]=1</M>
where the identical generator <M>x</M> occurs <M>n</M>-times.
Likewise, an element <M>b</M> is called an <E>left <M>n</M>-th Engel
element</E> or <E>left <M>n</M>-Engel element</E> 
<Index>left Engel element</Index>
if it satisfies the commutator law <M>[x,b,b,...b]=1</M>.

<P/>Let <M>G</M> be a nilpotent group.  Then <M>G</M> satisfies a
given law if the law is satisfied by a certain finite set of
instances given by Higman's Lemma, see <Cite Key="Higman59"/>.  The
ANU NQ uses Higman's Lemma to obtain a finite presentation for
groups that satisfy one or several identical relations.

</Section>

<Section Label="ExpTrees"><Heading>Expression Trees</Heading>
Expressions involving commutators play an important role in the
context of nilpotent groups.  Expanding an iterated commutator
produces a complicated and long expression.  For example, 
<Display>
          [x,y,z] = y^{-1}x^{-1}yxz^{-1}x^{-1}y^{-1}xyz.
</Display>
Evaluating a commutator <M>[a,b]</M> is done efficiently by
computing the equation <M>(ba)^{-1}ab</M>.  Therefore, for each
commutator we need to perform two multiplications and one inversion.
Evaluating <M>[x,y,z]</M> needs four multiplications and two
inversions.  Evaluation of an iterated commutator with <M>n</M>
components takes <M>2n-1</M> multiplications and
<M>n-1</M> inversions.  The expression on the right hand side above
needs <M>9</M> multiplications and <M>5</M> inversions which is
clearly much more expensive than evaluating the commutator directly.  

<P/> Assuming that no cancellations occur, expanding an iterated
commutator with n components produces a word with
<M>2^{n+1}-2^{n-1}-2</M> factors half of which are inverses.  A
similar effect occurs whenever a compact expression is expanded into
a word in generators and inverses, for example <M>(ab)^{49}</M>.

<P/> Therefore, it is important not to expand expressions into a
word in generators and inverses.  For this purpose we provide a
mechanism which we call here 
<Index>expression trees</Index>
<E>expression trees</E>.  An expression tree preserves the
structure of a given expression.  It is a (binary) tree in which
each node is assigned an operation and whose leaves are generators
of a free group or integers.  For example, the expression
<M>[(xy)^2, z]</M> is stored as a tree whose top node is a
commutator node.  The right subtree is just a generator node
(corresponding to <M>z</M>).  The
left subtree is a power node whose subtrees are a
product node on the left and an integer node on the right.  An
expression tree can involve products, powers, conjugates and
commutators.  However, the list of available operations can
be extended.

<P/>Evaluation of an expression tree is done recursively and
requires as many operations as there are nodes in the tree.  An
expression tree can be evaluated in a specific group by the function
<Ref Func="EvaluateExpTree" Style="Text"/>.

<P/>A presentation specified by expression trees is a record with
the components <F>.generators</F> and <F>.relations</F>.  See 
section <Ref Sect="FunctionsExpTrees"/> for a description of the functions
that produce and manipulate expression trees.
<Example>
gap> LoadPackage( "nq" );
true
gap> gens := ExpressionTrees( 2 );
[ x1, x2 ]
gap> r1 := LeftNormedComm( [gens[1],gens[2],gens[2]] );
Comm( x1, x2, x2 )
gap> r2 := LeftNormedComm( [gens[1],gens[2],gens[2],gens[1]] );
Comm( x1, x2, x2, x1 )
gap> pres := rec( generators := gens, relations := [r1,r2] );
rec( generators := [ x1, x2 ], 
relations := [ Comm( x1, x2, x2 ), Comm( x1, x2, x2, x1 ) ] )
</Example>
</Section>

<Section><Heading>A word about the implementation</Heading>

The ANU NQ is written in C, but not in ANSI C.  I hope to make one
of the next versions ANSI compliable.  However, it uses a fairly
restricted subset of the language so that it should be easy to
compile it in new environments.  The code is 64-bit clean.  If you
have difficulties with porting it to a new environment, let me know
and I'll be happy to assist if time permits.

<P/>The program has two collectors:  a simple collector from the left
as described in <Cite Key="LS90"/> and a combinatorial from the left
collector as described in <Cite Key="VL90a"/>.  The combinatorial
collector is always faster than the simple collector, therefore, it
is the collector used by this package by default.  This can be
changed by modifying the global variable <Ref Var="NqDefaultOptions"
Style="Text"/>.

<P/>In a polycyclic group with generators that do not have power
relations, exponents may become arbitrarily large.  Experience shows
that this happens rarely in the computations done by the ANU NQ.
Exponents are represented by 32-bit integers.  The collectors
perform an overflow check and abort the computation if an overflow
occurred.  In a GNU environment the program can be compiled using
the `long long' 64-bit integer type.  For this uncomment the
relevant line in src/Makefile and recompile the program.

<P/>As part of the step that enforces consistency and the relations
of the group, the ANU NQ performs computations with integer matrices
and converts them to Hermite Normal Form.  The algorithm used here
is a variation of the Kanan-Bachem algorithm based on the GNU
multiple precision package GNU MP <Cite Key="GNUMP"/>.  Experience shows
that the integer matrices are usually fairly sparse and Kanan-Bachem
seems to be sufficient in this context.  However, the implementation
might benefit from a more efficient strategy for computing Hermite
Normal Forms.  This is a topic for further investigations.

<P/>As the program does not compute the Smith Normal Form for each 
factor of the lower central series but the Hermite Normal
Form, it does not necessarily obtain a minimal generating set for
each factor of the lower central series.  The following is a simple
example of this behaviour.  We take the presentation
<Display>
\langle x, y | x^2 = y \rangle
</Display>
The group is clearly isomorphic to the additive group of the
integers.  Applying the ANU NQ to this presentation gives the
following nilpotent presentation:
<Display>
  \langle A,B | A^2 = B, [B,A] \rangle
</Display>
A nilpotent presentation on a minimal generating set would be the
presentation of the free group on one generator:
<Display>
  \langle A | \; \rangle
</Display>

</Section>

<Section><Heading>The input format of the standalone</Heading><Label Name="InputForm"/>

The input format for finite presentations resembles the way many
people write down a presentation on paper.  Here are some examples of
presentations that the ANU NQ accepts:

<Verb>
<![CDATA[
    < a, b | >                       # free group of rank 2

    < a, b, c; x, y | 
                [a,b,c],             # a left normed commutator
                [b,c,c,c]^6,         # another one raised to a power
                a^2 = c^-3*a^2*c^3,  # a relation
                a^(b*c) = a,         # a conjugate relation
                (a*[b,(a*c)])^6,     # something that looks complicated
                [x,y,y,y,y],         # an identical relation
                [c,x,x,x,x,x]        # c is a fifth right Engel element
    >
]]>
</Verb>

A presentation starts with '&tlt;' followed by a list of generators
separated by commas.  Generator names are strings that contain only
upper and lower case letters, digits, dots and underscores and that do
not start with a digit.  The list of generator names is separated from
the list of relators/relations by the symbol '<M>\mid</M>'.  The list of
generators can be followed by a list of identical generators separated
by a semicolon.  Relators and relations are separated by commas and
can be mixed arbitrarily.  Parentheses can be used in order to group
subexpressions together.  Square brackets can be used in order to form
left normed commutators.  The symbols '*' and '&circum;' can be
used to form products and powers, respectively. The presentation
finishes with the symbol '&tgt;'.  A comment starts with the symbol '&hash;'
and finishes at the end of the line.  The file src/presentation.c
contains a complete grammar for the presentations accepted by the ANU
NQ.


<P/>Typically, the input for the standalone is put into a file by
using a standard text editor.  The file can be passed as an argument
to the function <Ref Func="NilpotentQuotient" Style="Text"/>.  It is
also possible to put a presentation in the standalone's input format
into a string and use the string as argument for <Ref
Func="NilpotentQuotient" Style="Text"/>.

</Section>
</Chapter>  
