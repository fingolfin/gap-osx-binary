% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{GAP 4 Package \textsf{hecke}\mbox{}}}\\
\vfill

\hypersetup{pdftitle=GAP 4 Package \textsf{hecke}}
\markright{\scriptsize \mbox{}\hfill GAP 4 Package \textsf{hecke} \hfill\mbox{}}
{\Huge \textbf{\textsf{Hecke} - a port of \textsf{Specht} $2.4$ to GAP 4\mbox{}}}\\
\vfill

{\Huge  1.4 \mbox{}}\\[1cm]
{July 2013\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{Dmitriy Traytel    \mbox{}}}\\
\hypersetup{pdfauthor=Dmitriy Traytel    }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{Dmitriy Traytel    }  Email: \href{mailto://traytel@in.tum.de} {\texttt{traytel@in.tum.de}}\\
  Homepage: \href{http://home.in.tum.de/~traytel} {\texttt{http://home.in.tum.de/\texttt{\symbol{126}}traytel}}}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 1 ]}
 {\copyright} 2010{\textendash}2013 by Dmitriy Traytel

 This package may be distributed under the terms and conditions of the GNU
Public License Version 2 or higher. \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 2 ]}}

\tableofcontents
\newpage

  
\chapter{\textcolor{Chapter }{Decomposition numbers of Hecke algebras of type A}}\label{intro}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7CD78FC183A57690}{}
{
 \index{\textsf{hecke} package}  
\section{\textcolor{Chapter }{Description}}\label{desription}
\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X7BBCB13F82ACC213}{}
{
  \textsf{Hecke} is a port of the \textsf{GAP} 3-package \textsf{Specht} $2.4$ to \textsf{GAP} 4.

 This package contains functions for computing the decomposition matrices for
Iwahori-Hecke algebras of the symmetric groups. As the (modular)
representation theory of these algebras closely resembles that of the
(modular) representation theory of the symmetric groups (indeed, the latter is
a special case of the former) many of the combinatorial tools from the
representation theory of the symmetric group are included in the package.

 These programs grew out of the attempts by Gordon James and Andrew Mathas \cite{JM1} to understand the decomposition matrices of Hecke algebras of type \emph{A} when $q=-1$. The package is now much more general and its highlights include: 
\begin{enumerate}
\item \textsf{Hecke} provides a means of working in the Grothendieck ring of a Hecke algebra $H$ using the three natural bases corresponding to the Specht modules, projective
indecomposable modules, and simple modules. 
\item For Hecke algebras defined over fields of characteristic zero, the algorithm
of Lascoux, Leclerc, and Thibon \cite{LLT} for computing decomposition numbers and ``crystallized decomposition matrices'' has been implemented. In principle, this gives all of the decomposition
matrices of Hecke algebras defined over fields of characteristic zero. 
\item \textsf{Hecke} provides a way of inducing and restricting modules. In addition, it is
possible to ``induce'' decomposition matrices; this function is quite effective in calculating the
decomposition matrices of Hecke algebras for small $n$. 
\item The $q$-analogue of Schaper's theorem \cite{JM2} is included, as is Kleshchev's \cite{K} algorithm of calculating the Mullineux map. Both are used extensively when
inducing decomposition matrices. 
\item \textsf{Hecke} can be used to compute the decomposition numbers of $q$-Schur algebras (and the general linear groups), although there is less direct
support for these algebras. The decomposition matrices for the $q$-Schur algebras defined over fields of characteristic zero for $n<11$ and all $e$ are included in \textsf{Hecke}. 
\item The Littlewood-Richard rule, its inverse, and functions for many of the
standard operations on partitions (such as calculating cores, quotients, and
adding and removing hooks), are included. 
\item The decomposition matrices for the symmetric groups $S_n$ are included for $n<15$ and for all primes. 
\end{enumerate}
 }

 
\section{\textcolor{Chapter }{The modular representation theory of Hecke algebras}}\label{representationtheory}
\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X7A3BD2F77A4AC7EA}{}
{
  The ``modular'' representation theory of the Iwahori-Hecke algebras of type \emph{A} was pioneered by Dipper and James \cite{DJ1} \cite{DJ2}; here the theory is briefly outlined, referring the reader to the references
for details.

 Given a commutative integral domain $R$ and a non-zero unit $q$ in $R$, let $H=H_{R, q}$ be the Hecke algebra of the symmetric group $S_n$ on $n$ symbols defined over $R$ and with parameter $q$. For each partition $\mu$ of $n$, Dipper and James defined a \emph{Specht module} $S(\mu)$. Let $rad~S(\mu)$ be the radical of $S(\mu)$ and define $D(\mu)=S(\mu)/rad~S(\mu)$. When $R$ is a field, $D(\mu)$ is either zero or absolutely irreducible. Henceforth, we will always assume
that $R$ is a field.

 Given a non-negative integer $i$, let $[i]_q=1+q+\ldots+q^{i-1}$. Define $e$ to be the smallest non-negative integer such that $[e]_q=0$; if no such integer exists, we set $e$ equal to $0$. Many of the functions in this package depend upon e; the integer $e$ is the Hecke algebras analogue of the characteristic of the field in the
modular representation theory of finite groups.

 A partition $\mu=(\mu_1,\mu_2,\ldots)$ is \emph{$e$-singular} if there exists an integer $i$ such that $\mu_i=\mu_{i+1}=\cdots= \mu_{i+e-1}>0$; otherwise, $\mu$ is \emph{$e$-regular}. Dipper and James \cite{DJ1} showed that $D(\nu)\neq 0$ if and only if $\nu$ is $e$-regular and that the $D(\nu)$ give a complete set of non-isomorphic irreducible $H$-modules as $\nu$ runs over the $e$-regular partitions of $n$. Further, $S(\mu)$ and $S(\nu)$ belong to the same block if and only if $\mu$ and $\nu$ have the same $e$-core \cite{DJ2}\cite{JM2}. Note that these results depend only on $e$ and not directly on $R$ or $q$.

 Given two partitions $\mu$ and $\nu$, where $\nu$ is $e$ -regular, let $d_{\mu\nu}$ be the composition multiplicity of $D(\nu)$ in $S(\nu)$. The matrix $D=(d_{\mu\nu})$ is the \emph{ decomposition matrix} of $H$. When the rows and columns are ordered in a way compatible with dominance, $D$ is lower unitriangular.

 The indecomposable $H$-modules $P(\nu)$ are indexed by $e$ -regular partitions $\nu$. By general arguments, $P(\nu)$ has the same composition factors as $\sum_{\mu} d_{\mu\nu} S(\mu)$; so these linear combinations of modules become identified in the
Grothendieck ring of $H$. Similarly, $D(\nu) = \sum_{\mu} d_{\nu\mu}^{-1} S(\mu)$ in the Grothendieck ring. These observations are the basis for many of the
computations in \textsf{Hecke}. }

 
\section{\textcolor{Chapter }{Two small examples}}\label{examples}
\logpage{[ 1, 3, 0 ]}
\hyperdef{L}{X8226F6F77ACF26D8}{}
{
  Because of the algorithm of \cite{LLT}, in principle, all of decomposition matrices for all Hecke algebras defined
over fields of characteristic zero are known and available using \textsf{Hecke}. The algorithm is recursive; however, it is quite quick and, as with a car,
you need never look at the engine: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(4);   # e=4, 'R' a field of characteristic 0|
  <Hecke algebra with e = 4>
  !gapprompt@gap>| !gapinput@RInducedModule(MakePIM(H,12,2));|
  <direct sum of 5 P-modules>
  !gapprompt@gap>| !gapinput@Display(last);|
  P(13,2) + P(12,3) + P(12,2,1) + P(10,3,2) + P(9,6)
\end{Verbatim}
 The \cite{LLT} algorithm was applied 24 times during this calculation. 

 For Hecke algebras defined over fields of positive characteristic the major
tool provided by \textsf{Hecke}, apart from the decomposition matrices contained in the libraries, is a way
of ``inducing'' decomposition matrices. This makes it fairly easy to calculate the associated
decomposition matrices for ``small'' $n$. For example, the \textsf{Hecke} libraries contain the decomposition matrices for the symmetric groups $S_n$ over fields of characteristic $3$ for $n<15$. These matrices were calculated by \textsf{Hecke} using the following commands: 
\begin{Verbatim}[commandchars=!@A,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>A !gapinput@H:=Specht(3,3);   # e=3, 'R' field of characteristic 3A
  <Hecke algebra with e = 3>
  !gapprompt@gap>A !gapinput@d:=DecompositionMatrix(H,5);  # known for n<2eA
  <7x5 decomposition matrix>
  !gapprompt@gap>A !gapinput@Display(last);A
  5    | 1
  4,1  | . 1
  3,2  | . 1 1
  3,1^2| . . . 1
  2^2,1| 1 . . . 1
  2,1^3| . . . . 1
  1^5  | . . 1 . .
  !gapprompt@gap>A !gapinput@for n in [6..14] doA
  !gapprompt@>A !gapinput@      d:=InducedDecompositionMatrix(d); SaveDecompositionMatrix(d);A
  !gapprompt@>A !gapinput@   od;A
\end{Verbatim}
 The function \texttt{InducedDecompositionMatrix} contains almost every trick for computing decomposition matrices (except using
the spin groups).

 \textsf{Hecke} can also be used to calculate the decomposition numbers of the $q$-Schur algebras; although, as yet, here no additional routines for calculating
the projective indecomposables indexed by $e$-singular partitions. Such routines may be included in a future release,
together with the (conjectural) algorithm \cite{LT} for computing the decomposition matrices of the $q$-Schur algebras over fields of characteristic zero.

  }

 
\section{\textcolor{Chapter }{Overview over this manual}}\label{overview}
\logpage{[ 1, 4, 0 ]}
\hyperdef{L}{X786BACDB82918A65}{}
{
  Chapter \ref{install} describes the installation of this package. Chapter \ref{functionality} shows instructive examples for the usage of this package. }

 
\section{\textcolor{Chapter }{Credits}}\label{credits}
\logpage{[ 1, 5, 0 ]}
\hyperdef{L}{X8779AFAF8411A26A}{}
{
  I would like to thank Anne Henke for offering me the interesting project of
porting \textsf{Specht} $2.4$ to the current \textsf{GAP} version, Max Neunh{\"o}ffer for giving me an excellent introduction to the \textsf{GAP} 4-style of programming and Benjamin Wilson for supporting the project and
helping me to understand the mathematics behind \textsf{Hecke}.

 Also I thank Andrew Mathas for allowing me to use his \textsf{GAP} 3-code of the \textsf{Specht} $2.4$ package.

 The lastest version of \textsf{Hecke} can be obtained from

 \href{http://home.in.tum.de/~traytel/hecke/} {\texttt{http://home.in.tum.de/\texttt{\symbol{126}}traytel/hecke/}}.

 Dmitriy Traytel

 traytel@in.tum.de

 Technische Universit{\"a}t M{\"u}nchen, 2010.  }

  }

  
\chapter{\textcolor{Chapter }{Installation of the \textsf{hecke}-Package}}\label{install}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X878604E87ECCEAFA}{}
{
  \index{\textsf{hecke}} To install this package just extract the package's archive file to the \textsf{GAP} \texttt{pkg} directory.

 By default the \textsf{hecke} package is not automatically loaded by \textsf{GAP} when it is installed. You must load the package with \texttt{LoadPackage("hecke");} before its functions become available.

 Please, send me an e-mail if you have any questions, remarks, suggestions,
etc. concerning this package. Also, I would like to hear about applications of
this package.

 Dmitriy Traytel }

  
\chapter{\textcolor{Chapter }{Specht functionality}}\label{functionality}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X7ED1AB5C7E41D277}{}
{
  
\section{\textcolor{Chapter }{Porting notes}}\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X78AA2DBD7D5D3F02}{}
{
  Porting the \textsf{Specht} $2.4$ package to \textsf{GAP} 4 did not influence the algorithms but required a completely new object
oriented design of the underlying data structures. In \textsf{GAP} 3 records were used to represent algebra objects, modules and decomposition
matrices of \textsf{Specht} $2.4$. Further functions were stored inside of such records to provide name safety.

 In \textsf{Hecke} objects represent all the data that was named above. The overloading mechanism
the former record-internal functions to be available on the toplevel. The
operation selection mechanism of \textsf{GAP} 4 allows one to concentrate on the computation code instead of dealing with
different possible argument inputs. 

 Since variable argument length operations are not yet supported by \textsf{GAP} 4, we introduced our own dispatcher facility to enable the former possibility
of passing patrition arguments as sequences of integers (see \ref{partitions}).

 
\subsection{\textcolor{Chapter }{Structure of \textsf{Hecke}}}\logpage{[ 3, 1, 1 ]}
\hyperdef{L}{X8751E264810E0136}{}
{


 The data structure hierarchy in \textsf{GAP} 4 is defined through filters and their dependencies.

 \noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsAlgebraObj\index{IsAlgebraObj@\texttt{IsAlgebraObj}}
\label{IsAlgebraObj}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsHecke\index{IsHecke@\texttt{IsHecke}}
\label{IsHecke}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSchur\index{IsSchur@\texttt{IsSchur}}
\label{IsSchur}
}\hfill{\scriptsize (filter)}}\\


 \texttt{IsAlgebraObj} is a generic filter for the objects returned by the functions \texttt{Specht} (\ref{Specht}) and \texttt{Schur} (\ref{Schur}). Concretely, \texttt{Specht} (\ref{Specht}) returns an \texttt{IsHecke} object (automatically also an \texttt{IsAlgebraObj} object). For design reasons \texttt{IsSchur} is a subfilter of \texttt{IsHecke}. This allows to use the same functions for Schur-algebras as for
Hecke-algebras with minor restrictions.

 \noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsAlgebraObjModule\index{IsAlgebraObjModule@\texttt{IsAlgebraObjModule}}
\label{IsAlgebraObjModule}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsHeckeModule\index{IsHeckeModule@\texttt{IsHeckeModule}}
\label{IsHeckeModule}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsHeckeSpecht\index{IsHeckeSpecht@\texttt{IsHeckeSpecht}}
\label{IsHeckeSpecht}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsHeckePIM\index{IsHeckePIM@\texttt{IsHeckePIM}}
\label{IsHeckePIM}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsHeckeSimple\index{IsHeckeSimple@\texttt{IsHeckeSimple}}
\label{IsHeckeSimple}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsFockModule\index{IsFockModule@\texttt{IsFockModule}}
\label{IsFockModule}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsFockSpecht\index{IsFockSpecht@\texttt{IsFockSpecht}}
\label{IsFockSpecht}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsFockPIM\index{IsFockPIM@\texttt{IsFockPIM}}
\label{IsFockPIM}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsFockSimple\index{IsFockSimple@\texttt{IsFockSimple}}
\label{IsFockSimple}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSchurModule\index{IsSchurModule@\texttt{IsSchurModule}}
\label{IsSchurModule}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSchurWeyl\index{IsSchurWeyl@\texttt{IsSchurWeyl}}
\label{IsSchurWeyl}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSchurPIM\index{IsSchurPIM@\texttt{IsSchurPIM}}
\label{IsSchurPIM}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSchurSimple\index{IsSchurSimple@\texttt{IsSchurSimple}}
\label{IsSchurSimple}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsFockSchurModule\index{IsFockSchurModule@\texttt{IsFockSchurModule}}
\label{IsFockSchurModule}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsFockSchurWeyl\index{IsFockSchurWeyl@\texttt{IsFockSchurWeyl}}
\label{IsFockSchurWeyl}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsFockSchurPIM\index{IsFockSchurPIM@\texttt{IsFockSchurPIM}}
\label{IsFockSchurPIM}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsFockSchurSimple\index{IsFockSchurSimple@\texttt{IsFockSchurSimple}}
\label{IsFockSchurSimple}
}\hfill{\scriptsize (filter)}}\\


 The hierarchy of module objects is more complex. On top we have the filter \texttt{IsAlgebraObjModule}. Its direct descendant \texttt{IsHeckeModule} has \texttt{IsHeckeSpecht}, \texttt{IsHeckePIM}, \texttt{IsHeckeSimple}, \texttt{IsFockModule} and \texttt{IsSchurModule} as subfilters. Again the last two subfilter relations have no mathematical
sense but are technically comfortable. The filter \texttt{IsFockModule} is superfilter of \texttt{IsFockSpecht}, \texttt{IsFockPIM}, \texttt{IsFockSimple} and \texttt{IsFockSchurModule}. Analogously, \texttt{IsSchurModule} is superfilter of \texttt{IsSchurWeyl}, \texttt{IsSchurPIM}, \texttt{IsSchurSimple} and \texttt{IsFockSchurModule} which itself is superfilter of \texttt{IsFockSchurWeyl}, \texttt{IsFockSchurPIM}, \texttt{IsFockSchurSimple}. Further, there are subfilter relations between \texttt{IsFockSpecht} and \texttt{IsHeckeSpecht} etc., \texttt{IsFockSchurWeyl} and \texttt{IsFockSpecht} etc., \texttt{IsFockSchurWeyl} and \texttt{IsSchurWeyl} etc., \texttt{IsSchurWeyl} and \texttt{IsHeckeSpecht} etc. filters.

 \noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsDecompositionMatrix\index{IsDecompositionMatrix@\texttt{IsDecompositionMatrix}}
\label{IsDecompositionMatrix}
}\hfill{\scriptsize (filter)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsCrystalDecompositionMatrix\index{IsCrystalDecompositionMatrix@\texttt{IsCrystalDecompositionMatrix}}
\label{IsCrystalDecompositionMatrix}
}\hfill{\scriptsize (filter)}}\\


 For decomposition matrices we use the filter \texttt{IsDecompositionMatrix} and its subfilter \texttt{IsCrystalDecompositionMatrix}. }

 
\subsection{\textcolor{Chapter }{Renamings}}\logpage{[ 3, 1, 2 ]}
\hyperdef{L}{X8120A27282B82CC8}{}
{
  To keep things as backwards compatible as possible, we tried not to change
names and function signatures. But for the former \texttt{H.***}- and \texttt{H.operations.***}-style functions it makes more sense to use toplevel functions (especially
when the $H$ is not explicitly needed inside of the called operation). Here is an overview
of some important changes: \begin{center}
\begin{tabular}{|c|c|}\textsf{GAP} 3&
\textsf{GAP} 4\\
\hline
\texttt{H.S}&
\texttt{MakeSpecht} (\ref{MakeSpecht})\\
\hline
\texttt{H.P}&
\texttt{MakePIM} (\ref{MakePIM})\\
\hline
\texttt{H.D}&
\texttt{MakeSimple} (\ref{MakeSimple})\\
\hline
\texttt{H.Sq}&
\texttt{MakeFockSpecht} (\ref{MakeFockSpecht})\\
\hline
\texttt{H.Pq}&
\texttt{MakeFockPIM} (\ref{MakeFockPIM})\\
\hline
\texttt{S.W}&
\texttt{MakeSpecht} (\ref{MakeSpecht})\\
\hline
\texttt{S.F}&
\texttt{MakeSimple} (\ref{MakeSimple})\\
\hline
\texttt{InducedModule}&
\texttt{RInducedModule} (\ref{RInducedModule})\\
\hline
\texttt{RestrictedModule}&
\texttt{RRestrictedModule} (\ref{RRestrictedModule})\\
\hline
\texttt{H.operations.New}&
\texttt{Module}\\
\hline
\texttt{H.operations.Collect}&
\texttt{Collect}\\
\hline
\end{tabular}\\[2mm]
\end{center}

 }

 }

 
\section{\textcolor{Chapter }{Specht functions}}\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X7A7DF4FC796EF66F}{}
{
  

\subsection{\textcolor{Chapter }{Specht (for an integer)}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X7FE26921867C440A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Specht({\mdseries\slshape e})\index{Specht@\texttt{Specht}!for an integer}
\label{Specht:for an integer}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Specht({\mdseries\slshape e, p})\index{Specht@\texttt{Specht}!for two integers}
\label{Specht:for two integers}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Specht({\mdseries\slshape e, p, val})\index{Specht@\texttt{Specht}!for to integers and a valuation map}
\label{Specht:for to integers and a valuation map}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Specht({\mdseries\slshape e, p, val, ring})\index{Specht@\texttt{Specht}}
\label{Specht}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
object belonging to the filter \texttt{IsHecke} (\ref{IsHecke})



 Let $R$ be a field of characteristic $0$, $q$ a non-zero element of $R$, and let $e$ be the smallest positive integer such that $1+q+\ldots+q^{e-1}=0$ (we set $e=0$ if no such integer exists). The object returned by \texttt{Specht(e)} allows calculations in the Grothendieck rings of the Hecke algebras $H$ of type \emph{A} which are defined over $R$ and have parameter $q$. Below we also describe how to consider Hecke algebras defined over fields of
positive characteristic.

 \texttt{Specht} returns an object which contains information about the the family of Hecke
algebras determined by $R$ and $q$. This object needs to be passed to the most of the \textsf{Hecke} functions as an argument.

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(5);|
  <Hecke algebra with e = 5>
  !gapprompt@gap>| !gapinput@Display(last);|
  Specht(e=5, S(), P(), D())
  !gapprompt@gap>| !gapinput@IsZeroCharacteristic(last);|
  true
\end{Verbatim}
 There is also a method \texttt{Schur} (\ref{Schur}) for doing calculations with the $q$-Schur algebra. See \texttt{DecompositionMatrix} (\ref{DecompositionMatrix}), and \texttt{CrystalDecompositionMatrix} (\ref{CrystalDecompositionMatrix}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  
\subsection{\textcolor{Chapter }{Simple information access}}\logpage{[ 3, 2, 2 ]}
\hyperdef{L}{X8037763587274161}{}
{


 We allow to read/store some information from/in the algebra object returned by \texttt{Specht} (\ref{Specht}) using the following functions.

 \noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OrderOfQ({\mdseries\slshape H})\index{OrderOfQ@\texttt{OrderOfQ}}
\label{OrderOfQ}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
$e$.

\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Characteristic({\mdseries\slshape H})\index{Characteristic@\texttt{Characteristic}}
\label{Characteristic}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
$p$.

\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SetOrdering({\mdseries\slshape H, Ordering})\index{SetOrdering@\texttt{SetOrdering}}
\label{SetOrdering}
}\hfill{\scriptsize (method)}}\\


 Provides writing access to $Ordering$ that is stored in $H$. The ordering influences the way how decomposition matrices are printed.

 \noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SpechtDirectory\index{SpechtDirectory@\texttt{SpechtDirectory}}
\label{SpechtDirectory}
}\hfill{\scriptsize (global variable)}}\\


 Setting this global variable the user can tell \textsf{Hecke} where to find decomposition matrices that are not in the library and also not
in the current directory. By default this variable is set to the current
directory. }

  
\subsection{\textcolor{Chapter }{The functions MakeSpecht, MakePIM and MakeSimple}}\logpage{[ 3, 2, 3 ]}
\hyperdef{L}{X7C92700882971537}{}
{


 The functions MakeSpecht, MakePIM and MakeSimple return objects belonging to
the filter \texttt{IsAlgebraObjModule} (\ref{IsAlgebraObjModule}) which correspond to Specht modules (\texttt{IsHeckeSpecht} (\ref{IsHeckeSpecht})), projective indecomposable modules (\texttt{IsHeckePIM} (\ref{IsHeckePIM})) and simple modules (\texttt{IsHeckeSimple} (\ref{IsHeckeSimple})) respectively. \textsf{Hecke} allows manipulation of arbitrary linear combinations of these ``modules'', as well as a way of inducing and restricting them, ``multiplying'' them and converting between these three natural bases of the Grothendieck
ring. Multiplication of modules corresponds to taking a tensor productand then
inducing (thus giving a module for a larger Hecke algebra). Each of these
three functions can be called in four different ways, as we now describe.

 \noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MakeSpecht({\mdseries\slshape H, mu})\index{MakeSpecht@\texttt{MakeSpecht}}
\label{MakeSpecht}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MakePIM({\mdseries\slshape H, mu})\index{MakePIM@\texttt{MakePIM}}
\label{MakePIM}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MakeSimple({\mdseries\slshape H, mu})\index{MakeSimple@\texttt{MakeSimple}}
\label{MakeSimple}
}\hfill{\scriptsize (method)}}\\


 In the first form, $\mu$ is a partition (either a list, or a sequence of integers) and the
corresponding Specht module, PIM, or simple module (respectively), is
returned. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(5);; MakePIM(H,4,3,2);; Display(last);|
  P(4,3,2)
\end{Verbatim}


 \noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MakeSpecht({\mdseries\slshape x})\index{MakeSpecht@\texttt{MakeSpecht}!for a module}
\label{MakeSpecht:for a module}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MakePIM({\mdseries\slshape x})\index{MakePIM@\texttt{MakePIM}!for a module}
\label{MakePIM:for a module}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MakeSimple({\mdseries\slshape x})\index{MakeSimple@\texttt{MakeSimple}!for a module}
\label{MakeSimple:for a module}
}\hfill{\scriptsize (method)}}\\


 Here, $x$ is an $H$-module. In this form, \texttt{MakeSpecht} rewrites $x$ as a linear combination of Specht modules, if possible. Similarly, \texttt{MakePIM} and \texttt{MakeSimple} rewrite $x$ as a linear combination of PIMs and simple modules respectively. These
conversions require knowledge of the relevant decomposition matrix of $H$; if this is not known then \texttt{fail} is returned (over fields of characteristic zero, all of the decomposition
matrices are known via the algorithm of \cite{LLT}; various other decomposition matrices are included with \textsf{Hecke}). For example, \texttt{MakeSpecht(MakePIM(}$H, \mu$\texttt{))} returns $\sum_\nu d_{\nu\mu} S(\nu)$ or \texttt{fail} if some of these decomposition multiplicities are not known. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Display( MakeSimple( MakePIM(H,4,3,2) ) );|
  D(5,3,1) + 2D(4,3,2) + D(2^4,1)
  !gapprompt@gap>| !gapinput@Display( MakeSpecht( MakeSimple( MakeSpecht(H,1,1,1,1,1) ) ) );|
   - S(5) + S(4,1) - S(3,1^2) + S(2,1^3)
\end{Verbatim}
 As the last example shows, \textsf{Hecke} does not always behave as expected. The reason for this is that Specht modules
indexed by $e$-singular partitions can always be written as a linear combination of Specht
modules which involve only $e$-regular partitions. As such, it is not always clear when two elements are
equal in the Grothendieck ring. Consequently, to test whether two modules are
equal you should first rewrite both modules in the $D$-basis; this is \emph{not} done by \textsf{Hecke} because it would be very inefficient.

 \noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MakeSpecht({\mdseries\slshape d, mu})\index{MakeSpecht@\texttt{MakeSpecht}!for a decomposition matrix}
\label{MakeSpecht:for a decomposition matrix}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MakePIM({\mdseries\slshape d, mu})\index{MakePIM@\texttt{MakePIM}!for a decomposition matrix}
\label{MakePIM:for a decomposition matrix}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MakeSimple({\mdseries\slshape d, mu})\index{MakeSimple@\texttt{MakeSimple}!for a decomposition matrix}
\label{MakeSimple:for a decomposition matrix}
}\hfill{\scriptsize (method)}}\\


 In the third form, $d$ is a decomposition matrix and $\mu$ is a partition. This is useful when you are trying to calculate a new
decomposition matrix $d$ because it allows you to do calculations using the known entries of $d$ to deduce information about the unknown ones. When used in this way, \texttt{MakePIM} and \texttt{MakeSimple} use $d$ to rewrite $P(\mu)$ and $D(\mu)$ respectively as a linear combination of Specht modules and \texttt{MakeSpecht} uses $d$ to write $S(\mu)$ as a linear combination of simple modules. If the values of the unknown
entries in $d$ are needed, \texttt{fail} is returned. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(3,3);;   # e = 3, p = 3 = characteristic of 'R'|
  !gapprompt@gap>| !gapinput@ d:=InducedDecompositionMatrix(DecompositionMatrix(H,14));;|
  # Inducing....
  The following projectives are missing from <d>:
      [ 15 ]  [ 8, 7 ]
  !gapprompt@gap>| !gapinput@Display(MakePIM(d,4,3,3,2,2,1));|
  S(4,3^2,2^2,1) + S(4,3^2,2,1^3) + S(4,3,2^3,1^2) + S(3^3,2^2,1^2)
  !gapprompt@gap>| !gapinput@Display(MakeSpecht(d,7, 3, 3, 2));|
  D(11,2,1^2) + D(10,3,1^2) + D(8,5,1^2) + D(8,3^2,1) + D(7,6,1^2) + D(7,3^2,2)
  !gapprompt@gap>| !gapinput@Display(MakeSimple(d,14,1));|
  fail
\end{Verbatim}
 The final example returned \texttt{fail} because the partitions $(14,1)$ and $(15)$ have the same $3$-core (and $P(15)$ is missing from $d$).

 \noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MakeSpecht({\mdseries\slshape d, x})\index{MakeSpecht@\texttt{MakeSpecht}!for a decomposition matrix and a module}
\label{MakeSpecht:for a decomposition matrix and a module}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MakePIM({\mdseries\slshape d, x})\index{MakePIM@\texttt{MakePIM}!for a decomposition matrix and a module}
\label{MakePIM:for a decomposition matrix and a module}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MakeSimple({\mdseries\slshape d, x})\index{MakeSimple@\texttt{MakeSimple}!for a decomposition matrix and a module}
\label{MakeSimple:for a decomposition matrix and a module}
}\hfill{\scriptsize (method)}}\\


 In the final form, $d$ is a decomposition matrix and $x$ is a module. All three functions rewrite $x$ in their respective basis using $d$. Again this is only useful when you are trying to calculate a new
decomposition matrix because, for any ``known'' decomposition matrix $d$, \texttt{MakeSpecht(}$x$\texttt{)} and \texttt{MakeSpecht(}$d, x$\texttt{)} are equivalent (and similarly for \texttt{MakePIM} and \texttt{MakeSimple}). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Display(MakeSpecht(d, MakeSimple(d,10,5) ));|
   - S(13,2) + S(10,5)
\end{Verbatim}
 }

  
\subsection{\textcolor{Chapter }{Decomposition numbers of the symmetric groups}}\logpage{[ 3, 2, 4 ]}
\hyperdef{L}{X86F599A07A7C1C33}{}
{


 The last example looked at Hecke algebras with parameter $q=1$ and $R$ a field of characteristic $3$ (so $e=3$); that is, the group algebra of the symmetric group over a field of
characteristic $3$. More generally, the command \texttt{Specht(}$p,p$\texttt{)} can be used to consider the group algebras of the symmetric groups over fields
of characteristic $p$ (i.e. $e=p$ and $R$ a field of characteristic $p$). For example, the dimensions of the simple modules of $S_6$ over fields of characteristic $5$ can be computed as follows: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(5,5);; SimpleDimension(H,6);|
  6       : 1
  5,1     : 5
  4,2     : 8
  4,1^2   : 10
  3^2     : 5
  3,2,1   : 8
  3,1^3   : 10
  2^3     : 5
  2^2,1^2 : 1
  2,1^4   : 5
  true
\end{Verbatim}
 }

  
\subsection{\textcolor{Chapter }{Hecke algebras over fields of positive characteristic}}\logpage{[ 3, 2, 5 ]}
\hyperdef{L}{X838BEC0382BF87EA}{}
{


 To consider Hecke algebras defined over arbitrary fields, \texttt{Specht} (\ref{Specht}) must also be supplied with a valuation map $val$ as an argument. The function $val$ is a map from some PID into the natural numbers; at present it is needed only
by functions which rely (at least implicitly), upon the $q$-analogue of Schaper's theorem. In general, $val$ depends upon $q$ and the characteristic of $R$; full details can be found in \cite{JM2}. Over fields of characteristic zero and in the symmetric group case, the
function $val$ is automatically defined by \texttt{Specht} (\ref{Specht}). When $R$ is a field of characteristic zero, $val([i]_q)$ is $1$ if $e$ divides $i$ and $0$ otherwise (this is the valuation map associated to the prime ideal in ${\ensuremath{\mathbb C}}[v]$ generated by the $e$-th cyclotomic polynomial). When $q=1$ and $R$ is a field of characteristic $p$, $val$ is the usual $p$-adic valuation map. As another example, if $q=4$ and $R$ is a field of characteristic $5$ (so $e=2$), then the valuation map sends the integer $x$ to $\nu_5([4]_x)$ where $[4]_x$ is interpreted as an integer and $\nu_5$ is the usual $5$-adic valuation. To consider this Hecke algebra one could proceed as follows: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@val:=function(x) local v;|
  !gapprompt@>| !gapinput@      x:=Sum([0..x-1],v->4^v);  # x->[x]_q|
  !gapprompt@>| !gapinput@      v:=0; while x mod 5=0 do x:=x/5; v:=v+1; od;|
  !gapprompt@>| !gapinput@      return v;|
  !gapprompt@>| !gapinput@    end;;|
  !gapprompt@gap>| !gapinput@H:=Specht(2,5,val,"e2q4");; Display(H);|
  Specht(e=2, p=5, S(), P(), D(), HeckeRing="e2q4")
\end{Verbatim}
 Notice the string ``e2q4'' which was also passed to \texttt{Specht} (\ref{Specht}) in this example. Although it is not strictly necessary, it is a good idea when
using a ``non-standard'' valuation map $val$ to specify the value of $HeckeRing$. This string is used for internal bookkeeping by \textsf{Hecke}; in particular, it is used to determine filenames when reading and saving
decomposition matrices. If a ``standard'' valuation map is used then $HeckeRing$ is set to the string ``e{\textless}e{\textgreater}p{\textless}p{\textgreater}''; otherwise it defaults to ``unknown''. The function \texttt{SaveDecompositionMatrix} (\ref{SaveDecompositionMatrix}) will not save any decomposition matrix for any Hecke algebra $H$ with $HeckeRing=$``unknown''. }

  
\subsection{\textcolor{Chapter }{The Fock space and Hecke algebras over fields of characteristic zero }}\logpage{[ 3, 2, 6 ]}
\hyperdef{L}{X83009CE685621BD4}{}
{


 For Hecke algebras $H$ defined over fields of characteristic zero Lascoux, Leclerc and Thibon \cite{LLT} have described an easy, inductive, algorithm for calculating the decomposition
matrices of $H$. Their algorithm really calculates the \emph{canonical basis}, or (global) \emph{crystal basis} of the Fock space; results of Grojnowski-Lusztig \cite{Gr} show that computing this basis is equivalent to computing the decomposition
matrices of $H$ (see also \cite{A}).

 The \emph{Fock space} $\mathcal{F} $ is an (integrable) module for the quantum group $U_q(\widehat{sl} _{e})$ of the affine special linear group. $\mathcal{F} $ is a free ${\ensuremath{\mathbb C}}[v]$-module with basis the set of all Specht modules $S(\mu)$ for all partitions $\mu$ of all integers:

 $\mathcal{F}= \bigoplus_{n\geq0}\bigoplus_{\mu\vdash n}\mathbb{C}[v]S(\mu)$

 Here $v$ is an indeterminate over the integers (or strictly, ${\ensuremath{\mathbb C}}$) that is stored in the algebra object produced by \texttt{Specht} (\ref{Specht}). The canonical basis elements $Pq(\mu)$ for the $U_q( \widehat{sl}_e)$-submodule of $\mathcal{F} $ generated by the $0$-partition are indexed by $e$-regular partitions $\mu$. Moreover, under \emph{specialization}, $Pq(\mu)$ maps to $P(\mu)$. An eloquent description of the algorithm for computing $Pq(\mu)$ can be found in \cite{LLT}.

 To access the elements of the Fock space \textsf{Hecke} provides the functions:

 \noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MakeFockPIM({\mdseries\slshape H, mu})\index{MakeFockPIM@\texttt{MakeFockPIM}}
\label{MakeFockPIM}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MakeFockSpecht({\mdseries\slshape H, mu})\index{MakeFockSpecht@\texttt{MakeFockSpecht}}
\label{MakeFockSpecht}
}\hfill{\scriptsize (method)}}\\


 Notice that, unlike \texttt{MakePIM} (\ref{MakePIM}) and \texttt{MakeSpecht} (\ref{MakeSpecht}), the only arguments which \texttt{MakeFockPIM} and \texttt{MakeFockSpecht} accept are partitions.

 The function \texttt{MakeFockPIM} computes the canonical basis element $Pq(\mu)$ of the Fock space corresponding to the $e$-regular partition $\mu$ (there is a canonical basis -- defined using a larger quantum group -- for the
whole of the Fock space \cite{LT}; conjecturally, this basis can be used to compute the decomposition matrices
for the $q$-Schur algebra over fields of characteristic zero). The second function
returns a standard basis element $Sq(\mu)$ of $\mathcal{F}$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(4);; MakeFockPIM(H,6,2);; Display(last);|
  Sq(6,2) + vSq(5,3)
  !gapprompt@gap>| !gapinput@RRestrictedModule(last); Display(last);|
  Sq(6,1) + (v+v^-1)Sq(5,2) + vSq(4,3)
  !gapprompt@gap>| !gapinput@MakePIM(last);; Display(last);|
  Pq(6,1) + (v+v^-1)Pq(5,2)
  !gapprompt@gap>| !gapinput@Specialized(last);; Display(last);|
  P(6,1) + 2P(5,2)
  !gapprompt@gap>| !gapinput@MakeFockSpecht(H,5,3,2);; Display(last);|
  Sq(5,3,2)
  !gapprompt@gap>| !gapinput@RInducedModule(last,0);; Display(last);|
  v^-1Sq(5,3^2)
\end{Verbatim}
 The modules returned by \texttt{MakeFockPIM} and \texttt{MakeFockSpecht} behave very much like elements of the Grothendieck ring of $H$; however, they should be considered as elements of the Fock space. The key
difference is that when induced or restricted ``quantum'' analogues of induction and restriction are used. These analogues correspond to
the action of $U_q( \widehat{sl}_{e})$ on $\mathcal{F} $ \cite{LLT}.

 In effect, the functions \texttt{MakeFockPIM} and \texttt{MakeFockSpecht} allow computations in the Fock space, using the functions \texttt{RInducedModule} (\ref{RInducedModule}) and \texttt{RRestrictedModule} (\ref{RRestrictedModule}). The functions \texttt{MakeSpecht} (\ref{MakeSpecht}), \texttt{MakePIM} (\ref{MakePIM}) and \texttt{MakeSimple} (\ref{MakeSimple}) can also be applied to elements of the Fock space, in which case they have the
expected effect. In addition, any element of the Fock space can be specialized
to give the corresponding element of the Grothendieck ring of $H$ (it is because of this correspondence that we do not make a distinction
between elements of the Fock space and the Grothendieck ring of $H$).

 When working over fields of characteristic zero \textsf{Hecke} will automatically calculate any canonical basis elements that it needs for
computations in the Grothendieck ring of $H$. If you are not interested in the canonical basis elements you need never
work with them directly. }

  

\subsection{\textcolor{Chapter }{Schur (for an integer)}}
\logpage{[ 3, 2, 7 ]}\nobreak
\hyperdef{L}{X7B57DF517F73F00D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Schur({\mdseries\slshape e})\index{Schur@\texttt{Schur}!for an integer}
\label{Schur:for an integer}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Schur({\mdseries\slshape e, p})\index{Schur@\texttt{Schur}!for two integers}
\label{Schur:for two integers}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Schur({\mdseries\slshape e, p, val})\index{Schur@\texttt{Schur}!for to integers and a valuation map}
\label{Schur:for to integers and a valuation map}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Schur({\mdseries\slshape e, p, val, ring})\index{Schur@\texttt{Schur}}
\label{Schur}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
object belonging to the filter \texttt{IsSchur} (\ref{IsSchur})



 This function behaves almost identically to the function \texttt{Specht} (\ref{Specht}), the only difference being that the belonging modules are printed as ``W'', ``P'', ``F'' and that they correspond to the $q$-Weyl modules, the projective indecomposable modules, and the simple modules
of the $q$-Schur algebra respectively. Note that the \texttt{Make***}-functions (i.e. \texttt{MakeSpecht} (\ref{MakeSpecht}) is used to generate $q$-Weyl modules). Further, note that our labeling of these modules is
non-standard, following that used by James in \cite{J}. The standard labeling can be obtained from ours by replacing all partitions
by their conjugates.

 Almost all of the functions in \textsf{Hecke} which accept a Hecke algebra object $H$ will also accept the object $S$ returned by \texttt{Schur} .

 In the current version of \textsf{Hecke} the decomposition matrices of $q$ -Schur algebras are not fully supported. The \texttt{InducedDecompositionMatrix} (\ref{InducedDecompositionMatrix}) function can be applied to these matrices; however there are no additional
routines available for calculating the columns corresponding to $e$-singular partitions. The decomposition matrices for the $q$-Schur algebras defined over a field of characteristic $0$ for $n\leq 10$ are in the \textsf{Hecke} libraries. 
\begin{Verbatim}[commandchars=!@A,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>A !gapinput@S:=Schur(2);A
  <Schur algebra with e = 2>
  !gapprompt@gap>A !gapinput@InducedDecompositionMatrix(DecompositionMatrix(S,3));A
  # The following projectives are missing from <d>:
  #  [ 2, 2 ]
  <5x5 decomposition matrix>
  !gapprompt@gap>A !gapinput@Display(last);A
  4    | 1                   # DecompositionMatrix(S,4) returns the
  3,1  | 1 1                 # full decomposition matrix. The point
  2^2  | . 1 .               # of this example is to emphasize the
  2,1^2| 1 1 . 1             # current limitations of Schur.
  1^4  | 1 . . 1 1
\end{Verbatim}
 Note that when $S$ is defined over a field of characteristic zero then the functions \texttt{MakeFockSpecht} (\ref{MakeFockSpecht}) and \texttt{MakeFockPIM} (\ref{MakeFockPIM}) will calculate the canonical basis elements (see \texttt{Specht} (\ref{Specht})); currently \texttt{MakeFockPIM(}$\mu$\texttt{)} is implemented only for $e$-regular partitions.

 See also \texttt{Specht} (\ref{Specht}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{DecompositionMatrix (for an algebra and an integer)}}
\logpage{[ 3, 2, 8 ]}\nobreak
\hyperdef{L}{X84F0F9E47D5EEBCF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DecompositionMatrix({\mdseries\slshape H, n[, Ordering]})\index{DecompositionMatrix@\texttt{DecompositionMatrix}!for an algebra and an integer}
\label{DecompositionMatrix:for an algebra and an integer}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DecompositionMatrix({\mdseries\slshape H, file[, Ordering]})\index{DecompositionMatrix@\texttt{DecompositionMatrix}}
\label{DecompositionMatrix}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 the decomposition matrix $D$ of $H(S_n)$ where $H$ is a Hecke algebra object returned by the function \texttt{Specht} (\ref{Specht}) (or \texttt{Schur} (\ref{Schur}) ).



 \texttt{DecompositionMatrix} first checks whether the required decomposition matrix exists as a library
file (checking first in the current directory, next in the directory specified
by \texttt{SpechtDirectory} (\ref{SpechtDirectory}), and finally in the \textsf{Hecke} libraries). If the base field of $H$ has characteristic zero, \texttt{DecompositionMatrix} next looks for \emph{crystallized decomposition matrices} (see \texttt{CrystalDecompositionMatrix} (\ref{CrystalDecompositionMatrix})). If the decomposition matrix $d$ is not stored in the library \texttt{DecompositionMatrix} will calculate $d$ when $H$ is a Hecke algebra with a base field of characteristic zero, and will return \texttt{fail} otherwise (in which case the function \texttt{CalculateDecompositionMatrix} (\ref{CalculateDecompositionMatrix}) can be used to force \textsf{Hecke} to try and calculate this matrix).

 For Hecke algebras defined over fields of characteristic zero, \textsf{Hecke} uses the algorithm of \cite{LLT} to calculate decomposition matrices The decomposition matrices for the $q$-Schur algebras for $n\leq10$ are contained in the \textsf{Hecke} library, as are those for the symmetric group over fields of positive
characteristic when $n<15$.

 Once a decomposition matrix is known, \textsf{Hecke} keeps an internal copy of it which is used by the functions \texttt{MakeSpecht} (\ref{MakeSpecht}), \texttt{MakePIM} (\ref{MakePIM}), and \texttt{MakeSimple} (\ref{MakeSimple}); these functions also read decomposition matrix files as needed.

 If you set the variable \texttt{SpechtDirectory} (\ref{SpechtDirectory}), then \textsf{Hecke} will also search for decomposition matrix files in this directory. The files
in the current directory override those in \texttt{SpechtDirectory} (\ref{SpechtDirectory}) and those in the \textsf{Hecke} libraries.

 In the second form of the function, when a $filename$ is supplied, \texttt{DecompositionMatrix} will read the decomposition matrix in the file $filename$, and this matrix will become \textsf{Hecke}'s internal copy of this matrix.

 By default, the rows and columns of the decomposition matrices are ordered \texttt{DecompositionMatrix} with an ordering function such as \texttt{LengthLexicographic} (\ref{LengthLexicographic}) or \texttt{ReverseDominance} (\ref{ReverseDominance}). You do not need to specify the ordering you want every time you call \texttt{DecompositionMatrix}; \textsf{Hecke} will keep the same ordering until you change it again. This ordering can also
be set ``by hand'' using the operation \texttt{SetOrdering} (\ref{SetOrdering}) 
\begin{Verbatim}[commandchars=!@A,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>A !gapinput@DecompositionMatrix(Specht(3),6,LengthLexicographic);A
  <11x7 decomposition matrix>
  !gapprompt@gap>A !gapinput@Display(last);A
  6      | 1
  5,1    | 1 1
  4,2    | . . 1
  3^2    | . 1 . 1
  4,1^2  | . 1 . . 1
  3,2,1  | 1 1 . 1 1 1
  2^3    | 1 . . . . 1
  3,1^3  | . . . . 1 1
  2^2,1^2| . . . . . . 1
  2,1^4  | . . . 1 . 1 .
  1^6    | . . . 1 . . .
\end{Verbatim}
 Once you have a decomposition matrix it is often nice to be able to print it.
The on screen version is often good enough;  There are also functions for converting \textsf{Hecke} decomposition matrices into \textsf{GAP} matrices and vice versa (see \texttt{MatrixDecompositionMatrix} (\ref{MatrixDecompositionMatrix}) and \texttt{DecompositionMatrixMatrix} (\ref{DecompositionMatrixMatrix})).

 Using the function \texttt{InducedDecompositionMatrix} (\ref{InducedDecompositionMatrix}), it is possible to induce a decomposition matrix. See also \texttt{SaveDecompositionMatrix} (\ref{SaveDecompositionMatrix}) and \texttt{IsNewIndecomposable} (\ref{IsNewIndecomposable}), \texttt{Specht} (\ref{Specht}), \texttt{Schur} (\ref{Schur}), and \texttt{CrystalDecompositionMatrix} (\ref{CrystalDecompositionMatrix}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{CrystalDecompositionMatrix}}
\logpage{[ 3, 2, 9 ]}\nobreak
\hyperdef{L}{X7F616CCE808FA11E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CrystalDecompositionMatrix({\mdseries\slshape H, n[, Ordering]})\index{CrystalDecompositionMatrix@\texttt{CrystalDecompositionMatrix}}
\label{CrystalDecompositionMatrix}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CrystalDecompositionMatrix({\mdseries\slshape H, file[, Ordering]})\index{CrystalDecompositionMatrix@\texttt{CrystalDecompositionMatrix}!for an algebra and a filename}
\label{CrystalDecompositionMatrix:for an algebra and a filename}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 the crystal decomposition matrix $D$ of $H(S_n)$ where $H$ is a Hecke algebra object returned by the function \texttt{Specht} (\ref{Specht}) (or \texttt{Schur} (\ref{Schur}) ).



 This function is similar to \texttt{DecompositionMatrix} (\ref{DecompositionMatrix}). The columns of decomposition matrices correspond to projective
indecomposables; the columns of crystallized decomposition matrices correspond
to the canonical basis elements of the Fock space (see \texttt{Specht} (\ref{Specht:for an integer})). Consequently, the entries in these matrices are polynomials (in $v$), and by specializing (i.e. setting $v$ equal to $1$; see \texttt{Specialized} (\ref{Specialized})), the decomposition matrices of $H$ are obtained (see \texttt{Specht} (\ref{Specht})). Crystallized decomposition matrices are defined only for Hecke algebras
over a base field of characteristic zero. Unlike ``normal'' decomposition matrices, crystallized decomposition matrices cannot be induced. 
\begin{Verbatim}[commandchars=!@A,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>A !gapinput@CrystalDecompositionMatrix(Specht(3), 6);A
  <11x7 decomposition matrix>
  !gapprompt@gap>A !gapinput@Display(last);A
  6      |   1
  5,1    |   v   1
  4,2    |   .   .   1
  4,1^2  |   .   v   .   1
  3^2    |   .   v   .   .   1
  3,2,1  |   v v^2   .   v   v   1
  3,1^3  |   .   .   . v^2   .   v
  2^3    | v^2   .   .   .   .   v
  2^2,1^2|   .   .   .   .   .   .   1
  2,1^4  |   .   .   .   .   v v^2   .
  1^6    |   .   .   .   . v^2   .   .
  !gapprompt@gap>A !gapinput@Specialized(last);   # set v equal to 1.A
  <11x7 decomposition matrix>
  !gapprompt@gap>A !gapinput@Display(last);A
  6      | 1
  5,1    | 1 1
  4,2    | . . 1
  4,1^2  | . 1 . 1
  3^2    | . 1 . . 1
  3,2,1  | 1 1 . 1 1 1
  3,1^3  | . . . 1 . 1
  2^3    | 1 . . . . 1
  2^2,1^2| . . . . . . 1
  2,1^4  | . . . . 1 1 .
  1^6    | . . . . 1 . .
\end{Verbatim}
 See also \texttt{Specht} (\ref{Specht}), \texttt{Schur} (\ref{Schur}), \texttt{DecompositionMatrix} (\ref{DecompositionMatrix}) and \texttt{Specialized} (\ref{Specialized}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{DecompositionNumber}}
\logpage{[ 3, 2, 10 ]}\nobreak
\label{DecompositionNumber}
\hyperdef{L}{X829A23A97EE4C20E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DecompositionNumber({\mdseries\slshape H, mu, nu})\index{DecompositionNumber@\texttt{DecompositionNumber}}
\label{DecompositionNumber}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DecompositionNumber({\mdseries\slshape d, mu, nu})\index{DecompositionNumber@\texttt{DecompositionNumber}!for a decomposition matrix}
\label{DecompositionNumber:for a decomposition matrix}
}\hfill{\scriptsize (method)}}\\


 This function attempts to calculate the decomposition multiplicity of $D(\nu)$ in $S(\mu)$ (equivalently, the multiplicity of $S(\mu)$ in $P(\nu)$). If $P(\nu)$ is known, we just look up the answer; if not \texttt{DecompositionNumber} tries to calculate the answer using ``row and column removal'' (see \cite[Theorem 6.18]{J}).

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(6);; DecompositionNumber(H,[6,4,2],[6,6]);|
  0
\end{Verbatim}
 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

 }

  
\section{\textcolor{Chapter }{Partitions in \textsf{Hecke}}}\label{partitions}
\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X78B0F76B826C620C}{}
{
  Many of the functions in \textsf{Hecke} take partitions as arguments. Partitions are usually represented by lists in \textsf{GAP}. In \textsf{Hecke}, all the functions which expect a partition will accept their argument either
as a list or simply as a sequence of numbers. So, for example: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(4);; Print(MakeSpecht(MakePIM(H,6,4)),"\n");|
  S(6,4) + S(6,3,1) + S(5,3,1,1) + S(3,3,2,1,1) + S(2,2,2,2,2)
  !gapprompt@gap>| !gapinput@Print(MakeSpecht(MakePIM(H,[6,4])),"\n");|
  S(6,4) + S(6,3,1) + S(5,3,1,1) + S(3,3,2,1,1) + S(2,2,2,2,2)
\end{Verbatim}
 Some functions require more than one argument, but the convention still
applies. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ECore(3, [6,4,2]);|
  [ 6, 4, 2 ]
  !gapprompt@gap>| !gapinput@ECore(3, 6,4,2);|
  [ 6, 4, 2 ]
  !gapprompt@gap>| !gapinput@GoodNodes(3, 6,4,2);|
  [ false, false, 3 ]
  !gapprompt@gap>| !gapinput@GoodNodes(3, [6,4,2], 2);|
  3
\end{Verbatim}
 Basically, it never hurts to put the extra brackets in, and they can be
omitted so long as this is not ambiguous. One function where the brackets are
needed is \texttt{DecompositionNumber} (\ref{DecompositionNumber}) this is clear because the function takes two partitions as its arguments. }

 
\section{\textcolor{Chapter }{Inducing and restricting modules}}\label{induce}
\logpage{[ 3, 4, 0 ]}
\hyperdef{L}{X87A6E8DD85F3F020}{}
{
  \textsf{Hecke} provides four functions \texttt{RInducedModule} (\ref{RInducedModule}), \texttt{RRestrictedModule} (\ref{RRestrictedModule}), \texttt{SInducedModule} (\ref{SInducedModule}) and \texttt{SRestrictedModule} (\ref{SRestrictedModule}) for inducing and restricting modules. All functions can be applied to Specht
modules, PIMs, and simple modules. These functions all work by first rewriting
all modules as a linear combination of Specht modules (or $q$-Weyl modules), and then inducing and restricting. Whenever possible the
induced or restricted module will be written in the original basis.

 All of these functions can also be applied to elements of the Fock space (see \texttt{Specht} (\ref{Specht})); in which case they correspond to the action of the generators $E_i$ and $F_i$ of $U_q( \widehat{sl}_{e})$ on $\mathcal{F} $. There is also a function \texttt{InducedDecompositionMatrix} (\ref{InducedDecompositionMatrix}) for inducing decomposition matrices.  

\subsection{\textcolor{Chapter }{RInducedModule}}
\logpage{[ 3, 4, 1 ]}\nobreak
\hyperdef{L}{X81D7F7A4812BB04D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RInducedModule({\mdseries\slshape x})\index{RInducedModule@\texttt{RInducedModule}}
\label{RInducedModule}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RInducedModule({\mdseries\slshape x, r1[, r2, ...]})\index{RInducedModule@\texttt{RInducedModule}!for residues}
\label{RInducedModule:for residues}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the induced modules of the Specht modules, principal indecomposable modules,
and simple modules (more accurately, their image in the Grothendieck ring).



 There is an natural embedding of $H(S_n)$ in $H(S_{n+1})$ which in the usual way lets us define an \emph{induced} $H(S_{n+1})$-module for every $H(S_n)$-module.

 There is also a function \texttt{SInducedModule} (\ref{SInducedModule}) which provides a much faster way of $r$-inducing $s$ times (and inducing $s$ times).

 Let $\mu$ be a partition. Then the induced module \texttt{RInducedModule(S(}$\mu$\texttt{))} is easy to describe: it has the same composition factors as $\sum S(\nu)$ where $\nu$ runs over all partitions whose diagrams can be obtained by adding a single
node to the diagram of $\mu$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(2,2);;|
  !gapprompt@gap>| !gapinput@Display(RInducedModule(MakeSpecht(H,7,4,3,1)));|
  S(8,4,3,1) + S(7,5,3,1) + S(7,4^2,1) + S(7,4,3,2) + S(7,4,3,1^2)
  !gapprompt@gap>| !gapinput@Display(RInducedModule(MakePIM(H,5,3,1)));|
  P(6,3,1) + 2P(5,4,1) + P(5,3,2)
  !gapprompt@gap>| !gapinput@Display(RInducedModule(MakeSimple(H,11,2,1)));|
  # D(<x>), unable to rewrite <x> as a sum of simples
  S(12,2,1) + S(11,3,1) + S(11,2^2) + S(11,2,1^2)
\end{Verbatim}
 When inducing indecomposable modules and simple modules, \texttt{RInducedModule} first rewrites these modules as a linear combination of Specht modules (using
known decomposition matrices), and then induces this linear combination of
Specht modules. If possible \textsf{Hecke} then rewrites the induced module back in the original basis. Note that in the
last example above, the decomposition matrix for $S_{15}$ is not known by \textsf{Hecke} this is why \texttt{RInducedModule} was unable to rewrite this module in the $D$-basis.

 \emph{$r$-Induction}

 Two Specht modules $S(\mu)$ and $S(\nu)$ belong to the same block if and only if the corresponding partitions $\mu$ and $\nu$ have the same $e$-core \cite{JM2} (see \texttt{ECore} (\ref{ECore})). Because the $e$-core of a partition is determined by its (multiset of) $e$ -residues, if $S(\mu)$ and $S(\nu)$ appear in \texttt{RInducedModule(S(}$\tau$\texttt{))}, for some partition $\tau$, then $S(\mu)$ and $S(nu)$ belong to the same block if and only if $\mu$ and $\nu$ can be obtained by adding a node of the same $e$-residue to the diagram of $\tau$. The second form of \texttt{RInducedModule} allows one to induce ``within blocks'' by only adding nodes of some fixed $e$-residue $r$; this is known as \emph{r-induction}. Note that $0\leq r<e$.

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(4);; Display(RInducedModule(MakeSpecht(H,5,2,1)));|
  S(6,2,1) + S(5,3,1) + S(5,2^2) + S(5,2,1^2)
  !gapprompt@gap>| !gapinput@Display(RInducedModule(MakeSpecht(H,5,2,1),0));|
  0S()
  !gapprompt@gap>| !gapinput@Display(RInducedModule(MakeSpecht(H,5,2,1),1));|
  S(6,2,1) + S(5,3,1) + S(5,2,1^2)
  !gapprompt@gap>| !gapinput@Display(RInducedModule(MakeSpecht(H,5,2,1),2));|
  0S()
  !gapprompt@gap>| !gapinput@Display(RInducedModule(MakeSpecht(H,5,2,1),3));|
  S(5,2^2)
\end{Verbatim}
 The function \texttt{EResidueDiagram} (\ref{EResidueDiagram}), prints the diagram of $\mu$, labeling each node with its $e$-residue. A quick check of this diagram confirms the answers above. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@EResidueDiagram(H,5,2,1);|
    0  1  2  3  0
    3  0
    2
  true
\end{Verbatim}
 \emph{``Quantized'' induction}

 When \texttt{RInducedModule} is applied to the canonical basis elements \texttt{MakeFockPIM(}$\mu$\texttt{)} (or more generally elements of the Fock space; see \texttt{Specht} (\ref{Specht})), a ``quantum analogue'' of induction is applied. More precisely, the function \texttt{RInducedModule(}$*,i$\texttt{)} corresponds to the action of the generator $F_i$ of the quantum group $U_q( \widehat{sl}_{e})$ on $\mathcal{F} $ \cite{LLT}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(3);; x:=RInducedModule(MakeFockPIM(H,4,2),1,2);;|
  !gapprompt@gap>| !gapinput@Display(x); Display(MakePIM(x));|
  Sq(6,2) + vSq(4^2) + v^2Sq(4,2^2)
  Pq(6,2)
\end{Verbatim}
 See also \texttt{SInducedModule} (\ref{SInducedModule}), \texttt{RRestrictedModule} (\ref{RRestrictedModule}) and \texttt{SRestrictedModule} (\ref{SRestrictedModule}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{SInducedModule}}
\logpage{[ 3, 4, 2 ]}\nobreak
\hyperdef{L}{X780709B3865BC344}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SInducedModule({\mdseries\slshape x, s})\index{SInducedModule@\texttt{SInducedModule}}
\label{SInducedModule}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SInducedModule({\mdseries\slshape x, s, r})\index{SInducedModule@\texttt{SInducedModule}!for residues}
\label{SInducedModule:for residues}
}\hfill{\scriptsize (method)}}\\


 The function \texttt{SInducedModule}, standing for ``string induction'', provides a more efficient way of $r$-inducing $s$ times (and a way of inducing $s$ times if the residue $r$ is omitted); $r$-induction is explained in "\texttt{RInducedModule} (\ref{RInducedModule}). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SizeScreen([80,20]);;|
  !gapprompt@gap>| !gapinput@H:=Specht(4);; Display(SInducedModule(MakePIM(H,5,2,1),3));|
  P(8,2,1) + 3P(7,3,1) + 2P(7,2^2) + 6P(6,3,2) + 6P(6,3,1^2) + 3P(6,2,1^3) + 2P(\
  5,3^2) + P(5,2^2,1^2)
  !gapprompt@gap>| !gapinput@Display(SInducedModule(MakePIM(H,5,2,1),3,1));|
  P(6,3,1^2)
  !gapprompt@gap>| !gapinput@Display(RInducedModule(MakePIM(H,5,2,1),1,1,1));|
  6P(6,3,1^2)
\end{Verbatim}
 Note that the multiplicity of each summand of \texttt{RInducedModule(}$x,r,\ldots,r$\texttt{)} is divisible by $s!$ and that \texttt{SInducedModule} divides by this constant.

 As with \texttt{RInducedModule} (\ref{RInducedModule}) this function can also be applied to elements of the Fock space (see \texttt{Specht} (\ref{Specht})), in which case the quantum analogue of induction is used.

 See also \texttt{RInducedModule} (\ref{RInducedModule}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{RRestrictedModule}}
\logpage{[ 3, 4, 3 ]}\nobreak
\hyperdef{L}{X783BC74E81A7D0E6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RRestrictedModule({\mdseries\slshape x})\index{RRestrictedModule@\texttt{RRestrictedModule}}
\label{RRestrictedModule}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RRestrictedModule({\mdseries\slshape x, r1[, r2, ...]})\index{RRestrictedModule@\texttt{RRestrictedModule}!for residues}
\label{RRestrictedModule:for residues}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the corresponding module for $H(S_{n-1})$ when given a module $x$ for $H(S_n)$



 The restriction of the Specht module $S(\mu)$ is the linear combination of Specht modules $\sum S(\nu)$ where $\nu$ runs over the partitions whose diagrams are obtained by deleting a node from
the diagram of $\mu$. If only nodes of residue $r$ are deleted then this corresponds to first restricting $S(\mu)$ and then taking one of the block components of the restriction; this process
is known as \emph{$r$-restriction} (cf. $r$-induction in \texttt{RInducedModule} (\ref{RInducedModule})).

 There is also a function \texttt{SRestrictedModule} (\ref{SRestrictedModule}) which provides a faster way of $r$-restricting $s$ times (and restricting $s$ times).

 When more than one residue if given to \texttt{RRestrictedModule} it returns \texttt{RRestrictedModule(}$x,r_1,r_2,\ldots,r_k$\texttt{)}= \texttt{RRestrictedModule( RRestrictedModule(}$x,r_1$\texttt{)}$,r_2,\ldots,r_k$\texttt{)} (cf. \texttt{RInducedModule} (\ref{RInducedModule})). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(6);; Display(RRestrictedModule(MakePIM(H,5,3,2,1),4));|
  2P(4,3,2,1)
  !gapprompt@gap>| !gapinput@Display(RRestrictedModule(MakeSimple(H,5,3,2),1));|
  D(5,2^2)
\end{Verbatim}
 \emph{``Quantized'' restriction}

 As with \texttt{RInducedModule} (\ref{RInducedModule}), when \texttt{RRestrictedModule} is applied to the canonical basis elements \texttt{MakeFockPIM(}$\mu$\texttt{)} a quantum analogue of restriction is applied; this time, \texttt{RRestrictedModule(}$*,i$\texttt{)} corresponds to the action of the generator $E_i$ of $U_q(\widehat{sl} _{e})$ on $\mathcal{F} $\cite{LLT}.

 See also \texttt{RInducedModule} (\ref{RInducedModule}), \texttt{SInducedModule} (\ref{SInducedModule}) and \texttt{SRestrictedModule} (\ref{SRestrictedModule}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{SRestrictedModule}}
\logpage{[ 3, 4, 4 ]}\nobreak
\hyperdef{L}{X8041ABFA86D7A3EF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SRestrictedModule({\mdseries\slshape x, s})\index{SRestrictedModule@\texttt{SRestrictedModule}}
\label{SRestrictedModule}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SRestrictedModule({\mdseries\slshape x, s, r})\index{SRestrictedModule@\texttt{SRestrictedModule}!for residues}
\label{SRestrictedModule:for residues}
}\hfill{\scriptsize (method)}}\\


 As with \texttt{SInducedModule} (\ref{SInducedModule}) this function provides a more efficient way of $r$-restricting $s$ times, or restricting $s$ times if the residue $r$ is omitted (cf. \texttt{SInducedModule} (\ref{SInducedModule})). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(6);; Display(SRestrictedModule(MakeSpecht(H,4,3,2),3));|
  3S(4,2) + 2S(4,1^2) + 3S(3^2) + 6S(3,2,1) + 2S(2^3)
  !gapprompt@gap>| !gapinput@Display(SRestrictedModule(MakePIM(H,5,4,1),2,4));|
  P(4^2)
\end{Verbatim}
 See also \texttt{RInducedModule} (\ref{RInducedModule}), \texttt{SInducedModule} (\ref{SInducedModule}) and \texttt{RRestrictedModule} (\ref{RRestrictedModule}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

 }

  
\section{\textcolor{Chapter }{Operations on decomposition matrices}}\logpage{[ 3, 5, 0 ]}
\hyperdef{L}{X79F430837BA7BAD2}{}
{
  \textsf{Hecke} is a package for computing decomposition matrices; this section describes the
functions available for accessing these matrices directly. In addition to
decomposition matrices, \textsf{Hecke} also calculates the ``crystallized decomposition matrices'' of \cite{LLT} and the ``adjustment matrices'' introduced by James \cite{J} (and Geck \cite{G}).

 Throughout \textsf{Hecke} we place an emphasis on calculating the projective indecomposable modulesand
hence upon the columns of decomposition matrices. This approach seems more
efficient than the traditional approach of calculating decomposition matrices
by rows; ideally both approaches should be combined (as is done by \texttt{IsNewIndecomposable} (\ref{IsNewIndecomposable})).

 In principle, all decomposition matrices for all Hecke algebras defined over a
field of characteristic zero are available from within \textsf{Hecke}. In addition, the decomposition matrices for all $q$-Schur algebras with $n\leq10$ and all values of $e$ and the $p$-modular decomposition matrices of the symmetric groups $S_n$ for $n<15$ are in the \textsf{Hecke} library files.

 If you are using \textsf{Hecke} regularly to do calculations involving certain values of $e$ it would be advantageous to have \textsf{Hecke} calculate and save the first 20 odd decomposition matrices that you are
interested in. So, for $e=4$ use the commands: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(4);; for n in [8..20] do|
  !gapprompt@>| !gapinput@     SaveDecompositionMatrix(DecompositionMatrix(H,n));|
  !gapprompt@>| !gapinput@   od;|
\end{Verbatim}
 Alternatively, you could save the crystallized decomposition matrices. Note
that for $n<2e$ the decomposition matrices are known (by \textsf{Hecke}) and easy to compute.  

\subsection{\textcolor{Chapter }{InducedDecompositionMatrix}}
\logpage{[ 3, 5, 1 ]}\nobreak
\hyperdef{L}{X7D257389845738DB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{InducedDecompositionMatrix({\mdseries\slshape d})\index{InducedDecompositionMatrix@\texttt{InducedDecompositionMatrix}}
\label{InducedDecompositionMatrix}
}\hfill{\scriptsize (method)}}\\


 If $d$ is the decomposition matrix of $H(S_n)$, then \texttt{InducedDecompositionMatrix(}$d$\texttt{)} attempts to calculate the decomposition matrix of $H(S_{n+1})$. It does this by extracting each projective indecomposable from $d$ and inducing these modules to obtain projective modules for $H(S_{n+1})$. \texttt{InducedDecompositionMatrix} then tries to decompose these projectives using the function \texttt{IsNewIndecomposable} (\ref{IsNewIndecomposable}). In general there will be columns of the decomposition matrix which \texttt{InducedDecompositionMatrix} is unable to decompose and these will have to be calculated ``by hand''. \texttt{InducedDecompositionMatrix} prints a list of those columns of the decomposition matrix which it is unable
to calculate (this list is also printed by the function \texttt{MissingIndecomposables} (\ref{MissingIndecomposables})). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@d:=DecompositionMatrix(Specht(3,3),14);|
  <135x57 decomposition matrix>
  !gapprompt@gap>| !gapinput@InducedDecompositionMatrix(d);|
  # Inducing....
  The following projectives are missing from <d>:
      [ 15 ]  [ 8, 7 ]
  <176x70 decomposition matrix>
\end{Verbatim}
 Note that the missing indecomposables come in ``pairs'' which map to each other under the Mullineux map (see \texttt{MullineuxMap} (\ref{MullineuxMap})).

 Almost all of the decomposition matrices included in \textsf{Hecke} were calculated directly by \texttt{InducedDecompositionMatrix}. When $n$ is ``small'' \texttt{InducedDecompositionMatrix} is usually able to return the full decomposition matrix for $H(S_n)$. Finally, although the \texttt{InducedDecompositionMatrix} can also be applied to the decomposition matrices of the $q$-Schur algebras (see \texttt{Schur} (\ref{Schur})), \texttt{InducedDecompositionMatrix} is much less successful in inducing these decomposition matrices because it
contains no special routines for dealing with the indecomposable modules of
the $q$-Schur algebra which are indexed by $e$-singular partitions. Note also that we use a non-standard labeling of the
decomposition matrices of $q$-Schur algebras; see \texttt{Schur} (\ref{Schur}). }

  

\subsection{\textcolor{Chapter }{IsNewIndecomposable}}
\logpage{[ 3, 5, 2 ]}\nobreak
\hyperdef{L}{X803A99987E501AC9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsNewIndecomposable({\mdseries\slshape d, x[, mu]})\index{IsNewIndecomposable@\texttt{IsNewIndecomposable}}
\label{IsNewIndecomposable}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} if it is able to show that $x$ is indecomposable (and this indecomposable is not already listed in $d$), and \texttt{false} otherwise.



 \texttt{IsNewIndecomposable} is the function which does all of the hard work when the function \texttt{InducedDecompositionMatrix} (\ref{InducedDecompositionMatrix}) is applied to decomposition matrices. \texttt{IsNewIndecomposable} will also print a brief description of its findings, giving an upper and lower
bound on the \emph{first} decomposition number $\mu$ for which it is unable to determine the multiplicity of $S(\mu)$ in $x$.

 \texttt{IsNewIndecomposable} works by running through all of the partitions $\nu$ such that $P(\nu)$ could be a summand of $x$ and it uses various results, such as the $q$-Schaper theorem of \cite{JM2} (see \texttt{Schaper} (\ref{Schaper})), the Mullineux map (see \texttt{MullineuxMap} (\ref{MullineuxMap})) and inducing simple modules, to determine if $P(\nu)$ does indeed split off. In addition, if $d$ is the decomposition matrix for $H(S_n)$ then \texttt{IsNewIndecomposable} will probably use some of the decomposition matrices of $H(S_m)$ for $m\leq n$, if they are known. Consequently it is a good idea to save decomposition
matrices as they are calculated (see \texttt{SaveDecompositionMatrix} (\ref{SaveDecompositionMatrix})).

 For example, in calculating the $2$-modular decomposition matrices of $S_{r}$ the first projective which \texttt{InducedDecompositionMatrix} (\ref{InducedDecompositionMatrix}) is unable to calculate is $P(10)$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(2,2);;|
  !gapprompt@gap>| !gapinput@d:=InducedDecompositionMatrix(DecompositionMatrix(H,9));;|
  # Inducing.
  # The following projectives are missing from <d>:
  #  [ 10 ]
\end{Verbatim}
 (In fact, given the above commands, \textsf{Hecke} will return the full decomposition matrix for $S_{10}$ because this matrix is in the library; these were the commands that were used
to calculate the decomposition matrix in the library.)

 By inducing $P(9)$ we can find a projective $H$-module which contains $P(10)$. We can then use \texttt{IsNewIndecomposable} to try and decompose this induced module into a sum of PIMs. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SizeScreen([80,20]);; x:=RInducedModule(MakePIM(H,9),1);; Display(x);|
  # P(<x>), unable to rewrite <x> as a sum of projectives
  S(10) + S(9,1) + S(8,2) + 2S(8,1^2) + S(7,3) + 2S(7,1^3) + 3S(6,3,1) + 3S(6,2^\
  2) + 4S(6,2,1^2) + 2S(6,1^4) + 4S(5,3,2) + 5S(5,3,1^2) + 5S(5,2^2,1) + 2S(5,1^\
  5) + 2S(4^2,2) + 2S(4^2,1^2) + 2S(4,3^2) + 5S(4,3,1^3) + 2S(4,2^3) + 5S(4,2^2,\
  1^2) + 4S(4,2,1^4) + 2S(4,1^6) + 2S(3^3,1) + 2S(3^2,2^2) + 4S(3^2,2,1^2) + 3S(\
  3^2,1^4) + 3S(3,2^2,1^3) + 2S(3,1^7) + S(2^3,1^4) + S(2^2,1^6) + S(2,1^8) + S(\
  1^10)
  !gapprompt@gap>| !gapinput@IsNewIndecomposable(d,x);|
  # The multiplicity of S(6,3,1) in P(10) is at least 1 and at most 2.
  false
  !gapprompt@gap>| !gapinput@Display(x);|
  S(10) + S(9,1) + S(8,2) + 2S(8,1^2) + S(7,3) + 2S(7,1^3) + 2S(6,3,1) + 2S(6,2^\
  2) + 3S(6,2,1^2) + 2S(6,1^4) + 3S(5,3,2) + 4S(5,3,1^2) + 4S(5,2^2,1) + 2S(5,1^\
  5) + 2S(4^2,2) + 2S(4^2,1^2) + 2S(4,3^2) + 4S(4,3,1^3) + 2S(4,2^3) + 4S(4,2^2,\
  1^2) + 3S(4,2,1^4) + 2S(4,1^6) + 2S(3^3,1) + 2S(3^2,2^2) + 3S(3^2,2,1^2) + 2S(\
  3^2,1^4) + 2S(3,2^2,1^3) + 2S(3,1^7) + S(2^3,1^4) + S(2^2,1^6) + S(2,1^8) + S(\
  1^10)
\end{Verbatim}
 Notice that some of the coefficients of the Specht modules in $x$ have changed; this is because \texttt{IsNewIndecomposable} was able to determine that the multiplicity of $S(6,3,1)$ was at most $2$ and so it subtracted one copy of $P(6,3,1)$ from $x$.

 In this case, the multiplicity of $S(6,3,1)$ in $P(10)$ is easy to resolve because general theory says that this multiplicity must be
odd. Therefore, $x-P(6,3,1)$ is projective. After subtracting $P(6,3,1)$ from $x$ we again use \texttt{IsNewIndecomposable} to see if $x$ is now indecomposable. We can tell \texttt{IsNewIndecomposable} that all of the multiplicities up to and including $S(6,3,1)$ have already been checked by giving it the addition argument $\mu=[6,3,1]$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@x:=x-MakePIM(d,6,3,1);; IsNewIndecomposable(d,x,6,3,1);|
  true
\end{Verbatim}
 Consequently, $x=P(10)$ and we add it to the decomposition matrix $d$ (and save it). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@AddIndecomposable(d,x); SaveDecompositionMatrix(d);|
\end{Verbatim}
 A full description of what \texttt{IsNewIndecomposable} does can be found by reading the comments in \texttt{specht.gi}. Any suggestions or improvements on this function would be especially
welcome.

 See also \texttt{DecompositionMatrix} (\ref{DecompositionMatrix}) and \texttt{InducedDecompositionMatrix} (\ref{InducedDecompositionMatrix}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{InvertDecompositionMatrix}}
\logpage{[ 3, 5, 3 ]}\nobreak
\hyperdef{L}{X802E811683E611EE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{InvertDecompositionMatrix({\mdseries\slshape d})\index{InvertDecompositionMatrix@\texttt{InvertDecompositionMatrix}}
\label{InvertDecompositionMatrix}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
inverse of the ($e$-regular part of) $d$, where $d$ is a decomposition matrix, or crystallized decomposition matrix, of a Hecke
algebra or $q$-Schur algebra.



 If part of the decomposition matrix $d$ is unknown then \texttt{InvertDecompositionMatrix} will invert as much of $d$ as possible. 
\begin{Verbatim}[commandchars=!@A,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>A !gapinput@H:=Specht(4);; d:=CrystalDecompositionMatrix(H,5);;A
  !gapprompt@gap>A !gapinput@Display(InvertDecompositionMatrix(d));A
  5    |   1
  4,1  |   .   1
  3,2  |  -v   .   1
  3,1^2|   .   .   .   1
  2^2,1| v^2   .  -v   .   1
  2,1^3|   .   .   .   .   .   1
\end{Verbatim}
 See also \texttt{DecompositionMatrix} (\ref{DecompositionMatrix}) and \texttt{CrystalDecompositionMatrix} (\ref{CrystalDecompositionMatrix}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{AdjustmentMatrix}}
\logpage{[ 3, 5, 4 ]}\nobreak
\hyperdef{L}{X87B18FD97B2D8E80}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AdjustmentMatrix({\mdseries\slshape dp, d})\index{AdjustmentMatrix@\texttt{AdjustmentMatrix}}
\label{AdjustmentMatrix}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the adjustment matrix $a$



 James \cite{J} noticed and Geck \cite{G} proved, that the decomposition matrices $dp$ for Hecke algebras defined over fields of positive characteristic admit a
factorization $dp = d \cdot a$ where $d$ is a decomposition matrix for a suitable Hecke algebra defined over a field of
characteristic zero and $a$ is the so-called \emph{adjustment matrix}. 
\begin{Verbatim}[commandchars=!@B,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>B !gapinput@H:=Specht(2);; Hp:=Specht(2,2);;B
  !gapprompt@gap>B !gapinput@d:=DecompositionMatrix(H,13);; dp:=DecompositionMatrix(Hp,13);;B
  !gapprompt@gap>B !gapinput@a:=AdjustmentMatrix(dp,d);B
  <18x18 decomposition matrix>
  !gapprompt@gap>B !gapinput@Display(a);B
  13     | 1
  12,1   | . 1
  11,2   | 1 . 1
  10,3   | . . . 1
  10,2,1 | . . . . 1
  9,4    | 1 . 1 . . 1
  9,3,1  | 2 . . . . . 1
  8,5    | . 1 . . . . . 1
  8,4,1  | 1 . . . . . . . 1
  8,3,2  | . 2 . . . . . 1 . 1
  7,6    | 1 . . . . 1 . . . . 1
  7,5,1  | . . . . . . 1 . . . . 1
  7,4,2  | 1 . 1 . . 1 . . . . 1 . 1
  7,3,2,1| . . . . . . . . . . . . . 1
  6,5,2  | . 1 . . . . . 1 . 1 . . . . 1
  6,4,3  | 2 . . . 1 . . . . . . . . . . 1
  6,4,2,1| . 2 . 1 . . . . . . . . . . . . 1
  5,4,3,1| 4 . 2 . . . . . . . . . . . . . . 1
  !gapprompt@gap>B !gapinput@MatrixDecompositionMatrix(dp)=B
  !gapprompt@>B !gapinput@          MatrixDecompositionMatrix(d)*MatrixDecompositionMatrix(a);B
  true
\end{Verbatim}
 In the last line we have checked our calculation.

 See also \texttt{DecompositionMatrix} (\ref{DecompositionMatrix}) and \texttt{CrystalDecompositionMatrix} (\ref{CrystalDecompositionMatrix}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{SaveDecompositionMatrix}}
\logpage{[ 3, 5, 5 ]}\nobreak
\hyperdef{L}{X78B0FF2079269138}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SaveDecompositionMatrix({\mdseries\slshape d})\index{SaveDecompositionMatrix@\texttt{SaveDecompositionMatrix}}
\label{SaveDecompositionMatrix}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SaveDecompositionMatrix({\mdseries\slshape d, filename})\index{SaveDecompositionMatrix@\texttt{SaveDecompositionMatrix}!for a filename}
\label{SaveDecompositionMatrix:for a filename}
}\hfill{\scriptsize (method)}}\\


 The function \texttt{SaveDecompositionMatrix} saves the decomposition matrix $d$. After a decomposition matrix has been saved, the functions \texttt{MakeSpecht} (\ref{MakeSpecht}), \texttt{MakePIM} (\ref{MakePIM}) and \texttt{MakeSimple} (\ref{MakeSimple}) will automatically access it as needed. So, for example, before saving $d$ in order to retrieve the indecomposable $P(\mu)$ from $d$ it is necessary to type \texttt{MakePIM(}$d, \mu$\texttt{)}; once $d$ has been saved, the command \texttt{MakePIM(}$\mu$\texttt{)} suffices.

 Since \texttt{InducedDecompositionMatrix} (\ref{InducedDecompositionMatrix}) consults the decomposition matrices for smaller $n$, if they are available, it is advantageous to save decomposition matrices as
they are calculated. For example, over a field of characteristic $5$, the decomposition matrices for the symmetric groups $S_n$ with $n\leq 20$ can be calculated as follows: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(5,5);;|
  !gapprompt@gap>| !gapinput@d:=DecompositionMatrix(H,9);;|
  !gapprompt@gap>| !gapinput@for r in [10..20] do|
  !gapprompt@>| !gapinput@     d:=InducedDecompositionMatrix(d);|
  !gapprompt@>| !gapinput@     SaveDecompositionMatrix(d);|
  !gapprompt@>| !gapinput@   od;|
  # Inducing...
  # Inducing....
  # Inducing....
  # Inducing.....
  # Inducing......
  # Inducing.......
  # Inducing........
  # Inducing..........
  # Inducing............
  # Inducing..............
  # Inducing.................
\end{Verbatim}
 If your Hecke algebra object $H$ is defined using a non-standard valuation map (see \texttt{Specht} (\ref{Specht})) then it is also necessary to set the string $HeckeRing$, or to supply the function with a $filename$ before it will save your matrix. \texttt{SaveDecompositionMatrix} will also save adjustment matrices and the various other matrices that appear
in \textsf{Hecke} (they can be read back in using \texttt{DecompositionMatrix} (\ref{DecompositionMatrix})). Each matrix has a default filename which you can over ride by supplying a $filename$. Using non-standard file names will stop \textsf{Hecke} from automatically accessing these matrices in future. See also \texttt{DecompositionMatrix} (\ref{DecompositionMatrix}) and \texttt{CrystalDecompositionMatrix} (\ref{CrystalDecompositionMatrix}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{CalculateDecompositionMatrix}}
\logpage{[ 3, 5, 6 ]}\nobreak
\hyperdef{L}{X84DD2D517FC1F905}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CalculateDecompositionMatrix({\mdseries\slshape H, n})\index{CalculateDecompositionMatrix@\texttt{CalculateDecompositionMatrix}}
\label{CalculateDecompositionMatrix}
}\hfill{\scriptsize (method)}}\\


 \texttt{CalculateDecompositionMatrix} is similar to the function \texttt{DecompositionMatrix} (\ref{DecompositionMatrix}) in that both functions try to return the decomposition matrix $d$ of $H(S_n)$; the difference is that this function tries to calculate this matrix whereas
the latter reads the matrix from the library files (in characteristic zero
both functions apply the algorithm of \cite{LLT} to compute $d$). In effect this function is only needed when working with Hecke algebras
defined over fields of positive characteristic (or when you wish to avoid the
libraries). For example, if you want to do calculations with the decomposition
matrix of the symmetric group $S_{15}$ over a field of characteristic two, \texttt{DecompositionMatrix} (\ref{DecompositionMatrix}) returns fail whereas \texttt{CalculateDecompositionMatrix} returns a part of the decomposition matrix. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(2,2);; d:=DecompositionMatrix(H,15);|
  # This decomposition matrix is not known; use CalculateDecompositionMatrix()
  # or InducedDecompositionMatrix() to calculate with this matrix.
  fail
  !gapprompt@gap>| !gapinput@d:=CalculateDecompositionMatrix(H,15);;|
  # Projective indecomposable P(6,4,3,2) not known.
  # Projective indecomposable P(6,5,3,1) not known.
  # Projective indecomposable P(6,5,4) not known.
  # Projective indecomposable P(7,4,3,1) not known.
  # Projective indecomposable P(7,5,2,1) not known.
  # Projective indecomposable P(7,5,3) not known.
  # Projective indecomposable P(7,6,2) not known.
  # Projective indecomposable P(8,4,2,1) not known.
  # Projective indecomposable P(8,4,3) not known.
  # Projective indecomposable P(8,5,2) not known.
  # Projective indecomposable P(8,6,1) not known.
  # Projective indecomposable P(8,7) not known.
  # Projective indecomposable P(9,3,2,1) not known.
  # Projective indecomposable P(9,4,2) not known.
  # Projective indecomposable P(9,5,1) not known.
  # Projective indecomposable P(9,6) not known.
  # Projective indecomposable P(10,3,2) not known.
  # Projective indecomposable P(10,4,1) not known.
  # Projective indecomposable P(10,5) not known.
  # Projective indecomposable P(11,3,1) not known.
  # Projective indecomposable P(11,4) not known.
  # Projective indecomposable P(12,2,1) not known.
  # Projective indecomposable P(12,3) not known.
  # Projective indecomposable P(13,2) not known.
  # Projective indecomposable P(14,1) not known.
  # Projective indecomposable P(15) not known.
  !gapprompt@gap>| !gapinput@SizeScreen([80,20]);; MissingIndecomposables(d);|
  The following projectives are missing from <d>:
      [ 15 ]  [ 14, 1 ]  [ 13, 2 ]  [ 12, 3 ]  [ 12, 2, 1 ]  [ 11, 4 ]
  [ 11, 3, 1 ]  [ 10, 5 ]  [ 10, 4, 1 ]  [ 10, 3, 2 ]  [ 9, 6 ]  [ 9, 5, 1 ]
  [ 9, 4, 2 ]  [ 9, 3, 2, 1 ]  [ 8, 7 ]  [ 8, 6, 1 ]  [ 8, 5, 2 ]  [ 8, 4, 3 ]
  [ 8, 4, 2, 1 ]  [ 7, 6, 2 ]  [ 7, 5, 3 ]  [ 7, 5, 2, 1 ]  [ 7, 4, 3, 1 ]
  [ 6, 5, 4 ]  [ 6, 5, 3, 1 ]  [ 6, 4, 3, 2 ]
\end{Verbatim}
 Actually, you are much better starting with the decomposition matrix of $S_{14}$ and then applying \texttt{InducedDecompositionMatrix} (\ref{InducedDecompositionMatrix}) to this matrix. See also \texttt{DecompositionMatrix} (\ref{DecompositionMatrix}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{MatrixDecompositionMatrix}}
\logpage{[ 3, 5, 7 ]}\nobreak
\hyperdef{L}{X7FDC65328102C1B9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MatrixDecompositionMatrix({\mdseries\slshape d})\index{MatrixDecompositionMatrix@\texttt{MatrixDecompositionMatrix}}
\label{MatrixDecompositionMatrix}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the \textsf{GAP} matrix corresponding to the \textsf{Hecke} decomposition matrix $d$



 The rows and columns of $d$ are sorted by the ordering stored in the internal algebra object of the matrix $d$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SizeScreen([80,20]);;|
  !gapprompt@gap>| !gapinput@MatrixDecompositionMatrix(DecompositionMatrix(Specht(3),5));|
  [ [ 1, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0 ], [ 0, 1, 1, 0, 0 ], [ 0, 0, 0, 1, 0 ],
    [ 1, 0, 0, 0, 1 ], [ 0, 0, 0, 0, 1 ], [ 0, 0, 1, 0, 0 ] ]
\end{Verbatim}
 See also \texttt{DecompositionMatrix} (\ref{DecompositionMatrix}) and \texttt{DecompositionMatrixMatrix} (\ref{DecompositionMatrixMatrix}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{DecompositionMatrixMatrix}}
\logpage{[ 3, 5, 8 ]}\nobreak
\hyperdef{L}{X86EBEBF680EBC98E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DecompositionMatrixMatrix({\mdseries\slshape H, m, n})\index{DecompositionMatrixMatrix@\texttt{DecompositionMatrixMatrix}}
\label{DecompositionMatrixMatrix}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the \textsf{Hecke} decomposition matrix corresponding to the \textsf{GAP} matrix $m$



 If $p$ is the number of partitions of $n$ and $r$ the number of $e$-regular partitions of $n$, then $m$ must be either $r\times r$, $p\times r$ or $p\times p$. The rows and columns of $m$ are assumed to be indexed by partitions sorted by the ordering stored in the
algebra object $H$ (see \texttt{Specht} (\ref{Specht})). 
\begin{Verbatim}[commandchars=!@A,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>A !gapinput@H:=Specht(3);;A
  !gapprompt@gap>A !gapinput@m:=[ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 1, 0, 1, 0 ],A
  !gapprompt@>A !gapinput@        [ 0, 0, 0, 1 ], [ 0, 0, 1, 0 ] ];;A
  !gapprompt@gap>A !gapinput@Display(DecompositionMatrixMatrix(H,m,4));A
  4    | 1
  3,1  | . 1
  2^2  | 1 . 1
  2,1^2| . . . 1
  1^4  | . . 1 .
\end{Verbatim}
 See also \texttt{DecompositionMatrix} (\ref{DecompositionMatrix}) and \texttt{MatrixDecompositionMatrix} (\ref{MatrixDecompositionMatrix}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{AddIndecomposable}}
\logpage{[ 3, 5, 9 ]}\nobreak
\hyperdef{L}{X7B05627D83E6977E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AddIndecomposable({\mdseries\slshape d, x})\index{AddIndecomposable@\texttt{AddIndecomposable}}
\label{AddIndecomposable}
}\hfill{\scriptsize (method)}}\\


 \texttt{AddIndecomposable} inserts the indecomposable module $x$ into the decomposition matrix $d$. If $d$ already contains the indecomposable $d$ then a warning is printed. The function \texttt{AddIndecomposable} also calculates \texttt{MullineuxMap(} $x$\texttt{)} (see \texttt{MullineuxMap} (\ref{MullineuxMap})) and adds this indecomposable to $d$ (or checks to see that it agrees with the corresponding entry of $d$ if this indecomposable is already in $d$).

 See \texttt{IsNewIndecomposable} (\ref{IsNewIndecomposable}) for an example. See also \texttt{DecompositionMatrix} (\ref{DecompositionMatrix}) and \texttt{CrystalDecompositionMatrix} (\ref{CrystalDecompositionMatrix}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{RemoveIndecomposable}}
\logpage{[ 3, 5, 10 ]}\nobreak
\hyperdef{L}{X79FA055E8250E6A2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RemoveIndecomposable({\mdseries\slshape d, mu})\index{RemoveIndecomposable@\texttt{RemoveIndecomposable}}
\label{RemoveIndecomposable}
}\hfill{\scriptsize (method)}}\\


 The function \texttt{RemoveIndecomposable} removes the column from $d$ which corresponds to $P(\mu)$. This is sometimes useful when trying to calculate a new decomposition matrix
using \textsf{Hecke} and want to test a possible candidate for a yet to be identified PIM.

 See also \texttt{DecompositionMatrix} (\ref{DecompositionMatrix}) and \texttt{CrystalDecompositionMatrix} (\ref{CrystalDecompositionMatrix}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{MissingIndecomposables}}
\logpage{[ 3, 5, 11 ]}\nobreak
\hyperdef{L}{X8434DC7C8364CB54}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MissingIndecomposables({\mdseries\slshape d})\index{MissingIndecomposables@\texttt{MissingIndecomposables}}
\label{MissingIndecomposables}
}\hfill{\scriptsize (method)}}\\


 The function \texttt{MissingIndecomposables} prints the list of partitions corresponding to the indecomposable modules
which are not listed in $d$.

 See also \texttt{DecompositionMatrix} (\ref{DecompositionMatrix}) and \texttt{CrystalDecompositionMatrix} (\ref{CrystalDecompositionMatrix}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

 }

  
\section{\textcolor{Chapter }{Calculating dimensions}}\logpage{[ 3, 6, 0 ]}
\hyperdef{L}{X7A697AAA799BA7D4}{}
{
  \textsf{Hecke} has two functions for calculating the dimensions of modules of Hecke algebras; \texttt{SimpleDimension} (\ref{SimpleDimension}) and \texttt{SpechtDimension} (\ref{SpechtDimension}). As yet, \textsf{Hecke} does not know how to calculate the dimensions of modules for $q$-Schur algebras (these depend up on $q$).  

\subsection{\textcolor{Chapter }{SimpleDimension}}
\logpage{[ 3, 6, 1 ]}\nobreak
\hyperdef{L}{X828528747E4AC4C9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SimpleDimension({\mdseries\slshape d})\index{SimpleDimension@\texttt{SimpleDimension}}
\label{SimpleDimension}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SimpleDimension({\mdseries\slshape H, n})\index{SimpleDimension@\texttt{SimpleDimension}!for an algebra object and an integer}
\label{SimpleDimension:for an algebra object and an integer}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SimpleDimension({\mdseries\slshape H|d, mu})\index{SimpleDimension@\texttt{SimpleDimension}!for a partition}
\label{SimpleDimension:for a partition}
}\hfill{\scriptsize (method)}}\\


 In the first two forms, \texttt{SimpleDimension} prints the dimensions of all of the simple modules specified by $d$ or for the Hecke algebra $H(S_n)$ respectively. If a partition $\mu$ is supplied, as in the last form, then the dimension of the simple module $D(\mu)$ is returned. At present the function is not implemented for the simple modules
of the $q$-Schur algebras. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(6);;|
  !gapprompt@gap>| !gapinput@SimpleDimension(H,11,3);|
  272
  !gapprompt@gap>| !gapinput@d:=DecompositionMatrix(H,5);; SimpleDimension(d,3,2);|
  5
  !gapprompt@gap>| !gapinput@SimpleDimension(d);|
  5     : 1
  4,1   : 4
  3,2   : 5
  3,1^2 : 6
  2^2,1 : 5
  2,1^3 : 4
  1^5   : 1
  true
\end{Verbatim}
 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{SpechtDimension}}
\logpage{[ 3, 6, 2 ]}\nobreak
\hyperdef{L}{X7B98631580E193BB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SpechtDimension({\mdseries\slshape mu})\index{SpechtDimension@\texttt{SpechtDimension}}
\label{SpechtDimension}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the dimension of the Specht module $S(\mu)$



 $\dim S(\mu)$ is equal to the number of standard $\mu$-tableaux; the answer is given by the hook length formula (see \cite{JK}). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SpechtDimension(6,3,2,1);|
  5632
\end{Verbatim}
 See also \texttt{SimpleDimension} (\ref{SimpleDimension}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

 }

 
\section{\textcolor{Chapter }{Combinatorics on Young diagrams}}\logpage{[ 3, 7, 0 ]}
\hyperdef{L}{X78F1DC277875BAFD}{}
{
  These functions range from the representation theoretic $q$-Schaper theorem and Kleshchev's algorithm for the Mullineux map through to
simple combinatorial operations like adding and removing rim hooks from Young
diagrams.  

\subsection{\textcolor{Chapter }{Schaper}}
\logpage{[ 3, 7, 1 ]}\nobreak
\hyperdef{L}{X820A908F8337F59C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Schaper({\mdseries\slshape H, mu})\index{Schaper@\texttt{Schaper}}
\label{Schaper}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a linear combination of Specht modules which have the same composition factors
as the sum of the modules in the ``Jantzen filtration '' of $S(\mu)$; see \cite{JM2}. In particular, if $\nu$ strictly dominates $\mu$ then $D(\nu)$ is a composition factor of $S(\mu)$ if and only if it is a composition factor of \texttt{Schaper(}$\mu$\texttt{)}.



 \texttt{Schaper} uses the valuation map attached to $H$ (see \texttt{Specht} (\ref{Specht}) and \cite{JM2}).

 One way in which the $q$-Schaper theorem can be applied is as follows. Suppose that we have a
projective module $x$, written as a linear combination of Specht modules and suppose that we are
trying to decide whether the projective indecomposable $P(\mu)$ is a direct summand of $x$. Then, providing that we know that $P(\nu)$ is not a summand of $x$ for all ($e$-regular) partitions $\nu$ which strictly dominate $\mu$ (see \texttt{Dominates} (\ref{Dominates})), $P(\mu)$ is a summand of $x$ if and only if \texttt{InnerProduct(Schaper( }$H,\mu$\texttt{)},$x$\texttt{)} is non-zero (note, in particular, that we don't need to know the
indecomposable $P(\mu)$ in order to perform this calculation).

 The $q$-Schaper theorem can also be used to check for irreduciblity; in fact, this is
the basis for the criterion employed by \texttt{IsSimpleModule} (\ref{IsSimpleModule}). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SizeScreen([80,20]);; H:=Specht(2);;|
  !gapprompt@gap>| !gapinput@Display(Schaper(H,9,5,3,2,1));|
  S(17,2,1) - S(15,2,1^3) + S(13,2^3,1) - S(11,3^2,2,1) + S(10,4,3,2,1) - S(9,8,\
  3) - S(9,8,1^3) + S(9,6,3,2) + S(9,6,3,1^2) + S(9,6,2^2,1)
  !gapprompt@gap>| !gapinput@Display(Schaper(H,9,6,5,2));|
  0S()
\end{Verbatim}
 The last calculation shows that $S(9,6,5,2)$ is irreducible when $R$ is a field of characteristic zero and $e=2$ (cf. \texttt{IsSimpleModule(}$H,9,6,5,2$\texttt{)}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{IsSimpleModule}}
\logpage{[ 3, 7, 2 ]}\nobreak
\hyperdef{L}{X7FB82B3184287362}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsSimpleModule({\mdseries\slshape H, mu})\index{IsSimpleModule@\texttt{IsSimpleModule}}
\label{IsSimpleModule}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} if $S(\mu)$ is simple and \texttt{false} otherwise. 



 $\mu$ an $e$-regular partition.

 This calculation uses the valuation function of $H$; see \texttt{Specht} (\ref{Specht}). Note that the criterion used by \texttt{IsSimpleModule} is completely combinatorial; it is derived from the $q$-Schaper theorem \cite{JM2}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(3);;|
  !gapprompt@gap>| !gapinput@IsSimpleModule(H,45,31,24);|
  false
\end{Verbatim}
 See also \texttt{Schaper} (\ref{Schaper}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{MullineuxMap}}
\logpage{[ 3, 7, 3 ]}\nobreak
\hyperdef{L}{X7A6262B684185E3D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MullineuxMap({\mdseries\slshape e|H, mu})\index{MullineuxMap@\texttt{MullineuxMap}}
\label{MullineuxMap}
}\hfill{\scriptsize (method)}}\\


 The sign representation $D(1^n)$ of the Hecke algebra is the (one dimensional) representation sending $T_w$ to $(-1)^{l(w)}$. The Hecke algebra $H$ is not a Hopf algebra so there is no well defined action of $H$ upon the tensor product of two $H$-modules; however, there is an outer automorphism $\#$ of $H$ which corresponds to tensoring with $D(1^n)$. This sends an irreducible module $D(\mu)$ to an irreducible $D(\mu)^\#\cong D(\mu^\#)$ for some $e$-regular partition $\mu^\#$. In the symmetric group case, Mullineux gave a conjectural algorithm for
calculating $\mu^\#$; consequently the map sending $\mu$ to $\mu^\#$ is known as the \emph{Mullineux map}.

 Deep results of Kleshchev \cite{K} for the symmetric group give another (proven) algorithm for calculating the
partition $\mu^\#$ (Ford and Kleshchev have deduced Mullineux's conjecture from this). Using the
canonical basis, it was shown by \cite{LLT} that the natural generalization of Kleshchev's algorithm to $H$ gives the Mullineux map for Hecke algebras over fields of characteristic zero.
The general case follows from this, so the Mullineux map is now known for all
Hecke algebras. 

 Kleshchev's map is easy to describe; he proved that if $gns$ is any good node sequence for $\mu$, then the sequence obtained from $gns$ by replacing each residue $r$ by $-r\bmod e$ is a good node sequence for $\mu^\#$ (see \texttt{GoodNodeSequence} (\ref{GoodNodeSequence})). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@MullineuxMap(Specht(2),12,5,2);|
  [ 12, 5, 2 ]
  !gapprompt@gap>| !gapinput@MullineuxMap(Specht(4),12,5,2);|
  [ 4, 4, 4, 2, 2, 1, 1, 1 ]
  !gapprompt@gap>| !gapinput@MullineuxMap(Specht(6),12,5,2);|
  [ 4, 3, 2, 2, 2, 2, 2, 1, 1 ]
  !gapprompt@gap>| !gapinput@MullineuxMap(Specht(8),12,5,2);|
  [ 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1 ]
  !gapprompt@gap>| !gapinput@MullineuxMap(Specht(10),12,5,2);|
  [ 3, 3, 3, 3, 2, 1, 1, 1, 1, 1 ]
\end{Verbatim}
 \textbf{\indent Returns:\ }
the image of $\mu$ under the Mullineux map

\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MullineuxMap({\mdseries\slshape d, mu})\index{MullineuxMap@\texttt{MullineuxMap}!for a decomposition matrix}
\label{MullineuxMap:for a decomposition matrix}
}\hfill{\scriptsize (method)}}\\


 The Mullineux map can also be calculated using a decomposition matrix. To see
this recall that ``tensoring'' a Specht module $S(\mu)$ with the sign representation yields a module isomorphic to the dual of $S(\lambda)$, where $\lambda$ is the partition conjugate to $\mu$. It follows that $d_{\mu\nu}=d_{\lambda\nu^\#}$ for all $e$-regular partitions $\nu$. Therefore, if $\mu$ is the last partition in the lexicographic order such that $d_{\mu\nu}\neq 0$ then we must have $\nu^\#=\lambda$. The second form of \texttt{MullineuxMap} uses $d$ to calculate $\mu^\#$ rather than the Kleshchev-\cite{LLT} result. \noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MullineuxMap({\mdseries\slshape x})\index{MullineuxMap@\texttt{MullineuxMap}!for a module}
\label{MullineuxMap:for a module}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
returns $x^\#$, the image of $x$ under $\#$.



 Note that the above remarks show that $P(\mu)$ is mapped to $P(\mu^\#)$ via the Mullineux map; this observation is useful when calculating
decomposition matrices (and is used by the function \texttt{InducedDecompositionMatrix} (\ref{InducedDecompositionMatrix})).

 See also \texttt{GoodNodes} (\ref{GoodNodes}) and \texttt{GoodNodeSequence} (\ref{GoodNodeSequence}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{MullineuxSymbol}}
\logpage{[ 3, 7, 4 ]}\nobreak
\hyperdef{L}{X7CC6C04482DD1E9D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MullineuxSymbol({\mdseries\slshape e|H, mu})\index{MullineuxSymbol@\texttt{MullineuxSymbol}}
\label{MullineuxSymbol}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the Mullineux symbol of the $e$-regular partition $\mu$. 



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@MullineuxSymbol(5,[8,6,5,5]);|
  [ [ 10, 6, 5, 3 ], [ 4, 4, 3, 2 ] ]
\end{Verbatim}
 See also \texttt{PartitionMullineuxSymbol} (\ref{PartitionMullineuxSymbol}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{PartitionMullineuxSymbol}}
\logpage{[ 3, 7, 5 ]}\nobreak
\hyperdef{L}{X7826922879DD8D8A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PartitionMullineuxSymbol({\mdseries\slshape e|H, ms})\index{PartitionMullineuxSymbol@\texttt{PartitionMullineuxSymbol}}
\label{PartitionMullineuxSymbol}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the $e$-regular partition corresponding to the given Mullineux symbol $ms$



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PartitionMullineuxSymbol(5, MullineuxSymbol(5,[8,6,5,5]) );|
  [ 8, 6, 5, 5 ]
\end{Verbatim}
 See also \texttt{MullineuxSymbol} (\ref{MullineuxSymbol}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{GoodNodes}}
\logpage{[ 3, 7, 6 ]}\nobreak
\hyperdef{L}{X7CE4D6487FD009B1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GoodNodes({\mdseries\slshape e|H, mu})\index{GoodNodes@\texttt{GoodNodes}}
\label{GoodNodes}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a list of the rows of $\mu$ which end in a good node. The good node of residue $r$ (if it exists) is the $(r+1)$-st element in this list.

\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GoodNodes({\mdseries\slshape e|H, mu, r})\index{GoodNodes@\texttt{GoodNodes}!for residues}
\label{GoodNodes:for residues}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 the number of the row which ends with the good node of residue $r$ or \texttt{fail} if there is no good node of residue $r$. 



 Given a partition and an integer $e$, Kleshchev [K] defined the notion of \emph{good node} for each residue $r$ ($0\leq r<e$). When $e$ is prime and $\mu$ is $e$-regular, Kleshchev showed that the good nodes describe the restriction of the
socle of $D(\mu)$ in the symmetric group case. Brundan \cite{B} has recently generalized this result to the Hecke algebra.

 By definition, there is at most one good node for each residue $r$ and this node is a removable node (in the diagram of $\mu$). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@GoodNodes(5,[5,4,3,2]);|
  [ fail, fail, 2, fail, 1 ]
  !gapprompt@gap>| !gapinput@GoodNodes(5,[5,4,3,2],0);|
  fail
  !gapprompt@gap>| !gapinput@GoodNodes(5,[5,4,3,2],4);|
  1
\end{Verbatim}
 The good nodes also determine the Kleshchev-Mullineux map (see \texttt{GoodNodeSequence} (\ref{GoodNodeSequence}) and \texttt{MullineuxMap} (\ref{MullineuxMap})). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{NormalNodes}}
\logpage{[ 3, 7, 7 ]}\nobreak
\hyperdef{L}{X783B52458335975F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NormalNodes({\mdseries\slshape e|H, mu})\index{NormalNodes@\texttt{NormalNodes}}
\label{NormalNodes}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the numbers of the rows of $\mu$ which end in one of Kleshchev's \cite{K} normal nodes.

\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NormalNodes({\mdseries\slshape e|H, mu, r})\index{NormalNodes@\texttt{NormalNodes}!for residues}
\label{NormalNodes:for residues}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 the rows corresponding to normal nodes of the specified residue. 



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@NormalNodes(5,[6,5,4,4,3,2,1,1,1]);|
  [ [ 1, 4 ], [  ], [  ], [ 2, 5 ], [  ] ]
  !gapprompt@gap>| !gapinput@NormalNodes(5,[6,5,4,4,3,2,1,1,1],0);|
  [ 1, 4 ]
\end{Verbatim}
 See also \texttt{GoodNodes} (\ref{GoodNodes}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{GoodNodeSequence}}
\logpage{[ 3, 7, 8 ]}\nobreak
\hyperdef{L}{X85B290977A17D9EE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GoodNodeSequence({\mdseries\slshape e|H, mu})\index{GoodNodeSequence@\texttt{GoodNodeSequence}}
\label{GoodNodeSequence}
}\hfill{\scriptsize (method)}}\\


 Given an $e$-regular partition $\mu$ of $n$, a \emph{good node sequence} for $\mu$ is a sequence $gns$ of $n$ residues such that $\mu$ has a good node of residue $r$, where $r$ is the last residue in $gns$ and the first $n-1$ residues in $gns$ are a good node sequence for the partition obtained from $\mu$ by deleting its (unique) good node with residue $r$ (see \texttt{GoodNodes} (\ref{GoodNodes})). In general, $\mu$ will have more than one good node sequence; however, any good node sequence
uniquely determines $\mu$ (see \texttt{PartitionGoodNodeSequence} (\ref{PartitionGoodNodeSequence})). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(4);; GoodNodeSequence(H,4,3,1);|
  [ 0, 3, 1, 0, 2, 2, 1, 3 ]
  !gapprompt@gap>| !gapinput@GoodNodeSequence(H,4,3,2);|
  [ 0, 3, 1, 0, 2, 2, 1, 3, 3 ]
  !gapprompt@gap>| !gapinput@GoodNodeSequence(H,4,4,2);|
  [ 0, 3, 1, 0, 2, 2, 1, 3, 3, 2 ]
  !gapprompt@gap>| !gapinput@GoodNodeSequence(H,5,4,2);|
  [ 0, 3, 1, 0, 2, 2, 1, 3, 3, 2, 0 ]
\end{Verbatim}
 \noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GoodNodeSequences({\mdseries\slshape e|H, mu})\index{GoodNodeSequences@\texttt{GoodNodeSequences}}
\label{GoodNodeSequences}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
list of all good node sequences for $\mu$



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(4);; GoodNodeSequences(H,5,2,1);|
  [ [ 0, 1, 2, 3, 3, 2, 0, 0 ], [ 0, 3, 1, 2, 2, 3, 0, 0 ],
    [ 0, 1, 3, 2, 2, 3, 0, 0 ], [ 0, 1, 2, 3, 3, 0, 2, 0 ],
    [ 0, 1, 2, 3, 0, 3, 2, 0 ], [ 0, 1, 2, 3, 3, 0, 0, 2 ],
    [ 0, 1, 2, 3, 0, 3, 0, 2 ] ]
\end{Verbatim}
 The good node sequences determine the Mullineux map (see \texttt{GoodNodes} (\ref{GoodNodes}) and \texttt{MullineuxMap} (\ref{MullineuxMap})). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{PartitionGoodNodeSequence}}
\logpage{[ 3, 7, 9 ]}\nobreak
\hyperdef{L}{X7B704FE781A311E5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PartitionGoodNodeSequence({\mdseries\slshape e|H, gns})\index{PartitionGoodNodeSequence@\texttt{PartitionGoodNodeSequence}}
\label{PartitionGoodNodeSequence}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the unique $e$-regular partition corresponding to $gns$ (or \texttt{fail} if in fact $gns$ is not a good node sequence). 



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(4);;|
  !gapprompt@gap>| !gapinput@PartitionGoodNodeSequence(H,0, 3, 1, 0, 2, 2, 1, 3, 3, 2);|
  [ 4, 4, 2 ]
\end{Verbatim}
 See also \texttt{GoodNodes} (\ref{GoodNodes}), \texttt{GoodNodeSequence} (\ref{GoodNodeSequence}) and \texttt{MullineuxMap} (\ref{MullineuxMap}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{GoodNodeLatticePath}}
\logpage{[ 3, 7, 10 ]}\nobreak
\hyperdef{L}{X7A9DC101850008A2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GoodNodeLatticePath({\mdseries\slshape e|H, mu})\index{GoodNodeLatticePath@\texttt{GoodNodeLatticePath}}
\label{GoodNodeLatticePath}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a sequence of partitions which give a path in the $e$-good partition lattice from the empty partition to $\mu$.

\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GoodNodeLatticePaths({\mdseries\slshape e|H, mu})\index{GoodNodeLatticePaths@\texttt{GoodNodeLatticePaths}}
\label{GoodNodeLatticePaths}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the list of all paths in the $e$-good partition lattice which end in $\mu$.

\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LatticePathGoodNodeSequence({\mdseries\slshape e|H, gns})\index{LatticePathGoodNodeSequence@\texttt{LatticePathGoodNodeSequence}}
\label{LatticePathGoodNodeSequence}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the path corresponding to a given good node sequence $gns$ 



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@GoodNodeLatticePath(3,3,2,1);|
  [ [ 1 ], [ 1, 1 ], [ 2, 1 ], [ 2, 1, 1 ], [ 2, 2, 1 ], [ 3, 2, 1 ] ]
  !gapprompt@gap>| !gapinput@GoodNodeLatticePaths(3,3,2,1);|
  [ [ [ 1 ], [ 1, 1 ], [ 2, 1 ], [ 2, 1, 1 ], [ 2, 2, 1 ], [ 3, 2, 1 ] ],
    [ [ 1 ], [ 1, 1 ], [ 2, 1 ], [ 2, 2 ], [ 2, 2, 1 ], [ 3, 2, 1 ] ] ]
  !gapprompt@gap>| !gapinput@GoodNodeSequence(4,6,3,2);|
  [ 0, 3, 1, 0, 2, 2, 3, 3, 0, 1, 1 ]
  !gapprompt@gap>| !gapinput@LatticePathGoodNodeSequence(4,last);|
  [ [ 1 ], [ 1, 1 ], [ 2, 1 ], [ 2, 2 ], [ 3, 2 ], [ 3, 2, 1 ], [ 4, 2, 1 ],
    [ 4, 2, 2 ], [ 5, 2, 2 ], [ 6, 2, 2 ], [ 6, 3, 2 ] ]
\end{Verbatim}
 See also \texttt{GoodNodes} (\ref{GoodNodes}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{LittlewoodRichardsonRule}}
\logpage{[ 3, 7, 11 ]}\nobreak
\hyperdef{L}{X7918D9DE7ACE2294}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LittlewoodRichardsonRule({\mdseries\slshape mu, nu})\index{LittlewoodRichardsonRule@\texttt{LittlewoodRichardsonRule}}
\label{LittlewoodRichardsonRule}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LittlewoodRichardsonCoefficient({\mdseries\slshape mu, nu, tau})\index{LittlewoodRichardsonCoefficient@\texttt{LittlewoodRichardsonCoefficient}}
\label{LittlewoodRichardsonCoefficient}
}\hfill{\scriptsize (method)}}\\


 Given partitions $\mu$ of $n$ and $\nu$ of $m$ the module $S(\mu)\otimes S(\nu)$ is naturally an $H(S_n\times S_m)$- module and, by inducing, we obtain an $H(S_{n+m})$-module. This module has the same composition factors as $\sum_{\nu} a_{\mu\nu}^\lambda S(\lambda)$, where the sum runs over all partitions $\lambda$ of $n+m$ and the integers $a_{\mu\nu}^\lambda$ are the Littlewood-Richardson coefficients. The integers $a_{\mu\nu}^\lambda$ can be calculated using a straightforward combinatorial algorithm known as the
Littlewood-Richardson rule (see \cite{JK}). The function \texttt{LittlewoodRichardsonRule} returns an (unordered) list of partitions of $n+m$ in which each partition $\lambda$ occurs $a_{\mu\nu}^\lambda$ times. The Littlewood-Richardson coefficients are independent of $e$; they can be read more easily from the computation $S(\mu)\otimes S(\nu)$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SizeScreen([80,20]);;|
  !gapprompt@gap>| !gapinput@H:=Specht(0);; # the generic Hecke algebra with R=C[q]|
  !gapprompt@gap>| !gapinput@LittlewoodRichardsonRule([3,2,1],[4,2]);|
  [ [ 4, 3, 2, 2, 1 ], [ 4, 3, 3, 1, 1 ], [ 4, 3, 3, 2 ], [ 4, 4, 2, 1, 1 ],
    [ 4, 4, 2, 2 ], [ 4, 4, 3, 1 ], [ 5, 2, 2, 2, 1 ], [ 5, 3, 2, 1, 1 ],
    [ 5, 3, 2, 2 ], [ 5, 4, 2, 1 ], [ 5, 3, 2, 1, 1 ], [ 5, 3, 3, 1 ],
    [ 5, 4, 1, 1, 1 ], [ 5, 4, 2, 1 ], [ 5, 5, 1, 1 ], [ 5, 3, 2, 2 ],
    [ 5, 3, 3, 1 ], [ 5, 4, 2, 1 ], [ 5, 4, 3 ], [ 5, 5, 2 ], [ 6, 2, 2, 1, 1 ],
    [ 6, 3, 1, 1, 1 ], [ 6, 3, 2, 1 ], [ 6, 4, 1, 1 ], [ 6, 2, 2, 2 ],
    [ 6, 3, 2, 1 ], [ 6, 4, 2 ], [ 6, 3, 2, 1 ], [ 6, 3, 3 ], [ 6, 4, 1, 1 ],
    [ 6, 4, 2 ], [ 6, 5, 1 ], [ 7, 2, 2, 1 ], [ 7, 3, 1, 1 ], [ 7, 3, 2 ],
    [ 7, 4, 1 ] ]
  !gapprompt@gap>| !gapinput@Display(MakeSpecht(H,3,2,1)*MakeSpecht(H,4,2));|
  S(7,4,1) + S(7,3,2) + S(7,3,1^2) + S(7,2^2,1) + S(6,5,1) + 2S(6,4,2) + 2S(6,4,\
  1^2) + S(6,3^2) + 3S(6,3,2,1) + S(6,3,1^3) + S(6,2^3) + S(6,2^2,1^2) + S(5^2,2\
  ) + S(5^2,1^2) + S(5,4,3) + 3S(5,4,2,1) + S(5,4,1^3) + 2S(5,3^2,1) + 2S(5,3,2^\
  2) + 2S(5,3,2,1^2) + S(5,2^3,1) + S(4^2,3,1) + S(4^2,2^2) + S(4^2,2,1^2) + S(4\
  ,3^2,2) + S(4,3^2,1^2) + S(4,3,2^2,1)
  !gapprompt@gap>| !gapinput@LittlewoodRichardsonCoefficient([3,2,1],[4,2],[5,4,2,1]);|
  3
\end{Verbatim}
 The function \texttt{LittlewoodRichardsonCoefficient} returns a single Littlewood-Richardson coefficient (although you are really
better off asking for all of them, since they will all be calculated anyway).

 See also \texttt{RInducedModule} (\ref{RInducedModule}) and \texttt{InverseLittlewoodRichardsonRule} (\ref{InverseLittlewoodRichardsonRule}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{InverseLittlewoodRichardsonRule}}
\logpage{[ 3, 7, 12 ]}\nobreak
\hyperdef{L}{X7B9901427D1CF6F4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{InverseLittlewoodRichardsonRule({\mdseries\slshape tau})\index{InverseLittlewoodRichardsonRule@\texttt{InverseLittlewoodRichardsonRule}}
\label{InverseLittlewoodRichardsonRule}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a list of all pairs of partitions $[\mu,\nu]$ such that the Littlewood-Richardson coefficient $a_{\mu\nu}^\tau$ is non-zero (see \texttt{LittlewoodRichardsonRule} (\ref{LittlewoodRichardsonRule})). The list returned is unordered and $[\mu,\nu]$ will appear $a_{\mu\nu}^\tau$ times in it. 



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SizeScreen([80,20]);; InverseLittlewoodRichardsonRule(3,2,1);|
  [ [ [  ], [ 3, 2, 1 ] ], [ [ 1 ], [ 3, 2 ] ], [ [ 1 ], [ 2, 2, 1 ] ],
    [ [ 1 ], [ 3, 1, 1 ] ], [ [ 1, 1 ], [ 2, 2 ] ], [ [ 1, 1 ], [ 3, 1 ] ],
    [ [ 1, 1 ], [ 2, 1, 1 ] ], [ [ 1, 1, 1 ], [ 2, 1 ] ], [ [ 2 ], [ 2, 2 ] ],
    [ [ 2 ], [ 3, 1 ] ], [ [ 2 ], [ 2, 1, 1 ] ], [ [ 2, 1 ], [ 3 ] ],
    [ [ 2, 1 ], [ 2, 1 ] ], [ [ 2, 1 ], [ 2, 1 ] ], [ [ 2, 1 ], [ 1, 1, 1 ] ],
    [ [ 2, 1, 1 ], [ 2 ] ], [ [ 2, 1, 1 ], [ 1, 1 ] ], [ [ 2, 2 ], [ 2 ] ],
    [ [ 2, 2 ], [ 1, 1 ] ], [ [ 2, 2, 1 ], [ 1 ] ], [ [ 3 ], [ 2, 1 ] ],
    [ [ 3, 1 ], [ 2 ] ], [ [ 3, 1 ], [ 1, 1 ] ], [ [ 3, 1, 1 ], [ 1 ] ],
    [ [ 3, 2 ], [ 1 ] ], [ [ 3, 2, 1 ], [  ] ] ]
\end{Verbatim}
 See also \texttt{LittlewoodRichardsonRule} (\ref{LittlewoodRichardsonRule}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{EResidueDiagram}}
\logpage{[ 3, 7, 13 ]}\nobreak
\hyperdef{L}{X790D4ACF7930340F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{EResidueDiagram({\mdseries\slshape H|e, mu})\index{EResidueDiagram@\texttt{EResidueDiagram}}
\label{EResidueDiagram}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{EResidueDiagram({\mdseries\slshape x})\index{EResidueDiagram@\texttt{EResidueDiagram}!for modules}
\label{EResidueDiagram:for modules}
}\hfill{\scriptsize (method)}}\\


 The $e$-residue of the $(i,j)$-th node in the diagram of a partition $\mu$ is $(j-i)\bmod e$. \texttt{EResidueDiagram(}$e, \mu$\texttt{)} prints the diagram of the partition $\mu$ replacing each node with its $e$-residue. If $x$ is a module then \texttt{EResidueDiagram(}$x$\texttt{)} prints the $e$-residue diagrams of all of the $e$-regular partitions appearing in $x$ (such diagrams are useful when trying to decide how to restrict and induce
modules and also in applying results such as the ``Scattering theorem'' of \cite{JM1}). It is not necessary to supply the integer $e$ in this case because $x$ ``knows'' the value of $e$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(2);; EResidueDiagram(MakeSpecht(MakePIM(H,7,5)));|
  [ 7, 5 ]
     0   1   0   1   0   1   0
     1   0   1   0   1
  [ 6, 5, 1 ]
     0   1   0   1   0   1
     1   0   1   0   1
     0
  [ 5, 4, 2, 1 ]
     0   1   0   1   0
     1   0   1   0
     0   1
     1
  # There are 3 2-regular partitions.
  true
\end{Verbatim}
 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{HookLengthDiagram}}
\logpage{[ 3, 7, 14 ]}\nobreak
\hyperdef{L}{X7DE3773C78BC324C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{HookLengthDiagram({\mdseries\slshape mu})\index{HookLengthDiagram@\texttt{HookLengthDiagram}}
\label{HookLengthDiagram}
}\hfill{\scriptsize (method)}}\\


 Prints the diagram of $\mu$, replacing each node with its hook length (see \cite{JK}). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@HookLengthDiagram(11,6,3,2);|
    14  13  11   9   8   7   5   4   3   2   1
     8   7   5   3   2   1
     4   3   1
     2   1
  true
\end{Verbatim}
 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{RemoveRimHook}}
\logpage{[ 3, 7, 15 ]}\nobreak
\hyperdef{L}{X7F2ACCBF788A62E8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RemoveRimHook({\mdseries\slshape mu, row, col})\index{RemoveRimHook@\texttt{RemoveRimHook}}
\label{RemoveRimHook}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the partition obtained from $\mu$ by removing the $(row, col)$-th rim hook from (the diagram of) $\mu$.



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@RemoveRimHook([6,5,4],1,2);|
  [ 4, 3, 1 ]
  !gapprompt@gap>| !gapinput@RemoveRimHook([6,5,4],2,3);|
  [ 6, 3, 2 ]
  !gapprompt@gap>| !gapinput@HookLengthDiagram(6,5,4);|
     8   7   6   5   3   1
     6   5   4   3   1
     4   3   2   1
  true
\end{Verbatim}
 See also \texttt{AddRimHook} (\ref{AddRimHook}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{AddRimHook}}
\logpage{[ 3, 7, 16 ]}\nobreak
\hyperdef{L}{X7CEA98C779BDBD1A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AddRimHook({\mdseries\slshape mu, r, h})\index{AddRimHook@\texttt{AddRimHook}}
\label{AddRimHook}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a list $[\nu, l]$ where $\nu$ is the partition obtained from $\mu$ by adding a rim hook of length $h$ with its ``foot'' in the $r$-th row of (the diagram of) $\mu$ and $l$ is the leg length of the wrapped on rim hook (see, for example, \cite{JK}). If the resulting diagram $\nu$ is not the diagram of a partition then \texttt{fail} is returned.



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@AddRimHook([6,4,3],1,3);|
  [ [ 9, 4, 3 ], 0 ]
  !gapprompt@gap>| !gapinput@AddRimHook([6,4,3],2,3);|
  fail
  !gapprompt@gap>| !gapinput@AddRimHook([6,4,3],3,3);|
  [ [ 6, 5, 5 ], 1 ]
  !gapprompt@gap>| !gapinput@AddRimHook([6,4,3],4,3);|
  [ [ 6, 4, 3, 3 ], 0 ]
  !gapprompt@gap>| !gapinput@AddRimHook([6,4,3],5,3);|
  fail
\end{Verbatim}
 See also \texttt{RemoveRimHook} (\ref{RemoveRimHook}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

 }

  
\section{\textcolor{Chapter }{Operations on partitions}}\logpage{[ 3, 8, 0 ]}
\hyperdef{L}{X8350934A7F9AB5BE}{}
{
  This section contains functions for manipulating partitions and also several
useful orderings on the set of partitions.  

\subsection{\textcolor{Chapter }{ECore}}
\logpage{[ 3, 8, 1 ]}\nobreak
\hyperdef{L}{X867496487DC35776}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ECore({\mdseries\slshape e|H, mu})\index{ECore@\texttt{ECore}}
\label{ECore}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the $e$-core of the partition $\mu$.

\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{EAbacus({\mdseries\slshape e|H, mu})\index{EAbacus@\texttt{EAbacus}}
\label{EAbacus}
}\hfill{\scriptsize (method)}}\\


 The $e$-core of a partition $\mu$ is what remains after as many rim $e$-hooks as possible have been removed from the diagram of $\mu$ (that this is well defined is not obvious; see \cite{JK}). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(6);; ECore(H,16,8,6,5,3,1);|
  [ 4, 3, 1, 1 ]
\end{Verbatim}
 The $e$-core is calculated here using James'; notation of an \emph{abacus} there is also an \texttt{EAbacus} function; but it is more ``pretty'' than useful.

 See also \texttt{IsECore} (\ref{IsECore}), \texttt{EQuotient} (\ref{EQuotient}) and \texttt{EWeight} (\ref{EWeight}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{IsECore}}
\logpage{[ 3, 8, 2 ]}\nobreak
\hyperdef{L}{X8236220C87814790}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsECore({\mdseries\slshape e|H, mu})\index{IsECore@\texttt{IsECore}}
\label{IsECore}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} if $\mu$ is an $e$-core and \texttt{false} otherwise.



 See also \texttt{ECore} (\ref{ECore}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{EQuotient}}
\logpage{[ 3, 8, 3 ]}\nobreak
\hyperdef{L}{X8538AAAF8628A725}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{EQuotient({\mdseries\slshape e|H, mu})\index{EQuotient@\texttt{EQuotient}}
\label{EQuotient}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the $e$-quotient of $\mu$; this is a sequence of $e$ partitions whose definition can be found in \cite{JK}.



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(8);; EQuotient(H,22,18,16,12,12,1,1);|
  [ [ 1, 1 ], [  ], [  ], [  ], [  ], [ 2, 2 ], [  ], [ 1 ] ]
\end{Verbatim}
 See also \texttt{ECore} (\ref{ECore}) and \texttt{CombineEQuotientECore} (\ref{CombineEQuotientECore}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{CombineEQuotientECore}}
\logpage{[ 3, 8, 4 ]}\nobreak
\hyperdef{L}{X7F357B417D495B6F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CombineEQuotientECore({\mdseries\slshape e|H, q, C})\index{CombineEQuotientECore@\texttt{CombineEQuotientECore}}
\label{CombineEQuotientECore}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the partition which has $e$-quotient $q$ and $e$ -core $C$.



 A partition is uniquely determined by its $e$-quotient and its $e$ -core (see \texttt{EQuotient} (\ref{EQuotient}) and \texttt{ECore} (\ref{ECore})). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(11);; mu:=[100,98,57,43,12,1];;|
  !gapprompt@gap>| !gapinput@Q:=EQuotient(H,mu);|
  [ [ 9 ], [  ], [  ], [  ], [  ], [  ], [ 3 ], [ 1 ], [ 9 ], [  ], [ 5 ] ]
  !gapprompt@gap>| !gapinput@C:=ECore(H,mu);|
  [ 7, 2, 2, 1, 1, 1 ]
  !gapprompt@gap>| !gapinput@CombineEQuotientECore(H,Q,C);|
  [ 100, 98, 57, 43, 12, 1 ]
\end{Verbatim}
 See also \texttt{ECore} (\ref{ECore}) and \texttt{EQuotient} (\ref{EQuotient}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{EWeight}}
\logpage{[ 3, 8, 5 ]}\nobreak
\hyperdef{L}{X7C460635829E7ED0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{EWeight({\mdseries\slshape e|H, mu})\index{EWeight@\texttt{EWeight}}
\label{EWeight}
}\hfill{\scriptsize (method)}}\\


 The $e$-weight of a partition is the number of $e$-hooks which must be removed from the partition to reach the $e$-core (see \texttt{ECore} (\ref{ECore})). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@EWeight(6,[16,8,6,5,3,1]);|
  5
\end{Verbatim}
 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{ERegularPartitions}}
\logpage{[ 3, 8, 6 ]}\nobreak
\hyperdef{L}{X86308F6C818B220C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ERegularPartitions({\mdseries\slshape e|H, n})\index{ERegularPartitions@\texttt{ERegularPartitions}}
\label{ERegularPartitions}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the list of $e$-regular partitions of $n$, ordered reverse lexicographically (see \texttt{Lexicographic} (\ref{Lexicographic})).



 A partition $\mu=(\mu_1,\mu_2,\ldots)$ is \emph{$e$-regular} if there is no integer $i$ such that $\mu_i=\mu_{i+1}=\cdots=\mu_{i+e-1}>0$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(3);; ERegularPartitions(H,6);|
  [ [ 2, 2, 1, 1 ], [ 3, 2, 1 ], [ 3, 3 ], [ 4, 1, 1 ], [ 4, 2 ], [ 5, 1 ],
    [ 6 ] ]
\end{Verbatim}
 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{IsERegular}}
\logpage{[ 3, 8, 7 ]}\nobreak
\hyperdef{L}{X7BEDA8F286ED5F20}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsERegular({\mdseries\slshape e|H, mu})\index{IsERegular@\texttt{IsERegular}}
\label{IsERegular}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} if $\mu$ is $e$-regular and \texttt{false} otherwise.



 This functions requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{ConjugatePartition}}
\logpage{[ 3, 8, 8 ]}\nobreak
\hyperdef{L}{X7D131AF0839089BD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConjugatePartition({\mdseries\slshape mu})\index{ConjugatePartition@\texttt{ConjugatePartition}}
\label{ConjugatePartition}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the partition whose diagram is obtained by interchanging the rows and columns
in the diagram of $\mu$.



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ConjugatePartition(6,4,3,2);|
  [ 4, 4, 3, 2, 1, 1 ]
\end{Verbatim}
 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{BetaSet}}
\logpage{[ 3, 8, 9 ]}\nobreak
\hyperdef{L}{X8796C1D783ED9CB4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BetaSet({\mdseries\slshape mu})\index{BetaSet@\texttt{BetaSet}}
\label{BetaSet}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a \emph{set} of beta numbers (i.e. first column hook lengths; see \cite{JK}) corresponding to the partition $\mu$.



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@BetaSet([5,4,2,2]);|
  [ 2, 3, 6, 8 ]
\end{Verbatim}
 See also \texttt{PartitionBetaSet} (\ref{PartitionBetaSet}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{PartitionBetaSet}}
\logpage{[ 3, 8, 10 ]}\nobreak
\hyperdef{L}{X8711CC56792711A7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PartitionBetaSet({\mdseries\slshape bn})\index{PartitionBetaSet@\texttt{PartitionBetaSet}}
\label{PartitionBetaSet}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the partitions corresponding to the given set of beta numbers $bn$.Note in particular that $bn$ must be a set of integers. 



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PartitionBetaSet([ 2, 3, 6, 8 ]);|
  [ 5, 4, 2, 2 ]
\end{Verbatim}
 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{ETopLadder}}
\logpage{[ 3, 8, 11 ]}\nobreak
\hyperdef{L}{X7EC4D0FA81B55391}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ETopLadder({\mdseries\slshape e|H, mu})\index{ETopLadder@\texttt{ETopLadder}}
\label{ETopLadder}
}\hfill{\scriptsize (method)}}\\


 The ladders in the diagram of a partition are the lines connecting nodes of
constant $e$-residue, having slope $e-1$ (see \cite{JK}). A new partition can be obtained from $\mu$ by sliding all nodes up to the highest possible rungs on their ladders. \textbf{\indent Returns:\ }
the partition obtained in this way; it is automatically $e$-regular (this partition is denoted $\mu^R$ in \cite{JK}).



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(4);;|
  !gapprompt@gap>| !gapinput@ETopLadder(H,1,1,1,1,1,1,1,1,1,1);|
  [ 4, 3, 3 ]
  !gapprompt@gap>| !gapinput@ETopLadder(6,1,1,1,1,1,1,1,1,1,1);|
  [ 2, 2, 2, 2, 2 ]
\end{Verbatim}
 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{Dominates}}
\logpage{[ 3, 8, 12 ]}\nobreak
\hyperdef{L}{X820388EF7C8333BA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Dominates({\mdseries\slshape mu, nu})\index{Dominates@\texttt{Dominates}}
\label{Dominates}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} if either $\mu$=$\nu$ or $\forall i\geq 1: \sum_{j=1}^i\mu_j\geq\sum_{j=1}^i\nu_j$ and \texttt{false} otherwise.



 The dominance ordering is an important partial order in the representation
theory of Hecke algebra because $d_{\mu\nu}=0$ unless $\nu$ dominates $\mu$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Dominates([5,4],[4,4,1]);|
  true
\end{Verbatim}
 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{LengthLexicographic}}
\logpage{[ 3, 8, 13 ]}\nobreak
\hyperdef{L}{X84DB1DD37AF227CF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LengthLexicographic({\mdseries\slshape mu, nu})\index{LengthLexicographic@\texttt{LengthLexicographic}}
\label{LengthLexicographic}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} if the length of $\mu$ is less than the length of $\nu$ or if the length of $\mu$ equals the length of $\nu$ and \texttt{Lexicographic(}$\mu, \nu$\texttt{)}.



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@p:=Partitions(6);;Sort(p,LengthLexicographic); p;|
  [ [ 6 ], [ 5, 1 ], [ 4, 2 ], [ 3, 3 ], [ 4, 1, 1 ], [ 3, 2, 1 ], [ 2, 2, 2 ],
    [ 3, 1, 1, 1 ], [ 2, 2, 1, 1 ], [ 2, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1, 1 ] ]
\end{Verbatim}
 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{Lexicographic}}
\logpage{[ 3, 8, 14 ]}\nobreak
\hyperdef{L}{X8480188D81ECBD92}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Lexicographic({\mdseries\slshape mu, nu})\index{Lexicographic@\texttt{Lexicographic}}
\label{Lexicographic}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} if $\mu$ is lexicographically greater than or equal to $\nu$.



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@p:=Partitions(6);;Sort(p,Lexicographic); p;|
  [ [ 6 ], [ 5, 1 ], [ 4, 2 ], [ 4, 1, 1 ], [ 3, 3 ], [ 3, 2, 1 ],
    [ 3, 1, 1, 1 ], [ 2, 2, 2 ], [ 2, 2, 1, 1 ], [ 2, 1, 1, 1, 1 ],
    [ 1, 1, 1, 1, 1, 1 ] ]
\end{Verbatim}
 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{ReverseDominance}}
\logpage{[ 3, 8, 15 ]}\nobreak
\hyperdef{L}{X78F41DF77D6F8292}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ReverseDominance({\mdseries\slshape mu, nu})\index{ReverseDominance@\texttt{ReverseDominance}}
\label{ReverseDominance}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
\texttt{true} if $\forall i>0: \sum_{j\geq i}\mu_j > \sum_{j\geq i}\nu_j$.



 This is another total order on partitions which extends the dominance ordering
(see \texttt{Dominates} (\ref{Dominates})). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@p:=Partitions(6);;Sort(p,ReverseDominance); p;|
  [ [ 6 ], [ 5, 1 ], [ 4, 2 ], [ 3, 3 ], [ 4, 1, 1 ], [ 3, 2, 1 ], [ 2, 2, 2 ],
    [ 3, 1, 1, 1 ], [ 2, 2, 1, 1 ], [ 2, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1, 1 ] ]
\end{Verbatim}
 This is the ordering used by James in the appendix of his Springer lecture
notes book.

 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

 }

  
\section{\textcolor{Chapter }{Miscellaneous functions on modules}}\logpage{[ 3, 9, 0 ]}
\hyperdef{L}{X83890936806E3A34}{}
{
  This section contains some functions for looking at the partitions in a given
module for the Hecke algebras. Most of them are used internally by \textsf{Hecke}.  

\subsection{\textcolor{Chapter }{Specialized}}
\logpage{[ 3, 9, 1 ]}\nobreak
\hyperdef{L}{X7A8E810C85A62DD6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Specialized({\mdseries\slshape x[, q]})\index{Specialized@\texttt{Specialized}}
\label{Specialized}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Specialized({\mdseries\slshape d[, q]})\index{Specialized@\texttt{Specialized}!for a decomposition matrix}
\label{Specialized:for a decomposition matrix}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the corresponding element of the Grothendieck ring or the corresponding
decomposition matrix of the Hecke algebra when given an element of the Fock
space $x$ (see \texttt{Specht} (\ref{Specht})), or a crystallized decomposition matrix (see \texttt{CrystalDecompositionMatrix} (\ref{CrystalDecompositionMatrix})), respectively. 



 By default the indeterminate $v$ is specialized to $1$; however $v$ can be specialized to any (integer) $q$ by supplying a second argument. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SizeScreen([80,20]);; H:=Specht(2);; x:=MakeFockPIM(H,6,2);; Display(x);|
  Sq(6,2) + vSq(6,1^2) + vSq(5,3) + v^2Sq(5,1^3) + vSq(4,3,1) + v^2Sq(4,2^2) + (\
  v^3+v)Sq(4,2,1^2) + v^2Sq(4,1^4) + v^2Sq(3^2,1^2) + v^3Sq(3,2^2,1) + v^3Sq(3,1\
  ^5) + v^3Sq(2^3,1^2) + v^4Sq(2^2,1^4)
  !gapprompt@gap>| !gapinput@Display(Specialized(x));|
  S(6,2) + S(6,1^2) + S(5,3) + S(5,1^3) + S(4,3,1) + S(4,2^2) + 2S(4,2,1^2) + S(\
  4,1^4) + S(3^2,1^2) + S(3,2^2,1) + S(3,1^5) + S(2^3,1^2) + S(2^2,1^4)
  !gapprompt@gap>| !gapinput@Display(Specialized(x,2));|
  S(6,2) + 2S(6,1^2) + 2S(5,3) + 4S(5,1^3) + 2S(4,3,1) + 4S(4,2^2) + 10S(4,2,1^2\
  ) + 4S(4,1^4) + 4S(3^2,1^2) + 8S(3,2^2,1) + 8S(3,1^5) + 8S(2^3,1^2) + 16S(2^2,\
  1^4)
\end{Verbatim}
 An example of \texttt{Specialized} being applied to a crystallized decomposition matrix can be found in \texttt{CrystalDecompositionMatrix} (\ref{CrystalDecompositionMatrix}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{ERegulars}}
\logpage{[ 3, 9, 2 ]}\nobreak
\hyperdef{L}{X8232C0A1846A27FB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ERegulars({\mdseries\slshape x})\index{ERegulars@\texttt{ERegulars}}
\label{ERegulars}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ERegulars({\mdseries\slshape d})\index{ERegulars@\texttt{ERegulars}!for a decomposition matrix}
\label{ERegulars:for a decomposition matrix}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ListERegulars({\mdseries\slshape x})\index{ListERegulars@\texttt{ListERegulars}}
\label{ListERegulars}
}\hfill{\scriptsize (method)}}\\


 \texttt{ERegulars(}$x$\texttt{)} prints a list of the $e$-regular partitions, together with multiplicities, which occur in the module $x$. \texttt{ListERegulars(}$x$\texttt{)} returns an actual list of these partitions rather than printing them. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(8);;|
  !gapprompt@gap>| !gapinput@x:=MakeSpecht(RInducedModule(MakePIM(H,8,5,3)));; Display(x);|
  S(9,5,3) + S(8,6,3) + S(8,5,4) + S(8,5,3,1) + S(6,5,3^2) + S(5^2,4,3) + S(5^2,3^2,1)
  !gapprompt@gap>| !gapinput@ERegulars(x);|
  [ 9, 5, 3 ]  [ 8, 6, 3 ]  [ 8, 5, 4 ]  [ 8, 5, 3, 1 ]
  [ 6, 5, 3, 3 ]  [ 5, 5, 4, 3 ]  [ 5, 5, 3, 3, 1 ]
  !gapprompt@gap>| !gapinput@Display(MakePIM(x));|
  P(9,5,3) + P(8,6,3) + P(8,5,4) + P(8,5,3,1)
\end{Verbatim}
 This example shows why these functions are useful: given a projective module $x$, as aboveand the list of $e$-regular partitions in $x$ we know the possible indecomposable direct summands of $x$.

 Note that it is not necessary to specify what $e$ is when calling this function because $x$ ``knows'' the value of $e$.

 The function \texttt{ERegulars} can also be applied to a decomposition matrix $d$; in this case it returns the unitriangular submatrix of $d$ whose rows and columns are indexed by the $e$-regular partitions.

 These function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{SplitECores}}
\logpage{[ 3, 9, 3 ]}\nobreak
\hyperdef{L}{X822E8193835DD1D9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SplitECores({\mdseries\slshape x})\index{SplitECores@\texttt{SplitECores}}
\label{SplitECores}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
a list $[b_1,\ldots,b_k]$ where the Specht modules in each $b_i$ all belong to the same block (i.e. they have the same $e$-core).

\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SplitECores({\mdseries\slshape x, mu})\index{SplitECores@\texttt{SplitECores}!for a module and a partition}
\label{SplitECores:for a module and a partition}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the component of $x$ which is in the same block as $\mu$. 

\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SplitECores({\mdseries\slshape x, y})\index{SplitECores@\texttt{SplitECores}!for two modules}
\label{SplitECores:for two modules}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the component of $x$ which is in the same block as $y$. 



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(2);;|
  !gapprompt@gap>| !gapinput@Display(SplitECores(RInducedModule(MakeSpecht(H,5,3,1))));|
  [ S(6,3,1) + S(5,3,2) + S(5,3,1,1), S(5,4,1) ]
  !gapprompt@gap>| !gapinput@Display(RInducedModule(MakeSpecht(H,5,3,1),0));|
  S(5,4,1)
  !gapprompt@gap>| !gapinput@Display(RInducedModule(MakeSpecht(H,5,3,1),1));|
  S(6,3,1) + S(5,3,2) + S(5,3,1^2)
\end{Verbatim}
 See also \texttt{ECore} (\ref{ECore}), \texttt{RInducedModule} (\ref{RInducedModule}) and \texttt{RRestrictedModule} (\ref{RRestrictedModule}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{Coefficient}}
\logpage{[ 3, 9, 4 ]}\nobreak
\hyperdef{L}{X7E92948B80075E46}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Coefficient({\mdseries\slshape x, mu})\index{Coefficient@\texttt{Coefficient}}
\label{Coefficient}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the coefficient of $S(\mu)$ in $x$ (resp. $D(\mu)$, or $P(\mu)$).



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SizeScreen([80,20]);;|
  !gapprompt@gap>| !gapinput@H:=Specht(3);; x:=MakeSpecht(MakePIM(H,7,3));; Display(x);|
  S(7,3) + S(7,2,1) + S(6,2,1^2) + S(5^2) + S(5,2^2,1) + S(4^2,1^2) + S(4,3^2) +\
   S(4,3,2,1)
  !gapprompt@gap>| !gapinput@Coefficient(x,5,2,2,1);|
  1
\end{Verbatim}
 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{InnerProduct}}
\logpage{[ 3, 9, 5 ]}\nobreak
\hyperdef{L}{X79FB3FE67D55BCFA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{InnerProduct({\mdseries\slshape x, y})\index{InnerProduct@\texttt{InnerProduct}}
\label{InnerProduct}
}\hfill{\scriptsize (method)}}\\


 Here $x$ and $y$ are some modules of the Hecke algebra (i.e. Specht modules, PIMS, or simple
modules). \texttt{InnerProduct} computes the standard inner product of these elements. This is sometimes a
convenient way to compute decomposition numbers (for example). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@H:=Specht(2);; InnerProduct(MakeSpecht(H,2,2,2,1), MakePIM(H,4,3));|
  1
  !gapprompt@gap>| !gapinput@DecompositionNumber(H,[2,2,2,1],[4,3]);|
  1
\end{Verbatim}
 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

 }

  
\section{\textcolor{Chapter }{Semi-standard and standard tableaux}}\logpage{[ 3, 10, 0 ]}
\hyperdef{L}{X7D473E167C866CEC}{}
{
  These functions are not really part of \textsf{Hecke} proper; however they are related and may well be of use to someone. Tableaux
are represented by objects, that can be constructed from a list of lists.  

\subsection{\textcolor{Chapter }{Tableau}}
\logpage{[ 3, 10, 1 ]}\nobreak
\hyperdef{L}{X7F0F9663796E6978}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Tableau({\mdseries\slshape tab})\index{Tableau@\texttt{Tableau}}
\label{Tableau}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
tableau object corresponding to the given list of lists



 This is the constructor for tableau objects. The first entry of the given
argument list is the list corresponding to the first row of the tableau. }

  

\subsection{\textcolor{Chapter }{SemiStandardTableaux}}
\logpage{[ 3, 10, 2 ]}\nobreak
\hyperdef{L}{X79ADB1B980D12A14}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SemiStandardTableaux({\mdseries\slshape mu, nu})\index{SemiStandardTableaux@\texttt{SemiStandardTableaux}}
\label{SemiStandardTableaux}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
list of the semistandard $\mu$-tableaux of type $\nu$ \cite{JK}



 $\mu$ a partition, $\nu$ a composition. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SizeScreen([80,20]);; Display(SemiStandardTableaux([4,3],[1,1,1,2,2]));|
  [ Tableau( [ [ 1, 2, 3, 4 ], [ 4, 5, 5 ] ] ),
    Tableau( [ [ 1, 2, 3, 5 ], [ 4, 4, 5 ] ] ),
    Tableau( [ [ 1, 2, 4, 4 ], [ 3, 5, 5 ] ] ),
    Tableau( [ [ 1, 2, 4, 5 ], [ 3, 4, 5 ] ] ),
    Tableau( [ [ 1, 3, 4, 4 ], [ 2, 5, 5 ] ] ),
    Tableau( [ [ 1, 3, 4, 5 ], [ 2, 4, 5 ] ] ) ]
\end{Verbatim}
 See also \texttt{StandardTableaux} (\ref{StandardTableaux}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{StandardTableaux}}
\logpage{[ 3, 10, 3 ]}\nobreak
\hyperdef{L}{X7E51D6107DBE2A74}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{StandardTableaux({\mdseries\slshape mu})\index{StandardTableaux@\texttt{StandardTableaux}}
\label{StandardTableaux}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
list of the standard $\mu$-tableaux



 $\mu$ a partition 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SizeScreen([80,20]);; Display(StandardTableaux(4,2));|
  [ Tableau( [ [ 1, 2, 3, 4 ], [ 5, 6 ] ] ), Tableau( [ [ 1, 2, 3, 5 ], [ 4, 6 ] ] ),
    Tableau( [ [ 1, 2, 3, 6 ], [ 4, 5 ] ] ), Tableau( [ [ 1, 2, 4, 5 ], [ 3, 6 ] ] ),
    Tableau( [ [ 1, 2, 4, 6 ], [ 3, 5 ] ] ), Tableau( [ [ 1, 2, 5, 6 ], [ 3, 4 ] ] ),
    Tableau( [ [ 1, 3, 4, 5 ], [ 2, 6 ] ] ), Tableau( [ [ 1, 3, 4, 6 ], [ 2, 5 ] ] ),
    Tableau( [ [ 1, 3, 5, 6 ], [ 2, 4 ] ] ) ]
\end{Verbatim}
 See also \texttt{SemiStandardTableaux} (\ref{SemiStandardTableaux}). This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{ConjugateTableau}}
\logpage{[ 3, 10, 4 ]}\nobreak
\hyperdef{L}{X7869DA9A8198BD28}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConjugateTableau({\mdseries\slshape tab})\index{ConjugateTableau@\texttt{ConjugateTableau}}
\label{ConjugateTableau}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
tableau obtained from $tab$ by interchangings its rows and columns



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Display(ConjugateTableau(Tableau([ [ 1, 3, 5, 6 ], [ 2, 4 ] ])));|
  Standard Tableau:
  1	2
  3	4
  5
  6
\end{Verbatim}
 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{ShapeTableau}}
\logpage{[ 3, 10, 5 ]}\nobreak
\hyperdef{L}{X7E5351C27C9253D9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ShapeTableau({\mdseries\slshape tab})\index{ShapeTableau@\texttt{ShapeTableau}}
\label{ShapeTableau}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the partition (or composition) obtained from $tab$



 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ShapeTableau( Tableau([ [ 1, 1, 2, 3 ], [ 4, 5 ] ]) );|
  [ 4, 2 ]
\end{Verbatim}
 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

  

\subsection{\textcolor{Chapter }{TypeTableau}}
\logpage{[ 3, 10, 6 ]}\nobreak
\hyperdef{L}{X7CABF92D7BF07DD1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TypeTableau({\mdseries\slshape tab})\index{TypeTableau@\texttt{TypeTableau}}
\label{TypeTableau}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
the type of the (semistandard) tableau $tab$



 The type of a tableau is, the composition $\sigma= (\sigma_1,\sigma_2,\ldots)$ where $\sigma_i$ is the number of entries in $tab$ which are equal to $i$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SizeScreen([80,20]);;|
  !gapprompt@gap>| !gapinput@List(SemiStandardTableaux([5,4,2],[4,3,0,1,3]),TypeTableau);|
  [ [ 4, 3, 0, 1, 3 ], [ 4, 3, 0, 1, 3 ], [ 4, 3, 0, 1, 3 ], [ 4, 3, 0, 1, 3 ],
    [ 4, 3, 0, 1, 3 ] ]
\end{Verbatim}
 This function requires the package \textsf{hecke} (see \texttt{LoadPackage} (\textbf{Reference: LoadPackage})). }

 }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{hecke}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
