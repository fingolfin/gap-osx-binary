<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_4ti2_functions">
<Heading>4ti2 functions</Heading>

<Section Label="Chapter_4ti2_functions_Section_Groebner">
<Heading>Groebner</Heading>

These are wrappers of some use cases of 4ti2s groebner command.
<ManSection>
  <Func Arg="matrix[,ordering]" Name="4ti2Interface_groebner_matrix" />
 <Returns>A list of vectors
</Returns>
 <Description>
This launches the 4ti2 groebner command with the
argument as matrix input. The output will be the
the Groebner basis of the binomial ideal
generated by the left kernel of the input matrix.
Note that this is different from 4ti2's convention
which takes the right kernel.
It returns the output of the groebner command
as a list of lists.
The second argument can be a vector to specify a
monomial ordering, in the way that x^m > x^n if
ordering*m > ordering*n
 </Description>
</ManSection>


<ManSection>
  <Func Arg="basis[,ordering]" Name="4ti2Interface_groebner_basis" />
 <Returns>A list of vectors
</Returns>
 <Description>
This launches the 4ti2 groebner command with the
argument as matrix input.
The outpur will be the Groebner basis of the binomial
ideal generated by the rows of the input matrix.
It returns the output of the groebner command
as a list of lists.
The second argument is like before.
 </Description>
</ManSection>


<#Include Label="Groebner1">
</Section>


<Section Label="Chapter_4ti2_functions_Section_Hilbert">
<Heading>Hilbert</Heading>

These are wrappers of some use cases of 4ti2s hilbert command.
<ManSection Label="for_inequalities">
  <Func Arg="A" Name="4ti2Interface_hilbert_inequalities" />
  <Func Arg="A" Name="4ti2Interface_hilbert_inequalities_in_positive_orthant" />
 <Returns>a list of vectors
</Returns>
 <Description>
This function produces the hilbert basis of the cone C given
by <A>A</A>x >= 0 for all x in C. For the second function also
x >= 0 is assumed.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="A" Name="4ti2Interface_hilbert_equalities_in_positive_orthant" />
 <Returns>a list of vectors
</Returns>
 <Description>
This function produces the hilbert basis of the cone C given by
the equations <A>A</A>x = 0 in the positive orthant of the coordinate system.
 </Description>
</ManSection>


<ManSection Label="for_equalities_and_inequalities">
  <Func Arg="A, B" Name="4ti2Interface_hilbert_equalities_and_inequalities" />
  <Func Arg="A, B" Name="4ti2Interface_hilbert_equalities_and_inequalities_in_positive_orthant" />
 <Returns>a list of vectors
</Returns>
 <Description>
This function produces the hilbert basis of the cone C given by
the equations <A>A</A>x = 0 and the inequations <A>B</A>x >= 0.
For the second function x>=0 is assumed.
 </Description>
</ManSection>


<#Include Label="HilbertBasis">
<#Include Label="HilbertBasis2">
</Section>


<Section Label="Chapter_4ti2_functions_Section_ZSolve">
<Heading>ZSolve</Heading>

<ManSection Label="zsolve">
  <Func Arg="eqs,eqs_rhs,ineqs,ineqs_rhs[,signs]" Name="4ti2Interface_zsolve_equalities_and_inequalities" />
  <Func Arg="eqs,eqs_rhs,ineqs,ineqs_rhs" Name="4ti2Interface_zsolve_equalities_and_inequalities_in_positive_orthant" />
 <Returns>a list of three matrices
</Returns>
 <Description>
This function produces a basis of the system <A>eqs</A> = <A>eqs_rhs</A>
and <A>ineqs</A> >= <A>ineqs_rhs</A>. It outputs a list containing three matrices.
The first one is a list of points in a polytope, the second is the hilbert basis
of a cone. The set of solutions is then the minkowski sum of the polytope
generated by the points in the first list and the cone generated by the hilbert
basis in the second matrix. The third one is the free part of the solution polyhedron.
The optional argument <A>signs</A> must be a list of zeros and ones which length is
the number of variables. If the ith entry is one, the ith variable must be >= 0.
If the entry is 0, the number is arbitraty. Default is all zero.
It is also possible to set the option precision to 32, 64 or gmp.
The default, if no option is given, 32 is used.
Please note that a higher precision leads to slower computation.
For the second function xi >= 0 for all variables is assumed.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_4ti2_functions_Section_Graver">
<Heading>Graver</Heading>

<ManSection Label="graver">
  <Func Arg="eqs[,signs]" Name="4ti2Interface_graver_equalities" />
  <Func Arg="eqs" Name="4ti2Interface_graver_equalities_in_positive_orthant" />
 <Returns>a matrix
</Returns>
 <Description>
This calls the function graver with the equalities <A>eqs</A> = 0.
It outputs one list containing the
graver basis of the system.
the optional argument <A>signs</A> is used like in zsolve.
The second command assumes <M>x_i \geq 0</M>.
 </Description>
</ManSection>


</Section>


</Chapter>

