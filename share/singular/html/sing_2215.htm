<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on March, 4  2015 by texi2html 1.65 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>

-->
<HEAD>
<TITLE>Singular Manual: hilbertSeries</TITLE>

<META NAME="description" CONTENT="Singular Manual: hilbertSeries">
<META NAME="keywords" CONTENT="Singular Manual: hilbertSeries">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.65">

</HEAD>

<BODY LANG="EN"  BACKGROUND="Mybg.gif">

<A NAME="SEC2290"></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0">
<TR VALIGN="TOP">
<TD ALIGN="LEFT">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT">  <a href="index.htm"><img
    src="singular-icon-transparent.gif" width="50"
      border="0" ALT="Top"></a>
</TD>
</TR>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="sing_2214.htm#SEC2289"><IMG SRC="a_left.gif" BORDER="0" ALT="Back: smithNormalForm" ALIGN="MIDDLE"></A></TD>
</TR>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="sing_2216.htm#SEC2291"><IMG SRC="a_right.gif" BORDER="0" ALT="Forward: lll" ALIGN="MIDDLE"></A></TD>
</TR>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="sing_2163.htm#SEC2238"><IMG SRC="a_leftdouble.gif" BORDER="0" ALT="FastBack: modular_lib" ALIGN="MIDDLE"></A></TD>
</TR>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="sing_2217.htm#SEC2292"><IMG SRC="a_rightdouble.gif" BORDER="0" ALT="FastForward: numerAlg_lib" ALIGN="MIDDLE"></A></TD>
</TR>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="sing_2165.htm#SEC2240"><IMG SRC="a_up.gif" BORDER="0" ALT="Up: multigrading_lib" ALIGN="MIDDLE"></A></TD>
</TR>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="index.htm#SEC_Top"><IMG SRC="a_top.gif" BORDER="0" ALT="Top: Singular Manual" ALIGN="MIDDLE"></A></TD>
</TR>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="sing_toc.htm#SEC_Contents"><IMG SRC="a_tableofcon.gif" BORDER="0" ALT="Contents: Table of Contents" ALIGN="MIDDLE"></A></TD>
</TR>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="sing_2336.htm#SEC2422"><IMG SRC="a_index.gif" BORDER="0" ALT="Index: Index" ALIGN="MIDDLE"></A></TD>
</TR>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="sing_abt.htm#SEC_About"><IMG SRC="a_help.gif" BORDER="0" ALT="About: About this document" ALIGN="MIDDLE"></A></TD>
</TR>
</TABLE>
</TD>
<TD ALIGN="LEFT">
<H4> D.15.14.50 hilbertSeries </H4>
<!--docid::SEC2290::-->
Procedure from library <CODE>multigrading.lib</CODE> (see  <A HREF="sing_2165.htm#SEC2240">multigrading_lib</A>).
<P>

<DL COMPACT>
<DT><STRONG>Usage:</STRONG>
<DD>hilbertSeries(I); I is poly/vector/ideal/module
<P>

<DT><STRONG>Purpose:</STRONG>
<DD>computes the multigraded Hilbert Series of I
<P>

<DT><STRONG>Note:</STRONG>
<DD>input must have multigraded-homogeneous generators.
<BR>Multigrading should be positive.
<P>

<DT><STRONG>Returns:</STRONG>
<DD>a ring in variables t_(i), s_(i), with polynomials
<BR>numerator1 and denominator1 and mutually prime numerator2
and denominator2, quotients of which give the series.
<P>

</DL>
<STRONG>Example:</STRONG>
<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>LIB "multigrading.lib";
ring r = 0,(x,y,z,w),dp;
intmat g[2][4]=
1,1,1,1,
0,1,3,4;
setBaseMultigrading(g);
module M = ideal(xw-yz, x2z-y3, xz2-y2w, yw2-z3);
intmat V[2][1]=
1,
0;
M = setModuleGrading(M, V);
def h = hilbertSeries(M); setring h;
==>  ------------ 
==> This proc returns a ring with polynomials called 'numerator1/2' and 'deno\
   minator1/2'!
==> They represent the first and the second Hilbert Series.
==> The s_(i)-variables are defined to be the inverse of the t_(i)-variables.
==>  ------------ 
factorize(numerator2);
==> [1]:
==>    _[1]=-1
==>    _[2]=t_(1)
==>    _[3]=t_(1)^3*t_(2)^6-t_(1)^2*t_(2)^6-t_(1)^2*t_(2)^2-t_(1)*t_(2)^3-t_(\
   1)*t_(2)-1
==> [2]:
==>    1,1,1
factorize(denominator2);
==> [1]:
==>    _[1]=1
==>    _[2]=t_(1)-1
==>    _[3]=t_(1)*t_(2)^4-1
==> [2]:
==>    1,1,1
kill g, h; setring r;
intmat g[2][4]=
1,2,3,4,
0,0,5,8;
setBaseMultigrading(g);
ideal I = x^2, y, z^3;
I = std(I);
list L = multiDegResolution(I, 0, 1);
for( int j = 1; j&lt;=size(L); j++)
{
"----------------------------------- ", j, " -----------------------------";
L[j];
"Module Multigrading: "; print( getModuleGrading(L[j]) );
"Multigrading: "; print(multiDeg(L[j]));
}
==> -----------------------------------  1  -----------------------------
==> _[1]=y
==> _[2]=x2
==> _[3]=z3
==> Module Multigrading: 
==>      0
==>      0
==> Multigrading: 
==>      2     2     9
==>      0     0    15
==> -----------------------------------  2  -----------------------------
==> _[1]=-x2*gen(1)+y*gen(2)
==> _[2]=-z3*gen(1)+y*gen(3)
==> _[3]=-z3*gen(2)+x2*gen(3)
==> Module Multigrading: 
==>      2     2     9
==>      0     0    15
==> Multigrading: 
==>      4    11    11
==>      0    15    15
==> -----------------------------------  3  -----------------------------
==> _[1]=z3*gen(1)-x2*gen(2)+y*gen(3)
==> Module Multigrading: 
==>      4    11    11
==>      0    15    15
==> Multigrading: 
==>     13
==>     15
multiDeg(I);
==> 2,2,9,
==> 0,0,15 
def h = hilbertSeries(I); setring h;
==>  ------------ 
==> This proc returns a ring with polynomials called 'numerator1/2' and 'deno\
   minator1/2'!
==> They represent the first and the second Hilbert Series.
==> The s_(i)-variables are defined to be the inverse of the t_(i)-variables.
==>  ------------ 
factorize(numerator2);
==> [1]:
==>    _[1]=-1
==>    _[2]=t_(1)+1
==>    _[3]=t_(1)^6*t_(2)^10+t_(1)^3*t_(2)^5+1
==> [2]:
==>    1,1,1
factorize(denominator2);
==> [1]:
==>    _[1]=1
==>    _[2]=t_(1)*t_(2)^2-1
==>    _[3]=t_(1)*t_(2)^2+1
==>    _[4]=t_(1)^2*t_(2)^4+1
==> [2]:
==>    1,1,1,1
kill r, h, g, V;
////////////////////////////////////////////////
ring R = 0,(x,y,z),dp;
intmat W[2][3] =
1,1, 1,
0,0,-1;
setBaseMultigrading(W);
ideal I = x3y,yz2,y2z,z4;
def h = hilbertSeries(I); setring h;
==>  ------------ 
==> This proc returns a ring with polynomials called 'numerator1/2' and 'deno\
   minator1/2'!
==> They represent the first and the second Hilbert Series.
==> The s_(i)-variables are defined to be the inverse of the t_(i)-variables.
==>  ------------ 
factorize(numerator2);
==> [1]:
==>    _[1]=1
==>    _[2]=-t_(1)^5*s_(2)+t_(1)^3*s_(2)^3+t_(1)^2*s_(2)^2+t_(1)^3+t_(1)^2*s_\
   (2)+t_(1)^2+t_(1)*s_(2)+t_(1)+1
==> [2]:
==>    1,1
factorize(denominator2);
==> [1]:
==>    _[1]=-1
==>    _[2]=t_(1)-1
==> [2]:
==>    1,1
kill R, W, h;
////////////////////////////////////////////////
ring R = 0,(x,y,z,a,b,c),dp;
intmat W[2][6] =
1,1, 1,1,1,1,
0,0,-1,0,0,0;
setBaseMultigrading(W);
ideal I = x3y,yz2,y2z,z4;
def h = hilbertSeries(I); setring h;
==>  ------------ 
==> This proc returns a ring with polynomials called 'numerator1/2' and 'deno\
   minator1/2'!
==> They represent the first and the second Hilbert Series.
==> The s_(i)-variables are defined to be the inverse of the t_(i)-variables.
==>  ------------ 
factorize(numerator2);
==> [1]:
==>    _[1]=1
==>    _[2]=-t_(1)^5*s_(2)+t_(1)^3*s_(2)^3+t_(1)^2*s_(2)^2+t_(1)^3+t_(1)^2*s_\
   (2)+t_(1)^2+t_(1)*s_(2)+t_(1)+1
==> [2]:
==>    1,1
factorize(denominator2);
==> [1]:
==>    _[1]=1
==>    _[2]=t_(1)-1
==> [2]:
==>    1,4
kill R, W, h;
////////////////////////////////////////////////
// This is example 5.3.9. from Robbianos book.
ring R = 0,(x,y,z,w),dp;
intmat W[1][4] =
1,1, 1,1;
setBaseMultigrading(W);
ideal I = z3,y3zw2,x2y4w2xyz2;
hilb(std(I));
==> //         1 t^0
==> //        -1 t^3
==> //        -1 t^6
==> //         1 t^8
==> 
==> //         1 t^0
==> //         1 t^1
==> //         1 t^2
==> //        -1 t^6
==> //        -1 t^7
==> // dimension (proj.)  = 2
==> // degree (proj.)   = 1
def h = hilbertSeries(I); setring h;
==>  ------------ 
==> This proc returns a ring with polynomials called 'numerator1/2' and 'deno\
   minator1/2'!
==> They represent the first and the second Hilbert Series.
==> The s_(i)-variables are defined to be the inverse of the t_(i)-variables.
==>  ------------ 
numerator1;
==> t_(1)^8-t_(1)^6-t_(1)^3+1
denominator1;
==> t_(1)^4-4*t_(1)^3+6*t_(1)^2-4*t_(1)+1
factorize(numerator2);
==> [1]:
==>    _[1]=1
==>    _[2]=t_(1)^7+t_(1)^6-t_(1)^2-t_(1)-1
==> [2]:
==>    1,1
factorize(denominator2);
==> [1]:
==>    _[1]=1
==>    _[2]=t_(1)-1
==> [2]:
==>    1,3
kill h;
////////////////////////////////////////////////
setring R;
ideal I2 = x2,y2,z2; I2;
==> I2[1]=x2
==> I2[2]=y2
==> I2[3]=z2
hilb(std(I2));
==> //         1 t^0
==> //        -3 t^2
==> //         3 t^4
==> //        -1 t^6
==> 
==> //         1 t^0
==> //         3 t^1
==> //         3 t^2
==> //         1 t^3
==> // dimension (proj.)  = 0
==> // degree (proj.)   = 8
def h = hilbertSeries(I2); setring h;
==>  ------------ 
==> This proc returns a ring with polynomials called 'numerator1/2' and 'deno\
   minator1/2'!
==> They represent the first and the second Hilbert Series.
==> The s_(i)-variables are defined to be the inverse of the t_(i)-variables.
==>  ------------ 
numerator1;
==> -t_(1)^6+3*t_(1)^4-3*t_(1)^2+1
denominator1;
==> t_(1)^4-4*t_(1)^3+6*t_(1)^2-4*t_(1)+1
kill h;
////////////////////////////////////////////////
setring R;
W = 2,2,2,2;
setBaseMultigrading(W);
getVariableWeights();
==> 2,2,2,2 
intvec w = 2,2,2,2;
hilb(std(I2), 1, w);
==> 1,0,0,0,-3,0,0,0,3,0,0,0,-1,0
kill w;
def h = hilbertSeries(I2); setring h;
==>  ------------ 
==> This proc returns a ring with polynomials called 'numerator1/2' and 'deno\
   minator1/2'!
==> They represent the first and the second Hilbert Series.
==> The s_(i)-variables are defined to be the inverse of the t_(i)-variables.
==>  ------------ 
numerator1; denominator1;
==> -t_(1)^12+3*t_(1)^8-3*t_(1)^4+1
==> t_(1)^8-4*t_(1)^6+6*t_(1)^4-4*t_(1)^2+1
kill h;
kill R, W;
////////////////////////////////////////////////
ring R = 0,(x),dp;
intmat W[1][1] =
1;
setBaseMultigrading(W);
ideal I;
I = 1; I;
==> I[1]=1
hilb(std(I));
==> 
==> // dimension (affine) = 0
==> // degree (affine)  = 0
def h = hilbertSeries(I); setring h;
==>  ------------ 
==> This proc returns a ring with polynomials called 'numerator1/2' and 'deno\
   minator1/2'!
==> They represent the first and the second Hilbert Series.
==> The s_(i)-variables are defined to be the inverse of the t_(i)-variables.
==>  ------------ 
numerator1; denominator1;
==> 0
==> -t_(1)+1
kill h;
////////////////////////////////////////////////
setring R;
I = x; I;
==> I[1]=x
hilb(std(I));
==> //         1 t^0
==> //        -1 t^1
==> 
==> //         1 t^0
==> // dimension (affine) = 0
==> // degree (affine)  = 1
def h = hilbertSeries(I); setring h;
==>  ------------ 
==> This proc returns a ring with polynomials called 'numerator1/2' and 'deno\
   minator1/2'!
==> They represent the first and the second Hilbert Series.
==> The s_(i)-variables are defined to be the inverse of the t_(i)-variables.
==>  ------------ 
numerator1; denominator1;
==> -t_(1)+1
==> -t_(1)+1
kill h;
////////////////////////////////////////////////
setring R;
I = x^5; I;
==> I[1]=x5
hilb(std(I));
==> //         1 t^0
==> //        -1 t^5
==> 
==> //         1 t^0
==> //         1 t^1
==> //         1 t^2
==> //         1 t^3
==> //         1 t^4
==> // dimension (affine) = 0
==> // degree (affine)  = 5
hilb(std(I), 1);
==> 1,0,0,0,0,-1,0
def h = hilbertSeries(I); setring h;
==>  ------------ 
==> This proc returns a ring with polynomials called 'numerator1/2' and 'deno\
   minator1/2'!
==> They represent the first and the second Hilbert Series.
==> The s_(i)-variables are defined to be the inverse of the t_(i)-variables.
==>  ------------ 
numerator1; denominator1;
==> -t_(1)^5+1
==> -t_(1)+1
kill h;
////////////////////////////////////////////////
setring R;
I = x^10; I;
==> I[1]=x10
hilb(std(I));
==> //         1 t^0
==> //        -1 t^10
==> 
==> //         1 t^0
==> //         1 t^1
==> //         1 t^2
==> //         1 t^3
==> //         1 t^4
==> //         1 t^5
==> //         1 t^6
==> //         1 t^7
==> //         1 t^8
==> //         1 t^9
==> // dimension (affine) = 0
==> // degree (affine)  = 10
def h = hilbertSeries(I); setring h;
==>  ------------ 
==> This proc returns a ring with polynomials called 'numerator1/2' and 'deno\
   minator1/2'!
==> They represent the first and the second Hilbert Series.
==> The s_(i)-variables are defined to be the inverse of the t_(i)-variables.
==>  ------------ 
numerator1; denominator1;
==> -t_(1)^10+1
==> -t_(1)+1
kill h;
////////////////////////////////////////////////
setring R;
module M = 1;
M = setModuleGrading(M, W);
hilb(std(M));
==> 
==> // dimension (affine) = 0
==> // degree (affine)  = 0
def h = hilbertSeries(M); setring h;
==>  ------------ 
==> This proc returns a ring with polynomials called 'numerator1/2' and 'deno\
   minator1/2'!
==> They represent the first and the second Hilbert Series.
==> The s_(i)-variables are defined to be the inverse of the t_(i)-variables.
==>  ------------ 
numerator1; denominator1;
==> 0
==> -t_(1)+1
kill h;
////////////////////////////////////////////////
setring R;
kill M; module M = x^5*gen(1);
//  intmat V[1][3] = 0; // TODO: this would lead to a wrong result!!!?
intmat V[1][1] = 0; // all gen(i) of degree 0!
M = setModuleGrading(M, V);
hilb(std(M));
==> //         1 t^0
==> //        -1 t^5
==> 
==> //         1 t^0
==> //         1 t^1
==> //         1 t^2
==> //         1 t^3
==> //         1 t^4
==> // dimension (affine) = 0
==> // degree (affine)  = 5
def h = hilbertSeries(M); setring h;
==>  ------------ 
==> This proc returns a ring with polynomials called 'numerator1/2' and 'deno\
   minator1/2'!
==> They represent the first and the second Hilbert Series.
==> The s_(i)-variables are defined to be the inverse of the t_(i)-variables.
==>  ------------ 
numerator1; denominator1;
==> -t_(1)^5+1
==> -t_(1)+1
kill h;
////////////////////////////////////////////////
setring R;
module N = x^5*gen(3);
kill V;
intmat V[1][3] = 0; // all gen(i) of degree 0!
N = setModuleGrading(N, V);
hilb(std(N));
==> //         3 t^0
==> //        -1 t^5
==> 
==> //         3 t^0
==> //        -1 t^5
==> // dimension (proj.)  = 0
==> // degree (proj.)   = 2
def h = hilbertSeries(N); setring h;
==>  ------------ 
==> This proc returns a ring with polynomials called 'numerator1/2' and 'deno\
   minator1/2'!
==> They represent the first and the second Hilbert Series.
==> The s_(i)-variables are defined to be the inverse of the t_(i)-variables.
==>  ------------ 
numerator1; denominator1;
==> -t_(1)^5+3
==> -t_(1)+1
kill h;
////////////////////////////////////////////////
setring R;
module S = M + N;
S = setModuleGrading(S, V);
hilb(std(S));
==> //         3 t^0
==> //        -2 t^5
==> 
==> //         3 t^0
==> //        -2 t^5
==> // dimension (proj.)  = 0
==> // degree (proj.)   = 1
def h = hilbertSeries(S); setring h;
==>  ------------ 
==> This proc returns a ring with polynomials called 'numerator1/2' and 'deno\
   minator1/2'!
==> They represent the first and the second Hilbert Series.
==> The s_(i)-variables are defined to be the inverse of the t_(i)-variables.
==>  ------------ 
numerator1; denominator1;
==> -2*t_(1)^5+3
==> -t_(1)+1
kill h;
kill V;
kill R, W;
</FONT></pre></td></tr></table><P>

<A NAME="lll"></A>
</TD>
</TR>
</TABLE>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">  <a href="index.htm"><img
    src="singular-icon-transparent.gif" width="50"
      border="0" ALT="Top"></a>
</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="sing_2214.htm#SEC2289"><IMG SRC="a_left.gif" BORDER="0" ALT="Back: smithNormalForm" ALIGN="MIDDLE"></A></TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="sing_2216.htm#SEC2291"><IMG SRC="a_right.gif" BORDER="0" ALT="Forward: lll" ALIGN="MIDDLE"></A></TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="sing_2163.htm#SEC2238"><IMG SRC="a_leftdouble.gif" BORDER="0" ALT="FastBack: modular_lib" ALIGN="MIDDLE"></A></TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="sing_2217.htm#SEC2292"><IMG SRC="a_rightdouble.gif" BORDER="0" ALT="FastForward: numerAlg_lib" ALIGN="MIDDLE"></A></TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="sing_2165.htm#SEC2240"><IMG SRC="a_up.gif" BORDER="0" ALT="Up: multigrading_lib" ALIGN="MIDDLE"></A></TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="index.htm#SEC_Top"><IMG SRC="a_top.gif" BORDER="0" ALT="Top: Singular Manual" ALIGN="MIDDLE"></A></TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="sing_toc.htm#SEC_Contents"><IMG SRC="a_tableofcon.gif" BORDER="0" ALT="Contents: Table of Contents" ALIGN="MIDDLE"></A></TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="sing_2336.htm#SEC2422"><IMG SRC="a_index.gif" BORDER="0" ALT="Index: Index" ALIGN="MIDDLE"></A></TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="sing_abt.htm#SEC_About"><IMG SRC="a_help.gif" BORDER="0" ALT="About: About this document" ALIGN="MIDDLE"></A></TD>
</TR></TABLE>
<FONT SIZE="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <A HREF="http://www.singular.uni-kl.de/"><I>Singular</I></A> version 4-0-2, 2015,
generated by <I>texi2html</I>.
</FONT>

</BODY>
</HTML>
